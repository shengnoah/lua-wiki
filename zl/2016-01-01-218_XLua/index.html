<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>XLua | 糖果AIGC实验室-LUA</title><meta name="author" content="糖果AIGC实验室 备案:辽ICP备16003836号-5"><meta name="copyright" content="糖果AIGC实验室 备案:辽ICP备16003836号-5"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="&lt;blockquote&gt;  从这里下载一个zip压缩包，解压后会有Assets等几个文档夹，其他文档夹放进你所创建的unity工程的Assets同级的目录下，然后把加压出来的Assets里的文档和文档夹复制进unity项目的Assets文档夹里即可。  XLua教程XLua加载文档加载字符串1.LuaEnv luaenv &#x3D; new LuaEnv();   2.luaenv.D">
<meta property="og:type" content="article">
<meta property="og:title" content="XLua">
<meta property="og:url" content="https://lua.ren/zl/2016-01-01-218_XLua/index.html">
<meta property="og:site_name" content="糖果AIGC实验室-LUA">
<meta property="og:description" content="&lt;blockquote&gt;  从这里下载一个zip压缩包，解压后会有Assets等几个文档夹，其他文档夹放进你所创建的unity工程的Assets同级的目录下，然后把加压出来的Assets里的文档和文档夹复制进unity项目的Assets文档夹里即可。  XLua教程XLua加载文档加载字符串1.LuaEnv luaenv &#x3D; new LuaEnv();   2.luaenv.D">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-04-03T03:47:33.092Z">
<meta property="article:modified_time" content="2024-04-03T03:47:33.093Z">
<meta property="article:author" content="糖果AIGC实验室 备案:辽ICP备16003836号-5">
<meta property="article:tag" content="lua文章">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lua.ren/zl/2016-01-01-218_XLua/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?14cc93bf3f08d31c458639d309dde522";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();



</script><script>(function () {
  var meta = document.createElement('meta');
  meta.content = 'no-referrer';
  meta.name = 'referrer';
  document.getElementsByTagName('head')[0].appendChild(meta);
})();</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"OCGZTJTHCQ","apiKey":"4dede33603574dcaed0e9d4641849158","indexName":"jianpan.vip","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'XLua',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-03 11:47:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1769</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">195</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">96</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="糖果AIGC实验室-LUA"><span class="site-name">糖果AIGC实验室-LUA</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">XLua</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-03T03:47:33.092Z" title="发表于 2024-04-03 11:47:33">2024-04-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-03T03:47:33.093Z" title="更新于 2024-04-03 11:47:33">2024-04-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/topic/">topic</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="XLua"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><pre><code>    &lt;blockquote&gt;
</code></pre>
<p>从<strong><a href="https://github.com/Tencent/xLua" target="_blank" rel="noopener noreferrer"><font color="steelblue" size="3">这里</font></a></strong>下载一个zip压缩包，解压后会有Assets等几个文档夹，其他文档夹放进你所创建的unity工程的Assets同级的目录下，然后把加压出来的Assets里的文档和文档夹复制进unity项目的Assets文档夹里即可。</p>
</blockquote>
<h1 id="XLua教程"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#XLua%E6%95%99%E7%A8%8B" class="headerlink" title="XLua教程"></a>XLua教程</h1><h2 id="XLua加载文档"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#XLua%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6" class="headerlink" title="XLua加载文档"></a>XLua加载文档</h2><h3 id="加载字符串"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E5%8A%A0%E8%BD%BD%E5%AD%97%E7%AC%A6%E4%B8%B2" class="headerlink" title="加载字符串"></a>加载字符串</h3><pre><code>1.LuaEnv luaenv = new LuaEnv();  
2.luaenv.DoString("print('hello world')");  
</code></pre><blockquote>
<p>第1行是用来实例LuaEnv虚拟机的，类似于用这个类来实现所有lua的操作，尽量定义为全局，这样优化<br>第2行是通过DoString函数来加载lua脚本，也可直接加载lua脚本内容，如上述代码，print(‘hello world’)就是lua的代码内容。加载就是把lua的脚本加载到luaenv虚拟机里。</p>
</blockquote>
<h3 id="加载lua文档"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E5%8A%A0%E8%BD%BDlua%E6%96%87%E4%BB%B6" class="headerlink" title="加载lua文档"></a>加载lua文档</h3><pre><code>LuaEnv luaenv = new LuaEnv();
//方法一
public TextAsset lua_001;
//方法二
private TextAsset lua_002;
//方法三
//在Start函数里luaenv.DoString("require 'LuaText/lua_003'");
void Start()
&#123;
    lua_002 = Resources.Load&lt;TextAsset&gt;("LuaText/lua_002.lua");
    luaenv.DoString(lua_001.text);
    luaenv.DoString(lua_002.text);
    luaenv.DoString("require 'LuaText/lua_003'");
&#125;
<p>void Update()<br />
&#123;</p>
<p>&#125;<br />
void OnDestroy()<br />
&#123;<br />
luaenv.Dispose();<br />
&#125;<br />
</code></pre><blockquote></p>
<p>lua脚本在放在Resources文档夹的时候，后缀必须加上.txt，例如<strong>lua_001.lua.txt</strong>，因为Resources对支持的文档类型有限，也就是无法用Resouces读取.lua文档。  </p>
<p>方法一是在脚本所挂物体上，通过拖拽赋值变量的方法，直接把lua的脚本拖拽到脚本的变量上，然后通过DoString执行lua文档<br>方法二是先定义TextAsset变量，然后在初始化的时候读取Resources里的文档，然后赋值到变量上，然后通过DoString执行lua文档。<br>方法三此处主要是对require和loader的理解，可以吧loader看成是指向某个路径里的一个个文档，require实际上就是调用一个个loader去加载，和自己所输入文档名字匹配，有一个成功，就不再往下进行查找，全部失败则报找不到文档的错误，目前xLua除了包含自己原本的loader外还包含了Resource所加载的loader，也就是require也可直接读取Resources目录下的文档，类似Resources的读取，但是因为Resource支持的文档类型有限，所以如果lua脚本放进了Resources文档里，就必须在后面加一个.txt的后缀，就像<strong>lua_001.lua.txt</strong>。<br>建议在整个进程中加载脚本只用一个DoString(“require’main’”),然后在main.lua脚本里可以加载自己所需要的其他脚本，其实就只把main.lua脚本看成一个接口脚本，然后在这个脚本里加载其他的lua脚本。  </p>
</blockquote>
<h3 id="自定义Loader"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E8%87%AA%E5%AE%9A%E4%B9%89Loader" class="headerlink" title="自定义Loader"></a>自定义Loader</h3><pre><code>LuaEnv luaenv = null;
void Start () &#123;
    luaenv = new LuaEnv();
    LuaEnv.CustomLoader loader = CustomLoaderMethod;
    luaenv.AddLoader(loader);
    luaenv.DoString("require('main')");
&#125;
<p>// Update is called once per frame<br />
void Update () &#123;</p>
<p>&#125;<br />
private byte[] CustomLoaderMethod(ref string filepath)<br />
&#123;<br />
if(filepath== “main”)<br />
&#123;<br />
TextAsset lua_003 = Resources.Load&lt;TextAsset&gt;(“LuaText/lua_003.lua”);<br />
return System.Text.Encoding.UTF8.GetBytes(lua_003.text);<br />
&#125;<br />
return null;<br />
&#125;<br />
</code></pre><blockquote></p>
<p>有些脚本可能是进程运行下载下来的，或者是自定义的文档格式里头解压出来的，或者是需要解密的，所以存在文档不在指定的目录里，或者不是规定的lua脚本或者lua.txt格式，这样可有使用自定的loader，就类似于上面脚本，假如loader只包含原生的loader，这样就无法读取Resources里的文档夹，这样可以自定义loader,然后根据所要查找的lua脚本名字，指定到对应所在的地址，然后读取到需要的脚本，把文档里的内容一byte[]的形式回调回来即可，这样require(“脚本名字”)就可以直接执行脚本，不论脚本在什么位置，只要脚本所在的位置已经增加到loader上即可，即用LuaEnv.AddLoader（自己定义的loader），定义loader可以用LuaEnv.CustomLoader loader名字=CustomLoaderMethod来定义loader,用private byte[] CustomLoaderMethod(ref string filepath)函数来实现自己定义的loader.<br>通过AddLoader可以注册个回调，该回调参数是字符串，lua代码里头调用require时，参数将会透传给回调，回调中就可以根据这个参数去加载指定文档，如果需要支持调试，需要把filepath修改为真实路径传出。该回调返回值是一个byte数组，如果为空表示该loader找不到，否则则为lua文档的内容。 有了这个就简单了，用IIPS的IFS？没问题。写个loader调用IIPS的接口读文档内容即可。文档已经加密？没问题，自己写loader读取文档解密后返回即可。。。（<strong>此处的IIPS是什么可以不做了解</strong>）</p>
</blockquote>
<h2 id="C-访问Lua"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#C-%E8%AE%BF%E9%97%AELua" class="headerlink" title="C#访问Lua"></a>C#访问Lua</h2><h3 id="访问全局基本类型"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E8%AE%BF%E9%97%AE%E5%85%A8%E5%B1%80%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B" class="headerlink" title="访问全局基本类型"></a>访问全局基本类型</h3><p>lua脚本  </p>
<pre><code>a = 10  
b = 100  
c = "LianBai"
</code></pre><p>c#脚本   </p>
<pre><code>LuaEnv luaenv = null;
private TextAsset luatext;
void Start () 
&#123;
    luaenv = new LuaEnv();
    luatext = Resources.Load&lt;TextAsset&gt;("LuaText/lua_004.lua");
    luaenv.DoString(luatext.text);
    int a = luaenv.Global.Get&lt;int&gt;("a");
    string b = luaenv.Global.Get&lt;string&gt;("b");
    string c = luaenv.Global.Get&lt;string&gt;("c");
    print("a = "+a);
    print("b = " + b);
    print("c = " + c);
&#125;
</code></pre><blockquote>
<p>C#访问Lua脚本里的变量其实很简单，只需要先用DoString加载脚本，然后在通过luaenv.Global.Get&lt;变量类型&gt;(“变量名”);即可读取自己所需要的基础变量。</p>
</blockquote>
<h3 id="访问一个全局的table"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E7%9A%84table" class="headerlink" title="访问一个全局的table"></a>访问一个全局的table</h3><p>lua脚本  </p>
<pre><code>d =&#123;
    x1=2,
    x2=3,
    x3="LianBai",
    4,
    5,
    6,
    add = function(self,a,b)
        return a+b
    end
&#125;
</code></pre><h4 id="映射到一个普通的class"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84class" class="headerlink" title="映射到一个普通的class"></a>映射到一个普通的class</h4><p>C#脚本</p>
<pre><code>public class Table1
&#123;
    public int x2;
    public int x1;
    public string x3;
&#125;
Table1 table1 = luaenv.Global.Get&lt;Table1&gt;("d");
</code></pre><blockquote>
<p>可以自己测试输出table1的结果，根据结果可以看出lua的table映射到C#的class的时候，并不是按照顺序一一对应进行映射的，而是根据名字映射，lua的table中的x1变量只会映射到C#的class中的x1变量中，如果lua的table里没有class中所包含的变量，则会在class中赋值为空，如果lua中table变量多余class，多余的也不会赋值过来，只会把class所包含的赋值过来。</p>
</blockquote>
<h4 id="映射到一个Dictionary中"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AADictionary%E4%B8%AD" class="headerlink" title="映射到一个Dictionary中"></a>映射到一个Dictionary中</h4><p>C#脚本</p>
<pre><code>Dictionary&lt;string,double&gt; table2= luaenv.Global.Get&lt;Dictionary&lt;string,double&gt;&gt;("d");
print("table1.x1:" + table2["x1"]);
print("table1.x2:" + table2["x2"]);
</code></pre><blockquote>
<p>在映射到Dictionary的时候，只会映射符合Dictionary自己定义的规则的变量，把变量名存为keys，把变量值存为对应的数据，所以不会把x3等后面的数据存到Dictionary里。</p>
</blockquote>
<h4 id="映射到一个List里"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AAList%E9%87%8C" class="headerlink" title="映射到一个List里"></a>映射到一个List里</h4><p>C#脚本</p>
<pre><code>List&lt;double&gt; table3= luaenv.Global.Get&lt;List&lt;double&gt;&gt;("d");
print("List的Count" + table3.Count);
foreach(double i in table3)
&#123;
    print("i:" + i);
&#125;
</code></pre><blockquote>
<p>在映射到List中，也只会映射到符合List规则的变量，但是有一点要注意的是，table中带keys的不会映射进List，不管储存的变量是不是符合规则，都不会映射进去，所以在上述脚本打印的时候，table3存的值是lua脚本中table中的4,5,6,三个变量。</p>
</blockquote>
<h4 id="映射到一个interface"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AAinterface" class="headerlink" title="映射到一个interface"></a>映射到一个interface</h4><p>C#脚本</p>
<pre><code>[CSharpCallLua]
public interface ITable4
&#123;
    int x1 &#123; get; set; &#125;
    int x2 &#123; get; set; &#125;
    string x3 &#123; get; set; &#125;
    int add(int a, int b);
&#125;
<p>ITable4 table4 = luaenv.Global.Get&lt;ITable4&gt;(“d”);<br />
print(&quot;table4 x1 = &quot; + table4.x1);<br />
print(&quot;table4 x2 = &quot; + table4.x2);<br />
print(&quot;table4 x3 = &quot; + table4.x3);<br />
print(&quot;table4 add = &quot; + table4.add(5, 6));<br />
</code></pre><blockquote></p>
<p>什么是interface？<strong><a href="http://www.runoob.com/csharp/csharp-interface.html" target="_blank" rel="noopener noreferrer"><font color="steelblue" size="3">点击这里</font></a></strong>。理解清楚interface后，从代码里我们可以看出接口类多了一个[CSharpCallLua]，这是在为这个类打上了一个标签，因为与LUA交互的代理和类型需要添加 CSharpCallLua 标签，xlua的特性之一就是标记，这一次与lua交互的特性标记则是[CSharpCallLua]，只有这样写，才可支持热更新。然后接口类的继承和普通类类似，也是根据变量名字一一对应的关系。</p>
</blockquote>
<h4 id="映射到一个LuaTable变量"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AALuaTable%E5%8F%98%E9%87%8F" class="headerlink" title="映射到一个LuaTable变量"></a>映射到一个LuaTable变量</h4><p>C#脚本</p>
<pre><code>LuaTable table5= luaenv.Global.Get&lt;LuaTable&gt;("d");
print("table5长度:" + table5.Length);
print("table5.x1:" + table5.Get&lt;int&gt;("x1"));
print("table5.x2:" + table5.Get&lt;int&gt;("x2"));
print("table5.x3:" + table5.Get&lt;string&gt;("x3"));
</code></pre><blockquote>
<p>这是一种by ref方式，所以不会生成代码，但是这种方式比较慢，并且没有变量检测。</p>
</blockquote>
<h3 id="访问一个funaction"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AAfunaction" class="headerlink" title="访问一个funaction"></a>访问一个funaction</h3><p>Lua脚本</p>
<pre><code>function e()
&#123;
    print("lua脚本的函数")
&#125;
function f(a, b)
    print('a', a, 'b', b)
    return 1, 2, &#123;x1 = 1024,x2 = 2048&#125;
end
function ret_e()
    print("LuaScripts return e function")
    return e
end
</code></pre><h4 id="映射到一个委托（Action或者delgate）"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AA%E5%A7%94%E6%89%98%EF%BC%88Action%E6%88%96%E8%80%85delgate%EF%BC%89" class="headerlink" title="映射到一个委托（Action或者delgate）"></a>映射到一个委托（Action或者delgate）</h4><p>C#脚本</p>
<pre><code>public static class AddGenerateList
&#123;
     [CSharpCallLua]
       public static List&lt;Type&gt; CSharpCallLua = new List&lt;Type&gt;()
    &#123;
        typeof(Action),
        typeof(Action&lt;bool&gt;),
    &#125;;
&#125;
<p>Action function1 = luaenv.Global.Get&lt;Action&gt;(“e”);<br />
function1();<br />
</code></pre><blockquote></p>
<p>在把函数映射到Action的时候，一定要把Action添加到生成列表，脚本中第一个静态的AddGenerateList类就是把Action增加到生成列表里。然后才可把函数映射到Action中。否则将会报错。</p>
</blockquote>
<h4 id="lua脚本多返回值映射"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#lua%E8%84%9A%E6%9C%AC%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%A0%E5%B0%84" class="headerlink" title="lua脚本多返回值映射"></a>lua脚本多返回值映射</h4><p>C#脚本</p>
<pre><code>[CSharpCallLua]
public delegate int Function2(int a, string b, out int c, out Table1 d);
<p>Function2 function2 = luaenv.Global.Get&lt;Function2&gt;(“f”);<br />
Table1 table1;<br />
int fun2_02;<br />
int fun2_01 = function2(66, “LianBai”, out fun2_02, out table1);<br />
print(“fun2_01:” + fun2_01);<br />
print(“fun2_02:” + fun2_02);<br />
print(“table1.x1:” + table1.x1);<br />
print(“table1.x2:” + table1.x2);<br />
</code></pre><blockquote></p>
<p>lua脚本里的函数支持多个返回值，而且返回值的类型也不同，在C#访问lua函数的时候，可以通过上述方法接收lua函数的多个返回值，第一个返回值直接接收映射过来函数的返回值，正如上述脚本里的fun2_01就是第一个返回值，然后后面的返回值均可用out接收，不过映射前声明的时候要用上述的声明方法：<br>[CSharpCallLua]<br>public delegate 第一个返回值类型 Function(参数1,参数2，…, out 第二个返回值,out 第三个返回值，…)</p>
</blockquote>
<h4 id="映射lua返回复杂类型的函数"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E6%98%A0%E5%B0%84lua%E8%BF%94%E5%9B%9E%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0" class="headerlink" title="映射lua返回复杂类型的函数"></a>映射lua返回复杂类型的函数</h4><p>C#脚本</p>
<pre><code>[CSharpCallLua]
public delegate Action Function3();
<p>Function3 function3 = luaenv.Global.Get&lt;Function3&gt;(“ret_e”);<br />
print(“第一步：”);<br />
function3();<br />
print(“第二步：”);<br />
Action function3_01 = function3();<br />
function3_01();<br />
</code></pre><blockquote></p>
<p>在C#访问lua的函数返回类型是复杂类型的时候，可以用委托接收，例如上述脚本，访问的函数的返回值是一个函数，在访问的时候，同样用委托接收，不过是两层委托，例如Function3的定义，function3所访问的就是访问对应的函数，然后用一个委托接收function3的返回值，然后就可以访问所返回的函数。</p>
</blockquote>
<h3 id="使用建议"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE" class="headerlink" title="使用建议"></a>使用建议</h3><blockquote>
<p>1.访问lua全局数据，特别是table以及function，代价比较大，建议尽量少做，比如在初始化时把要调用的lua function获取一次（映射到delegate）后，保存下来，后续直接调用该delegate即可。table也类似。 </p>
</blockquote>
<blockquote>
<p>2.如果lua测的实现的部分都以delegate和interface的方式提供，使用方可以完全和xLua解耦：由一个专门的模块负责xlua的初始化以及delegate、interface的映射，然后把这些delegate和interface设置到要用到它们的地方。</p>
</blockquote>
<h2 id="Lua访问C-脚本"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#Lua%E8%AE%BF%E9%97%AEC-%E8%84%9A%E6%9C%AC" class="headerlink" title="Lua访问C#脚本"></a>Lua访问C#脚本</h2><h3 id="lua创建一个C-的对象"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#lua%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAC-%E7%9A%84%E5%AF%B9%E8%B1%A1" class="headerlink" title="lua创建一个C#的对象"></a>lua创建一个C#的对象</h3><p>Lua脚本</p>
<pre><code>local CShapObject = CS.UnityEngine.GameObject("LianBai")
</code></pre><blockquote>
<p>通过上述方法可以用lua脚本创建一个新的gameobject,后面跟的字符串就是物体的名字，所以创建新物体的lua脚本就是<strong>local lua函数名 = CS.对象(class)命名空间.C#对象(class)名(参数)</strong>。</p>
</blockquote>
<h3 id="lua访问C-的静态属性、静态方法"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#lua%E8%AE%BF%E9%97%AEC-%E7%9A%84%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" class="headerlink" title="lua访问C#的静态属性、静态方法"></a>lua访问C#的静态属性、静态方法</h3><p>C#脚本</p>
<pre><code>LuaEnv luaenv = null;
private TextAsset luatext;
namespace MySpace
&#123;
    [LuaCallCSharp]
    public static class CShapStaticClass
    &#123;
        public static int a = 10;
        public static string b = "LianBai";
    &#125;
&#125;
<p>luaenv = new LuaEnv();<br />
luatext = Resources.Load&lt;TextAsset&gt;(“LuaText/lua_005.lua”);<br />
luaenv.DoString(luatext.text);<br />
print(CShapStaticClass.a);<br />
</code></pre><p>Lua脚本</p></p>
<pre><code>local CShapObject = CS.UnityEngine.GameObject("LianBai")
local a=CS.MySpace.CShapStaticClass.a
local b=CS.MySpace.CShapStaticClass.b
CS.MySpace.CShapStaticClass.a=66
print(a);
print(b);
</code></pre><blockquote>
<p>lua在访问c#的静态变量时与创建对象类似，CS.命名空间.静态类.静态变量<br>如果需要经常访问的类，可以先用局部变量引用后访问，除了减少敲代码的时间，还能提高性能。</p>
</blockquote>
<h3 id="lua访问C-成员属性、方法"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#lua%E8%AE%BF%E9%97%AEC-%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95" class="headerlink" title="lua访问C#成员属性、方法"></a>lua访问C#成员属性、方法</h3><h4 id="lua访问普通的类"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#lua%E8%AE%BF%E9%97%AE%E6%99%AE%E9%80%9A%E7%9A%84%E7%B1%BB" class="headerlink" title="lua访问普通的类"></a>lua访问普通的类</h4><p>C#脚本</p>
<pre><code>[LuaCallCSharp]
public class CShapClass02
&#123;
    public int c = 99;
    public void Class02Fun01()
    &#123;
        Debug.Log("This is CShapClass01's function d");
    &#125;
&#125;
</code></pre><p>lua脚本</p>
<pre><code>local LuaClass02 = CS.MySpace.CShapClass02
local luaclass02 = LuaClass02()
print(luaclass02.c)
luaclass02.c = 88
luaclass02:Class02Fun01()
</code></pre><blockquote>
<p>lua在访问C#的成员属性和方法的时候，先用变量映射出C#的类，然后再用一个变量接收。local 变量1 = CS.类所在命名空间.类名,变量1是映射过来的对象的声明，需要自己定义一个对象，local 变量2 = 变量1()，即变量2就是所映射过来的类的实例，通过<strong>变量2.变量名</strong>就可访问变量，通过<strong>变量2: 函数名()</strong>就可启用C#的函数。</p>
</blockquote>
<h4 id="lua访问继承的类"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#lua%E8%AE%BF%E9%97%AE%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB" class="headerlink" title="lua访问继承的类"></a>lua访问继承的类</h4><p>C#脚本</p>
<pre><code>[LuaCallCSharp]
public class CShapClass01
&#123;
    public static int a = 1;
    public static string b = "LianBai";
    public static void Class01Fun01()
    &#123;
        Debug.Log("This is Class01Fun01");
    &#125;
    public void Class01Fun02()
    &#123;
        Debug.Log("This is Class01Fun02");
    &#125;
&#125;
[LuaCallCSharp]
public class CShapClass02: CShapClass01
&#123;
    public int c = 99;
    public void Class02Fun01()
    &#123;
        Debug.Log("This is CShapClass01's function d");
    &#125;
&#125;
</code></pre><p>lua脚本  </p>
<pre><code>local LuaClass02 = CS.MySpace.CShapClass02
local luaclass02 = LuaClass02()
print(luaclass02.c)
print(LuaClass02.a)
print(LuaClass02.b)
luaclass02.c = 88
luaclass02:Class02Fun01()
LuaClass02.Class01Fun01()
luaclass02:Class01Fun02()
</code></pre><blockquote>
<p>lua在访问C#的含有继承类的类的时候，访问基类普通变量和访问子类一样，用<strong>变量2.变量名</strong>，和<strong>变量2：函数名</strong>来访问，但是在访问基类的静态变量的时候，通过<strong>变量1.变量名</strong>来访问基类<strong>静态变量</strong>，通过<strong>变量1：函数名</strong>来访问基类<strong>静态函数</strong>。xlua支持（通过派生类）访问基类的静态属性，静态方法，（通过派生类实例）访问基类的成员属性，成员方法。</p>
</blockquote>
<h4 id="访问复杂函数"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E8%AE%BF%E9%97%AE%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0" class="headerlink" title="访问复杂函数"></a>访问复杂函数</h4><p>C#脚本</p>
<pre><code>[LuaCallCSharp]
public class CShapClass02
&#123;
    public int c = 99;
    public void Class02Fun01()
    &#123;
        Debug.Log("This is CShapClass01's function d");
    &#125;
    public double Class02Fun02(CShapClass01 cshapclass01,ref int x1,out string x2,Action luafun,out Action csfun)
    &#123;
        Debug.Log(cshapclass01.c + " : " + cshapclass01.d);
        luafun();
        x1 = x1 * cshapclass01.c;
        x2 = "CShapClass01.d = " + cshapclass01.d;
        csfun = () =&gt;
        &#123;
            Debug.Log("This is CsFun");
        &#125;;
        Debug.Log(x1 + " : " + x2);
        return 6.66;
    &#125;
&#125;
</code></pre><p>Lua脚本</p>
<pre><code>local LuaClass02 = CS.MySpace.CShapClass02
local luaclass02 = LuaClass02()
function LuaFun()
    print("This is LuaFun")
end
local cshapclass01,x1,x2,csfun = luaclass02:Class02Fun02(&#123;c = 100,d = "LianHei"&#125;,88,LuaFun)
print("cshapclass01:",cshapclass01)
print("x1:", x1)
print("x2:", x2)
print("csfun:", csfun)
csfun();
</code></pre><blockquote>
<p>参数的输入输出属性（out，ref）<br>Lua调用测的参数处理规则：C#的普通参数算一个输入形参，ref修饰的算一个输入形参，out不算，然后从左往右对应lua 调用测的实参列表；<br>Lua调用测的返回值处理规则：C#函数的返回值（如果有的话）算一个返回值，out算一个返回值，ref算一个返回值，然后从左往右对应lua的多返回值。  </p>
<p>上述话的意思是lua在映射复杂的函数的时候，C#函数中的参数中有普通参数，ref定义的参数，out定义的参数，例如上述的<em>Class02Fun02</em>函数中<em>CShapClass01 cshapclass01</em>是普通的参数，就是我们正常定义的参数，<em>ref int x1</em>和<em>out string x2</em>分别是ref和out定义的参数，在lua调用的时候，<em>luaclass02:Class02Fun02({c = 100,d = “LianHei”},88,LuaFun)</em>，第一个表<em>{c = 100,d = “LianHei”}</em>是给<em>cshapclass01</em>传参数，88传给的是x1,LuaFun是传给的,Action luafun,因为x2和csfun是out形容的参数，所以不用传递。  </p>
<p>ref定义的参数，在调用的时候要传参数，在返回的时候也要接收，out定义的参数在调用的时候不用传递参数，但是在接收的时候要接收参数<br>在调用这个函数的时候会执行C#脚本里面的函数，然后函数会有返回值，如果函数本身就有返回值，则lua脚本在接收的第一个返回值就是函数的返回值，然后在C#函数中有些参数是ref或者out参数，这些参数从左往右依次都是函数的返回值，所以在C#函数里必须为这些参数赋值。</p>
</blockquote>
<h4 id="访问重载方法"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E8%AE%BF%E9%97%AE%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95" class="headerlink" title="访问重载方法"></a>访问重载方法</h4><p>C#脚本</p>
<pre><code>[LuaCallCSharp]
public class CShapClass03
&#123;
    public void CShapFun()
    &#123;
        Debug.Log("This is NULL");
    &#125;
    public void CShapFun(int a)
    &#123;
        Debug.Log("This is int");
    &#125;
    public void CShapFun(string a)
    &#123;
        Debug.Log("This is string");
    &#125;
&#125;
</code></pre><p>Lua脚本</p>
<pre><code>local LuaClass03 = CS.MySpace.CShapClass03
local luaclass03 = LuaClass03()
luaclass03:CShapFun()
luaclass03:CShapFun(2)
luaclass03:CShapFun("LianBai")
</code></pre><blockquote>
<p>在C#里运行脚本可以看出，在访问重载函数的时候，只要改变穿进去的参数，就会自动调用重载对应的函数。<br>注意：xlua只一定程度上支持重载函数的调用，因为lua的类型远远不如C#丰富，存在一对多的情况，比如C#的int，float，double都对应于lua的number，上面的例子中TestFunc如果有这些重载参数，第一行将无法区分开来，只能调用到其中一个（生成代码中排前面的那个）</p>
</blockquote>
<h4 id="调用操作符"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6" class="headerlink" title="调用操作符"></a>调用操作符</h4><p>C#脚本</p>
<pre><code>[LuaCallCSharp]
public class CShapClass03
&#123;
    public int a = 66;
    public string b = "LianBai";
    public static CShapClass03 operator + (CShapClass03 class1, CShapClass03 class2)
    &#123;
        CShapClass03 ret = new CShapClass03();
        ret.a = class1.a + class2.a;
        ret.b = class1.b + class2.b;
        return ret;
    &#125;
&#125;
</code></pre><p>Lua脚本</p>
<pre><code>local LuaClass03 = CS.MySpace.CShapClass03
local luaclass03 = LuaClass03()
local luaclass04 = LuaClass03()
print(luaclass03.a)
print(luaclass04.b)
luaclass04.a = 88
print(luaclass04.a)
print("This ",(luaclass03 + luaclass04).a)
luaclass03.b="I am "
print((luaclass03+luaclass04).b)
</code></pre><blockquote>
<p>在lua使用所访问的对象的操作符的时候，在对象内部必须重载此运算符，这样才可以使用此运算符，C#的运算符可以自己百度查询。然后在类里面即可像C#里面一样调用，允许操作的运算符有：<br>+，-，*，/，==，一元-，&lt;，&lt;=， %，[]</p>
</blockquote>
<h4 id="访问含默认值方法"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E8%AE%BF%E9%97%AE%E5%90%AB%E9%BB%98%E8%AE%A4%E5%80%BC%E6%96%B9%E6%B3%95" class="headerlink" title="访问含默认值方法"></a>访问含默认值方法</h4><p>C#脚本</p>
<pre><code>public void CShapClass03DefaultFun(int a = 66,string b = "LianBai",string c = null)
&#123;
    Debug.Log("a = " + a + " b = " + b + " c = " + c);
&#125;
</code></pre><p>Lua脚本  </p>
<pre><code>local LuaClass03 = CS.MySpace.CShapClass03
local luaclass03 = LuaClass03()
luaclass03:CShapClass03DefaultFun()
luaclass03:CShapClass03DefaultFun(88)
luaclass03:CShapClass03DefaultFun(88,"LianHei")
luaclass03:CShapClass03DefaultFun(88,"LianHei","COOL")
</code></pre><blockquote>
<p>在访问含有默认值的方法时，在lua里调用函数和C#调用有默认值参数的函数一样，如果所给的实参少于形参，则会用默认值补上。  </p>
</blockquote>
<h4 id="访问可变参数方法"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E8%AE%BF%E9%97%AE%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95" class="headerlink" title="访问可变参数方法"></a>访问可变参数方法</h4><p>C#脚本</p>
<pre><code>[LuaCallCSharp]
public class CShapClass03
&#123;
    public int a = 66;
    public string b = "LianBai";
    public void CShapClassVariableFun(int a,params string[] str)
    &#123;
        string s = null;
        foreach(string c in str)
        &#123;
            s = s + c +" ";
        &#125;
        Debug.Log("a = " + a + "  str = " + s);
    &#125;
&#125;
</code></pre><p>Lua脚本</p>
<pre><code>local LuaClass03 = CS.MySpace.CShapClass03
local luaclass03 = LuaClass03()
luaclass03:CShapClassVariableFun(10,"I")
luaclass03:CShapClassVariableFun(20,"I","am")
luaclass03:CShapClassVariableFun(30,"I","am","LianBai")
</code></pre><blockquote>
<p>lua在访问的方法中含有可变参数（<a href="http://www.runoob.com/csharp/csharp-param-arrays.html" target="_blank" rel="noopener noreferrer"><font color="steelblue">params</font></a>）的时候，也可以类似于在C#脚本的使用方法传进去参数。</p>
</blockquote>
<h4 id="映射枚举并访问枚举"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#%E6%98%A0%E5%B0%84%E6%9E%9A%E4%B8%BE%E5%B9%B6%E8%AE%BF%E9%97%AE%E6%9E%9A%E4%B8%BE" class="headerlink" title="映射枚举并访问枚举"></a>映射枚举并访问枚举</h4><p>C#脚本</p>
<pre><code>[LuaCallCSharp]
public enum MyEnum
&#123;
    x1 = 66,
    x2 = 88,
    x3 = 99
&#125;
[LuaCallCSharp]
public class CShapClass04
&#123;
    public MyEnum CShapEnumFun(MyEnum e)
    &#123;
        Debug.Log("MyEnum:" + e);
        return e;
    &#125;
&#125;
</code></pre><p>Lua脚本</p>
<pre><code>local LuaEnum = CS.MySpace.MyEnum
print(LuaEnum.__CastFrom("x1"),LuaEnum.__CastFrom("x2"),LuaEnum.__CastFrom("x3"))
local LuaClass04 = CS.MySpace.CShapClass04
local luaclass04 = LuaClass04()
local luaenum = luaclass04:CShapEnumFun(CS.MySpace.MyEnum.x1)
print(luaenum,luaenum == LuaEnum.x1)
print(LuaEnum.__CastFrom(0),LuaEnum.__CastFrom(1),LuaEnum.__CastFrom(2))
</code></pre><blockquote>
<p>在映射枚举的时候，直接像类一样直接声明枚举对象就可调用，方法是：<strong>local 变量1 = CS.枚举所在命名空间.枚举名</strong>，然后就可以通过<strong>变量1.key值</strong>就可访问枚举中的对象。<br>在映射类里面含有枚举参数的时候，可以直接通过<strong>CS.枚举所在命名空间.枚举名.key值”</strong>直接传进key对应的值，也可直接通过映射过来的变量1，通过<strong>变量1.key值”</strong>访问对应的key值。<br>如果枚举类加入到生成代码的话，枚举类将支持<strong>__CastFrom()</strong>方法，可以实现从一个整数或者字符串到枚举值的转换。（<font color="red">注：CastFrom前面是两个英文的下划线</font>)  </p>
</blockquote>
<h4 id="Lua访问C-委托"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#Lua%E8%AE%BF%E9%97%AEC-%E5%A7%94%E6%89%98" class="headerlink" title="Lua访问C#委托"></a>Lua访问C#委托</h4><p>C#脚本</p>
<pre><code>[LuaCallCSharp]
public class CShapClass04
&#123;
    public MyEnum CShapEnumFun(MyEnum e)
    &#123;
        Debug.Log("MyEnum:" + e);
        return e;
    &#125;
    public static Action&lt;string&gt; CShapStaticAction;
    public Action&lt;string&gt; CShapAction = (param) =&gt;
    &#123;
        Debug.Log("This is My CShapAction：" + param);
    &#125;;
public delegate void CShapDelegate(string obj);
&#125;
[LuaCallCSharp]
public class CShapClass05
&#123;
    public CShapClass04.CShapDelegate MyClassFun = null;
    public CShapClass05()
    &#123;
        MyClassFun = new CShapClass04.CShapDelegate(MyAction) ;
    &#125;
    private void MyAction(string obj)
    &#123;
        Debug.Log("This is My CShapDelegates：" + obj);
    &#125;
&#125;
<p>MySpace.CShapClass04.CShapStaticAction += MyStaticAction;<br />
</code></pre><p>Lua脚本</p></p>
<pre><code>local LuaClass04 = CS.MySpace.CShapClass04
local luaclass04 = LuaClass04()
local LuaClass05 = CS.MySpace.CShapClass05
local luaclass05 = LuaClass05()
LuaClass04.CShapStaticAction("LianBai")
luaclass04.CShapAction("LianBai")
local MyLuaClass = luaclass05.MyClassFun
上MyLuaClass("LianBai")
MyLuaClass("LianBai")
local function LuaAction(str)
    print("This is LuaAction :",str)
end
local luaaction = LuaAction + LuaClass04.CShapStaticAction
luaaction("+")
local luaaction = LuaClass04.CShapStaticAction - LuaAction
luaaction("-")
local luaaction = LuaClass04.CShapStaticAction + LuaAction
luaaction("+2")
local luaaction = LuaClass04.CShapStaticAction - LuaAction
luaaction("-2")
</code></pre><blockquote>
<p>C#的委托关键字是delegate,Action和Func都是别人封装好的委托，通过上述方法可以观测到，delegate在定义委托的时候，默认就是静态的方法，但是Action定义委托的时候需要手动添加关键字，如果没有添加关键字，只能通过对象调用，但是无法传递参数，因为delegate本身是静态的，所以导致无法使用，关于delegate和Action、Func的区别请<strong><a href="https://blog.csdn.net/cubesky/article/details/39577879" target="_blank" rel="noopener noreferrer"><font color="steelblue" size="3">点击这里</font></a></strong>  、<br>通过上述脚本，测试可发现，lua在访问委托的时候，和调用普通的函数方法一样。<br>+操作符：对应C#的+操作符，把两个调用串成一个调用链，右操作数可以是同类型的C# delegate或者是lua函数。<br>-操作符：和+相反，把一个delegate从调用链中移除。<br>+操作符左右任意一个是delegate就可以，但是-操作符delegate必须放在左边<br>Ps：delegate属性可以用 一个luafunction来赋值。</p>
</blockquote>
<h4 id="Lua访问类的事件-Event"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#Lua%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E4%BA%8B%E4%BB%B6-Event" class="headerlink" title="Lua访问类的事件(Event)"></a>Lua访问类的事件(Event)</h4><p>C#脚本  </p>
<pre><code>[LuaCallCSharp]
public class DelegateClass
&#123;
    public delegate void MyDelegate();  //定义一个委托
    public event MyDelegate myevent;    //定义了一个事件
    public void ClassFun01()
    &#123;
        myevent();
    &#125;
&#125;
</code></pre><p>Lua脚本  </p>
<pre><code>local LuaClass = CS.MySpace01.DelegateClass
local luaclass = LuaClass()
local function luafun01()
    print("This is luafun01")
end
local function luafun02()
    print("This is luafun02")
end
luaclass:myevent("+",luafun01)
luaclass:ClassFun01()
luaclass:myevent("+",luafun02)
luaclass:ClassFun01()
luaclass:myevent("-",luafun01)
luaclass:ClassFun01()
</code></pre><blockquote>
<p>Lua在访问<a href="http://www.runoob.com/csharp/csharp-event.html" target="_blank" rel="noopener noreferrer"><font color="steelblue">Event</font></a>的时候，添加事件回调的方法是<strong>类对象:委托名(“+”,函数名)</strong>，同样的，在移除事件回调的时候是<strong>类对象:委托名(“-“,函数名)</strong>。</p>
</blockquote>
<h4 id="Lua访问64位整数"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#Lua%E8%AE%BF%E9%97%AE64%E4%BD%8D%E6%95%B4%E6%95%B0" class="headerlink" title="Lua访问64位整数"></a>Lua访问64位整数</h4><p>C#脚本</p>
<pre><code>public ulong LongFun(long l)
&#123;
    return (ulong)l + 1;
&#125;
</code></pre><p>Lua脚本</p>
<pre><code>local LuaClass = CS.MySpace01.DelegateClass
local luaclass = LuaClass()
local a = luaclass:LongFun(11)
print(type(a),a+10,a+100,a+1000,a+10000)
</code></pre><blockquote>
<p>Lua53版本64位整数（long，ulong）映射到原生的64未整数，而luaji版本t，相当于lua5.1的标准，本身不支持64位，xlua做了个64位支持的扩展库，C#的long和ulong都将映射到userdata：<br>支持在lua里头进行64位的运算，比较，打印<br>支持和lua number的运算，比较<br>要注意的是，在64扩展库中，实际上只有int64，ulong也会先强转成long再传递到lua，而对ulong的一些运算，比较，我们采取和java一样的支持方式，提供一组API，详情请看API文档。</p>
</blockquote>
<h4 id="C-复杂类型和table的转换"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#C-%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E5%92%8Ctable%E7%9A%84%E8%BD%AC%E6%8D%A2" class="headerlink" title="C#复杂类型和table的转换"></a>C#复杂类型和table的转换</h4><p>C#脚本</p>
<pre><code>[LuaCallCSharp]
public class MyClass01
&#123;
    public int a;
    public void Show()
    &#123;
        Debug.Log("This is MyClass01's a:" + a);
    &#125;
&#125;
[LuaCallCSharp]
public class MyClass02
&#123;
    public MyClass01 a;
    public string b;
    public void Show()
    &#123;
        a.Show();
        Debug.Log("This is MyClass02's b:" + a);
    &#125;
<p>&#125;<br />
[LuaCallCSharp]<br />
public class MyClass03<br />
&#123;<br />
public void Set(MyClass02 my)<br />
&#123;<br />
my.Show();<br />
&#125;<br />
&#125;<br />
</code></pre><p>Lua脚本</p></p>
<pre><code>local LuaClass = CS.MySpace01.MyClass03
local luaclass = LuaClass()
luaclass:Set(&#123;a=&#123;a=66&#125;,b="LianBai"&#125;)
</code></pre><blockquote>
<p>Lua在访问复杂的Class参数时，一个{}就是一个类，如果想用上述方法，变量必须public，这样lua才能根据变量名进行赋值，就像一开头讲的，根据变量名字进行赋值。</p>
</blockquote>
<h4 id="Lua获取C-的类型-相当于C-的typeof"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#Lua%E8%8E%B7%E5%8F%96C-%E7%9A%84%E7%B1%BB%E5%9E%8B-%E7%9B%B8%E5%BD%93%E4%BA%8EC-%E7%9A%84typeof" class="headerlink" title="Lua获取C#的类型(相当于C#的typeof)"></a>Lua获取C#的类型(相当于C#的typeof)</h4><p>Lua脚本<br>    print(typeof(CS.MySpace01))</p>
<blockquote>
<p>要获取CS.MySpace01类的Type信息，可以用上述脚本</p>
</blockquote>
<h4 id="Lua强转数据"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#Lua%E5%BC%BA%E8%BD%AC%E6%95%B0%E6%8D%AE" class="headerlink" title="Lua强转数据"></a>Lua强转数据</h4><p>C#脚本</p>
<pre><code>[LuaCallCSharp]
public interface MyClass04
&#123;
    void  Show(int a, string b);
&#125;
[LuaCallCSharp]
public class MyClass05 : MyClass04
&#123;
    public int ID = 88;
    public void Show(int a, string b)
    &#123;
        Debug.Log(a);
        Debug.Log(b);
    &#125;
    public MyClass04 GetClass04()
    &#123;
        return new MyClass05();
    &#125;
&#125;
</code></pre><p>Lua脚本</p>
<pre><code>local LuaClass01 = CS.MySpace01.MyClass05 
local luaclass01 = LuaClass01()
local luainterface01 = luaclass01:GetClass04()
luainterface01:Show(66,"LianBai")
assert(luainterface01.ID == 88)
--assert(luainterface01.ID == nil)
<p>local LuaClass02 = CS.MySpace01.MyClass05<br />
local luaclass02 = LuaClass02()<br />
local luainterface02 = luaclass02:GetClass04()<br />
cast(luainterface02,typeof(CS.MySpace01.MyClass04))<br />
luainterface02:Show(88,“LianHei”)<br />
–assert(<a target="_blank" rel="noopener" href="http://luainterface02.ID">luainterface02.ID</a> == 88)<br />
assert(<a target="_blank" rel="noopener" href="http://luainterface02.ID">luainterface02.ID</a> == nil)<br />
</code></pre></p>
<h1 id="XLua配置"><a target="_blank" rel="noopener" href="https://LianBai.github.io/#XLua%E9%85%8D%E7%BD%AE" class="headerlink" title="XLua配置"></a>XLua配置</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lua.ren">糖果AIGC实验室 备案:辽ICP备16003836号-5</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lua.ren/zl/2016-01-01-218_XLua/">https://lua.ren/zl/2016-01-01-218_XLua/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="null" target="_blank">null</a> 许可协议。转载请注明来自 <a href="https://lua.ren" target="_blank">糖果AIGC实验室-LUA</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/lua%E6%96%87%E7%AB%A0/">lua文章</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/zl/2016-01-01-217_C++%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%B0%83%E7%94%A8Lua%E8%84%9A%E6%9C%AC/" title="C++项目中添加调用Lua脚本"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++项目中添加调用Lua脚本</div></div></a></div><div class="next-post pull-right"><a href="/zl/2016-01-01-213_Lua%20Study/" title="Lua Study"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Lua Study</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/zl/2016-01-01-2_AutoToolboxPopluate/" title="AutoToolboxPopluate"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-03</div><div class="title">AutoToolboxPopluate</div></div></a></div><div><a href="/zl/2016-01-01-1001_Lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="Lua正则表达式"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-03</div><div class="title">Lua正则表达式</div></div></a></div><div><a href="/zl/2016-01-01-1003_lua%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="lua快速入门"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-03</div><div class="title">lua快速入门</div></div></a></div><div><a href="/zl/2016-01-01-1004_C#%20%E4%BD%BF%E7%94%A8%20Lua%20%E5%8F%96%E5%BE%97%20Redis%20%E8%87%AA%E8%A8%82%E8%A4%87%E9%9B%9C%E5%9E%8B%E5%88%A5/" title="C# 使用 Lua 取得 Redis 自訂複雜型別"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-03</div><div class="title">C# 使用 Lua 取得 Redis 自訂複雜型別</div></div></a></div><div><a href="/zl/2016-01-01-1005_Lua%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/" title="Lua语言学习（二）"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-03</div><div class="title">Lua语言学习（二）</div></div></a></div><div><a href="/zl/2016-01-01-1002_Lua%20%E5%AD%A6%E4%B9%A0%20chapter7%20/" title="Lua 学习 chapter7"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-03</div><div class="title">Lua 学习 chapter7</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">糖果AIGC实验室 备案:辽ICP备16003836号-5</div><div class="author-info__description">AIGC</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1769</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">195</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">96</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">公众号：糖果的实验室 <img src="https://gitee.com/shengnoah/picture/raw/master/20231027182204.png"></img></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#XLua%E6%95%99%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">XLua教程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#XLua%E5%8A%A0%E8%BD%BD%E6%96%87%E6%A1%A3"><span class="toc-number">1.1.</span> <span class="toc-text">XLua加载文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.1.</span> <span class="toc-text">加载字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BDlua%E6%96%87%E6%A1%A3"><span class="toc-number">1.1.2.</span> <span class="toc-text">加载lua文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Loader"><span class="toc-number">1.1.3.</span> <span class="toc-text">自定义Loader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E8%AE%BF%E9%97%AELua"><span class="toc-number">1.2.</span> <span class="toc-text">C#访问Lua</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%A8%E5%B1%80%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">访问全局基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E7%9A%84table"><span class="toc-number">1.2.2.</span> <span class="toc-text">访问一个全局的table</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84class"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">映射到一个普通的class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AADictionary%E4%B8%AD"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">映射到一个Dictionary中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AAList%E9%87%8C"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">映射到一个List里</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AAinterface"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">映射到一个interface</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AALuaTable%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">映射到一个LuaTable变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AAfunaction"><span class="toc-number">1.2.3.</span> <span class="toc-text">访问一个funaction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AA%E5%A7%94%E6%89%98%EF%BC%88Action%E6%88%96%E8%80%85delgate%EF%BC%89"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">映射到一个委托（Action或者delgate）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lua%E8%84%9A%E6%9C%AC%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">lua脚本多返回值映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84lua%E8%BF%94%E5%9B%9E%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">映射lua返回复杂类型的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.2.4.</span> <span class="toc-text">使用建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua%E8%AE%BF%E9%97%AEC-%E8%84%9A%E6%9C%AC"><span class="toc-number">1.3.</span> <span class="toc-text">Lua访问C#脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lua%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAC-%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">lua创建一个C#的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lua%E8%AE%BF%E9%97%AEC-%E7%9A%84%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">lua访问C#的静态属性、静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lua%E8%AE%BF%E9%97%AEC-%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">lua访问C#成员属性、方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lua%E8%AE%BF%E9%97%AE%E6%99%AE%E9%80%9A%E7%9A%84%E7%B1%BB"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">lua访问普通的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lua%E8%AE%BF%E9%97%AE%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">lua访问继承的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">访问复杂函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">访问重载方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">调用操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%90%AB%E9%BB%98%E8%AE%A4%E5%80%BC%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">访问含默认值方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.7.</span> <span class="toc-text">访问可变参数方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E6%9E%9A%E4%B8%BE%E5%B9%B6%E8%AE%BF%E9%97%AE%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.3.3.8.</span> <span class="toc-text">映射枚举并访问枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lua%E8%AE%BF%E9%97%AEC-%E5%A7%94%E6%89%98"><span class="toc-number">1.3.3.9.</span> <span class="toc-text">Lua访问C#委托</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lua%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E4%BA%8B%E4%BB%B6-Event"><span class="toc-number">1.3.3.10.</span> <span class="toc-text">Lua访问类的事件(Event)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lua%E8%AE%BF%E9%97%AE64%E4%BD%8D%E6%95%B4%E6%95%B0"><span class="toc-number">1.3.3.11.</span> <span class="toc-text">Lua访问64位整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E5%92%8Ctable%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.3.12.</span> <span class="toc-text">C#复杂类型和table的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lua%E8%8E%B7%E5%8F%96C-%E7%9A%84%E7%B1%BB%E5%9E%8B-%E7%9B%B8%E5%BD%93%E4%BA%8EC-%E7%9A%84typeof"><span class="toc-number">1.3.3.13.</span> <span class="toc-text">Lua获取C#的类型(相当于C#的typeof)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lua%E5%BC%BA%E8%BD%AC%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.3.14.</span> <span class="toc-text">Lua强转数据</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XLua%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">XLua配置</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/zl/2016-01-01-99_%E6%B7%B1%E5%85%A5%20Lua%20Garbage%20Collector(%E4%B8%89)/" title="深入 Lua Garbage Collector(三)"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入 Lua Garbage Collector(三)"/></a><div class="content"><a class="title" href="/zl/2016-01-01-99_%E6%B7%B1%E5%85%A5%20Lua%20Garbage%20Collector(%E4%B8%89)/" title="深入 Lua Garbage Collector(三)">深入 Lua Garbage Collector(三)</a><time datetime="2024-04-03T03:47:36.244Z" title="发表于 2024-04-03 11:47:36">2024-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/zl/2016-01-01-9_Evaluating%20Polynomials/" title="Evaluating Polynomials"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Evaluating Polynomials"/></a><div class="content"><a class="title" href="/zl/2016-01-01-9_Evaluating%20Polynomials/" title="Evaluating Polynomials">Evaluating Polynomials</a><time datetime="2024-04-03T03:47:36.244Z" title="发表于 2024-04-03 11:47:36">2024-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/zl/2016-01-01-999_%E6%B7%B1%E5%85%A5Lua%20/" title="深入Lua"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入Lua"/></a><div class="content"><a class="title" href="/zl/2016-01-01-999_%E6%B7%B1%E5%85%A5Lua%20/" title="深入Lua">深入Lua</a><time datetime="2024-04-03T03:47:36.244Z" title="发表于 2024-04-03 11:47:36">2024-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/zl/2016-01-01-996_evaluation%20and%20selection%20%C2%B7%20ngc7293's%20blog/" title="evaluation and selection · ngc7293's blog"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="evaluation and selection · ngc7293's blog"/></a><div class="content"><a class="title" href="/zl/2016-01-01-996_evaluation%20and%20selection%20%C2%B7%20ngc7293's%20blog/" title="evaluation and selection · ngc7293's blog">evaluation and selection · ngc7293's blog</a><time datetime="2024-04-03T03:47:36.243Z" title="发表于 2024-04-03 11:47:36">2024-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/zl/2016-01-01-998_lua%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="lua 基础数据类型"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="lua 基础数据类型"/></a><div class="content"><a class="title" href="/zl/2016-01-01-998_lua%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="lua 基础数据类型">lua 基础数据类型</a><time datetime="2024-04-03T03:47:36.243Z" title="发表于 2024-04-03 11:47:36">2024-04-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 糖果AIGC实验室 备案:辽ICP备16003836号-5</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><script>(function () {
  var meta = document.createElement('meta');
  meta.content = 'no-referrer';
  meta.name = 'referrer';
  document.getElementsByTagName('head')[0].appendChild(meta);
})();</script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></body></html>