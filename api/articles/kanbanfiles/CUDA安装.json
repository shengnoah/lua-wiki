{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"kanbanfiles/CUDA安装","date":"2024-03-14T06:15:59.717Z","updated":"2024-03-14T06:15:59.717Z","comments":true,"path":"api/articles/kanbanfiles/CUDA安装.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>如何用apt-get 安装CUDA 11.8</p>\n<p>很抱歉，但是 CUDA 11.8 并不是一个存在的版本。CUDA 最新的稳定版本是 CUDA 11.5。以下是安装 CUDA 11.5 的步骤：</p>\n<ol>\n<li><p>首先，确保你的系统满足 CUDA 11.5 的要求。CUDA 11.5 支持 Linux、Windows 和 macOS 系统。你需要一块支持 NVIDIA GPU 的显卡，并且需要安装相应的驱动程序。</p>\n</li>\n<li><p>访问 NVIDIA 开发者网站（<a href=\"https://developer.nvidia.com/cuda-downloads%EF%BC%89%E5%B9%B6%E4%B8%8B%E8%BD%BD%E9%80%82%E7%94%A8%E4%BA%8E%E4%BD%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84\">https://developer.nvidia.com/cuda-downloads）并下载适用于你操作系统的</a> CUDA Toolkit 安装包。</p>\n</li>\n<li><p>在终端中运行以下命令以添加 CUDA 的软件源：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/7fa2af80.pub</span><br><span class=\"line\">$ sudo sh -c &#x27;echo &quot;deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64 /&quot; &gt; /etc/apt/sources.list.d/cuda.list&#x27;</span><br><span class=\"line\">$ sudo apt update</span><br></pre></td></tr></table></figure>\n\n<p>这些命令将添加 NVIDIA CUDA 软件源到你的系统。</p>\n</li>\n<li><p>接下来，运行以下命令安装 CUDA Toolkit：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install cuda</span><br></pre></td></tr></table></figure>\n\n<p>这将自动下载和安装 CUDA Toolkit 及其依赖项。</p>\n</li>\n<li><p>安装完成后，重启系统以使更改生效。</p>\n</li>\n<li><p>验证安装是否成功，可以运行以下命令查看 CUDA 版本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nvcc --version</span><br></pre></td></tr></table></figure>\n\n<p>如果显示了 CUDA 版本信息，则表示安装成功。</p>\n</li>\n</ol>\n<p>请注意，以上步骤适用于 Ubuntu 20.04 系统。如果你使用的是其他操作系统或版本，请参考 NVIDIA 官方文档以获取相应的安装指南。</p>\n<p>希望能对你有所帮助！</p>\n<p>apt-get 安装软件，如何指定安装目录</p>\n<p>在apt-get命令中，无法直接指定软件的安装目录。apt-get是一个高级包管理工具，它会自动将软件安装到预定义的目录结构中。</p>\n<p>默认情况下，apt-get会将软件安装到以下目录：</p>\n<ul>\n<li>可执行文件：/usr/bin/</li>\n<li>库文件：/usr/lib/</li>\n<li>配置文件：/etc/</li>\n<li>文档文件：/usr/share/doc/</li>\n</ul>\n<p>如果你需要指定软件的安装目录，可以考虑使用源代码编译的方式进行安装。这样可以手动指定软件的安装路径。</p>\n<p>以下是使用源代码编译方式进行软件安装以及指定安装目录的步骤：</p>\n<ol>\n<li>下载并解压源代码包。</li>\n<li>进入解压后的源代码目录。</li>\n<li>执行配置命令 <code>./configure --prefix=/desired/installation/path</code> 来指定安装路径。</li>\n<li>执行 <code>make</code> 命令进行编译。</li>\n<li>执行 <code>sudo make install</code> 命令进行安装。</li>\n</ol>\n<p>在上述步骤中，通过 <code>--prefix=/desired/installation/path</code> 参数来指定你希望软件被安装到哪个路径下。</p>\n<h3 id=\"如何用CUDA安显卡的占用率\"><a href=\"#如何用CUDA安显卡的占用率\" class=\"headerlink\" title=\"如何用CUDA安显卡的占用率\"></a>如何用CUDA安显卡的占用率</h3><p>要使用CUDA来监测显卡的占用率，可以按照以下步骤进行操作：</p>\n<ol>\n<li><p>安装CUDA Toolkit：首先，您需要下载并安装适用于您的显卡型号和操作系统的CUDA Toolkit。在NVIDIA官方网站上可以找到相关的下载链接。</p>\n</li>\n<li><p>编写CUDA程序：使用支持CUDA的编程语言（如C++、Python等），编写一个简单的CUDA程序。在该程序中，您可以创建一个或多个CUDA核函数，并通过调用这些函数来执行并行计算任务。</p>\n</li>\n<li><p>获取显卡占用率信息：在主机端的代码中，您可以使用NVIDIA提供的运行时API函数来获取有关显卡占用率的信息。具体而言，您可以使用<code>cudaGetDeviceProperties</code>函数获得有关当前设备（即显卡）的属性信息，包括设备名称、总共可用内存、最大线程数等等。此外，还可以使用<code>cudaEventRecord</code>和<code>cudaEventElapsedTime</code>等函数来计算GPU执行任务所需时间。</p>\n</li>\n<li><p>输出占用率信息：将获取到的显卡属性信息和执行时间等结果输出到终端或日志文件中，以便后续分析和监测。</p>\n</li>\n</ol>\n<p>需要注意的是，在进行显卡监测时，请确保您已正确地安装了适当版本的CUDA Toolkit，并且已正确配置了环境变量等相关设置。此外，还应遵循CUDA编程指南中的最佳实践，以确保您的CUDA程序能够正确地与显卡进行通信并利用其计算资源。</p>\n<p>希望以上内容对您有所帮助！</p>\n<p> 如何安Ubuntu上GPU的使用情况</p>\n<p>您可以使用以下命令来查看Ubuntu上GPU的使用情况：</p>\n<ol>\n<li>使用<code>nvidia-smi</code>命令来查看当前GPU的使用情况和相关信息。这个命令会显示当前系统中所有可用GPU的实时状态，包括GPU的使用率、显存使用情况、温度等。输入以下命令来运行<code>nvidia-smi</code>：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvidia-smi</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用<code>nvidia-settings</code>命令来查看和修改NVIDIA显卡的设置。该命令提供了一个图形界面，可以用于查看显卡信息、调整显示设置、监控温度和风扇速度等。输入以下命令来运行<code>nvidia-settings</code>：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvidia-settings</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>使用<code>gpustat</code>命令来查看当前系统中所有GPU的使用情况和相关信息。该命令会显示每个GPU的利用率、显存使用情况、温度等详细信息，并以表格形式展示。输入以下命令来安装并运行<code>gpustat</code>：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gpustat</span><br><span class=\"line\">gpustat</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>使用其他第三方工具如NVIDIA System Management Interface（NVSMI）或NVIDIA CUDA Toolkit提供的相关工具来获取更详细的GPU使用情况。</li>\n</ol>\n<p>请注意，要正确显示和获取GPU信息，您需要安装相应的驱动程序和工具包，并且您必须有适当的权限才能访问GPU信息。</p>\n<h3 id=\"Chatglm在做微调训练时，train-sh如何设置，CUDA同时使用两个显卡GPU\"><a href=\"#Chatglm在做微调训练时，train-sh如何设置，CUDA同时使用两个显卡GPU\" class=\"headerlink\" title=\"Chatglm在做微调训练时，train.sh如何设置，CUDA同时使用两个显卡GPU\"></a>Chatglm在做微调训练时，train.sh如何设置，CUDA同时使用两个显卡GPU</h3><p>要在Chatglm中进行微调训练并同时使用两个显卡GPU，可以按照以下步骤设置train.sh文件：</p>\n<ol>\n<li>打开train.sh文件并找到<code>CUDA_VISIBLE_DEVICES</code>这一行。该行用于设置可见的GPU设备。</li>\n<li>更改<code>CUDA_VISIBLE_DEVICES</code>的值为你想要使用的GPU设备的索引。例如，如果你有两个GPU设备，索引分别为0和1，则可以将其设置为”0,1”。</li>\n<li>确保你已经按照Chatglm的要求安装了正确版本的CUDA和cuDNN，并且在运行训练脚本之前已经正确配置了环境变量。</li>\n<li>运行train.sh脚本来启动微调训练。Chatglm将会自动检测并使用设置好的GPU设备。</li>\n</ol>\n<p>请注意，同时使用多个GPU设备进行训练可能需要更长的训练时间和更高的系统资源要求。确保你的系统满足这些要求，并根据需要进行相应配置。</p>\n<h3 id=\"Chatglm在做微调训练时，train-sh如何设置，CUDA同时使用两台主机上的两个显卡GPU，-多机多卡部署。\"><a href=\"#Chatglm在做微调训练时，train-sh如何设置，CUDA同时使用两台主机上的两个显卡GPU，-多机多卡部署。\" class=\"headerlink\" title=\"Chatglm在做微调训练时，train.sh如何设置，CUDA同时使用两台主机上的两个显卡GPU， 多机多卡部署。\"></a>Chatglm在做微调训练时，train.sh如何设置，CUDA同时使用两台主机上的两个显卡GPU， 多机多卡部署。</h3><p>在进行多机多卡部署时，可以使用分布式训练的方式来同时使用两台主机上的两个显卡GPU。具体来说，在train.sh文件中，可以按照以下步骤进行设置：</p>\n<ol>\n<li><p>安装和配置分布式训练所需的依赖项。确保在每台主机上都安装了CUDA和相应的驱动程序，并且所有主机都能够互相通信。</p>\n</li>\n<li><p>修改train.sh文件，添加分布式训练相关的参数。下面是一个示例：</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export CUDA_VISIBLE_DEVICES=0,1  # 设置使用的GPU索引</span><br><span class=\"line\"></span><br><span class=\"line\">python -m torch.distributed.launch --nproc_per_node=2 --use_env main.py \\</span><br><span class=\"line\">--data_dir /path/to/data \\</span><br><span class=\"line\">--model_name bert-base-uncased \\</span><br><span class=\"line\">--output_dir /path/to/output \\</span><br><span class=\"line\">--max_seq_length 128 \\</span><br><span class=\"line\">--per_device_train_batch_size 8 \\</span><br><span class=\"line\">--gradient_accumulation_steps 4 \\</span><br><span class=\"line\">--learning_rate 2e-5 \\</span><br><span class=\"line\">--num_train_epochs 3</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>CUDA_VISIBLE_DEVICES</code>参数用于指定要使用的GPU索引。在这个例子中，我们设置为0和1表示使用第一台主机上的两个显卡。</p>\n<p><code>torch.distributed.launch</code>模块是PyTorch提供的用于启动分布式训练的工具。<code>--nproc_per_node</code>参数指定每个节点（即每台主机）上使用的GPU数量，在这里设置为2表示每台主机上同时使用两个显卡。</p>\n<p>其余参数根据具体情况进行设置，如输入数据路径（<code>--data_dir</code>）、模型名称（<code>--model_name</code>）、输出路径（<code>--output_dir</code>）、每个设备上的训练批次大小（<code>--per_device_train_batch_size</code>）等。</p>\n<ol start=\"3\">\n<li>在每台主机上运行train.sh脚本。确保在每台主机上都运行相同的脚本，并且指定了正确的参数。</li>\n</ol>\n<p>这样，两台主</p>\n<p>Chatglm在做微调训练时，train.sh如何设置，CUDA，分布式指定，如何配置远程服务器的IP</p>\n<p>在进行ChatGPT微调训练时，可以使用train.sh文件来设置训练的各种参数。以下是一些常用的设置：</p>\n<ol>\n<li><p>CUDA设置：如果你的机器上有多个GPU，你可以使用CUDA_VISIBLE_DEVICES环境变量来指定要使用的GPU设备。例如，如果你要使用第一张和第三张GPU设备，则可以将该变量设置为”0,2”。</p>\n</li>\n<li><p>分布式训练指定：如果你想进行分布式训练，需要指定分布式训练的相关参数，如–num_gpus和–num_nodes。–num_gpus用于指定每个节点上使用的GPU数量，而–num_nodes则用于指定参与训练的节点数量。</p>\n</li>\n<li><p>配置远程服务器IP：如果你要将训练任务提交到远程服务器上执行，你需要在train.sh文件中配置远程服务器的IP地址。具体配置方法取决于你所使用的分布式训练框架。例如，在PyTorch中，你可以通过设置MASTER_ADDR和MASTER_PORT环境变量来指定主节点（即远程服务器）的IP地址和端口号。</p>\n</li>\n</ol>\n<p>示例train.sh文件内容如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> CUDA_VISIBLE_DEVICES=<span class=\"string\">&quot;0,2&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> MASTER_ADDR=192.168.1.100</span><br><span class=\"line\"><span class=\"built_in\">export</span> MASTER_PORT=1234</span><br><span class=\"line\"></span><br><span class=\"line\">python train.py \\</span><br><span class=\"line\">    --model_name_or_path gpt2 \\</span><br><span class=\"line\">    --output_dir ./output \\</span><br><span class=\"line\">    --do_train \\</span><br><span class=\"line\">    --train_data_file ./data/train.txt \\</span><br><span class=\"line\">    --per_device_train_batch_size 4 \\</span><br><span class=\"line\">    --num_train_epochs 5 \\</span><br><span class=\"line\">    --logging_steps 100 \\</span><br><span class=\"line\">    --save_steps 1000 \\</span><br><span class=\"line\">    --overwrite_output_dir \\</span><br><span class=\"line\">    --fp16</span><br></pre></td></tr></table></figure>\n\n<p>在上述示例中，我们指定了使用第一张和第三张GPU设备，将训练任务提交到IP地址为192.168.1.100的远程服务器上执行。其他训练参数根据实际需求进行设置。</p>\n<p>请注意，具体的设置可能因你所</p>\n<p> chatglm分布微调训练，如何配置MASTER_ADDR和MASTER_PORT变量</p>\n<p>在进行chatglm分布微调训练时，需要配置MASTER_ADDR和MASTER_PORT变量来指定主节点的地址和端口。</p>\n<ol>\n<li><p>首先，确定一个机器作为主节点。这个节点将负责协调整个训练过程。</p>\n</li>\n<li><p>然后，在其他参与训练的机器上设置MASTER_ADDR和MASTER_PORT变量，将它们指向主节点的地址和端口。可以使用以下命令设置环境变量：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export MASTER_ADDR=&lt;主节点地址&gt;</span><br><span class=\"line\">export MASTER_PORT=&lt;主节点端口号&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>确保所有参与训练的机器都设置了相同的MASTER_ADDR和MASTER_PORT值。</p>\n</li>\n<li><p>在启动每个参与训练的机器上运行相应的代码。代码将连接到指定的主节点，并与其他机器进行通信。</p>\n</li>\n</ol>\n<p>请注意，这些步骤可能因具体使用的框架或工具而有所不同。确保查阅相关文档以了解正确的配置方法。</p>\n<p>ChatGLM微调训练如何配置主结点的train.sh</p>\n<p>ChatGLM微调训练的主结点的train.sh可以配置如下：</p>\n<ol>\n<li><p>首先，需要设置训练数据和验证数据的路径。可以使用<code>--train_path</code>参数指定训练数据的路径，<code>--valid_path</code>参数指定验证数据的路径。</p>\n</li>\n<li><p>接下来，可以设置模型保存的路径。可以使用<code>--save_dir</code>参数指定模型保存的目录。</p>\n</li>\n<li><p>然后，需要指定模型的超参数。例如，可以使用<code>--learning_rate</code>参数设置学习率，<code>--batch_size</code>参数设置批次大小。</p>\n</li>\n<li><p>可以选择加载预训练模型进行微调。可以使用<code>--pretrained_model_path</code>参数指定预训练模型的路径。</p>\n</li>\n<li><p>可以选择冻结部分层进行微调。可以使用<code>--frozen_layers</code>参数指定要冻结的层。</p>\n</li>\n<li><p>可以设置训练轮数和打印信息频率。例如，可以使用<code>--num_epochs</code>参数设置训练轮数，<code>--log_steps</code>参数设置打印信息频率。</p>\n</li>\n<li><p>可以选择是否启用混合精度训练。可以使用<code>--fp16_opt_level O1/O2/O3/Off </code>参数启用混合精度训练，并通过调整优化级别来控制精度和性能之间的平衡。</p>\n</li>\n<li><p>最后，可以运行主结点脚本开始微调训练。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m paddle.distributed.launch --gpus &quot;0,1,2,3&quot; train.py \\</span><br><span class=\"line\">--train_path /path/to/train_data \\</span><br><span class=\"line\">--valid_path /path/to/valid_data \\</span><br><span class=\"line\">--save_dir /path/to/save_model \\</span><br><span class=\"line\">--learning_rate 0.001 \\</span><br><span class=\"line\">--batch_size 32 \\</span><br><span class=\"line\">--pretrained_model_path /path/to/pretrained_model \\</span><br><span class=\"line\">--frozen_layers 6 \\</span><br><span class=\"line\">--num_epochs 10 \\</span><br><span class=\"line\">--log_steps 100</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>以上是一个示例的配置，具体的参数</p>\n<p>chatglm的web_demo.sh如何配置指定IP和端口</p>\n<p>要配置chatglm的web_demo.sh指定IP和端口，可以按照以下步骤进行操作：</p>\n<ol>\n<li><p>打开web_demo.sh文件，可以使用文本编辑器（如vi、nano等）打开该文件。</p>\n</li>\n<li><p>在文件中找到以下行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 -m chatglm.web.serve</span><br></pre></td></tr></table></figure></li>\n<li><p>在该行的末尾添加参数以指定IP和端口，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 -m chatglm.web.serve --host 192.168.1.100 --port 8000</span><br></pre></td></tr></table></figure>\n\n<p>这将使web_demo.sh在IP地址为192.168.1.100，端口为8000的主机上运行。</p>\n</li>\n<li><p>保存并关闭文件。</p>\n</li>\n<li><p>运行web_demo.sh脚本以启动chatglm的Web demo，并监听指定的IP和端口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh web_demo.sh</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>现在，chatglm的Web demo将在指定的IP地址和端口上运行。</p>\n<p>chatGLM的web_demo.py运行时指定IP和端口</p>\n<p>要在chatGLM的web_demo.py运行时指定IP和端口，可以使用以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python web_demo.py --ip &lt;IP地址&gt; --port &lt;端口号&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>&lt;IP地址&gt;</code>是你想要指定的IP地址，可以是本地主机的IP地址或者其他可用的IP地址。</p>\n<p><code>&lt;端口号&gt;</code>是你想要指定的端口号，可以是任意未被占用的端口号。</p>\n<p>例如，如果你想将chatGLM的web_demo.py运行在本地主机的IP地址为127.0.0.1，端口号为5000上，可以使用以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python web_demo.py --ip 127.0.0.1 --port 5000</span><br></pre></td></tr></table></figure>\n\n<p>这样，chatGLM将会在指定的IP地址和端口上运行。你可以通过访问<code>http://&lt;IP地址&gt;:&lt;端口号&gt;</code>来查看和使用chatGLM。</p>\n<p>chatglm的demo.queue().launch(share=False, inbrowser=True)指定IP</p>\n<p>在chatglm的demo中，queue().launch()函数的share和inbrowser参数不支持指定IP。</p>\n<p>queue().launch(share=False)参数用于控制是否与其他用户共享会话。如果设置为True，则可以与其他用户共享同一个会话，而设置为False则会创建一个新的私有会话。</p>\n<p>queue().launch(inbrowser=True)参数用于控制是否在浏览器中打开机器人对话界面。如果设置为True，则会在默认浏览器中打开对话界面，而设置为False则不会打开对话界面。</p>\n<p>但是，这些参数都没有提供指定IP的选项。</p>\n<p>chatglm运行web demo如何指定IP和端口号启动</p>\n<p>要指定IP和端口号启动chatglm的web demo，您可以按照以下步骤进行操作：</p>\n<ol>\n<li>打开<code>app.py</code>文件。</li>\n<li>在文件的顶部找到以下代码段：</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    app.run(debug=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>在<code>app.run()</code>函数中添加参数来指定IP和端口号。例如，如果您想要将IP设置为<code>127.0.0.1</code>，端口号设置为<code>5000</code>，则将代码修改为如下：</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    app.run(debug=<span class=\"literal\">True</span>, host=<span class=\"string\">&quot;127.0.0.1&quot;</span>, port=<span class=\"number\">5000</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>保存文件并关闭。</li>\n</ol>\n<p>现在，当您运行web demo时，它将在指定的IP和端口号上启动。</p>\n<p>如何用go启动的一个程序转127.0.0.1:7860给 0.0.0.0:7860</p>\n<p>你可以使用net包中的Listen函数来启动一个TCP服务器，然后将地址参数设置为”127.0.0.1:7860”。接下来，你可以使用Accept函数等待客户端连接，并将连接转发到”0.0.0.0:7860”上。</p>\n<p>下面是一个示例代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 启动TCP服务器</span></span><br><span class=\"line\">\tlistener, err := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;127.0.0.1:7860&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> listener.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;Server started on 127.0.0.1:7860&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 等待客户端连接</span></span><br><span class=\"line\">\t\tconn, err := listener.Accept()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将连接转发到新的地址</span></span><br><span class=\"line\">        <span class=\"keyword\">go</span> forwardConnection(conn)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">forwardConnection</span><span class=\"params\">(conn net.Conn)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 连接到目标地址</span></span><br><span class=\"line\">    targetConn, err := net.Dial(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;0.0.0.0:7860&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Println(err)</span><br><span class=\"line\">        conn.Close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在两个连接之间复制数据</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        _, err := io.Copy(conn, targetConn)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &amp;&amp; !isClosedError(err) &#123;</span><br><span class=\"line\">            log.Println(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        conn.Close()</span><br><span class=\"line\">        targetConn.Close()</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    </span><br><span class=\"line\">    _, err = io.Copy(targetConn, conn)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &amp;&amp; !isClosedError(err) &#123;</span><br><span class=\"line\">        log.Println(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    conn.Close()</span><br><span class=\"line\">    targetConn.Close()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isClosedError</span><span class=\"params\">(err <span class=\"type\">error</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> opErr, ok := err.(*net.OpError); ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> opErr.Err.Error() == <span class=\"string\">&quot;use of closed network connection&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，你的程序就可以将来自”127.0.0.1:7860”的连接转发到”0.0.0.0:7860”上了。</p>\n<p>如何执行一段go代码</p>\n<p>要执行一段Go代码，您需要按照以下步骤进行操作：</p>\n<ol>\n<li><p>安装Go：首先，您需要安装Go编程语言。您可以从官方网站（<a href=\"https://golang.org/dl/%EF%BC%89%E4%B8%8B%E8%BD%BD%E9%80%82%E7%94%A8%E4%BA%8E%E6%82%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%8C%E5%B9%B6%E6%8C%89%E7%85%A7%E5%AE%89%E8%A3%85%E5%90%91%E5%AF%BC%E7%9A%84%E6%8C%87%E7%A4%BA%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E3%80%82\">https://golang.org/dl/）下载适用于您操作系统的安装包，并按照安装向导的指示进行安装。</a></p>\n</li>\n<li><p>编写代码：使用任何文本编辑器编写您的Go代码，并将其保存为以<code>.go</code>为扩展名的文件。例如，您可以创建一个名为<code>hello.go</code>的文件，并在其中编写一个简单的“Hello, World!”程序。</p>\n</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Hello, World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>打开终端或命令提示符：打开终端（Mac和Linux）或命令提示符（Windows），并导航到保存了您的代码文件的目录。</p>\n</li>\n<li><p>构建程序：使用以下命令构建您的Go程序：</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go build hello.go</span><br></pre></td></tr></table></figure>\n\n<p>这将生成一个可执行文件（在Windows上是<code>.exe</code>文件，在其他操作系统上没有扩展名），其名称与源代码文件相同（在此示例中为<code>hello</code>）。</p>\n<ol start=\"5\">\n<li>运行程序：使用以下命令运行生成的可执行文件：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./hello</span><br></pre></td></tr></table></figure>\n\n<p>如果一切顺利，您应该能够在终端或命令提示符中看到输出结果：“Hello, World!”</p>\n<p>请注意，如果您只想运行而不构建可执行文件，则可以使用以下命令直接运行Go代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run hello.go</span><br></pre></td></tr></table></figure>\n\n<p>这将编译并运行您的代码，而不会在硬盘上生成可执行文件。</p>\n<p>ubuntu 22如何安装golang</p>\n<p>要在Ubuntu 22上安装Golang，请按照以下步骤进行操作：</p>\n<ol>\n<li><p>打开终端。</p>\n</li>\n<li><p>使用以下命令下载Golang的二进制文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://golang.org/dl/go1.17.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>\n\n<p>这将下载Golang 1.17版本的二进制文件，你也可以根据需要选择其他版本。</p>\n</li>\n<li><p>解压下载的文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo tar -C /usr/local -xzf go1.17.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li>\n<li><p>配置环境变量。编辑<code>~/.profile</code>文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nano ~/.profile</span><br></pre></td></tr></table></figure></li>\n<li><p>在文件末尾添加以下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure></li>\n<li><p>按下Ctrl + X保存并退出编辑器。</p>\n</li>\n<li><p>刷新配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~/.profile</span><br></pre></td></tr></table></figure></li>\n<li><p>验证Golang是否成功安装。在终端中运行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go version</span><br></pre></td></tr></table></figure></li>\n<li><p>如果正确显示了Go的版本号，那么恭喜你，已成功安装Golang！</p>\n</li>\n</ol>\n<p>现在你可以开始使用Golang开发应用程序了。祝你好运！</p>\n","text":"如何用apt-get 安装CUDA 11.8 很抱歉，但是 CUDA 11.8 并不是一个存在的版本。CUDA 最新的稳定版本是 CUDA 11.5。以下是安装 CUDA 11.5 的步骤： 首先，确保你的系统满足 CUDA 11.5 的要求。CUDA 11.5 支持 Linux...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%94%A8CUDA%E5%AE%89%E6%98%BE%E5%8D%A1%E7%9A%84%E5%8D%A0%E7%94%A8%E7%8E%87\"><span class=\"toc-text\">如何用CUDA安显卡的占用率</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Chatglm%E5%9C%A8%E5%81%9A%E5%BE%AE%E8%B0%83%E8%AE%AD%E7%BB%83%E6%97%B6%EF%BC%8Ctrain-sh%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%EF%BC%8CCUDA%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%98%BE%E5%8D%A1GPU\"><span class=\"toc-text\">Chatglm在做微调训练时，train.sh如何设置，CUDA同时使用两个显卡GPU</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Chatglm%E5%9C%A8%E5%81%9A%E5%BE%AE%E8%B0%83%E8%AE%AD%E7%BB%83%E6%97%B6%EF%BC%8Ctrain-sh%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%EF%BC%8CCUDA%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B8%A4%E5%8F%B0%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%98%BE%E5%8D%A1GPU%EF%BC%8C-%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E9%83%A8%E7%BD%B2%E3%80%82\"><span class=\"toc-text\">Chatglm在做微调训练时，train.sh如何设置，CUDA同时使用两台主机上的两个显卡GPU， 多机多卡部署。</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"kanbanfiles/ATT&CK技术","date":"2024-03-14T06:15:59.717Z","updated":"2024-03-14T06:15:59.717Z","comments":true,"path":"api/articles/kanbanfiles/ATT&CK技术.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"ATT&amp;CK技术指是什么？ ATT&amp;CK技术指的是一种用于描述和分类威胁行为的系统。ATT&amp;CK代表Adversarial Tactics, Techniques, and Common Knowledge（对抗性战术、技术和共享知识），是由MITRE公司...","link":"","photos":[],"count_time":{"symbolsCount":366,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"kanbanfiles/Go语言实现代理","date":"2024-03-14T06:15:59.717Z","updated":"2024-03-14T06:15:59.717Z","comments":true,"path":"api/articles/kanbanfiles/Go语言实现代理.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"如何用Go语言实现代理转发HTTP请求的流量，从80端口转发给实际服务上的8000端口。 要使用Go语言实现代理转发HTTP请求的流量，可以使用net/http包和httputil包来处理。以下是一个简单的示例代码： 1234567891011121314151617181920...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}