{"title":"Lua元表","uid":"0498ed7eca93166bac9cec9951eb31df","slug":"old-lua/2016-06-01-metatables","date":"2024-03-14T06:15:59.731Z","updated":"2024-03-14T06:15:59.731Z","comments":true,"path":"api/articles/old-lua/2016-06-01-metatables.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<h1 id=\"Lua-元表\"><a href=\"#Lua-元表\" class=\"headerlink\" title=\"Lua 元表\"></a>Lua 元表</h1><p>正如其名，元表也是表。不过，将元表与表相关联后，我们就可以通过设置元表的键和相关方法来改变表的行为。元方法的功能十分强大，使用元方法可以实现很多的功能，比如：  </p>\n<ul>\n    <li>修改表的操作符功能或为操作符添加新功能（译注：如果您学过 C++ 之类的面向对象的语言，应该比较好理解，其实它实现的是操作的重载）。</li>\n    <li>使用元表中的 __index 方法，我们可以实现在表中查找键不存在时转而在元表中查找键值的功能。</li>\n</ul>  \n\n<p>Lua 提供了两个十分重要的用来处理元表的方法，如下：  </p>\n<ul>\n    <li>setmetatable(table,metatable):此方法用于为一个表设置元表。</li>\n    <li>getmetatable(table)：此方法用于获取表的元表对象。</li>\n</ul>  \n\n<p>首先，让我们看一下如何将一个表设置为另一个表的元表。示例如下：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mytable = &#123;&#125;</span><br><span class=\"line\">mymetatable = &#123;&#125;</span><br><span class=\"line\">setmetatable(mytable,mymetatable)</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">上面的代码可以简写成如下的一行代码：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mytable = setmetatable({},{})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## __index  </span><br><span class=\"line\"></span><br><span class=\"line\">下面的例子中，我们实现了在表中查找键不存在时转而在元表中查找该键的功能：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mytable = setmetatable({key1 = “value1”}, {<br>  __index = function(mytable, key)<br>    if key == “key2” then<br>      return “metatablevalue”<br>    else<br>      return mytable[key]<br>    end<br>  end<br>})</p>\n<p>print(mytable.key1,mytable.key2)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">运行上面的程序，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>value1    metatablevalue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">接下来逐步解释上面例子运行的过程：  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">\t&lt;li&gt;表 mytable 为 &#123;key = &quot;values1&quot;&#125;&lt;/li&gt;</span><br><span class=\"line\">\t&lt;li&gt;为 mytable 设置了一个元表，该元表的键 __index 存储了一个函数，我们称这个函数为元方法。&lt;/li&gt;</span><br><span class=\"line\">\t&lt;li&gt;这个元方法的工作也十分简单。它仅查找索引 “key2”,如果找到该索引值，则返回 &quot;metatablevalue&quot;,否则返回 mytable 中索引对应的值。&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">上面的程序同样可以简化成如下的形式：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mytable = setmetatable({key1 = “value1”}, { __index = { key2 = “metatablevalue” } })<br>print(mytable.key1,mytable.key2)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## __newindex  </span><br><span class=\"line\"></span><br><span class=\"line\">为元表添加 __newindex 后，当访问的键在表中不存在时，此时添加新键值对的行为将由此元方法（__newindex）定义。下面的例子中，如果访问的索引在表中不存在则在元表中新加该索引值（注意，是添加在另外一个表 mymetatable 中而非在原表 mytable 中。），具体代码如下(译注：请注意此处 __newindex 的值并非一个方法而是一个表。)：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mymetatable = {}<br>mytable = setmetatable({key1 = “value1”}, { __newindex = mymetatable })</p>\n<p>print(mytable.key1)</p>\n<p>mytable.newkey = “new value 2”<br>print(mytable.newkey,mymetatable.newkey)</p>\n<p>mytable.key1 = “new  value 1”<br>print(mytable.key1,mymetatable.newkey1)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">执行上面的程序，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>value1<br>nil    new value 2<br>new  value 1    nil</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">可以看出，在上面的程序中，如果键存在于主表中，只会简单更新相应的键值。而如果键不在表中时，会在另外的表 mymetatable 中添加该键值对。  </span><br><span class=\"line\">在接下来这个例子中，我们用 rawset 函数在相同的表（主表）中更新键值，而不再是将新的键添加到另外的表中。代码如下所示：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mytable = setmetatable({key1 = “value1”}, {<br>  __newindex = function(mytable, key, value)<br>        rawset(mytable, key, “&quot;“..value..”&quot;“)</p>\n<p>  end<br>})</p>\n<p>mytable.key1 = “new value”<br>mytable.key2 = 4</p>\n<p>print(mytable.key1,mytable.key2)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">执行上面的程序，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>new value    “4”</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">rawset 函数设置值时不会使用元表中的 __newindex 元方法。同样的，Lua 中也存的一个 rawget 方法，该方法访问表中键值时也不会调用 __index 的元方法。  </span><br><span class=\"line\"></span><br><span class=\"line\">## 为表添加操作符行为  </span><br><span class=\"line\"></span><br><span class=\"line\">使用 + 操作符完成两个表组合的方法如下所示（译注：可以看出重载的意思了）：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mytable = setmetatable({ 1, 2, 3 }, {<br>  __add = function(mytable, newtable)<br>    for i = 1, table.maxn(newtable) do<br>      table.insert(mytable, table.maxn(mytable)+1,newtable[i])<br>    end<br>    return mytable<br>  end<br>})</p>\n<p>secondtable = {4,5,6}</p>\n<p>mytable = mytable + secondtable<br>for k,v in ipairs(mytable) do<br>print(k,v)<br>end</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">执行上面的的程序，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>1    1<br>2    2<br>3    3<br>4    4<br>5    5<br>6    6</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">元表中 __add 键用于修改加法操作符的行为。其它操作对应的元表中的键值如下表所示。  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;th&gt;键&lt;/th&gt;</span><br><span class=\"line\">\t\t&lt;th&gt;描述&lt;/th&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__add&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变加法操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__sub&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变减法操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__mul&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变乘法操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__div&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变除法操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__mod&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变模除操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__unm&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变一元减操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__concat&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变连接操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__eq&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变等于操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__lt&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变小于操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__le&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变小于等于操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">&lt;/table&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">## __call  </span><br><span class=\"line\"></span><br><span class=\"line\">使用 __call 可以使表具有像函数一样可调用的特性。下面的例子中涉及两个表，主表 mytable 和 传入的实参表结构 newtable，程序完成两个表中值的求和。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mytable = setmetatable({10}, {<br>  __call = function(mytable, newtable)<br>    sum = 0<br>    for i = 1, table.maxn(mytable) do<br>        sum = sum + mytable[i]<br>    end<br>    for i = 1, table.maxn(newtable) do<br>        sum = sum + newtable[i]<br>    end<br>    return sum<br>  end<br>})<br>newtable = {10,20,30}<br>print(mytable(newtable))</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">运行上面的代码，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>70</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## __tostring  </span><br><span class=\"line\"></span><br><span class=\"line\">要改变 print 语句的行为，我们需要用到 __tostring 元方法。下面是一个简单的例子：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mytable = setmetatable({ 10, 20, 30 }, {<br>  __tostring = function(mytable)<br>    sum = 0<br>    for k, v in pairs(mytable) do<br>        sum = sum + v<br>    end<br>    return “The sum of values in the table is “ .. sum<br>  end<br>})<br>print(mytable)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">运行上面的代码，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>The sum of values in the table is 60</p>\n<p>```  </p>\n<p>如果你完全掌握了元表的用法，你就可以实现很多看上面很复杂的操作。如果不使用元表，就不仅仅是看上去很复杂了，而是真的非常复杂。所以，多做一些使用元表的练习，并熟练掌握所有元表的可选项，这会让你受益匪浅。</p>\n","text":"Lua 元表正如其名，元表也是表。不过，将元表与表相关联后，我们就可以通过设置元表的键和相关方法来改变表的行为。元方法的功能十分强大，使用元方法可以实现很多的功能，比如： 修改表的操作符功能或为操作符添加新功能（译注：如果您学过 C++ 之类的面向对象的语言，应该比较好理解，其实...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"LUA教程","slug":"LUA教程","count":8,"path":"api/tags/LUA教程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Lua-%E5%85%83%E8%A1%A8\"><span class=\"toc-text\">Lua 元表</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua中的for循环","uid":"26bfa2ece82537ab5f6962e2d31968f1","slug":"old-lua/2016-06-11-for","date":"2024-03-14T06:15:59.732Z","updated":"2024-03-14T06:15:59.732Z","comments":true,"path":"api/articles/old-lua/2016-06-11-for.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"text":"Lua 中的 for 循环for 循环控制结构可以让你高效地写出需要执行特定次数的循环代码。 语法Lua 语言中 for 循环的语法如下： 1234for init,max/min value, incrementdo statement(s)end 下面是 for 循环执行的流...","link":"","photos":[],"count_time":{"symbolsCount":509,"symbolsTime":"1 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"},{"name":"lua教程","slug":"lua-guide/lua教程","count":3,"path":"api/categories/lua-guide/lua教程.json"}],"tags":[{"name":"LUA","slug":"LUA","count":2,"path":"api/tags/LUA.json"},{"name":"abc","slug":"abc","count":2,"path":"api/tags/abc.json"},{"name":"basic","slug":"basic","count":2,"path":"api/tags/basic.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua模块","uid":"795dd91f8815508a13e65b7151fdf68c","slug":"old-lua/2016-06-01-modules","date":"2024-03-14T06:15:59.731Z","updated":"2024-03-14T06:15:59.731Z","comments":true,"path":"api/articles/old-lua/2016-06-01-modules.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"Lua 模块什么是模块？Lua 中的模块与库的概念相似，每个模块都有一个全局唯一名字，并且每个模块都包含一个表。使用一个模块时，可以使用 require 加载模块。模块中可以包括函数和变量，所有这些函数和变量被表存储于模块的表中。模块中的表的功能类似于命名空间，用于隔离不同模块中...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}