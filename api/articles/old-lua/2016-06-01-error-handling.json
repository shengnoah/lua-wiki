{"title":"Lua错误处理","uid":"8fa5391aad4ba0aa8b3b2333eb0ffb7d","slug":"old-lua/2016-06-01-error-handling","date":"2024-03-14T07:45:09.100Z","updated":"2024-03-14T07:45:09.100Z","comments":true,"path":"api/articles/old-lua/2016-06-01-error-handling.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h1>Lua 错误处理</h1>\n<h2 id=\"为什么需要错误处理机制\">为什么需要错误处理机制</h2>\n<p>在真实的系统中程序往往非常复杂，它们经常涉及到文件操作、数据库事务操作或网络服务调用等，这个时候错误处理就显得非常重要。不关注错误处理可能在处理诸如涉密或金融交易这些业务时造成重大的损失。<br>\n无论什么时候，程序开发都要求小心地做好错误处理工作。在 Lua 中错误可以被分为两类：</p>\n<ul>\n\t<li>语法错误</li>\n\t<li>运行时错误</li>\n</ul>\n<h2 id=\"语法错误\">语法错误</h2>\n<p>语法错误是由于不正确的使用各种程序语法造成的，比如错误的使用操作符或表达式。下面即是一个语法错误的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a == 2</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">正如你知道的那样，单个等号与双等号是完全不一样的。二者之间随意的替换就导致语法错误。一个等号表示的是赋值，而双等号表示比较。类似地，下面这一小段代码中也存在语法错误：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>for a= 1,10<br>\nprint(a)<br>\nend</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">执行上面的这段程序，我们会得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>lua: test2.lua:2: ‘do’ expected near ‘print’</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">语法错误相比于运行时错误更容易处理，因为 Lua 解释器可以更精确的定位到语法错误的位置。由上面的错误，我们可以容易就知道，在 print 语句前添加 do 语句就可以了，这是 Lua 语法结构所要求的。  </span><br><span class=\"line\"></span><br><span class=\"line\">## 运行时错误  </span><br><span class=\"line\"></span><br><span class=\"line\">对于运行时错误，虽然程序也能成功运行，但是程序运行过程中可能因为错误的输入或者错误的使用函数而导致运行过程中产生错误。下面的例子显示了运行时错误如何产生的：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function add(a,b)<br>\nreturn a+b<br>\nend</p>\n<p>add(10)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">当我们尝试生成(build)上面的程序，程序可以正常的生成和运行。但是一旦运行后，立马出现下面的运行时错误。  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>lua: test2.lua:2: attempt to perform arithmetic on local ‘b’ (a nil value)<br>\nstack traceback:<br>\ntest2.lua:2: in function ‘add’<br>\ntest2.lua:5: in main chunk<br>\n[C]: ?</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这个运行时错误是由于没有正确的为 add 函数传入参数导致的，由于没有为 b 传入值，所有 b 的值为 nil 从而导致在进行加法运算时出错。  </span><br><span class=\"line\"></span><br><span class=\"line\">## Assert and Error 函数  </span><br><span class=\"line\"></span><br><span class=\"line\">我们经常用到 assert 和 error 两个函数处理错误。下面是一个简单的例子。  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>local function add(a,b)<br>\nassert(type(a) == “number”, “a is not a number”)<br>\nassert(type(b) == “number”, “b is not a number”)<br>\nreturn a+b<br>\nend<br>\nadd(10)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">执行上面的程序，我们会得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>lua: test2.lua:3: b is not a number<br>\nstack traceback:<br>\n[C]: in function ‘assert’<br>\ntest2.lua:3: in function ‘add’<br>\ntest2.lua:6: in main chunk<br>\n[C]: ?</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">error(message [,level]) 函数会结束调用自己的函数，并将 message 作为错误信息返回调用者(译注:保护模式下才会返回调用者，一般情况会结束程序运行并在控制终端输出错误信息)。error 函数本身从不返回。一般地，error 函数会在消息前附上错误位置信息。级别(level) 参数指定错误发生的位置。若其值为 1(默认值)，返回的错误的位置是 error 函数被调用的位置。若为 2, 返回的错误位置为调用 error 函数的函数被调用的位置，依次类推。将 level 参数的值设为 0 就不再需要在消息前增加额外的位置信息了。  </span><br><span class=\"line\"></span><br><span class=\"line\">## pcall 与 xpcall　　</span><br><span class=\"line\"></span><br><span class=\"line\">在 Lua 中，为了避免使用抛出错误和处理错误，我们需要用到 pcall 和 xpcall 函数来处理异常。  </span><br><span class=\"line\">使用 pcall(f,arg1,...) 函数可以使用保护模式调用一个函数。如果函数 f 中发生了错误， 它并不会抛出一个错误，而是返回错误的状态。使用的 pcall 函数的方法如下所示：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function myfunction ()<br>\nn = n/nil<br>\nend</p>\n<p>if pcall(myfunction) then<br>\nprint(“Success”)<br>\nelse<br>\nprint(“Failure”)<br>\nend</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">执行上面的程序，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Failure</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">xpcall(f,err) 函数调用函数 f 同时为其设置了错误处理方法 err，并返回调用函数的状态。任何发生在函数 f 中的错误都不会传播，而是由 xpcall 函数捕获错误并调用错误处理函数 err，传入的参数即是错误对象本身。xpcall 的使用示例如下：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function myfunction ()<br>\nn = n/nil<br>\nend</p>\n<p>function myerrorhandler( err )<br>\nprint( “ERROR:”, err )<br>\nend</p>\n<p>status = xpcall( myfunction, myerrorhandler )<br>\nprint( status)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">执行上面的程序，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>ERROR:\ttest2.lua:2: attempt to perform arithmetic on global ‘n’ (a nil value)<br>\nfalse</p>\n<pre><code>\n作为程序开发人员，在程序中正确合理地处理错误是非常重要的。正确地处理错误可以保证发生意外情况不会影响到程序用户的使用。\n</code></pre>\n","text":"Lua 错误处理 为什么需要错误处理机制 在真实的系统中程序往往非常复杂，它们经常涉及到文件操作、数据库事务操作或网络服务调用等，这个时候错误处理就显得非常重要。不关注错误处理可能在处理诸如涉密或金融交易这些业务时造成重大的损失。 无论什么时候，程序开发都要求小心地做好错误处理工...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\">Lua 错误处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">为什么需要错误处理机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">语法错误</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua中的for循环","uid":"26bfa2ece82537ab5f6962e2d31968f1","slug":"old-lua/2016-06-11-for","date":"2024-03-14T07:45:09.101Z","updated":"2024-03-14T07:45:09.101Z","comments":true,"path":"api/articles/old-lua/2016-06-11-for.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua 中的 for 循环 for 循环控制结构可以让你高效地写出需要执行特定次数的循环代码。 语法 Lua 语言中 for 循环的语法如下： 1234for init,max/min value, incrementdo statement(s)end 下面是 for 循环执行...","link":"","photos":[],"count_time":{"symbolsCount":476,"symbolsTime":"1 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"},{"name":"lua教程","slug":"lua-guide/lua教程","count":3,"path":"api/categories/lua-guide/lua教程.json"}],"tags":[{"name":"LUA","slug":"LUA","count":2,"path":"api/tags/LUA.json"},{"name":"abc","slug":"abc","count":2,"path":"api/tags/abc.json"},{"name":"basic","slug":"basic","count":2,"path":"api/tags/basic.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua中的 if...else 语句","uid":"90762206aba1aa8a729d07e471d48c2c","slug":"old-lua/2016-06-01-if-else-if-statement","date":"2024-03-14T07:45:09.100Z","updated":"2024-03-14T07:45:09.100Z","comments":true,"path":"api/articles/old-lua/2016-06-01-if-else-if-statement.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"#Lua 中的 if…else 语句 如果 if 语句后面跟上 else 语句，那么条件为假时就执行 else 语句的代码。 ##语法 Lua 语言中 if…else 语句的语法如下所示： 1234567891011121314151617if(boolean_expressio...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}