{"title":"Lua调试","uid":"374513b04e64d95f7bc41ddb08581b8d","slug":"old-lua/2016-06-01-debugging","date":"2024-03-14T06:15:59.729Z","updated":"2024-03-14T06:15:59.729Z","comments":true,"path":"api/articles/old-lua/2016-06-01-debugging.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<h1 id=\"Lua-调试\"><a href=\"#Lua-调试\" class=\"headerlink\" title=\"Lua 调试\"></a>Lua 调试</h1><p>Lua 提供一个调试库，这个库中提供了创建自己的调试器所需的所有原语函数。虽然，Lua 没有内置调试器，但是开发者们为 Lua 开发了许多的开源调试器。 </p>\n<p>Lua 调试库包括的函数如下表所示。</p>\n<table>\n    <tr>\n        <th>S.N.</th>\n        <th>方法和描述</th>\n    </tr>\n    <tr>\n    <td>1</td>\n        <td>debug():进入交互式调试模式，在此模式下用户可以用其它函数查看变量的值。</td>\n    </tr>\n    <tr>\n        <td>2</td>\n        <td>getfenv(object):返回对象的环境。</td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td>gethook(optional thread)：返回线程当前的钩子设置，总共三个值：当前钩子函数、当前的钩子掩码与当前的钩子计数。</td>\n    </tr>\n    <tr>\n        <td>4</td>\n        <td>getinfo(optional thread,function or stack leve,optional flag)：返回保存函数信息的一个表。你可以直接指定函数，或者你也可以通过一个值指定函数，该值为函数在当前线程的函数调用栈的层次。其中，0 表示当前函数（getinfo 本身）；层次 1 表示调用 getinfo 的函数，依次类推。如果数值大于活跃函数的总量，getinfo 则返回 nil。</td>\n    </tr>\n    <tr>\n        <td>5</td>\n        <td>getlocal(optional thread,stack level,local index)：此函数返回在 level 层次的函数中指定索引位置处的局部变量和对应的值。如果指定的索引处不存在局部变量，则返回 nil。当 level 超出范围时，则抛出错误。</td>\n    </tr>\n    <tr>\n        <td>6</td>\n        <td>getmetatable(value)：返回指定对象的元表，如果不存在则返回 nil。</td>\n    </tr>\n    <tr>\n        <td>7</td>\n        <td>getregistry()：返回寄存器表。寄存器表是一个预定义的用于 C 代码存储 Lua 值的表。</td>\n    </tr>\n    <tr>\n        <td>8</td>\n        <td>getupvalue(func function,upvalue index)：根据指定索引返回函数 func 的 upvalue 值（译注：upvalue 值与函数局部变量的区别在于，即使函数并非活跃状态也可能有 upvalue 值，而非活跃函数则不存在局部变量，所以其第一个参数不是栈的层次而是函数）。如果不存在，则返回 nil。</td>\n    </tr>\n    <tr>\n        <td>9</td>\n        <td>setfenv(function or thread or userdata,environment table)：将指定的对象的环境设置为 table,即改变对象的作用域。</td>\n    </tr>\n    <tr>\n        <td>10</td>\n        <td>sethook(optional thread,hook function,hook mask string with \"c\" and/or \"r\" and/or \"l\",optional instruction count)：把指定函数设置为钩子。字符串掩码和计数值表示钩子被调用的时机。这里，c 表示每次调用函数时都会执行钩子；r 表示每次从函数中返回时都调用钩子；l 表示每进入新的一行调用钩子。</td>\n    </tr>\n    <tr>\n        <td>11</td>\n        <td>setlocal(optional thread,stack level,local index,value):在指定的栈深度的函数中，为 index 指定的局部变量赋予值。如果局部变量不存在，则返回 nil。若 level 超出范围则抛出错误；否则返回局部变量的名称。</td>\n    </tr>\n    <tr>\n        <td>12</td>\n        <td>setmetatable(value,metatable):为指定的对象设置元表，元表可以为 nil。</td>\n    </tr>\n    <tr>\n        <td>13</td>\n        <td>setupvalue(function,upvalue index,value):为指定函数中索引指定的 upvalue 变量赋值。如果 upvalue 不存在，则返回 nil。否则返回此 upvalue 的名称。</td>\n    </tr>\n    <tr>\n        <td>14</td>\n        <td>traceback(optional thread,optional meesage string,opitona level argument)：用 traceback 构建扩展错误消息。</td>\n    </tr>\n</table>\n\n<p>上面的表中列出了 Lua 的全部调试函数，我们经常用到的调试库都会用到上面的函数，它让调试变得非常容易。虽然提供了便捷的接口，但是想要用上面的函数创建一个自己的调试器并不是件容易的事。无论怎样，我们可以看一下下面这个例子中怎么使用这些调试函数的。  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function myfunction ()</span><br><span class=\"line\">print(debug.traceback(&quot;Stack trace&quot;))</span><br><span class=\"line\">print(debug.getinfo(1))</span><br><span class=\"line\">print(&quot;Stack trace end&quot;)</span><br><span class=\"line\">\treturn 10</span><br><span class=\"line\">end</span><br><span class=\"line\">myfunction ()</span><br><span class=\"line\">print(debug.getinfo(1))</span><br></pre></td></tr></table></figure>\n\n<p>执行上面的程序，我们可以得到如下的栈轨迹信息：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack trace</span><br><span class=\"line\">stack traceback:</span><br><span class=\"line\">\ttest2.lua:2: in function &#x27;myfunction&#x27;</span><br><span class=\"line\">\ttest2.lua:8: in main chunk</span><br><span class=\"line\">\t[C]: ?</span><br><span class=\"line\">table: 0054C6C8</span><br><span class=\"line\">Stack trace end</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">上面的例子中，我们使用 debug.trace 函数输出了栈轨迹。 debug.getinfo 函数获得函数的当前表。  </span><br><span class=\"line\"></span><br><span class=\"line\">## 示例二  </span><br><span class=\"line\"></span><br><span class=\"line\">在调试过程中，我们常常需要查看或修改函数局部变量的值。因此，我们可以用 getupvalue 获得变量的值，用 setupvalue 修改变量的值。示例如下：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function newCounter ()<br>  local n = 0<br>  local k = 0<br>  return function ()<br>    k = n<br>    n = n + 1<br>    return n<br>    end<br>end</p>\n<p>counter = newCounter ()<br>print(counter())<br>print(counter())</p>\n<p>local i = 1</p>\n<p>repeat<br>  name, val = debug.getupvalue(counter, i)<br>  if name then<br>    print (“index”, i, name, “=”, val)<br>    if(name == “n”) then<br>        debug.setupvalue (counter,2,10)<br>    end<br>    i = i + 1<br>  end – if<br>until not name</p>\n<p>print(counter())</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">运行上面的程序，我们可以得到如下面的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>1<br>2<br>index    1    k    =    1<br>index    2    n    =    2<br>11</p>\n<p>```  </p>\n<p>在这个例子中，每次调用 counter 都会更新该闭包函数。我们可以通过 getupvalue 查看其当前的局部变量值。随后，我们更新局部变量的值。在为 n 设置新值之前，其值为 2。调用 setupvalue 后，n 被设置为 10。再调用 counter 时，它就会返回值 11 而不再是 3。  </p>\n<h2 id=\"调试类型\"><a href=\"#调试类型\" class=\"headerlink\" title=\"调试类型\"></a>调试类型</h2><ul>\n    <li>命令行调试</li>\n    <li>图形界面调试</li>\n</ul>\n\n<h3 id=\"命令行调试工具\"><a href=\"#命令行调试工具\" class=\"headerlink\" title=\"命令行调试工具\"></a>命令行调试工具</h3><p>命令行调试就是使用命令行命令和 print 语句来调试程序。已经有许多现成的 Lua 命令行调试工具，下面列出了其中的一部分：</p>\n<ul>\n<li>RemDebug：RemDebug 是一个远程的调试器，它支持 Lua 5.0 和 5.1 版本。允许远程调试 Lua 程序，设置断点以及查看程序的当前状态。同时，它还能调试 CGILua 脚本。</li>\n<li>clidebugger：此调试器是用纯 Lua 脚本开发的命令行调试工具，支持 Lua 5.1。除了 Lua 5.1 标准库以外，它不依赖于任何其它的 Lua 库。虽然它受到了 RemDebug 影响而产生的，但是它没有远程调试的功能。</li>\n<li>ctrace：跟踪 Lua API 调用的小工具。</li>\n<li>xdbLua：windows 平台下的 Lua 命令行调试工具。</li>\n<li>LuaInterface - Debuger：这个项目是 LuaInterface 的扩展，它对 Lua 调试接口进行进一步的抽象，允许通过事件和方法调用的方式调试程序。</li>\n<li>RIdb：使用套接字的远程 Lua 调试器，支持 Linux 和 Windows 平台。它的特性比任何其它调试器都丰富。</li>\n<li>ModDebug：允许远程控制另外一个 Lua　程序的执行、设置断点以及查看程序的当前状态。</li>\n</ul>\n<h3 id=\"图形界面调试工具\"><a href=\"#图形界面调试工具\" class=\"headerlink\" title=\"图形界面调试工具\"></a>图形界面调试工具</h3><p>图形界面的调试工具往往和集成开发环境（IDE）打包在一起。它允许在可视环境下进行调试，比如查看变量值，栈跟踪等。通过 IDE 的图形界面，你可以设置断点单步执行程序。  </p>\n<p>下面列出了几种图形界面的调试工具。  </p>\n<ul>\n    <li>SciTE：Windows 系统上默认的 Lua 集成开发环境，它提供了丰富的调试功能，比如，断点、单步、跳过、查看变量等等。</li>\n    <li>Decoda：一个允许远程调试的图形界面调试工具。</li>\n    <li>ZeroBrane Studio：一个 Lua 的集成开发环境，它集成了远程调试器、栈视图、远程控制终端、静态分析等诸多功能。它兼容各类 Lua 引擎，例如 LuaJIT,Love2d,Moai等。支持 Windows, OSX, Linux；开源。</li>\n    <li>akdebugger：eclipse 的 Lua 调试器和编辑器插件。</li>\n    <li>luaedit：支持运程调试、本地调试、语法高亮、自动补完、高级断点管理（包括有条件地触发断和断点计数）、函数列表、全局和本地变量列表、面对方案的管理等。</li>\n</ul>","text":"Lua 调试Lua 提供一个调试库，这个库中提供了创建自己的调试器所需的所有原语函数。虽然，Lua 没有内置调试器，但是开发者们为 Lua 开发了许多的开源调试器。 Lua 调试库包括的函数如下表所示。 S.N. 方法和描述 1 debug():进入交互式调试模式，在此模式下用户...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Lua-%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">Lua 调试</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%83%E8%AF%95%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">调试类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">命令行调试工具</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">图形界面调试工具</span></a></li></ol></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua数据库访问","uid":"5593d949c022c9556ceb62d288c587d5","slug":"old-lua/2016-06-01-database-access","date":"2024-03-14T06:15:59.729Z","updated":"2024-03-14T06:15:59.729Z","comments":true,"path":"api/articles/old-lua/2016-06-01-database-access.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"Lua 数据库访问简单的数据操作，我们用文件就可以处理。但是，某些时候文件操作存在性能、扩展性等问题。这时候，我们就需要使用数据库。LuaSQL 是一个提供数据库操作的库，它支持多种 SQL 数据库的操作。包括： SQLite MySQL ODBC 在本教程中，我们会讲解用 Lu...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"数据类型","uid":"a760ef6d11a2d6078a812f5bc31cf898","slug":"old-lua/2016-06-01-data-types","date":"2024-03-14T06:15:59.729Z","updated":"2024-03-14T06:15:59.729Z","comments":true,"path":"api/articles/old-lua/2016-06-01-data-types.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"数据类型Lua 是动态类型编程语言，变量没有类型，只有值才有类型。值可以存储在变量中，作为参数传递或者作为返回值。尽管在 Lua 中没有变量数据类型，但是值是有类型的。下面的列表中列出了数据类型： 值类型 描述 nil 用于区分值是否有数据，nil 表示没有数据。 boolean...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}