{"title":"Lua迭代器","uid":"eacf32e453764fca08d4d96ce1e78183","slug":"old-lua/2016-06-01-iterators","date":"2024-03-14T07:45:09.101Z","updated":"2024-03-14T07:45:09.101Z","comments":true,"path":"api/articles/old-lua/2016-06-01-iterators.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h1>Lua 迭代器</h1>\n<p>迭代器是用于遍历集合或容器中元素的一种结构。在 Lua 语言中，集合往往指的是可以用来创建各种数据结构的表。比如，数组就是用表来创建的。</p>\n<h2 id=\"通用迭代器\">通用迭代器</h2>\n<p>通用迭代器可以访问集合中的键值对。下面是通用迭代器的一个简单例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array = &#123;&quot;Lua&quot;, &quot;Tutorial&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for key,value in ipairs(array) </span><br><span class=\"line\">do</span><br><span class=\"line\">   print(key, value)</span><br><span class=\"line\">end</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">执行的上面的代码，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>1  Lua<br>\n2  Tutorial</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的例子中使用了 Lua 提供的默认迭代器函数 ipairs。 </span><br><span class=\"line\"> </span><br><span class=\"line\">在 Lua 语言中，我们使用函数表示迭代器。根据是否在迭代器函数中是否维护状态信息，我们将迭代器分为以下两类：  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">\t&lt;li&gt;无状态迭代器&lt;/li&gt;  </span><br><span class=\"line\">\t&lt;li&gt;有状态迭代器&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">## 无状态迭代器  </span><br><span class=\"line\"></span><br><span class=\"line\">由此迭代器的名称就可以看出来，这一类的迭代器函数中不会保存任何中间状态。 </span><br><span class=\"line\"> </span><br><span class=\"line\">让我们一起来看一下下面这个例子。在这个例子中，我们用一个简单的函数创建了一个自己的迭代器。这个迭代器用以输出 n 个数的平方值。  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function square(iteratorMaxCount,currentNumber)<br>\nif currentNumber&lt;iteratorMaxCount<br>\nthen<br>\ncurrentNumber = currentNumber+1<br>\nreturn currentNumber, currentNumber*currentNumber<br>\nend<br>\nend</p>\n<p>for i,n in square,3,0<br>\ndo<br>\nprint(i,n)<br>\nend</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">执行上面的代码，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>1\t1<br>\n2\t4<br>\n3\t9</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">我们可以稍微的修改一下上面的代码，使得此迭代器可以像 ipairs 那样工作。如下所示：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function square(iteratorMaxCount,currentNumber)<br>\nif currentNumber&lt;iteratorMaxCount<br>\nthen<br>\ncurrentNumber = currentNumber+1<br>\nreturn currentNumber, currentNumber*currentNumber<br>\nend<br>\nend</p>\n<p>function squares(iteratorMaxCount)<br>\nreturn square,iteratorMaxCount,0<br>\nend</p>\n<p>for i,n in squares(3)<br>\ndo<br>\nprint(i,n)<br>\nend</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行上面的代码，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>1\t1<br>\n2\t4<br>\n3\t9</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 有状态迭代器  </span><br><span class=\"line\"></span><br><span class=\"line\">前面的例子使用的迭代器函数是不保存状态的。每次调用迭代器函数时，函数基于传入函数的第二个变量访问集合的下一个元素。在 Lua 中可以使用闭包来存储当前元素的状态。闭包通过函数调用得到变量的值。为了创建一个新的闭包，我们需创建两个函数，包括闭包函数本身和一个工厂函数，其中工厂函数用于创建闭包。  </span><br><span class=\"line\"></span><br><span class=\"line\">下面的示例中，我们将使用闭包来创建我们的迭代器。  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>array = {“Lua”, “Tutorial”}</p>\n<p>function elementIterator (collection)<br>\nlocal index = 0<br>\nlocal count = #collection<br>\n– 返回闭包函数<br>\nreturn function ()<br>\nindex = index + 1<br>\nif index &lt;= count<br>\nthen<br>\n– 返回迭代器的当前元素<br>\nreturn collection[index]<br>\nend<br>\nend<br>\nend</p>\n<p>for element in elementIterator(array)<br>\ndo<br>\nprint(element)<br>\nend</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">执行上面的代码，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Lua<br>\nTutorial</p>\n<pre><code>\n上面的例子中我们可以看到，在　elementIterator 函数内定义了另外一个匿名函数。此匿名函数中使用了一个外部变量 index (译注：此变量在匿名函数之外，elementIterator 函数内)。每次内部的匿名函数被调用时，都会将 index 的值增加 1，并统计数返回的每个元素。 \n \n我们可以参照上面的方法使用闭包创建一个迭代器函数。每次我们使用迭代器遍历集合时，它都可以返回多个元素。</code></pre>\n","text":"Lua 迭代器 迭代器是用于遍历集合或容器中元素的一种结构。在 Lua 语言中，集合往往指的是可以用来创建各种数据结构的表。比如，数组就是用表来创建的。 通用迭代器 通用迭代器可以访问集合中的键值对。下面是通用迭代器的一个简单例子： 12345678910array = &#12...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\">Lua 迭代器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%9A%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">通用迭代器</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua判断","uid":"d6286a3606fee451e0f5f2e41e7f6205","slug":"old-lua/2016-06-01-decision-making","date":"2024-03-14T07:45:09.101Z","updated":"2024-03-14T07:45:09.102Z","comments":true,"path":"api/articles/old-lua/2016-06-01-decision-making.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"决策 决策结构要求程序开发人员设置一个或多测试或计算条件。如果条件计算结果为真，则执行一个或多个语句；如果条件为假，则执行另外的语句。 下面是大多数程序语言中的决策结构的一般形式： Lua 语言中所有布尔真和非 nil 值都当作真；把所有的布尔假和 nil 作为假。请注意，Lua...","link":"","photos":[],"count_time":{"symbolsCount":375,"symbolsTime":"1 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua元表","uid":"0498ed7eca93166bac9cec9951eb31df","slug":"old-lua/2016-06-01-metatables","date":"2024-03-14T07:45:09.101Z","updated":"2024-03-14T07:45:09.101Z","comments":true,"path":"api/articles/old-lua/2016-06-01-metatables.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua 元表 正如其名，元表也是表。不过，将元表与表相关联后，我们就可以通过设置元表的键和相关方法来改变表的行为。元方法的功能十分强大，使用元方法可以实现很多的功能，比如： 修改表的操作符功能或为操作符添加新功能（译注：如果您学过 C++ 之类的面向对象的语言，应该比较好理解，其...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"LUA教程","slug":"LUA教程","count":8,"path":"api/tags/LUA教程.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}