{"title":"Lua 的标准输出与缓存","uid":"eb6769635061336dbbe2c0540f762f81","slug":"zl/2016-01-01-233_Lua 的标准输出与缓存 ","date":"2024-04-03T03:47:33.102Z","updated":"2024-04-03T03:47:33.102Z","comments":true,"path":"api/articles/zl/2016-01-01-233_Lua 的标准输出与缓存 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>\t\t\t&lt;p&gt;最近我遇到了个奇怪的问题，我的一个 Lua 脚本需要通过 shell 的重定向将输出追加到一个日志文档中。但是那个 Lua 脚本的输出在日志文档里看来却不是实时的，输出的文本直到脚本结束时才能看到。&lt;/p&gt;\n</code></pre>\n<p>在 shell 下运行这个进程，是可以看到实时输出的：</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">-- buffer_test.lua</span>\n<span class=\"kd\">local</span> <span class=\"n\">socket</span> <span class=\"o\">=</span> <span class=\"nb\">require</span> <span class=\"s2\">\"socket\"</span>\n<p><span class=\"kd\">local</span> <span class=\"n\">const</span> <span class=\"o\">=</span> <span class=\"mi\">100</span></p>\n<p><span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">const</span><span class=\"p\">,</span> <span class=\"mi\">1</span> <span class=\"k\">do</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span><br />\n<span class=\"n\">socket</span><span class=\"p\">.</span><span class=\"n\">select</span><span class=\"p\">(</span><span class=\"kc\">nil</span><span class=\"p\">,</span> <span class=\"kc\">nil</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span><br />\n<span class=\"k\">end</span><br />\n</code></pre></div></div></p>\n<p>但是当通过重定向时，只有脚本结束后才能看到文档：</p>\n<div class=\"language-sh highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># lua buffer_test.lua &gt;&gt;log.txt 2&gt;&amp;1 &amp;</span>\n<span class=\"c\"># tail -f log.txt</span>\n</code></pre></div></div>\n<p>看来当 Lua 的标准输出 stdout 连接的是终端时，采用了行缓存模式，而重定向到文档时则变成了完全缓存。翻遍了 Lua 的官方文档也没有找到这样的说明。但是在查看 stdio 的手册页时发现了下面的一段话：</p>\n<p>原来 stdio 都是由 libc 提供，而我在 <code class=\"highlighter-rouge\">ldd lua</code> 时发现 Lua 确实也依赖于 libc。这下就可以解释了：Lua 在连接是终端的时候采用的是行缓存，而连接的是非活跃的设备时是采用的是完全缓存。</p>\n<p>但是假如我们中途终止脚本，查看日志：</p>\n<div class=\"language-sh highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># nl log.txt</span>\n 1\tlua: io.lua:9: interrupted!\n 2\tstack traceback:\n 3\t\t<span class=\"o\">[</span>C]: <span class=\"k\">in function</span> <span class=\"s1\">'select'</span>\n 4\t\tio.lua:9: <span class=\"k\">in </span>main chunk\n 5\t\t<span class=\"o\">[</span>C]: ?\n 6\t1\n 7\t2\n 8\t3\n</code></pre></div></div>\n<p>可以发现异常的日志难道不应该在最后面吗？其实上面的引用已经帮我们回答了：stderr 并不是完全缓存，当发生异常时，stderr 首先被写入日志，接着缓存区的 stdout 才会被刷入文档。</p>\n<p><strong>回顾这个问题，给我们留下的经验是 Lua 的很多库的实现原理其实在 libc 与系统调用那儿，不要只把目光局限在 Lua 的文档上。其实在其他的语言中，我估计也差不多。我们在查找问题的时候，一定要跳出自己的固有思维，有时候自己非常有把握的知识恰恰是不准确的。</strong></p>","text":" &lt;p&gt;最近我遇到了个奇怪的问题，我的一个 Lua 脚本需要通过 shell 的重定向将输出追加到一个日志文档中。但是那个 Lua 脚本的输出在日志文档里看来却不是实时的，输出的文本直到脚本结束时才能看到。&lt;/p&gt; 在 shell 下运行这个进程，是可以看...","link":"","photos":[],"count_time":{"symbolsCount":988,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua编程2之数据类型","uid":"0511ba373e6efe0ed64cccc5235edd14","slug":"zl/2016-01-01-232_Lua编程2之数据类型","date":"2024-04-03T03:47:33.102Z","updated":"2024-04-03T03:47:33.102Z","comments":true,"path":"api/articles/zl/2016-01-01-232_Lua编程2之数据类型.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;思考并回答以下问题：&lt;br&gt;1.nil 的“删除”作用怎么理解？如何删除table里的一个值？&lt;br&gt;2.怎么比较一个变量是否为nil？&lt;br&gt;3.数字零和空字符串为真吗？假有哪些？&lt;br&gt;4.如何表示块字符串？...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua Learning Notes","uid":"4b8499e3ac801948195a5de99e588873","slug":"zl/2016-01-01-231_Lua Learning Notes","date":"2024-04-03T03:47:33.101Z","updated":"2024-04-03T03:47:33.101Z","comments":true,"path":"api/articles/zl/2016-01-01-231_Lua Learning Notes.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"注释 -- 单行注释 –[[ 多行注释 ]] 变量 a = \"string\" b = 10 b = nil -- 'b' deleted local c = 0 变量没有类型, 默认为全局变量, 使用local关键字声明局部变量, 要删除变量只需要将其赋值为nil即可 a, b ...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}