{"title":"LuaTable判空","uid":"32bbc491153d9d789c957531761cb91b","slug":"zl/2016-01-01-933_LuaTable判空","date":"2024-04-03T03:47:36.206Z","updated":"2024-04-03T03:47:36.206Z","comments":true,"path":"api/articles/zl/2016-01-01-933_LuaTable判空.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p><strong>Lua判断表为空t = {}的逻辑</strong></p><figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">next</span>(a) == <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br/></pre></td></tr></tbody></table></figure><p><strong>next(table[,index])</strong></p><blockquote>\n<p>运行程序来遍历表中的所有域。 第一个参数是要遍历的表，第二个参数是表中的某个键。 <code>next</code> 返回该键的下一个键及其关联的值。 如果用 <strong>nil</strong> 作为第二个参数调用 <code>next</code> 将返回初始键及其关联值。 当以最后一个键去调用，或是以 <strong>nil</strong> 调用一张空表时， <code>next</code> 返回 <strong>nil</strong>。 如果不提供第二个参数，将认为它就是 <strong>nil</strong>。 特别指出，你可以用 <code>next(t)</code> 来判断一张表是否是空的。</p>\n<p>索引在遍历过程中的次序无定义， <em>即使是数字索引也是这样</em>。 （如果想按数字次序遍历表，可以使用数字形式的 <strong>for</strong> 。） -Lua 5.3参考手册</p>\n</blockquote>\n<p><strong>(转)</strong>在项目的脚本lua中经常有这样的需求，</p>\n<p>1、local a = {}</p>\n<p>2、对a进行处理</p>\n<p>3、对a是否为空表进行判断</p>\n<p>关于对a是否为空表的判断，如果直接这样做：</p>\n<p>if a == {} then</p>\n<p>这样的结果就是a == {}永远返回false，是一个逻辑错误。因为这里比较的是table a和一个匿名table的内存地址。</p>\n<p>也有些代码如此做：</p>\n<p>if table.maxn(a) == 0 then</p>\n<p>这样做也不保险，除非table的key都是数字，而没有hash部分。</p>\n<p>难道真的要遍历table发现有东西就return false跳出才能断定它是否为空吗？这样做是可以的，至少目前项目中前人是这么封装的，不过代码太难看. </p>\n<p>网上小搜了一下，发现原来官方手册里早已经给了答案，那就是靠lua内置的next函数</p>\n<p>即如此用：if next(a) == nil then</p>\n<p>next其实就是pairs遍历table时用来取下一个内容的函数.</p>","text":"Lua判断表为空t = {}的逻辑1if next(a) == nil thennext(table[,index]) 运行程序来遍历表中的所有域。 第一个参数是要遍历的表，第二个参数是表中的某个键。 next 返回该键的下一个键及其关联的值。 如果用 nil 作为第二个参数调用...","link":"","photos":[],"count_time":{"symbolsCount":742,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua数据类型","uid":"fbf063cfd1e14012521ff08e60dd9b1f","slug":"zl/2016-01-01-936_Lua数据类型","date":"2024-04-03T03:47:36.207Z","updated":"2024-04-03T03:47:36.207Z","comments":true,"path":"api/articles/zl/2016-01-01-936_Lua数据类型.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"前言 接触lua近4年了，一直断断续续读相关源码，这次计划把lua源码整体分析一遍，基于最新版本(Lua 5.3.5), 完成如下文章（顺序可能不一致）： 基本数据类型 string/table 剖析 luavm 分析 lexer/ast/gencode 词法分析/语法树/生成字...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua 排序算法","uid":"18c65ae79c1521b9ec150d64b8237a42","slug":"zl/2016-01-01-934_Lua 排序算法 ","date":"2024-04-03T03:47:36.206Z","updated":"2024-04-03T03:47:36.207Z","comments":true,"path":"api/articles/zl/2016-01-01-934_Lua 排序算法 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经...","link":"","photos":[],"count_time":{"symbolsCount":883,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}