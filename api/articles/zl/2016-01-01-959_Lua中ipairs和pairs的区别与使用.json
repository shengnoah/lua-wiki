{"title":"Lua中ipairs和pairs的区别与使用","uid":"ee708369e43d7b01905981d2b3485e2f","slug":"zl/2016-01-01-959_Lua中ipairs和pairs的区别与使用","date":"2024-04-03T03:47:36.228Z","updated":"2024-04-03T03:47:36.229Z","comments":true,"path":"api/articles/zl/2016-01-01-959_Lua中ipairs和pairs的区别与使用.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<div class=\"post-nav\">\n          <div class=\"post-nav-next post-nav-item\">\n<pre><code>          &lt;a href=&quot;/2015/11/11/lua_cpp_toluapp_tutorial/&quot; rel=&quot;next&quot; title=&quot;tolua++安装&quot;&gt;\n            &lt;i class=&quot;fa fa-chevron-left&quot;&gt;&lt;/i&gt; \n            &lt;p class=&quot;post-nav-pre-next-title&quot;&gt;\n              tolua++安装\n            &lt;/p&gt; \n          &lt;/a&gt;\n        \n      &lt;/div&gt;\n\n      &lt;span class=&quot;post-nav-divider&quot;&gt;&lt;/span&gt;\n\n      &lt;div class=&quot;post-nav-prev post-nav-item&quot;&gt;\n        \n          &lt;a href=&quot;/2015/12/09/cpp_vargs/&quot; rel=&quot;prev&quot; title=&quot;C++可变参数&quot;&gt;\n          &lt;p class=&quot;post-nav-pre-next-title&quot;&gt;\n              C++可变参数\n          &lt;/p&gt; \n          &lt;i class=&quot;fa fa-chevron-right&quot;&gt;&lt;/i&gt;\n          &lt;/a&gt;\n        \n      &lt;/div&gt;\n    &lt;/div&gt;\n  \n\n  \n  \n\n  \n  \n\n  \n    &lt;p&gt;关于ipairs()和pairs(),Lua官方手册是这样说明的：&lt;/p&gt;\n</code></pre>\n<p><strong>pairs (t)</strong></p>\n<p>If t has a metamethod __pairs, calls it with t as argument and returns the first three results from the call.</p>\n<p>Otherwise, returns three values: the next function, the table t, and nil, so that the construction</p>\n<pre><code>` for k,v in pairs(t) do body end`</code></pre><p>will iterate over all key–value pairs of table t.</p>\n<p>See function next for the caveats of modifying the table during its traversal.</p>\n<p><strong>ipairs (t)</strong></p>\n<p>If t has a metamethod __ipairs, calls it with t as argument and returns the first three results from the call.</p>\n<p>Otherwise, returns three values: an iterator function, the table t, and 0, so that the construction</p>\n<pre><code>` for i,v in ipairs(t) do body end`</code></pre><p>will iterate over the pairs (1,t[1]), (2,t[2]), …, up to the first integer key absent from the table.</p>\n<p>根据官方手册的描述，pairs会遍历表中所有的key-value值，而pairs会根据key的数值从1开始加1递增遍历对应的table[i]值，直到出现第一个不是按1递增的数值时候退出。</p>\n<p><strong>. . .</strong></p>\n<p>下面我们以例子说明一下吧</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">stars = {[<span class=\"number\">1</span>] = <span class=\"string\">&#34;Sun&#34;</span>, [<span class=\"number\">2</span>] = <span class=\"string\">&#34;Moon&#34;</span>, [<span class=\"number\">5</span>] = <span class=\"string\">&#39;Earth&#39;</span>}</span><br/><span class=\"line\"><span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(stars) <span class=\"keyword\">do</span></span><br/><span class=\"line\">   <span class=\"built_in\">print</span>(i, v)</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>使用pairs()将会遍历表中所有的数据，输出结果是：</p>\n<pre><code>1    Sun\n2    Moon\n5    Earth</code></pre><p>如果使用ipairs（）的话，</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> <span class=\"built_in\">ipairs</span>(stars) <span class=\"keyword\">do</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">   <span class=\"built_in\">print</span>(i, v)</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>当i的值遍历到第三个元素时，i的值为5，此时i并不是上一个次i值（2）的+1递增，所以遍历结束，结果则会是：</p>\n<pre><code>1    Sun\n2    Moon</code></pre><p>ipairs()和pairs()的区别就是这么简单。</p>\n<p>还有一个要注意的是pairs()的一个问题，用pairs()遍历是[key]-[value]形式的表是随机的，跟key的哈希值有关系。看以下这个例子：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">stars = {[<span class=\"number\">1</span>] = <span class=\"string\">&#34;Sun&#34;</span>, [<span class=\"number\">2</span>] = <span class=\"string\">&#34;Moon&#34;</span>, [<span class=\"number\">3</span>] = <span class=\"string\">&#34;Earth&#34;</span>, [<span class=\"number\">4</span>] = <span class=\"string\">&#34;Mars&#34;</span>, [<span class=\"number\">5</span>] = <span class=\"string\">&#34;Venus&#34;</span>}</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(stars) <span class=\"keyword\">do</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">   <span class=\"built_in\">print</span>(i, v)</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>结果是：</p>\n<pre><code>2    Moon\n3    Earth\n1    Sun\n4    Mars\n5    Venus</code></pre><p>并没有按照其在表中的顺序输出。</p>\n<p>但是如果是这样定义表stars的话</p>\n<p><code>stars = &#123;&#34;Sun&#34;, &#34;Moon&#34;,  “Earth”, &#34;Mars&#34;,  &#34;Venus&#34;&#125;</code></p>\n<p>结果则会是</p>\n<pre><code>1    Sun\n2    Moon\n3    Earth\n4    Mars\n5    Venus</code></pre><p>你清楚了吗？:)</p>","text":" &lt;a href=&quot;/2015/11/11/lua_cpp_toluapp_tutorial/&quot; rel=&quot;next&quot; title=&quot;tolua++安装&quot;&gt; &lt;i class=&quot;fa fa-c...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 排序算法","uid":"18c65ae79c1521b9ec150d64b8237a42","slug":"zl/2016-01-01-958_Lua 排序算法 ","date":"2024-04-03T03:47:36.228Z","updated":"2024-04-03T03:47:36.228Z","comments":true,"path":"api/articles/zl/2016-01-01-958_Lua 排序算法 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。 分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。 算法步骤 从数列中...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua Table","uid":"8cb65eb3b9a904681d4c6e1e9f1f7448","slug":"zl/2016-01-01-956_Lua Table","date":"2024-04-03T03:47:36.227Z","updated":"2024-04-03T03:47:36.227Z","comments":true,"path":"api/articles/zl/2016-01-01-956_Lua Table.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"前言 table 是lua中是lua中唯一的复合结构， 大多数高级语言中具有的：Array/Map/Class/Struct 数据组织结构均可通过table去实现。table核心的实现主要有： Array part： 存储数组部分数据结构 Hash part： 存储Map相关数据...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}