{"title":"XLua","uid":"8694e34b8398544a8555a3d595186270","slug":"zl/2016-01-01-218_XLua","date":"2024-04-03T03:47:33.092Z","updated":"2024-04-03T03:47:33.093Z","comments":true,"path":"api/articles/zl/2016-01-01-218_XLua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>    &lt;blockquote&gt;\n</code></pre>\n<p>从<strong><a href=\"https://github.com/Tencent/xLua\" target=\"_blank\" rel=\"noopener noreferrer\"><font color=\"steelblue\" size=\"3\">这里</font></a></strong>下载一个zip压缩包，解压后会有Assets等几个文档夹，其他文档夹放进你所创建的unity工程的Assets同级的目录下，然后把加压出来的Assets里的文档和文档夹复制进unity项目的Assets文档夹里即可。</p>\n</blockquote>\n<h1 id=\"XLua教程\"><a href=\"https://LianBai.github.io/#XLua%E6%95%99%E7%A8%8B\" class=\"headerlink\" title=\"XLua教程\"></a>XLua教程</h1><h2 id=\"XLua加载文档\"><a href=\"https://LianBai.github.io/#XLua%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6\" class=\"headerlink\" title=\"XLua加载文档\"></a>XLua加载文档</h2><h3 id=\"加载字符串\"><a href=\"https://LianBai.github.io/#%E5%8A%A0%E8%BD%BD%E5%AD%97%E7%AC%A6%E4%B8%B2\" class=\"headerlink\" title=\"加载字符串\"></a>加载字符串</h3><pre><code>1.LuaEnv luaenv = new LuaEnv();  \n2.luaenv.DoString(\"print('hello world')\");  \n</code></pre><blockquote>\n<p>第1行是用来实例LuaEnv虚拟机的，类似于用这个类来实现所有lua的操作，尽量定义为全局，这样优化<br>第2行是通过DoString函数来加载lua脚本，也可直接加载lua脚本内容，如上述代码，print(‘hello world’)就是lua的代码内容。加载就是把lua的脚本加载到luaenv虚拟机里。</p>\n</blockquote>\n<h3 id=\"加载lua文档\"><a href=\"https://LianBai.github.io/#%E5%8A%A0%E8%BD%BDlua%E6%96%87%E4%BB%B6\" class=\"headerlink\" title=\"加载lua文档\"></a>加载lua文档</h3><pre><code>LuaEnv luaenv = new LuaEnv();\n//方法一\npublic TextAsset lua_001;\n//方法二\nprivate TextAsset lua_002;\n//方法三\n//在Start函数里luaenv.DoString(\"require 'LuaText/lua_003'\");\nvoid Start()\n&#123;\n    lua_002 = Resources.Load&lt;TextAsset&gt;(\"LuaText/lua_002.lua\");\n    luaenv.DoString(lua_001.text);\n    luaenv.DoString(lua_002.text);\n    luaenv.DoString(\"require 'LuaText/lua_003'\");\n&#125;\n<p>void Update()<br />\n&#123;</p>\n<p>&#125;<br />\nvoid OnDestroy()<br />\n&#123;<br />\nluaenv.Dispose();<br />\n&#125;<br />\n</code></pre><blockquote></p>\n<p>lua脚本在放在Resources文档夹的时候，后缀必须加上.txt，例如<strong>lua_001.lua.txt</strong>，因为Resources对支持的文档类型有限，也就是无法用Resouces读取.lua文档。  </p>\n<p>方法一是在脚本所挂物体上，通过拖拽赋值变量的方法，直接把lua的脚本拖拽到脚本的变量上，然后通过DoString执行lua文档<br>方法二是先定义TextAsset变量，然后在初始化的时候读取Resources里的文档，然后赋值到变量上，然后通过DoString执行lua文档。<br>方法三此处主要是对require和loader的理解，可以吧loader看成是指向某个路径里的一个个文档，require实际上就是调用一个个loader去加载，和自己所输入文档名字匹配，有一个成功，就不再往下进行查找，全部失败则报找不到文档的错误，目前xLua除了包含自己原本的loader外还包含了Resource所加载的loader，也就是require也可直接读取Resources目录下的文档，类似Resources的读取，但是因为Resource支持的文档类型有限，所以如果lua脚本放进了Resources文档里，就必须在后面加一个.txt的后缀，就像<strong>lua_001.lua.txt</strong>。<br>建议在整个进程中加载脚本只用一个DoString(“require’main’”),然后在main.lua脚本里可以加载自己所需要的其他脚本，其实就只把main.lua脚本看成一个接口脚本，然后在这个脚本里加载其他的lua脚本。  </p>\n</blockquote>\n<h3 id=\"自定义Loader\"><a href=\"https://LianBai.github.io/#%E8%87%AA%E5%AE%9A%E4%B9%89Loader\" class=\"headerlink\" title=\"自定义Loader\"></a>自定义Loader</h3><pre><code>LuaEnv luaenv = null;\nvoid Start () &#123;\n    luaenv = new LuaEnv();\n    LuaEnv.CustomLoader loader = CustomLoaderMethod;\n    luaenv.AddLoader(loader);\n    luaenv.DoString(\"require('main')\");\n&#125;\n<p>// Update is called once per frame<br />\nvoid Update () &#123;</p>\n<p>&#125;<br />\nprivate byte[] CustomLoaderMethod(ref string filepath)<br />\n&#123;<br />\nif(filepath== “main”)<br />\n&#123;<br />\nTextAsset lua_003 = Resources.Load&lt;TextAsset&gt;(“LuaText/lua_003.lua”);<br />\nreturn System.Text.Encoding.UTF8.GetBytes(lua_003.text);<br />\n&#125;<br />\nreturn null;<br />\n&#125;<br />\n</code></pre><blockquote></p>\n<p>有些脚本可能是进程运行下载下来的，或者是自定义的文档格式里头解压出来的，或者是需要解密的，所以存在文档不在指定的目录里，或者不是规定的lua脚本或者lua.txt格式，这样可有使用自定的loader，就类似于上面脚本，假如loader只包含原生的loader，这样就无法读取Resources里的文档夹，这样可以自定义loader,然后根据所要查找的lua脚本名字，指定到对应所在的地址，然后读取到需要的脚本，把文档里的内容一byte[]的形式回调回来即可，这样require(“脚本名字”)就可以直接执行脚本，不论脚本在什么位置，只要脚本所在的位置已经增加到loader上即可，即用LuaEnv.AddLoader（自己定义的loader），定义loader可以用LuaEnv.CustomLoader loader名字=CustomLoaderMethod来定义loader,用private byte[] CustomLoaderMethod(ref string filepath)函数来实现自己定义的loader.<br>通过AddLoader可以注册个回调，该回调参数是字符串，lua代码里头调用require时，参数将会透传给回调，回调中就可以根据这个参数去加载指定文档，如果需要支持调试，需要把filepath修改为真实路径传出。该回调返回值是一个byte数组，如果为空表示该loader找不到，否则则为lua文档的内容。 有了这个就简单了，用IIPS的IFS？没问题。写个loader调用IIPS的接口读文档内容即可。文档已经加密？没问题，自己写loader读取文档解密后返回即可。。。（<strong>此处的IIPS是什么可以不做了解</strong>）</p>\n</blockquote>\n<h2 id=\"C-访问Lua\"><a href=\"https://LianBai.github.io/#C-%E8%AE%BF%E9%97%AELua\" class=\"headerlink\" title=\"C#访问Lua\"></a>C#访问Lua</h2><h3 id=\"访问全局基本类型\"><a href=\"https://LianBai.github.io/#%E8%AE%BF%E9%97%AE%E5%85%A8%E5%B1%80%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B\" class=\"headerlink\" title=\"访问全局基本类型\"></a>访问全局基本类型</h3><p>lua脚本  </p>\n<pre><code>a = 10  \nb = 100  \nc = \"LianBai\"\n</code></pre><p>c#脚本   </p>\n<pre><code>LuaEnv luaenv = null;\nprivate TextAsset luatext;\nvoid Start () \n&#123;\n    luaenv = new LuaEnv();\n    luatext = Resources.Load&lt;TextAsset&gt;(\"LuaText/lua_004.lua\");\n    luaenv.DoString(luatext.text);\n    int a = luaenv.Global.Get&lt;int&gt;(\"a\");\n    string b = luaenv.Global.Get&lt;string&gt;(\"b\");\n    string c = luaenv.Global.Get&lt;string&gt;(\"c\");\n    print(\"a = \"+a);\n    print(\"b = \" + b);\n    print(\"c = \" + c);\n&#125;\n</code></pre><blockquote>\n<p>C#访问Lua脚本里的变量其实很简单，只需要先用DoString加载脚本，然后在通过luaenv.Global.Get&lt;变量类型&gt;(“变量名”);即可读取自己所需要的基础变量。</p>\n</blockquote>\n<h3 id=\"访问一个全局的table\"><a href=\"https://LianBai.github.io/#%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E7%9A%84table\" class=\"headerlink\" title=\"访问一个全局的table\"></a>访问一个全局的table</h3><p>lua脚本  </p>\n<pre><code>d =&#123;\n    x1=2,\n    x2=3,\n    x3=\"LianBai\",\n    4,\n    5,\n    6,\n    add = function(self,a,b)\n        return a+b\n    end\n&#125;\n</code></pre><h4 id=\"映射到一个普通的class\"><a href=\"https://LianBai.github.io/#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84class\" class=\"headerlink\" title=\"映射到一个普通的class\"></a>映射到一个普通的class</h4><p>C#脚本</p>\n<pre><code>public class Table1\n&#123;\n    public int x2;\n    public int x1;\n    public string x3;\n&#125;\nTable1 table1 = luaenv.Global.Get&lt;Table1&gt;(\"d\");\n</code></pre><blockquote>\n<p>可以自己测试输出table1的结果，根据结果可以看出lua的table映射到C#的class的时候，并不是按照顺序一一对应进行映射的，而是根据名字映射，lua的table中的x1变量只会映射到C#的class中的x1变量中，如果lua的table里没有class中所包含的变量，则会在class中赋值为空，如果lua中table变量多余class，多余的也不会赋值过来，只会把class所包含的赋值过来。</p>\n</blockquote>\n<h4 id=\"映射到一个Dictionary中\"><a href=\"https://LianBai.github.io/#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AADictionary%E4%B8%AD\" class=\"headerlink\" title=\"映射到一个Dictionary中\"></a>映射到一个Dictionary中</h4><p>C#脚本</p>\n<pre><code>Dictionary&lt;string,double&gt; table2= luaenv.Global.Get&lt;Dictionary&lt;string,double&gt;&gt;(\"d\");\nprint(\"table1.x1:\" + table2[\"x1\"]);\nprint(\"table1.x2:\" + table2[\"x2\"]);\n</code></pre><blockquote>\n<p>在映射到Dictionary的时候，只会映射符合Dictionary自己定义的规则的变量，把变量名存为keys，把变量值存为对应的数据，所以不会把x3等后面的数据存到Dictionary里。</p>\n</blockquote>\n<h4 id=\"映射到一个List里\"><a href=\"https://LianBai.github.io/#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AAList%E9%87%8C\" class=\"headerlink\" title=\"映射到一个List里\"></a>映射到一个List里</h4><p>C#脚本</p>\n<pre><code>List&lt;double&gt; table3= luaenv.Global.Get&lt;List&lt;double&gt;&gt;(\"d\");\nprint(\"List的Count\" + table3.Count);\nforeach(double i in table3)\n&#123;\n    print(\"i:\" + i);\n&#125;\n</code></pre><blockquote>\n<p>在映射到List中，也只会映射到符合List规则的变量，但是有一点要注意的是，table中带keys的不会映射进List，不管储存的变量是不是符合规则，都不会映射进去，所以在上述脚本打印的时候，table3存的值是lua脚本中table中的4,5,6,三个变量。</p>\n</blockquote>\n<h4 id=\"映射到一个interface\"><a href=\"https://LianBai.github.io/#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AAinterface\" class=\"headerlink\" title=\"映射到一个interface\"></a>映射到一个interface</h4><p>C#脚本</p>\n<pre><code>[CSharpCallLua]\npublic interface ITable4\n&#123;\n    int x1 &#123; get; set; &#125;\n    int x2 &#123; get; set; &#125;\n    string x3 &#123; get; set; &#125;\n    int add(int a, int b);\n&#125;\n<p>ITable4 table4 = luaenv.Global.Get&lt;ITable4&gt;(“d”);<br />\nprint(&quot;table4 x1 = &quot; + table4.x1);<br />\nprint(&quot;table4 x2 = &quot; + table4.x2);<br />\nprint(&quot;table4 x3 = &quot; + table4.x3);<br />\nprint(&quot;table4 add = &quot; + table4.add(5, 6));<br />\n</code></pre><blockquote></p>\n<p>什么是interface？<strong><a href=\"http://www.runoob.com/csharp/csharp-interface.html\" target=\"_blank\" rel=\"noopener noreferrer\"><font color=\"steelblue\" size=\"3\">点击这里</font></a></strong>。理解清楚interface后，从代码里我们可以看出接口类多了一个[CSharpCallLua]，这是在为这个类打上了一个标签，因为与LUA交互的代理和类型需要添加 CSharpCallLua 标签，xlua的特性之一就是标记，这一次与lua交互的特性标记则是[CSharpCallLua]，只有这样写，才可支持热更新。然后接口类的继承和普通类类似，也是根据变量名字一一对应的关系。</p>\n</blockquote>\n<h4 id=\"映射到一个LuaTable变量\"><a href=\"https://LianBai.github.io/#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AALuaTable%E5%8F%98%E9%87%8F\" class=\"headerlink\" title=\"映射到一个LuaTable变量\"></a>映射到一个LuaTable变量</h4><p>C#脚本</p>\n<pre><code>LuaTable table5= luaenv.Global.Get&lt;LuaTable&gt;(\"d\");\nprint(\"table5长度:\" + table5.Length);\nprint(\"table5.x1:\" + table5.Get&lt;int&gt;(\"x1\"));\nprint(\"table5.x2:\" + table5.Get&lt;int&gt;(\"x2\"));\nprint(\"table5.x3:\" + table5.Get&lt;string&gt;(\"x3\"));\n</code></pre><blockquote>\n<p>这是一种by ref方式，所以不会生成代码，但是这种方式比较慢，并且没有变量检测。</p>\n</blockquote>\n<h3 id=\"访问一个funaction\"><a href=\"https://LianBai.github.io/#%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AAfunaction\" class=\"headerlink\" title=\"访问一个funaction\"></a>访问一个funaction</h3><p>Lua脚本</p>\n<pre><code>function e()\n&#123;\n    print(\"lua脚本的函数\")\n&#125;\nfunction f(a, b)\n    print('a', a, 'b', b)\n    return 1, 2, &#123;x1 = 1024,x2 = 2048&#125;\nend\nfunction ret_e()\n    print(\"LuaScripts return e function\")\n    return e\nend\n</code></pre><h4 id=\"映射到一个委托（Action或者delgate）\"><a href=\"https://LianBai.github.io/#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AA%E5%A7%94%E6%89%98%EF%BC%88Action%E6%88%96%E8%80%85delgate%EF%BC%89\" class=\"headerlink\" title=\"映射到一个委托（Action或者delgate）\"></a>映射到一个委托（Action或者delgate）</h4><p>C#脚本</p>\n<pre><code>public static class AddGenerateList\n&#123;\n     [CSharpCallLua]\n       public static List&lt;Type&gt; CSharpCallLua = new List&lt;Type&gt;()\n    &#123;\n        typeof(Action),\n        typeof(Action&lt;bool&gt;),\n    &#125;;\n&#125;\n<p>Action function1 = luaenv.Global.Get&lt;Action&gt;(“e”);<br />\nfunction1();<br />\n</code></pre><blockquote></p>\n<p>在把函数映射到Action的时候，一定要把Action添加到生成列表，脚本中第一个静态的AddGenerateList类就是把Action增加到生成列表里。然后才可把函数映射到Action中。否则将会报错。</p>\n</blockquote>\n<h4 id=\"lua脚本多返回值映射\"><a href=\"https://LianBai.github.io/#lua%E8%84%9A%E6%9C%AC%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%A0%E5%B0%84\" class=\"headerlink\" title=\"lua脚本多返回值映射\"></a>lua脚本多返回值映射</h4><p>C#脚本</p>\n<pre><code>[CSharpCallLua]\npublic delegate int Function2(int a, string b, out int c, out Table1 d);\n<p>Function2 function2 = luaenv.Global.Get&lt;Function2&gt;(“f”);<br />\nTable1 table1;<br />\nint fun2_02;<br />\nint fun2_01 = function2(66, “LianBai”, out fun2_02, out table1);<br />\nprint(“fun2_01:” + fun2_01);<br />\nprint(“fun2_02:” + fun2_02);<br />\nprint(“table1.x1:” + table1.x1);<br />\nprint(“table1.x2:” + table1.x2);<br />\n</code></pre><blockquote></p>\n<p>lua脚本里的函数支持多个返回值，而且返回值的类型也不同，在C#访问lua函数的时候，可以通过上述方法接收lua函数的多个返回值，第一个返回值直接接收映射过来函数的返回值，正如上述脚本里的fun2_01就是第一个返回值，然后后面的返回值均可用out接收，不过映射前声明的时候要用上述的声明方法：<br>[CSharpCallLua]<br>public delegate 第一个返回值类型 Function(参数1,参数2，…, out 第二个返回值,out 第三个返回值，…)</p>\n</blockquote>\n<h4 id=\"映射lua返回复杂类型的函数\"><a href=\"https://LianBai.github.io/#%E6%98%A0%E5%B0%84lua%E8%BF%94%E5%9B%9E%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0\" class=\"headerlink\" title=\"映射lua返回复杂类型的函数\"></a>映射lua返回复杂类型的函数</h4><p>C#脚本</p>\n<pre><code>[CSharpCallLua]\npublic delegate Action Function3();\n<p>Function3 function3 = luaenv.Global.Get&lt;Function3&gt;(“ret_e”);<br />\nprint(“第一步：”);<br />\nfunction3();<br />\nprint(“第二步：”);<br />\nAction function3_01 = function3();<br />\nfunction3_01();<br />\n</code></pre><blockquote></p>\n<p>在C#访问lua的函数返回类型是复杂类型的时候，可以用委托接收，例如上述脚本，访问的函数的返回值是一个函数，在访问的时候，同样用委托接收，不过是两层委托，例如Function3的定义，function3所访问的就是访问对应的函数，然后用一个委托接收function3的返回值，然后就可以访问所返回的函数。</p>\n</blockquote>\n<h3 id=\"使用建议\"><a href=\"https://LianBai.github.io/#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE\" class=\"headerlink\" title=\"使用建议\"></a>使用建议</h3><blockquote>\n<p>1.访问lua全局数据，特别是table以及function，代价比较大，建议尽量少做，比如在初始化时把要调用的lua function获取一次（映射到delegate）后，保存下来，后续直接调用该delegate即可。table也类似。 </p>\n</blockquote>\n<blockquote>\n<p>2.如果lua测的实现的部分都以delegate和interface的方式提供，使用方可以完全和xLua解耦：由一个专门的模块负责xlua的初始化以及delegate、interface的映射，然后把这些delegate和interface设置到要用到它们的地方。</p>\n</blockquote>\n<h2 id=\"Lua访问C-脚本\"><a href=\"https://LianBai.github.io/#Lua%E8%AE%BF%E9%97%AEC-%E8%84%9A%E6%9C%AC\" class=\"headerlink\" title=\"Lua访问C#脚本\"></a>Lua访问C#脚本</h2><h3 id=\"lua创建一个C-的对象\"><a href=\"https://LianBai.github.io/#lua%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAC-%E7%9A%84%E5%AF%B9%E8%B1%A1\" class=\"headerlink\" title=\"lua创建一个C#的对象\"></a>lua创建一个C#的对象</h3><p>Lua脚本</p>\n<pre><code>local CShapObject = CS.UnityEngine.GameObject(\"LianBai\")\n</code></pre><blockquote>\n<p>通过上述方法可以用lua脚本创建一个新的gameobject,后面跟的字符串就是物体的名字，所以创建新物体的lua脚本就是<strong>local lua函数名 = CS.对象(class)命名空间.C#对象(class)名(参数)</strong>。</p>\n</blockquote>\n<h3 id=\"lua访问C-的静态属性、静态方法\"><a href=\"https://LianBai.github.io/#lua%E8%AE%BF%E9%97%AEC-%E7%9A%84%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\" class=\"headerlink\" title=\"lua访问C#的静态属性、静态方法\"></a>lua访问C#的静态属性、静态方法</h3><p>C#脚本</p>\n<pre><code>LuaEnv luaenv = null;\nprivate TextAsset luatext;\nnamespace MySpace\n&#123;\n    [LuaCallCSharp]\n    public static class CShapStaticClass\n    &#123;\n        public static int a = 10;\n        public static string b = \"LianBai\";\n    &#125;\n&#125;\n<p>luaenv = new LuaEnv();<br />\nluatext = Resources.Load&lt;TextAsset&gt;(“LuaText/lua_005.lua”);<br />\nluaenv.DoString(luatext.text);<br />\nprint(CShapStaticClass.a);<br />\n</code></pre><p>Lua脚本</p></p>\n<pre><code>local CShapObject = CS.UnityEngine.GameObject(\"LianBai\")\nlocal a=CS.MySpace.CShapStaticClass.a\nlocal b=CS.MySpace.CShapStaticClass.b\nCS.MySpace.CShapStaticClass.a=66\nprint(a);\nprint(b);\n</code></pre><blockquote>\n<p>lua在访问c#的静态变量时与创建对象类似，CS.命名空间.静态类.静态变量<br>如果需要经常访问的类，可以先用局部变量引用后访问，除了减少敲代码的时间，还能提高性能。</p>\n</blockquote>\n<h3 id=\"lua访问C-成员属性、方法\"><a href=\"https://LianBai.github.io/#lua%E8%AE%BF%E9%97%AEC-%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95\" class=\"headerlink\" title=\"lua访问C#成员属性、方法\"></a>lua访问C#成员属性、方法</h3><h4 id=\"lua访问普通的类\"><a href=\"https://LianBai.github.io/#lua%E8%AE%BF%E9%97%AE%E6%99%AE%E9%80%9A%E7%9A%84%E7%B1%BB\" class=\"headerlink\" title=\"lua访问普通的类\"></a>lua访问普通的类</h4><p>C#脚本</p>\n<pre><code>[LuaCallCSharp]\npublic class CShapClass02\n&#123;\n    public int c = 99;\n    public void Class02Fun01()\n    &#123;\n        Debug.Log(\"This is CShapClass01's function d\");\n    &#125;\n&#125;\n</code></pre><p>lua脚本</p>\n<pre><code>local LuaClass02 = CS.MySpace.CShapClass02\nlocal luaclass02 = LuaClass02()\nprint(luaclass02.c)\nluaclass02.c = 88\nluaclass02:Class02Fun01()\n</code></pre><blockquote>\n<p>lua在访问C#的成员属性和方法的时候，先用变量映射出C#的类，然后再用一个变量接收。local 变量1 = CS.类所在命名空间.类名,变量1是映射过来的对象的声明，需要自己定义一个对象，local 变量2 = 变量1()，即变量2就是所映射过来的类的实例，通过<strong>变量2.变量名</strong>就可访问变量，通过<strong>变量2: 函数名()</strong>就可启用C#的函数。</p>\n</blockquote>\n<h4 id=\"lua访问继承的类\"><a href=\"https://LianBai.github.io/#lua%E8%AE%BF%E9%97%AE%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB\" class=\"headerlink\" title=\"lua访问继承的类\"></a>lua访问继承的类</h4><p>C#脚本</p>\n<pre><code>[LuaCallCSharp]\npublic class CShapClass01\n&#123;\n    public static int a = 1;\n    public static string b = \"LianBai\";\n    public static void Class01Fun01()\n    &#123;\n        Debug.Log(\"This is Class01Fun01\");\n    &#125;\n    public void Class01Fun02()\n    &#123;\n        Debug.Log(\"This is Class01Fun02\");\n    &#125;\n&#125;\n[LuaCallCSharp]\npublic class CShapClass02: CShapClass01\n&#123;\n    public int c = 99;\n    public void Class02Fun01()\n    &#123;\n        Debug.Log(\"This is CShapClass01's function d\");\n    &#125;\n&#125;\n</code></pre><p>lua脚本  </p>\n<pre><code>local LuaClass02 = CS.MySpace.CShapClass02\nlocal luaclass02 = LuaClass02()\nprint(luaclass02.c)\nprint(LuaClass02.a)\nprint(LuaClass02.b)\nluaclass02.c = 88\nluaclass02:Class02Fun01()\nLuaClass02.Class01Fun01()\nluaclass02:Class01Fun02()\n</code></pre><blockquote>\n<p>lua在访问C#的含有继承类的类的时候，访问基类普通变量和访问子类一样，用<strong>变量2.变量名</strong>，和<strong>变量2：函数名</strong>来访问，但是在访问基类的静态变量的时候，通过<strong>变量1.变量名</strong>来访问基类<strong>静态变量</strong>，通过<strong>变量1：函数名</strong>来访问基类<strong>静态函数</strong>。xlua支持（通过派生类）访问基类的静态属性，静态方法，（通过派生类实例）访问基类的成员属性，成员方法。</p>\n</blockquote>\n<h4 id=\"访问复杂函数\"><a href=\"https://LianBai.github.io/#%E8%AE%BF%E9%97%AE%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0\" class=\"headerlink\" title=\"访问复杂函数\"></a>访问复杂函数</h4><p>C#脚本</p>\n<pre><code>[LuaCallCSharp]\npublic class CShapClass02\n&#123;\n    public int c = 99;\n    public void Class02Fun01()\n    &#123;\n        Debug.Log(\"This is CShapClass01's function d\");\n    &#125;\n    public double Class02Fun02(CShapClass01 cshapclass01,ref int x1,out string x2,Action luafun,out Action csfun)\n    &#123;\n        Debug.Log(cshapclass01.c + \" : \" + cshapclass01.d);\n        luafun();\n        x1 = x1 * cshapclass01.c;\n        x2 = \"CShapClass01.d = \" + cshapclass01.d;\n        csfun = () =&gt;\n        &#123;\n            Debug.Log(\"This is CsFun\");\n        &#125;;\n        Debug.Log(x1 + \" : \" + x2);\n        return 6.66;\n    &#125;\n&#125;\n</code></pre><p>Lua脚本</p>\n<pre><code>local LuaClass02 = CS.MySpace.CShapClass02\nlocal luaclass02 = LuaClass02()\nfunction LuaFun()\n    print(\"This is LuaFun\")\nend\nlocal cshapclass01,x1,x2,csfun = luaclass02:Class02Fun02(&#123;c = 100,d = \"LianHei\"&#125;,88,LuaFun)\nprint(\"cshapclass01:\",cshapclass01)\nprint(\"x1:\", x1)\nprint(\"x2:\", x2)\nprint(\"csfun:\", csfun)\ncsfun();\n</code></pre><blockquote>\n<p>参数的输入输出属性（out，ref）<br>Lua调用测的参数处理规则：C#的普通参数算一个输入形参，ref修饰的算一个输入形参，out不算，然后从左往右对应lua 调用测的实参列表；<br>Lua调用测的返回值处理规则：C#函数的返回值（如果有的话）算一个返回值，out算一个返回值，ref算一个返回值，然后从左往右对应lua的多返回值。  </p>\n<p>上述话的意思是lua在映射复杂的函数的时候，C#函数中的参数中有普通参数，ref定义的参数，out定义的参数，例如上述的<em>Class02Fun02</em>函数中<em>CShapClass01 cshapclass01</em>是普通的参数，就是我们正常定义的参数，<em>ref int x1</em>和<em>out string x2</em>分别是ref和out定义的参数，在lua调用的时候，<em>luaclass02:Class02Fun02({c = 100,d = “LianHei”},88,LuaFun)</em>，第一个表<em>{c = 100,d = “LianHei”}</em>是给<em>cshapclass01</em>传参数，88传给的是x1,LuaFun是传给的,Action luafun,因为x2和csfun是out形容的参数，所以不用传递。  </p>\n<p>ref定义的参数，在调用的时候要传参数，在返回的时候也要接收，out定义的参数在调用的时候不用传递参数，但是在接收的时候要接收参数<br>在调用这个函数的时候会执行C#脚本里面的函数，然后函数会有返回值，如果函数本身就有返回值，则lua脚本在接收的第一个返回值就是函数的返回值，然后在C#函数中有些参数是ref或者out参数，这些参数从左往右依次都是函数的返回值，所以在C#函数里必须为这些参数赋值。</p>\n</blockquote>\n<h4 id=\"访问重载方法\"><a href=\"https://LianBai.github.io/#%E8%AE%BF%E9%97%AE%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95\" class=\"headerlink\" title=\"访问重载方法\"></a>访问重载方法</h4><p>C#脚本</p>\n<pre><code>[LuaCallCSharp]\npublic class CShapClass03\n&#123;\n    public void CShapFun()\n    &#123;\n        Debug.Log(\"This is NULL\");\n    &#125;\n    public void CShapFun(int a)\n    &#123;\n        Debug.Log(\"This is int\");\n    &#125;\n    public void CShapFun(string a)\n    &#123;\n        Debug.Log(\"This is string\");\n    &#125;\n&#125;\n</code></pre><p>Lua脚本</p>\n<pre><code>local LuaClass03 = CS.MySpace.CShapClass03\nlocal luaclass03 = LuaClass03()\nluaclass03:CShapFun()\nluaclass03:CShapFun(2)\nluaclass03:CShapFun(\"LianBai\")\n</code></pre><blockquote>\n<p>在C#里运行脚本可以看出，在访问重载函数的时候，只要改变穿进去的参数，就会自动调用重载对应的函数。<br>注意：xlua只一定程度上支持重载函数的调用，因为lua的类型远远不如C#丰富，存在一对多的情况，比如C#的int，float，double都对应于lua的number，上面的例子中TestFunc如果有这些重载参数，第一行将无法区分开来，只能调用到其中一个（生成代码中排前面的那个）</p>\n</blockquote>\n<h4 id=\"调用操作符\"><a href=\"https://LianBai.github.io/#%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6\" class=\"headerlink\" title=\"调用操作符\"></a>调用操作符</h4><p>C#脚本</p>\n<pre><code>[LuaCallCSharp]\npublic class CShapClass03\n&#123;\n    public int a = 66;\n    public string b = \"LianBai\";\n    public static CShapClass03 operator + (CShapClass03 class1, CShapClass03 class2)\n    &#123;\n        CShapClass03 ret = new CShapClass03();\n        ret.a = class1.a + class2.a;\n        ret.b = class1.b + class2.b;\n        return ret;\n    &#125;\n&#125;\n</code></pre><p>Lua脚本</p>\n<pre><code>local LuaClass03 = CS.MySpace.CShapClass03\nlocal luaclass03 = LuaClass03()\nlocal luaclass04 = LuaClass03()\nprint(luaclass03.a)\nprint(luaclass04.b)\nluaclass04.a = 88\nprint(luaclass04.a)\nprint(\"This \",(luaclass03 + luaclass04).a)\nluaclass03.b=\"I am \"\nprint((luaclass03+luaclass04).b)\n</code></pre><blockquote>\n<p>在lua使用所访问的对象的操作符的时候，在对象内部必须重载此运算符，这样才可以使用此运算符，C#的运算符可以自己百度查询。然后在类里面即可像C#里面一样调用，允许操作的运算符有：<br>+，-，*，/，==，一元-，&lt;，&lt;=， %，[]</p>\n</blockquote>\n<h4 id=\"访问含默认值方法\"><a href=\"https://LianBai.github.io/#%E8%AE%BF%E9%97%AE%E5%90%AB%E9%BB%98%E8%AE%A4%E5%80%BC%E6%96%B9%E6%B3%95\" class=\"headerlink\" title=\"访问含默认值方法\"></a>访问含默认值方法</h4><p>C#脚本</p>\n<pre><code>public void CShapClass03DefaultFun(int a = 66,string b = \"LianBai\",string c = null)\n&#123;\n    Debug.Log(\"a = \" + a + \" b = \" + b + \" c = \" + c);\n&#125;\n</code></pre><p>Lua脚本  </p>\n<pre><code>local LuaClass03 = CS.MySpace.CShapClass03\nlocal luaclass03 = LuaClass03()\nluaclass03:CShapClass03DefaultFun()\nluaclass03:CShapClass03DefaultFun(88)\nluaclass03:CShapClass03DefaultFun(88,\"LianHei\")\nluaclass03:CShapClass03DefaultFun(88,\"LianHei\",\"COOL\")\n</code></pre><blockquote>\n<p>在访问含有默认值的方法时，在lua里调用函数和C#调用有默认值参数的函数一样，如果所给的实参少于形参，则会用默认值补上。  </p>\n</blockquote>\n<h4 id=\"访问可变参数方法\"><a href=\"https://LianBai.github.io/#%E8%AE%BF%E9%97%AE%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95\" class=\"headerlink\" title=\"访问可变参数方法\"></a>访问可变参数方法</h4><p>C#脚本</p>\n<pre><code>[LuaCallCSharp]\npublic class CShapClass03\n&#123;\n    public int a = 66;\n    public string b = \"LianBai\";\n    public void CShapClassVariableFun(int a,params string[] str)\n    &#123;\n        string s = null;\n        foreach(string c in str)\n        &#123;\n            s = s + c +\" \";\n        &#125;\n        Debug.Log(\"a = \" + a + \"  str = \" + s);\n    &#125;\n&#125;\n</code></pre><p>Lua脚本</p>\n<pre><code>local LuaClass03 = CS.MySpace.CShapClass03\nlocal luaclass03 = LuaClass03()\nluaclass03:CShapClassVariableFun(10,\"I\")\nluaclass03:CShapClassVariableFun(20,\"I\",\"am\")\nluaclass03:CShapClassVariableFun(30,\"I\",\"am\",\"LianBai\")\n</code></pre><blockquote>\n<p>lua在访问的方法中含有可变参数（<a href=\"http://www.runoob.com/csharp/csharp-param-arrays.html\" target=\"_blank\" rel=\"noopener noreferrer\"><font color=\"steelblue\">params</font></a>）的时候，也可以类似于在C#脚本的使用方法传进去参数。</p>\n</blockquote>\n<h4 id=\"映射枚举并访问枚举\"><a href=\"https://LianBai.github.io/#%E6%98%A0%E5%B0%84%E6%9E%9A%E4%B8%BE%E5%B9%B6%E8%AE%BF%E9%97%AE%E6%9E%9A%E4%B8%BE\" class=\"headerlink\" title=\"映射枚举并访问枚举\"></a>映射枚举并访问枚举</h4><p>C#脚本</p>\n<pre><code>[LuaCallCSharp]\npublic enum MyEnum\n&#123;\n    x1 = 66,\n    x2 = 88,\n    x3 = 99\n&#125;\n[LuaCallCSharp]\npublic class CShapClass04\n&#123;\n    public MyEnum CShapEnumFun(MyEnum e)\n    &#123;\n        Debug.Log(\"MyEnum:\" + e);\n        return e;\n    &#125;\n&#125;\n</code></pre><p>Lua脚本</p>\n<pre><code>local LuaEnum = CS.MySpace.MyEnum\nprint(LuaEnum.__CastFrom(\"x1\"),LuaEnum.__CastFrom(\"x2\"),LuaEnum.__CastFrom(\"x3\"))\nlocal LuaClass04 = CS.MySpace.CShapClass04\nlocal luaclass04 = LuaClass04()\nlocal luaenum = luaclass04:CShapEnumFun(CS.MySpace.MyEnum.x1)\nprint(luaenum,luaenum == LuaEnum.x1)\nprint(LuaEnum.__CastFrom(0),LuaEnum.__CastFrom(1),LuaEnum.__CastFrom(2))\n</code></pre><blockquote>\n<p>在映射枚举的时候，直接像类一样直接声明枚举对象就可调用，方法是：<strong>local 变量1 = CS.枚举所在命名空间.枚举名</strong>，然后就可以通过<strong>变量1.key值</strong>就可访问枚举中的对象。<br>在映射类里面含有枚举参数的时候，可以直接通过<strong>CS.枚举所在命名空间.枚举名.key值”</strong>直接传进key对应的值，也可直接通过映射过来的变量1，通过<strong>变量1.key值”</strong>访问对应的key值。<br>如果枚举类加入到生成代码的话，枚举类将支持<strong>__CastFrom()</strong>方法，可以实现从一个整数或者字符串到枚举值的转换。（<font color=\"red\">注：CastFrom前面是两个英文的下划线</font>)  </p>\n</blockquote>\n<h4 id=\"Lua访问C-委托\"><a href=\"https://LianBai.github.io/#Lua%E8%AE%BF%E9%97%AEC-%E5%A7%94%E6%89%98\" class=\"headerlink\" title=\"Lua访问C#委托\"></a>Lua访问C#委托</h4><p>C#脚本</p>\n<pre><code>[LuaCallCSharp]\npublic class CShapClass04\n&#123;\n    public MyEnum CShapEnumFun(MyEnum e)\n    &#123;\n        Debug.Log(\"MyEnum:\" + e);\n        return e;\n    &#125;\n    public static Action&lt;string&gt; CShapStaticAction;\n    public Action&lt;string&gt; CShapAction = (param) =&gt;\n    &#123;\n        Debug.Log(\"This is My CShapAction：\" + param);\n    &#125;;\npublic delegate void CShapDelegate(string obj);\n&#125;\n[LuaCallCSharp]\npublic class CShapClass05\n&#123;\n    public CShapClass04.CShapDelegate MyClassFun = null;\n    public CShapClass05()\n    &#123;\n        MyClassFun = new CShapClass04.CShapDelegate(MyAction) ;\n    &#125;\n    private void MyAction(string obj)\n    &#123;\n        Debug.Log(\"This is My CShapDelegates：\" + obj);\n    &#125;\n&#125;\n<p>MySpace.CShapClass04.CShapStaticAction += MyStaticAction;<br />\n</code></pre><p>Lua脚本</p></p>\n<pre><code>local LuaClass04 = CS.MySpace.CShapClass04\nlocal luaclass04 = LuaClass04()\nlocal LuaClass05 = CS.MySpace.CShapClass05\nlocal luaclass05 = LuaClass05()\nLuaClass04.CShapStaticAction(\"LianBai\")\nluaclass04.CShapAction(\"LianBai\")\nlocal MyLuaClass = luaclass05.MyClassFun\n上MyLuaClass(\"LianBai\")\nMyLuaClass(\"LianBai\")\nlocal function LuaAction(str)\n    print(\"This is LuaAction :\",str)\nend\nlocal luaaction = LuaAction + LuaClass04.CShapStaticAction\nluaaction(\"+\")\nlocal luaaction = LuaClass04.CShapStaticAction - LuaAction\nluaaction(\"-\")\nlocal luaaction = LuaClass04.CShapStaticAction + LuaAction\nluaaction(\"+2\")\nlocal luaaction = LuaClass04.CShapStaticAction - LuaAction\nluaaction(\"-2\")\n</code></pre><blockquote>\n<p>C#的委托关键字是delegate,Action和Func都是别人封装好的委托，通过上述方法可以观测到，delegate在定义委托的时候，默认就是静态的方法，但是Action定义委托的时候需要手动添加关键字，如果没有添加关键字，只能通过对象调用，但是无法传递参数，因为delegate本身是静态的，所以导致无法使用，关于delegate和Action、Func的区别请<strong><a href=\"https://blog.csdn.net/cubesky/article/details/39577879\" target=\"_blank\" rel=\"noopener noreferrer\"><font color=\"steelblue\" size=\"3\">点击这里</font></a></strong>  、<br>通过上述脚本，测试可发现，lua在访问委托的时候，和调用普通的函数方法一样。<br>+操作符：对应C#的+操作符，把两个调用串成一个调用链，右操作数可以是同类型的C# delegate或者是lua函数。<br>-操作符：和+相反，把一个delegate从调用链中移除。<br>+操作符左右任意一个是delegate就可以，但是-操作符delegate必须放在左边<br>Ps：delegate属性可以用 一个luafunction来赋值。</p>\n</blockquote>\n<h4 id=\"Lua访问类的事件-Event\"><a href=\"https://LianBai.github.io/#Lua%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E4%BA%8B%E4%BB%B6-Event\" class=\"headerlink\" title=\"Lua访问类的事件(Event)\"></a>Lua访问类的事件(Event)</h4><p>C#脚本  </p>\n<pre><code>[LuaCallCSharp]\npublic class DelegateClass\n&#123;\n    public delegate void MyDelegate();  //定义一个委托\n    public event MyDelegate myevent;    //定义了一个事件\n    public void ClassFun01()\n    &#123;\n        myevent();\n    &#125;\n&#125;\n</code></pre><p>Lua脚本  </p>\n<pre><code>local LuaClass = CS.MySpace01.DelegateClass\nlocal luaclass = LuaClass()\nlocal function luafun01()\n    print(\"This is luafun01\")\nend\nlocal function luafun02()\n    print(\"This is luafun02\")\nend\nluaclass:myevent(\"+\",luafun01)\nluaclass:ClassFun01()\nluaclass:myevent(\"+\",luafun02)\nluaclass:ClassFun01()\nluaclass:myevent(\"-\",luafun01)\nluaclass:ClassFun01()\n</code></pre><blockquote>\n<p>Lua在访问<a href=\"http://www.runoob.com/csharp/csharp-event.html\" target=\"_blank\" rel=\"noopener noreferrer\"><font color=\"steelblue\">Event</font></a>的时候，添加事件回调的方法是<strong>类对象:委托名(“+”,函数名)</strong>，同样的，在移除事件回调的时候是<strong>类对象:委托名(“-“,函数名)</strong>。</p>\n</blockquote>\n<h4 id=\"Lua访问64位整数\"><a href=\"https://LianBai.github.io/#Lua%E8%AE%BF%E9%97%AE64%E4%BD%8D%E6%95%B4%E6%95%B0\" class=\"headerlink\" title=\"Lua访问64位整数\"></a>Lua访问64位整数</h4><p>C#脚本</p>\n<pre><code>public ulong LongFun(long l)\n&#123;\n    return (ulong)l + 1;\n&#125;\n</code></pre><p>Lua脚本</p>\n<pre><code>local LuaClass = CS.MySpace01.DelegateClass\nlocal luaclass = LuaClass()\nlocal a = luaclass:LongFun(11)\nprint(type(a),a+10,a+100,a+1000,a+10000)\n</code></pre><blockquote>\n<p>Lua53版本64位整数（long，ulong）映射到原生的64未整数，而luaji版本t，相当于lua5.1的标准，本身不支持64位，xlua做了个64位支持的扩展库，C#的long和ulong都将映射到userdata：<br>支持在lua里头进行64位的运算，比较，打印<br>支持和lua number的运算，比较<br>要注意的是，在64扩展库中，实际上只有int64，ulong也会先强转成long再传递到lua，而对ulong的一些运算，比较，我们采取和java一样的支持方式，提供一组API，详情请看API文档。</p>\n</blockquote>\n<h4 id=\"C-复杂类型和table的转换\"><a href=\"https://LianBai.github.io/#C-%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E5%92%8Ctable%E7%9A%84%E8%BD%AC%E6%8D%A2\" class=\"headerlink\" title=\"C#复杂类型和table的转换\"></a>C#复杂类型和table的转换</h4><p>C#脚本</p>\n<pre><code>[LuaCallCSharp]\npublic class MyClass01\n&#123;\n    public int a;\n    public void Show()\n    &#123;\n        Debug.Log(\"This is MyClass01's a:\" + a);\n    &#125;\n&#125;\n[LuaCallCSharp]\npublic class MyClass02\n&#123;\n    public MyClass01 a;\n    public string b;\n    public void Show()\n    &#123;\n        a.Show();\n        Debug.Log(\"This is MyClass02's b:\" + a);\n    &#125;\n<p>&#125;<br />\n[LuaCallCSharp]<br />\npublic class MyClass03<br />\n&#123;<br />\npublic void Set(MyClass02 my)<br />\n&#123;<br />\nmy.Show();<br />\n&#125;<br />\n&#125;<br />\n</code></pre><p>Lua脚本</p></p>\n<pre><code>local LuaClass = CS.MySpace01.MyClass03\nlocal luaclass = LuaClass()\nluaclass:Set(&#123;a=&#123;a=66&#125;,b=\"LianBai\"&#125;)\n</code></pre><blockquote>\n<p>Lua在访问复杂的Class参数时，一个{}就是一个类，如果想用上述方法，变量必须public，这样lua才能根据变量名进行赋值，就像一开头讲的，根据变量名字进行赋值。</p>\n</blockquote>\n<h4 id=\"Lua获取C-的类型-相当于C-的typeof\"><a href=\"https://LianBai.github.io/#Lua%E8%8E%B7%E5%8F%96C-%E7%9A%84%E7%B1%BB%E5%9E%8B-%E7%9B%B8%E5%BD%93%E4%BA%8EC-%E7%9A%84typeof\" class=\"headerlink\" title=\"Lua获取C#的类型(相当于C#的typeof)\"></a>Lua获取C#的类型(相当于C#的typeof)</h4><p>Lua脚本<br>    print(typeof(CS.MySpace01))</p>\n<blockquote>\n<p>要获取CS.MySpace01类的Type信息，可以用上述脚本</p>\n</blockquote>\n<h4 id=\"Lua强转数据\"><a href=\"https://LianBai.github.io/#Lua%E5%BC%BA%E8%BD%AC%E6%95%B0%E6%8D%AE\" class=\"headerlink\" title=\"Lua强转数据\"></a>Lua强转数据</h4><p>C#脚本</p>\n<pre><code>[LuaCallCSharp]\npublic interface MyClass04\n&#123;\n    void  Show(int a, string b);\n&#125;\n[LuaCallCSharp]\npublic class MyClass05 : MyClass04\n&#123;\n    public int ID = 88;\n    public void Show(int a, string b)\n    &#123;\n        Debug.Log(a);\n        Debug.Log(b);\n    &#125;\n    public MyClass04 GetClass04()\n    &#123;\n        return new MyClass05();\n    &#125;\n&#125;\n</code></pre><p>Lua脚本</p>\n<pre><code>local LuaClass01 = CS.MySpace01.MyClass05 \nlocal luaclass01 = LuaClass01()\nlocal luainterface01 = luaclass01:GetClass04()\nluainterface01:Show(66,\"LianBai\")\nassert(luainterface01.ID == 88)\n--assert(luainterface01.ID == nil)\n<p>local LuaClass02 = CS.MySpace01.MyClass05<br />\nlocal luaclass02 = LuaClass02()<br />\nlocal luainterface02 = luaclass02:GetClass04()<br />\ncast(luainterface02,typeof(CS.MySpace01.MyClass04))<br />\nluainterface02:Show(88,“LianHei”)<br />\n–assert(<a href=\"http://luainterface02.ID\">luainterface02.ID</a> == 88)<br />\nassert(<a href=\"http://luainterface02.ID\">luainterface02.ID</a> == nil)<br />\n</code></pre></p>\n<h1 id=\"XLua配置\"><a href=\"https://LianBai.github.io/#XLua%E9%85%8D%E7%BD%AE\" class=\"headerlink\" title=\"XLua配置\"></a>XLua配置</h1>","text":" &lt;blockquote&gt; 从这里下载一个zip压缩包，解压后会有Assets等几个文档夹，其他文档夹放进你所创建的unity工程的Assets同级的目录下，然后把加压出来的Assets里的文档和文档夹复制进unity项目的Assets文档夹里即可。 XLua教程XL...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#XLua%E6%95%99%E7%A8%8B\"><span class=\"toc-text\">XLua教程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XLua%E5%8A%A0%E8%BD%BD%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">XLua加载文档</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E8%BD%BD%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">加载字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E8%BD%BDlua%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">加载lua文档</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89Loader\"><span class=\"toc-text\">自定义Loader</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-%E8%AE%BF%E9%97%AELua\"><span class=\"toc-text\">C#访问Lua</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E5%85%A8%E5%B1%80%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">访问全局基本类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E7%9A%84table\"><span class=\"toc-text\">访问一个全局的table</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84class\"><span class=\"toc-text\">映射到一个普通的class</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AADictionary%E4%B8%AD\"><span class=\"toc-text\">映射到一个Dictionary中</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AAList%E9%87%8C\"><span class=\"toc-text\">映射到一个List里</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AAinterface\"><span class=\"toc-text\">映射到一个interface</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AALuaTable%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">映射到一个LuaTable变量</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AAfunaction\"><span class=\"toc-text\">访问一个funaction</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AA%E5%A7%94%E6%89%98%EF%BC%88Action%E6%88%96%E8%80%85delgate%EF%BC%89\"><span class=\"toc-text\">映射到一个委托（Action或者delgate）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#lua%E8%84%9A%E6%9C%AC%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%A0%E5%B0%84\"><span class=\"toc-text\">lua脚本多返回值映射</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84lua%E8%BF%94%E5%9B%9E%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">映射lua返回复杂类型的函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE\"><span class=\"toc-text\">使用建议</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lua%E8%AE%BF%E9%97%AEC-%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">Lua访问C#脚本</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#lua%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAC-%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">lua创建一个C#的对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#lua%E8%AE%BF%E9%97%AEC-%E7%9A%84%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">lua访问C#的静态属性、静态方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#lua%E8%AE%BF%E9%97%AEC-%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">lua访问C#成员属性、方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#lua%E8%AE%BF%E9%97%AE%E6%99%AE%E9%80%9A%E7%9A%84%E7%B1%BB\"><span class=\"toc-text\">lua访问普通的类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#lua%E8%AE%BF%E9%97%AE%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB\"><span class=\"toc-text\">lua访问继承的类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">访问复杂函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">访问重载方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">调用操作符</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E5%90%AB%E9%BB%98%E8%AE%A4%E5%80%BC%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">访问含默认值方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">访问可变参数方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84%E6%9E%9A%E4%B8%BE%E5%B9%B6%E8%AE%BF%E9%97%AE%E6%9E%9A%E4%B8%BE\"><span class=\"toc-text\">映射枚举并访问枚举</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Lua%E8%AE%BF%E9%97%AEC-%E5%A7%94%E6%89%98\"><span class=\"toc-text\">Lua访问C#委托</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Lua%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E4%BA%8B%E4%BB%B6-Event\"><span class=\"toc-text\">Lua访问类的事件(Event)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Lua%E8%AE%BF%E9%97%AE64%E4%BD%8D%E6%95%B4%E6%95%B0\"><span class=\"toc-text\">Lua访问64位整数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#C-%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E5%92%8Ctable%E7%9A%84%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">C#复杂类型和table的转换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Lua%E8%8E%B7%E5%8F%96C-%E7%9A%84%E7%B1%BB%E5%9E%8B-%E7%9B%B8%E5%BD%93%E4%BA%8EC-%E7%9A%84typeof\"><span class=\"toc-text\">Lua获取C#的类型(相当于C#的typeof)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Lua%E5%BC%BA%E8%BD%AC%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">Lua强转数据</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#XLua%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">XLua配置</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C++项目中添加调用Lua脚本","uid":"e7db23bc50608c8f5fa8074570c0d23f","slug":"zl/2016-01-01-217_C++项目中添加调用Lua脚本","date":"2024-04-03T03:47:33.092Z","updated":"2024-04-03T03:47:33.092Z","comments":true,"path":"api/articles/zl/2016-01-01-217_C++项目中添加调用Lua脚本.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;http://xtutu.me/#%E5%89%8D%E8%A8%80&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua Study","uid":"fe1195f4f5556419e838cea354cbb4a3","slug":"zl/2016-01-01-213_Lua Study","date":"2024-04-03T03:47:33.091Z","updated":"2024-04-03T03:47:33.091Z","comments":true,"path":"api/articles/zl/2016-01-01-213_Lua Study.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;本文并不会把Lua语言的所有内容都包含在内，只对个人学习过程中感觉比较重要的部分做一个记录，以便回顾。&lt;/p&gt; 类型学习语言首先要了解它提供的类型，Lua语言提供了如下几种。 nil boolean number string userdata f...","link":"","photos":[],"count_time":{"symbolsCount":877,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}