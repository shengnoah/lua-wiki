{"title":"cocos2dx lua注册事件详解","uid":"af9261daf33a3d2b8198b8c9a27ae883","slug":"zl/2016-01-01-426_cocos2dx lua注册事件详解","date":"2024-04-03T03:47:35.717Z","updated":"2024-04-03T03:47:35.718Z","comments":true,"path":"api/articles/zl/2016-01-01-426_cocos2dx lua注册事件详解.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>最近在学习cocos2dx lua的时候，遇到了一些关于事件注册的逻辑！</p>\n<p>结合用户实际操作和游戏的真实需求，关于事件在游戏中还是使用非常多的，所以特此记录一下</p>\n<blockquote>\n<p>事件(源自网络)</p>\n<blockquote>\n<p>事件是可以被控件识别的操作。如按下确定按钮，选择某个单选按钮或者复选框。每一种控件有自己可以识别的事件，如窗体的加载、单击、双击等事件，编辑框（文本框）的文本改变事件，等等。</p>\n</blockquote>\n</blockquote>\n<h6 id=\"事件是用户对窗口上各种组件的操作。\"><a href=\"#事件是用户对窗口上各种组件的操作。\" class=\"headerlink\" title=\"事件是用户对窗口上各种组件的操作。\"></a>事件是用户对窗口上各种组件的操作。</h6><ul>\n<li>事件有系统事件和用户事件。<ul>\n<li>1.系统事件由系统激发，如时间间隔24小时，银行储蓄的存款日期增加一天。</li>\n<li>2.用户事件由用户激发，如用户点击按钮，在文本框中显示特定的文本。事件驱动控件执行某项功能。</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；\"><a href=\"#触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；\" class=\"headerlink\" title=\"触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；\"></a>触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；</h6><blockquote>\n<p>注: 这里只针对用户事件！</p>\n</blockquote>\n<h4 id=\"cocos2dx中事件的类型\"><a href=\"#cocos2dx中事件的类型\" class=\"headerlink\" title=\"cocos2dx中事件的类型\"></a>cocos2dx中事件的类型</h4><ul>\n<li>registerScriptTouchHandler             注册触屏事件</li>\n<li>registerScriptTapHandler                  注册点击事件</li>\n<li>registerScriptHandler                         注册基本事件 包括 触屏 层的进入 退出 事件</li>\n<li>registerScriptKeypadHandler           注册键盘事件</li>\n<li>registerScriptAccelerateHandler      注册加速事件</li>\n</ul>\n<p>在3.x之前事件的注册可以直接使用这些方式来注册，</p>\n<ul>\n<li>事件监听器主要有：<ul>\n<li>触摸事件     : EventListenerTouchOneByOne、EventListenerTouchAllAtOnce</li>\n<li>鼠标响应事件 : EventListenerMouse</li>\n<li>键盘响应事件 : EventListenerKeyboard</li>\n<li>加速计事件   : EventListenerAcceleration</li>\n<li>自定义事件   : EventListenerCustom</li>\n<li>物理碰撞事件 : EventListenerPhysicsContact</li>\n<li>游戏手柄事件 : EventListenerController</li>\n</ul>\n</li>\n</ul>\n<p>而在3.x中由于加入了C++11的特性，而对事件的分发机制通过事件分发器EventDispatcher 来进行统一的管理。</p>\n<blockquote>\n<p>官方说明：触摸事件，键盘事件，加速器事件和自定义事件等所有事件都由 EventDispatcher 分发。 TouchDispatcher, KeypadDispatcher, KeyboardDispatcher, AccelerometerDispatcher 已经被移除。</p>\n</blockquote>\n<h3 id=\"【事件分发器】\"><a href=\"#【事件分发器】\" class=\"headerlink\" title=\"【事件分发器】\"></a>【事件分发器】</h3><p>事件分发器EventDispatcher，用于统一管理事件监听器的所有事件的分发。</p>\n<ul>\n<li><p>EventDispatcher 的特性主要有:</p>\n<ul>\n<li>事件的分发基于渲染顺序</li>\n<li>所有的事件都由 EventDispatcher 分发</li>\n<li>可以使用 EventDispatcher 来分发自定义事件</li>\n<li>可以注册一个 lambda 表达式作为回调函数</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"1、-eventDispatcher\"><a href=\"#1、-eventDispatcher\" class=\"headerlink\" title=\"1、_eventDispatcher\"></a>1、_eventDispatcher</h5><p>_eventDispatcher是Node的属性，通过Director::getInstance()-&gt;getEventDispatcher() 获得。</p>\n<ul>\n<li>_eventDispatcher的工作由三部分组成：<ul>\n<li>（1）事件分发器 ：EventDispatcher。</li>\n<li>（2）事件类型   ：EventTouch, EventKeyboard 等。</li>\n<li>（3）事件监听器 ：EventListenerTouch, EventListenerKeyboard 等。</li>\n</ul>\n</li>\n</ul>\n<p>监听器实现了各种触发后的逻辑，在适当时候由事件分发器分发事件类型，然后调用相应类型的监听器。</p>\n<h5 id=\"2、添加-删除监听器\"><a href=\"#2、添加-删除监听器\" class=\"headerlink\" title=\"2、添加/删除监听器\"></a>2、添加/删除监听器</h5><ul>\n<li><p>添加监听器：</p>\n<ul>\n<li>addEventListenerWithSceneGraphPriority ，</li>\n<li>addEventListenerWithFixedPriority 。</li>\n</ul>\n</li>\n<li><p>删除监听器：</p>\n<ul>\n<li>removeEventListener ，</li>\n<li>removeAllEventListeners 。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"3、主要函数\"><a href=\"#3、主要函数\" class=\"headerlink\" title=\"3、主要函数\"></a>3、主要函数</h5><p>包含监听器的添加、删除、暂停、恢复，优先级的设置，手动分发事件等。</p>\n<pre><code>class EventDispatcher : public Ref\n&#123;\n/**\n* 添加监听器\n*     - addEventListenerWithSceneGraphPriority\n*     - addEventListenerWithFixedPriority\n*     - addCustomEventListener\n*/\n//使用 场景图的优先级 为指定事件添加一个监听.\n//listener : 指定要监听的事件.\n//node     : 这个节点的绘制顺序是基于监听优先级.\n//优先级   : 0\nvoid addEventListenerWithSceneGraphPriority(EventListener* listener, Node* node);\n<p>//使用 一定的优先级 为指定事件添加一个监听.<br />\n//listener      : 指定要监听的事件.<br />\n//fixedPriority : 这个监听器的固定优先级.<br />\n//优先级        : fixedPriority。(但是不能为0，因为他是场景图的基本优先级)<br />\nvoid addEventListenerWithFixedPriority(EventListener* listener, int fixedPriority);</p>\n<p>//用户自定义监听器<br />\nEventListenerCustom* addCustomEventListener(const std::string &amp;eventName, const std::function&lt;void(EventCustom*)&gt;&amp; callback);</p>\n<p>/**</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>删除监听器</p>\n</li>\n<li class=\"lvl-2\">\n<pre><code>- removeEventListener\n</code></pre>\n</li>\n<li class=\"lvl-2\">\n<pre><code>- removeEventListenersForType\n</code></pre>\n</li>\n<li class=\"lvl-2\">\n<pre><code>- removeEventListenersForTarget\n</code></pre>\n</li>\n<li class=\"lvl-2\">\n<pre><code>- removeCustomEventListeners\n</code></pre>\n</li>\n<li class=\"lvl-2\">\n<pre><code>- removeAllEventListeners\n</code></pre>\n</li>\n</ul>\n<p><em>/<br />\n//删除指定监听器<br />\nvoid removeEventListener(EventListener</em> listener);</p>\n<p>//删除某类型对应的所有监听器<br />\n//EventListener::Type::<br />\n//  单点触摸 : TOUCH_ONE_BY_ONE<br />\n//  多点触摸 : TOUCH_ALL_AT_ONCE<br />\n//  键盘     : KEYBOARD<br />\n//  鼠标     : MOUSE<br />\n//  加速计   : ACCELERATION<br />\n//  自定义   : CUSTOM<br />\nvoid removeEventListenersForType(EventListener::Type listenerType);</p>\n<p>//删除绑定在节点target上的所有监听器<br />\nvoid removeEventListenersForTarget(Node* target, bool recursive = false);</p>\n<p>//删除名字为customEventName的所有自定义监听器<br />\nvoid removeCustomEventListeners(const std::string&amp; customEventName);</p>\n<p>//移除所有监听器<br />\nvoid removeAllEventListeners();</p>\n<p>/**</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>暂停、恢复在节点target上的所有监听器</p>\n</li>\n<li class=\"lvl-2\">\n<pre><code>- pauseEventListenersForTarget\n</code></pre>\n</li>\n<li class=\"lvl-2\">\n<pre><code>- resumeEventListenersForTarget\n</code></pre>\n</li>\n</ul>\n<p><em>/<br />\nvoid pauseEventListenersForTarget(Node</em> target, bool recursive = false);<br />\nvoid resumeEventListenersForTarget(Node* target, bool recursive = false);</p>\n<p>/**</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>其他</p>\n</li>\n<li class=\"lvl-2\">\n<pre><code>- setPriority\n</code></pre>\n</li>\n<li class=\"lvl-2\">\n<pre><code>- setEnabled\n</code></pre>\n</li>\n<li class=\"lvl-2\">\n<pre><code>- dispatchEvent\n</code></pre>\n</li>\n<li class=\"lvl-2\">\n<pre><code>- dispatchCustomEvent\n</code></pre>\n</li>\n</ul>\n<p><em>/<br />\n//设置某监听器的优先级<br />\nvoid setPriority(EventListener</em> listener, int fixedPriority);</p>\n<p>//启用事件分发器<br />\nvoid setEnabled(bool isEnabled);<br />\nbool isEnabled() const;</p>\n<p>//手动派发自定义事件<br />\nvoid dispatchEvent(Event* event);</p>\n<p>//给名字为eventName的自定义监听器, 绑定用户数据<br />\nvoid dispatchCustomEvent(const std::string &amp;eventName, void *optionalUserData = nullptr);<br />\n}<br />\n</code></pre><h5 id=\"4、关于事件监听器的优先权\"><a href=\"#4、关于事件监听器的优先权\" class=\"headerlink\" title=\"4、关于事件监听器的优先权\"></a>4、关于事件监听器的优先权</h5><p>通过 addEventListenerWithSceneGraphPriority 添加的监听器，优先权为0。<br/>通过 addEventListenerWithFixedPriority 添加的监听器，可以自定义优先权，但不能为0。</p></p>\n<ul>\n<li>优先级越低，越先响应事件。</li>\n<li>如果优先级相同，则上层的（z轴）先接收触摸事件。</li>\n</ul>\n<h5 id=\"5、使用步骤\"><a href=\"#5、使用步骤\" class=\"headerlink\" title=\"5、使用步骤\"></a>5、使用步骤</h5><ul>\n<li>（1）获取事件分发器：<ul>\n<li>dispatcher = Director::getInstance()-&gt;getEventDispatcher();</li>\n</ul>\n</li>\n<li>（2）创建监听器：<ul>\n<li>auto listener = EventListenerTouchOneByOne::create();</li>\n</ul>\n</li>\n<li>（3）绑定响应事件函数：<ul>\n<li>listener-&gt;onTouchBegan = CC_CALLBACK_2(callback, this);</li>\n</ul>\n</li>\n<li>（4）将监听器添加到事件分发器dispatcher中：<ul>\n<li>dispatcher-&gt;addEventListenerWithSceneGraphPriority(Listener, this);</li>\n</ul>\n</li>\n<li>（5）编写回调响应函数：<ul>\n<li>bool callback(Touch<em> touch, Event</em> event) { … }</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实战案例\"><a href=\"#实战案例\" class=\"headerlink\" title=\"实战案例\"></a>实战案例</h3><p>先来看看项目用用到的一些简单时间的操作， 两种方式创建使用</p>\n<h5 id=\"触摸事件\"><a href=\"#触摸事件\" class=\"headerlink\" title=\"触摸事件\"></a>触摸事件</h5><p>根据用户手机在屏幕触摸的位置，对场景或者场景中的精灵，控件的做一些处理，这种类型偏向于触摸屏的设备。</p>\n<pre><code>local function onTouchBegan(touch, event)\n<p>local location = touch:getLocation()<br />\nlocal visiableSize = cc.Director:getInstance():getVisibleSize()<br />\nlocal origin = cc.Director:getInstance():getVisibleOrigin()</p>\n<p>local finalX = location.x - (origin.x + visiableSize.width/2)<br />\nlocal finalY = location.y - (origin.y + visiableSize.height/2)</p>\n<p>finalX, finalY 根据实际屏幕计算触摸点</p>\n<p>end</p>\n<p>local listener = cc.EventListenerTouchOneByOne:create()<br />\nlistener:registerScriptHandler(onTouchBegan, cc.Handler.EVENT_TOUCH_BEGAN)<br />\nlocal eventDiapatcher = self:getEventDispatcher()<br />\neventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self)<br />\n</code></pre><h5 id=\"键盘事件\"><a href=\"#键盘事件\" class=\"headerlink\" title=\"键盘事件\"></a>键盘事件</h5><p>这里是coco2dx 定义的一套键盘字节码，每一个键盘上的键都对应一个数字，我们可以根据用户按键对精灵和界面做控制，这种偏向于桌面版的游戏！</p></p>\n<h6 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h6><pre><code>-- 键盘监听器\nlocal listener = cc.EventListenerKeyboard:create()\n<p>listener:registerScriptHandler(function(keyCode, event)<br />\nif self.tank ~= nil then<br />\n– w<br />\nif keyCode == 146 then<br />\nself.tank:MoveBegin(&quot;up&quot;)<br />\n– s<br />\nelseif keyCode == 142 then<br />\nself.tank:MoveBegin(&quot;down&quot;)<br />\n– a<br />\nelseif keyCode == 124 then<br />\nself.tank:MoveBegin(&quot;left&quot;)<br />\n– d<br />\nelseif keyCode == 127 then<br />\nself.tank:MoveBegin(&quot;right&quot;)<br />\nend<br />\nend<br />\nend, cc.Handler.EVENT_KEYBOARD_PRESSED) — cc.Handler.EVENT_KEYBOARD_RELEASED)<br />\nlocal eventDiapatcher = self:getEventDispatcher()<br />\neventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self)<br />\n</code></pre><h6 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h6><pre><code>local function keyboardPressed(keyCode, event)<br />\n– up<br />\nif keyCode == 28 then<br />\nself:MoveCursor(0, 1)<br />\n– down<br />\nelseif keyCode == 29 then<br />\nself:MoveCursor(0, -1)<br />\n– left<br />\nelseif keyCode == 26 then<br />\nself:MoveCursor(-1, 0)<br />\n– right<br />\nelseif keyCode == 27 then<br />\nself:MoveCursor(1, 0)<br />\n– page up<br />\nelseif keyCode == 38 then<br />\nself:SwitchCursor(-1)<br />\n– page down<br />\nelseif keyCode == 44 then<br />\nself:SwitchCursor(1)<br />\n– enter<br />\nelseif keyCode == 38 then<br />\nself:Place()<br />\n– delete<br />\nelseif keyCode == 44 then<br />\nself:Delete()<br />\n– F3<br />\nelseif keyCode == 49 then<br />\nself:Load()<br />\n– F4<br />\nelseif keyCode == 50 then<br />\nself:Save()<br />\nend<br />\nprint(&quot;key board ??? keyCode&quot;, keyCode)<br />\nend</p>\n<p>– 键盘监听器<br />\nlocal listener = cc.EventListenerKeyboard:create()<br />\nlistener:registerScriptHandler(keyboardPressed, cc.Handler.EVENT_KEYBOARD_PRESSED)<br />\nlocal eventDiapatcher = self:getEventDispatcher()<br />\neventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self)<br />\n</code></pre><p>这里主要说一下codeKey，codeKey是cocos2dx定义的一套键盘的代码，每个平台几乎是通用的</p></p>\n<h3 id=\"【触摸事件】\"><a href=\"#【触摸事件】\" class=\"headerlink\" title=\"【触摸事件】\"></a>【触摸事件】</h3><h5 id=\"1、单点触摸：EventListenerTouchOneByOne\"><a href=\"#1、单点触摸：EventListenerTouchOneByOne\" class=\"headerlink\" title=\"1、单点触摸：EventListenerTouchOneByOne\"></a>1、单点触摸：EventListenerTouchOneByOne</h5><p>单点触摸监听器相关：</p>\n<pre><code>static EventListenerTouchOneByOne* create();\n<p>std::function&lt;bool(Touch*, Event*)&gt; onTouchBegan; //只有这个返回值为 bool<br />\nstd::function&lt;void(Touch*, Event*)&gt; onTouchMoved;<br />\nstd::function&lt;void(Touch*, Event*)&gt; onTouchEnded;<br />\nstd::function&lt;void(Touch*, Event*)&gt; onTouchCancelled;<br />\n</code></pre><p>使用举例：</p></p>\n<pre><code>//获取事件分发器\nauto dispatcher = Director::getInstance()-&gt;getEventDispatcher();\n\n//创建单点触摸监听器 EventListenerTouchOneByOne\nauto touchListener = EventListenerTouchOneByOne::create();\n\n//单点触摸响应事件绑定\ntouchListener-&gt;onTouchBegan     = CC_CALLBACK_2(HelloWorld::onTouchBegan, this);\ntouchListener-&gt;onTouchMoved     = CC_CALLBACK_2(HelloWorld::onTouchMoved, this);\ntouchListener-&gt;onTouchEnded     = CC_CALLBACK_2(HelloWorld::onTouchEnded, this);\ntouchListener-&gt;onTouchCancelled = CC_CALLBACK_2(HelloWorld::onTouchCancelled, this);\n\n//在事件分发器中，添加触摸监听器，事件响应委托给 this 处理\ndispatcher-&gt;addEventListenerWithSceneGraphPriority(touchListener, this);\n\n\n//单点触摸事件响应函数\nbool onTouchBegan(Touch *touch, Event *unused_event)     &#123; CCLOG(&#34;began&#34;); return true; &#125;\nvoid onTouchMoved(Touch *touch, Event *unused_event)     &#123; CCLOG(&#34;moved&#34;); &#125;\nvoid onTouchEnded(Touch *touch, Event *unused_event)     &#123; CCLOG(&#34;ended&#34;); &#125;\nvoid onTouchCancelled(Touch *touch, Event *unused_event) &#123; CCLOG(&#34;cancelled&#34;); &#125;\n</code></pre><h5 id=\"2、多点触摸：EventListenerTouchAllAtOnce\"><a href=\"#2、多点触摸：EventListenerTouchAllAtOnce\" class=\"headerlink\" title=\"2、多点触摸：EventListenerTouchAllAtOnce\"></a>2、多点触摸：EventListenerTouchAllAtOnce</h5><p>多点触摸监听器相关：</p>\n<pre><code>static EventListenerTouchAllAtOnce* create();\n\nstd::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesBegan;\nstd::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesMoved;\nstd::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesEnded;\nstd::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesCancelled;\n</code></pre><p>使用举例：</p>\n<pre><code>//获取事件分发器\nauto dispatcher = Director::getInstance()-&gt;getEventDispatcher();\n\n//创建多点触摸监听器 EventListenerTouchAllAtOnce\nauto touchesListener = EventListenerTouchAllAtOnce::create();\n\n//多点触摸响应事件绑定\ntouchesListener-&gt;onTouchesBegan     = CC_CALLBACK_2(HelloWorld::onTouchesBegan, this);\ntouchesListener-&gt;onTouchesMoved     = CC_CALLBACK_2(HelloWorld::onTouchesMoved, this);\ntouchesListener-&gt;onTouchesEnded     = CC_CALLBACK_2(HelloWorld::onTouchesEnded, this);\ntouchesListener-&gt;onTouchesCancelled = CC_CALLBACK_2(HelloWorld::onTouchesCancelled, this);\n\n//在事件分发器中，添加触摸监听器，事件响应委托给 this 处理\ndispatcher-&gt;addEventListenerWithSceneGraphPriority(touchesListener, this);\n\n//多点触摸事件响应函数\nvoid onTouchesBegan(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event)    &#123; CCLOG(&#34;began&#34;); &#125;\nvoid onTouchesMoved(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event)    &#123; CCLOG(&#34;moved&#34;); &#125;\nvoid onTouchesEnded(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event)    &#123; CCLOG(&#34;ended&#34;); &#125;\nvoid onTouchesCancelled(const std::vector&lt;Touch*&gt;&amp;touches, Event *unused_event) &#123; CCLOG(&#34;cancelled&#34;); &#125;\n</code></pre><h3 id=\"【鼠标事件】\"><a href=\"#【鼠标事件】\" class=\"headerlink\" title=\"【鼠标事件】\"></a>【鼠标事件】</h3><p>EventListenerMouse，主要用于监听鼠标的点击、松开、移动、滚轮的事件。</p>\n<p>鼠标事件监听器相关：</p>\n<pre><code>static EventListenerMouse* create();\n<p>std::function&lt;void(Event* event)&gt; onMouseDown;     //按下鼠标, 单击鼠标<br />\nstd::function&lt;void(Event* event)&gt; onMouseUp;   //松开鼠标, 按下的状态下松开<br />\nstd::function&lt;void(Event* event)&gt; onMouseMove;  //移动鼠标, 在屏幕中移动<br />\nstd::function&lt;void(Event* event)&gt; onMouseScroll;//滚动鼠标, 滚动鼠标的滚轮<br />\n</code></pre><p>使用举例：</p></p>\n<pre><code>//获取事件分发器\nauto dispatcher = Director::getInstance()-&gt;getEventDispatcher();\n\n//创建鼠标事件监听器 EventListenerMouse\nEventListenerMouse* mouseListenter = EventListenerMouse::create();\n\n//鼠标事件响应函数\nmouseListenter-&gt;onMouseDown   = CC_CALLBACK_1(HelloWorld::onMouseDown,   this);\nmouseListenter-&gt;onMouseUp     = CC_CALLBACK_1(HelloWorld::onMouseUp,     this);\nmouseListenter-&gt;onMouseMove   = CC_CALLBACK_1(HelloWorld::onMouseMove,   this);\nmouseListenter-&gt;onMouseScroll = CC_CALLBACK_1(HelloWorld::onMouseScroll, this);\n\n//添加鼠标事件监听器，事件响应处理委托给this\ndispatcher-&gt;addEventListenerWithSceneGraphPriority(mouseListenter, this);\n\n//事件响应函数\nvoid onMouseDown(Event* event)   &#123; CCLOG(&#34;Down&#34;); &#125;\nvoid onMouseUp(Event* event)     &#123; CCLOG(&#34;UP&#34;); &#125;\nvoid onMouseMove(Event* event)   &#123; CCLOG(&#34;MOVE&#34;); &#125;\nvoid onMouseScroll(Event* event) &#123; CCLOG(&#34;Scroll&#34;); &#125;\n</code></pre><h3 id=\"【键盘事件】\"><a href=\"#【键盘事件】\" class=\"headerlink\" title=\"【键盘事件】\"></a>【键盘事件】</h3><p>EventListenerKeyboard，主要用于监听键盘某个键的按下、松开的事件。</p>\n<p>键盘事件监听器相关：</p>\n<pre><code>static EventListenerKeyboard* create();\n<p>std::function&lt;void(EventKeyboard::KeyCode, Event*)&gt; onKeyPressed;  //按下某键<br />\nstd::function&lt;void(EventKeyboard::KeyCode, Event*)&gt; onKeyReleased; //松开某键</p>\n<p>//键盘按键枚举类型 EventKeyboard::KeyCode<br />\n//KeyCode的值对应的不是键盘的键值、也不是ASCII码，只是纯粹的枚举类型<br />\n//如:<br />\n//  EventKeyboard::KeyCode::KEY_A<br />\n//  EventKeyboard::KeyCode::KEY_1<br />\n//  EventKeyboard::KeyCode::KEY_F1<br />\n//  EventKeyboard::KeyCode::KEY_SPACE<br />\n//  EventKeyboard::KeyCode::KEY_ALT<br />\n//  EventKeyboard::KeyCode::KEY_SHIFT<br />\n</code></pre><p>使用举例：</p></p>\n<pre><code>//\n//获取事件分发器\nauto dispatcher = Director::getInstance()-&gt;getEventDispatcher();\n\n//创建键盘按键事件监听器\nEventListenerKeyboard* keyboardListener = EventListenerKeyboard::create();\n\n//绑定事件响应函数\nkeyboardListener-&gt;onKeyPressed = CC_CALLBACK_2(HelloWorld::onKeyPressed, this);\nkeyboardListener-&gt;onKeyReleased = CC_CALLBACK_2(HelloWorld::onKeyReleased, this);\n\n//添加监听器\ndispatcher-&gt;addEventListenerWithSceneGraphPriority(keyboardListener, this);\n\n\n//事件响应函数\nvoid onKeyPressed(EventKeyboard::KeyCode keyCode, Event* event) &#123;\nif (EventKeyboard::KeyCode::KEY_J == keyCode) &#123;\nCCLOG(&#34;Pressed: J&#34;);\n&#125;\n&#125;\nvoid onKeyReleased(EventKeyboard::KeyCode keyCode, Event* event) &#123;\nif (EventKeyboard::KeyCode::KEY_SPACE == keyCode) &#123;\nCCLOG(&#34;Released: SPACE&#34;);\n&#125;\n&#125;\n</code></pre><h3 id=\"【加速计事件】\"><a href=\"#【加速计事件】\" class=\"headerlink\" title=\"【加速计事件】\"></a>【加速计事件】</h3><p>EventListenerAcceleration，主要用于监听移动设备的所受重力方向感应事件。</p>\n<p>重力感应来自移动设备的加速计，通常支持 (X, Y, Z) 三个方向的加速度感应，所以又称为三向加速计。在实际应用中，可以根据3个方向的力度大小来计算手机倾斜的角度或方向。</p>\n<h5 id=\"1、加速计信息类Acceleration\"><a href=\"#1、加速计信息类Acceleration\" class=\"headerlink\" title=\"1、加速计信息类Acceleration\"></a>1、加速计信息类Acceleration</h5><p>该类中每个方向的加速度，大小都为一个重力加速度大小。</p>\n<pre><code>//加速计信息\nclass Acceleration\n&#123;\ndouble x; double y; double z;\n&#125;;\n</code></pre><h5 id=\"2、开启加速计感应\"><a href=\"#2、开启加速计感应\" class=\"headerlink\" title=\"2、开启加速计感应\"></a>2、开启加速计感应</h5><p>在使用加速计事件监听器之前，需要先启用此硬件设备：</p>\n<pre><code>Device::setAccelerometerEnabled(true);\n</code></pre><h5 id=\"3、加速计监听器相关\"><a href=\"#3、加速计监听器相关\" class=\"headerlink\" title=\"3、加速计监听器相关\"></a>3、加速计监听器相关</h5><pre><code>static EventListenerAcceleration* create(const std::function&lt;void(Acceleration*, Event*)&gt;&amp; callback);\n<p>std::function&lt;void(Acceleration*, Event*)&gt; onAccelerationEvent;<br />\n</code></pre><h5 id=\"4、使用举例\"><a href=\"#4、使用举例\" class=\"headerlink\" title=\"4、使用举例\"></a>4、使用举例</h5><pre><code>//标签: 显示加速计信息<br />\nlabel = Label::createWithTTF(&quot;no used&quot;, &quot;Marker Felt.ttf&quot;, 12);<br />\nlabel-&gt;setPosition(visibleSize / 2);<br />\nthis-&gt;addChild(label);</p>\n<p>//小球: 可视化加速计<br />\nball = Sprite::create(&quot;ball.png&quot;);<br />\nball-&gt;setPosition(visibleSize / 2);<br />\nthis-&gt;addChild(ball);</p>\n<p>//获取事件分发器<br />\nauto dispatcher = Director::getInstance()-&gt;getEventDispatcher();</p>\n<p>//需要开启移动设备的加速计<br />\nDevice::setAccelerometerEnabled(true);</p>\n<p>//创建加速计事件监听器<br />\nauto accelerationListener = EventListenerAcceleration::create(CC_CALLBACK_2(HelloWorld::onAccelerationEvent, this));</p>\n<p>//添加加速计监听器<br />\ndispatcher-&gt;addEventListenerWithSceneGraphPriority(accelerationListener, this);</p>\n<p>//事件响应函数<br />\nvoid HelloWorld::onAccelerationEvent(Acceleration* acceleration, Event* event)<br />\n&#123;<br />\nchar s[100];<br />\nsprintf(s, &quot;X: %f; Y: %f; Z:%f; &quot;, acceleration-&gt;x, acceleration-&gt;y, acceleration-&gt;z);<br />\nlabel-&gt;setString(s);</p>\n<p>//改变小球ball的位置<br />\nfloat x = ball-&gt;getPositionX() + acceleration-&gt;x * 10;<br />\nfloat y = ball-&gt;getPositionY() + acceleration-&gt;y * 10;<br />\nVec2 pos = Vec2(x, y);<br />\npos.clamp(ball-&gt;getContentSize() / 2, Vec2(288, 512) - ball-&gt;getContentSize() / 2);<br />\nball-&gt;setPosition(pos); //设置位置<br />\n&#125;<br />\n</code></pre><h3 id=\"【自定义事件】\"><a href=\"#【自定义事件】\" class=\"headerlink\" title=\"【自定义事件】\"></a>【自定义事件】</h3><p>以上是系统自带的事件类型，事件由系统内部自动触发，如 触摸屏幕，键盘响应等。</p></p>\n<p>EventListenerCustom 自定义事件，它不是由系统自动触发，而是人为的干涉。</p>\n<p>它的出现，使得2.x中的 观察者模式 NotificationCenter（订阅发布消息） 被无情的遗弃了。</p>\n<blockquote>\n<p>在 3.x 中，使用EventListenerCustom来实现消息的订阅与发布。</p>\n</blockquote>\n<p>学习它之前，最好了解一下 NotificationCenter 这个类的用法。</p>\n<blockquote>\n<p>NotificationCenter 的用法参见：<a href=\"http://shahdza.blog.51cto.com/2410787/1611575\" target=\"_blank\" rel=\"noopener noreferrer\">http://shahdza.blog.51cto.com/2410787/1611575</a></p>\n</blockquote>\n<h5 id=\"1、创建自定义监听器\"><a href=\"#1、创建自定义监听器\" class=\"headerlink\" title=\"1、创建自定义监听器\"></a>1、创建自定义监听器</h5><p>该监听器，就相当于是订阅消息。即与NotificationCenter的 addObserver 类似。</p>\n<pre><code>//eventName : 监听器名字，即消息的名称\n//callback  : 监听器函数，即消息的回调函数\nstatic EventListenerCustom* create(const std::string&amp; eventName, const std::function&lt;void(EventCustom*)&gt;&amp; callback);\n</code></pre><h5 id=\"2、分发自定义事件\"><a href=\"#2、分发自定义事件\" class=\"headerlink\" title=\"2、分发自定义事件\"></a>2、分发自定义事件</h5><p>自定义的事件监听器，需要通过手动的方式，将事件分发出去。</p>\n<blockquote>\n<p>通过 EventCustom(string eventName);       来设置需要发布消息的数据信息，eventName为消息名称。</p>\n</blockquote>\n<p>其中EventCustom可以通过setUserData来绑定想要传递的消息数据。</p>\n<blockquote>\n<p>通过 dispatcher-&gt;dispatchEvent(&amp;event); 来手动将事件分发出去。即发布消息。</p>\n</blockquote>\n<p>这与NotificationCenter的 postNotification 类似。</p>\n<pre><code>EventCustom event(&#34;custom_event&#34;);\nevent-&gt;setUserData((void*)123); // 绑定消息传递的数据，可以为任意类型void。\ndispatcher-&gt;dispatchEvent(&amp;event); // 发布名称为&#34;custom_event&#34;的消息。\n</code></pre><h5 id=\"3、使用举例\"><a href=\"#3、使用举例\" class=\"headerlink\" title=\"3、使用举例\"></a>3、使用举例</h5><pre><code>//获取事件分发器\nauto dispatcher = Director::getInstance()-&gt;getEventDispatcher();\n<p>//创建自定义事件监听器<br />\n//监听器名字  : &quot;custom_event&quot;<br />\n//事件响应函数: HelloWorld::onCustomEvent<br />\nauto customListener = EventListenerCustom::create(&quot;custom_event&quot;, CC_CALLBACK_1(HelloWorld::onCustomEvent, this));</p>\n<p>//添加自定义事件监听器，优先权为1<br />\ndispatcher-&gt;addEventListenerWithFixedPriority(customListener, 1);</p>\n<p>//手动分发监听器的事件，通过dispatchEvent发布名称为custom_event的消息。<br />\nEventCustom event = EventCustom(&quot;custom_event&quot;);<br />\nevent-&gt;setUserData((void*)123); // 绑定消息传递的数据，可以为任意类型void。<br />\ndispatcher-&gt;dispatchEvent(&amp;event);</p>\n<p>//消息事件回调函数<br />\nvoid HelloWorld::onCustomEvent(EventCustom* event)<br />\n&#123;<br />\n// 获取消息传递的数据<br />\nint* data = (int*)event-&gt;getUserData()<br />\nCCLOG(&quot;onCustomEvent data = %d&quot;, data);<br />\n&#125;<br />\n</code></pre><h5 id=\"4、说明\"><a href=\"#4、说明\" class=\"headerlink\" title=\"4、说明\"></a>4、说明</h5><blockquote></p>\n<p>每个自定义的事件监听器，都有一个监听器名字eventName。即为订阅的消息名称。</p>\n</blockquote>\n<blockquote>\n<p>需要通过 dispatcher-&gt;dispatchEvent(&amp;event); 来手动将事件分发出去。即为发布消息。</p>\n</blockquote>\n<blockquote>\n<p>可以通过 dispatcher-&gt;dispatchCustomEvent(,); 来给自定义事件监听器绑定一个用户数据。</p>\n</blockquote>","text":"最近在学习cocos2dx lua的时候，遇到了一些关于事件注册的逻辑！ 结合用户实际操作和游戏的真实需求，关于事件在游戏中还是使用非常多的，所以特此记录一下 事件(源自网络) 事件是可以被控件识别的操作。如按下确定按钮，选择某个单选按钮或者复选框。每一种控件有自己可以识别的事件...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E6%98%AF%E7%94%A8%E6%88%B7%E5%AF%B9%E7%AA%97%E5%8F%A3%E4%B8%8A%E5%90%84%E7%A7%8D%E7%BB%84%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82\"><span class=\"toc-text\">事件是用户对窗口上各种组件的操作。</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%A7%B0%E4%B8%BA%E4%BA%8B%E4%BB%B6%E5%8F%91%E9%80%81%E8%80%85%EF%BC%9B%E6%8E%A5%E6%94%B6%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%A7%B0%E4%B8%BA%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%97%E8%80%85%EF%BC%9B\"><span class=\"toc-text\">触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cocos2dx%E4%B8%AD%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">cocos2dx中事件的类型</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%90%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%99%A8%E3%80%91\"><span class=\"toc-text\">【事件分发器】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1%E3%80%81-eventDispatcher\"><span class=\"toc-text\">1、_eventDispatcher</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4%E7%9B%91%E5%90%AC%E5%99%A8\"><span class=\"toc-text\">2、添加&#x2F;删除监听器</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3%E3%80%81%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3、主要函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%85%B3%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E4%BC%98%E5%85%88%E6%9D%83\"><span class=\"toc-text\">4、关于事件监听器的优先权</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5%E3%80%81%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">5、使用步骤</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">实战案例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">触摸事件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">键盘事件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80\"><span class=\"toc-text\">方法一</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%BA%8C\"><span class=\"toc-text\">方法二</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%90%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E3%80%91\"><span class=\"toc-text\">【触摸事件】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%8D%95%E7%82%B9%E8%A7%A6%E6%91%B8%EF%BC%9AEventListenerTouchOneByOne\"><span class=\"toc-text\">1、单点触摸：EventListenerTouchOneByOne</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%91%B8%EF%BC%9AEventListenerTouchAllAtOnce\"><span class=\"toc-text\">2、多点触摸：EventListenerTouchAllAtOnce</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%90%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E3%80%91\"><span class=\"toc-text\">【鼠标事件】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%90%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E3%80%91\"><span class=\"toc-text\">【键盘事件】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%90%E5%8A%A0%E9%80%9F%E8%AE%A1%E4%BA%8B%E4%BB%B6%E3%80%91\"><span class=\"toc-text\">【加速计事件】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%8A%A0%E9%80%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E7%B1%BBAcceleration\"><span class=\"toc-text\">1、加速计信息类Acceleration</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%BC%80%E5%90%AF%E5%8A%A0%E9%80%9F%E8%AE%A1%E6%84%9F%E5%BA%94\"><span class=\"toc-text\">2、开启加速计感应</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%8A%A0%E9%80%9F%E8%AE%A1%E7%9B%91%E5%90%AC%E5%99%A8%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">3、加速计监听器相关</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4%E3%80%81%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B\"><span class=\"toc-text\">4、使用举例</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%90%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E3%80%91\"><span class=\"toc-text\">【自定义事件】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E5%90%AC%E5%99%A8\"><span class=\"toc-text\">1、创建自定义监听器</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%88%86%E5%8F%91%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">2、分发自定义事件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3%E3%80%81%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B\"><span class=\"toc-text\">3、使用举例</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4%E3%80%81%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">4、说明</span></a>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua学习笔记（四）","uid":"9f7e83ce19d0f00693e9a104549dd317","slug":"zl/2016-01-01-430_lua学习笔记（四）","date":"2024-04-03T03:47:35.718Z","updated":"2024-04-03T03:47:35.719Z","comments":true,"path":"api/articles/zl/2016-01-01-430_lua学习笔记（四）.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua数组一维数组123456789101112131415161718192021array={&#34;Lua&#34;,&#34;Java&#34;,&#34;C++&#34;}for i=0,2 do print(array[i])end输出结果：nilLuaJava结果...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Unity Excel导表工具，导成Lua，支持嵌套结构 木之子南","uid":"637f0a8ba3b17b68093f59de919ea387","slug":"zl/2016-01-01-424_Unity Excel导表工具，导成Lua，支持嵌套结构 木之子南","date":"2024-04-03T03:47:35.713Z","updated":"2024-04-03T03:47:35.713Z","comments":true,"path":"api/articles/zl/2016-01-01-424_Unity Excel导表工具，导成Lua，支持嵌套结构 木之子南.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"为什么要使用导表工具？ 几乎所有游戏公司数据由策划来配置，程序负责逻辑，策划看不懂代码，excel是可以相对具象的让策划了解一个模块的数据配置，起到了策划和程序之间的桥梁作用，也可以方便策划对数据的把控。 根据各个公司各个项目的不同，导表工具的输出形式不同，输出形式有：json，...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}