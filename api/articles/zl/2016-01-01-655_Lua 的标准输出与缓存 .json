{"title":"Lua 的标准输出与缓存","uid":"eb6769635061336dbbe2c0540f762f81","slug":"zl/2016-01-01-655_Lua 的标准输出与缓存 ","date":"2024-04-03T03:47:35.877Z","updated":"2024-04-03T03:47:35.877Z","comments":true,"path":"api/articles/zl/2016-01-01-655_Lua 的标准输出与缓存 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>最近我遇到了个奇怪的问题，我的一个Lua脚本需要通过shell的重定向将输出追加到一个日志文件中。但是那个Lua脚本的输出在日志文件里看来却不是实时的，输出的文本直到脚本结束时才能看到。</p>\n<p>在shell下运行这个程序，是可以看到实时输出的：</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">-- buffer_test.lua</span>\n<span class=\"kd\">local</span> <span class=\"n\">socket</span> <span class=\"o\">=</span> <span class=\"nb\">require</span> <span class=\"s2\">&#34;socket&#34;</span>\n<p><span class=\"kd\">local</span> <span class=\"n\">const</span> <span class=\"o\">=</span> <span class=\"mi\">100</span></p>\n<p><span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">const</span><span class=\"p\">,</span> <span class=\"mi\">1</span> <span class=\"k\">do</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span><br />\n<span class=\"n\">socket</span><span class=\"p\">.</span><span class=\"n\">select</span><span class=\"p\">(</span><span class=\"kc\">nil</span><span class=\"p\">,</span> <span class=\"kc\">nil</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span><br />\n<span class=\"k\">end</span><br />\n</code></pre></div></div></p>\n<p>但是当通过重定向时，只有脚本结束后才能看到文件：</p>\n<div class=\"language-sh highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># lua buffer_test.lua &gt;&gt;log.txt 2&gt;&amp;1 &amp;</span>\n<span class=\"c\"># tail -f log.txt</span>\n</code></pre></div></div>\n<p>看来当Lua的标准输出stdout连接的是终端时，采用了行缓存模式，而重定向到文件时则变成了完全缓存。翻遍了Lua的官方文档也没有找到这样的说明。但是在查看stdio的手册页时发现了下面的一段话：</p>\n<blockquote>\n  <p>The stdio library is a part of the library libc and routines are auto-matically loaded as needed by the compilers cc(1) and pc(1).\n<br/><br/>\nAt program startup, three text streams are predefined and need not be opened explicitly — standard input (for reading conventional input), — standard output (for writing conventional input), and standard error (for writing diagnostic output). These streams are abbreviated stdin,stdout and stderr. <span style=\"background-color: #FFFB00;\">When opened, the standard error stream is not fully buffered; the standard input and output streams are fully buffered if and only if the streams do not to refer to an interactive device.</span>\n<br/><br/>\nOutput streams that refer to terminal devices are always line buffered by default;</p>\n</blockquote>\n<p>原来stdio都是由libc提供，而我在<code class=\"highlighter-rouge\">ldd lua</code>时发现Lua确实也依赖于libc。这下就可以解释了：Lua在连接是终端的时候采用的是行缓存，而连接的是非活跃的设备时是采用的是完全缓存。</p>\n<p>但是假如我们中途终止脚本，查看日志：</p>\n<div class=\"language-sh highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># nl log.txt</span>\n 1\tlua: io.lua:9: interrupted!\n 2\tstack traceback:\n 3\t\t<span class=\"o\">[</span>C]: <span class=\"k\">in function</span> <span class=\"s1\">&#39;select&#39;</span>\n 4\t\tio.lua:9: <span class=\"k\">in </span>main chunk\n 5\t\t<span class=\"o\">[</span>C]: ?\n 6\t1\n 7\t2\n 8\t3\n</code></pre></div></div>\n<p>可以发现异常的日志难道不应该在最后面吗？其实上面的引用已经帮我们回答了：stderr并不是完全缓存，当发生异常时，stderr首先被写入日志，接着缓存区的stdout才会被刷入文件。</p>\n<p><strong>回顾这个问题，给我们留下的经验是Lua的很多库的实现原理其实在libc与系统调用那儿，不要只把目光局限在Lua的文档上。其实在其他的语言中，我估计也差不多。我们在查找问题的时候，一定要跳出自己的固有思维，有时候自己非常有把握的知识恰恰是不准确的。</strong></p>\n<pre><code>            &lt;hr style=&quot;visibility: hidden;&quot;/&gt;\n</code></pre>\n","text":"最近我遇到了个奇怪的问题，我的一个Lua脚本需要通过shell的重定向将输出追加到一个日志文件中。但是那个Lua脚本的输出在日志文件里看来却不是实时的，输出的文本直到脚本结束时才能看到。 在shell下运行这个程序，是可以看到实时输出的： -- buffer_test.lua l...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Redis实现分布式锁Lua脚本","uid":"856aae23dd974ad10df3608af21dd73a","slug":"zl/2016-01-01-657_Redis实现分布式锁Lua脚本","date":"2024-04-03T03:47:35.878Z","updated":"2024-04-03T03:47:35.879Z","comments":true,"path":"api/articles/zl/2016-01-01-657_Redis实现分布式锁Lua脚本.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"简单锁采用键值对存储，键是锁的标识，值是全局唯一值（如uuid）。 获取锁1234567891011121314local key = KEYS[1] -- 锁标识local value = ARGV[1] -- 全局唯一值local ttl = tonumber(ARGV[2]...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"150. Evaluate Reverse Polish Notation","uid":"a3c66f1145fcdbb9f5cecca2e489dca0","slug":"zl/2016-01-01-656_150. Evaluate Reverse Polish Notation","date":"2024-04-03T03:47:35.877Z","updated":"2024-04-03T03:47:35.878Z","comments":true,"path":"api/articles/zl/2016-01-01-656_150. Evaluate Reverse Polish Notation.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"每日一题 2019 - 05 - 12 题目：Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each opera...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}