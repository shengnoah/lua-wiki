{"title":"Lua和C#交互","uid":"53e30d434ce1eee1be8eac653667cc03","slug":"zl/2016-01-01-230_Lua和C#交互","date":"2024-04-03T03:47:33.100Z","updated":"2024-04-03T03:47:33.101Z","comments":true,"path":"api/articles/zl/2016-01-01-230_Lua和C#交互.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>    &lt;p&gt;项目中一直使用tolua框架，底层使用C#开发，逻辑使用lua开发。借助tolua的源码，研究一下lua与C#是如何互相调用的，然后自己写了个简单的demo作为记录。&lt;/p&gt;\n</code></pre>\n<p>Demo里没有拿lua的源码编译，而是直接使用lua的静态库，将lua库中的方法封装成为动态库dll给C#使用。涉及到两个工程：</p>\n<ul>\n<li><p>首先是c++的dll工程，包含了lua库的一些方法（此处仅为演示，所以手动包装了一些用到的），暴露给C#调用；</p>\n</li>\n<li><p>其次是c#的工程，引用前一步的dll库，并且通过其接口来调用lua库的函数以实现交互。</p>\n</li>\n</ul>\n<p>涉及到的源码托管在<a href=\"https://github.com/aillieo/lua-cpp-cs-interaction\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a>。</p>\n<h2 id=\"lua-cs\"><a href=\"https://aillieo.cn/#lua-cs\" class=\"headerlink\" title=\"lua-cs\"></a>lua-cs</h2><p>在lua中调用C#基本步骤如下（仅供演示用，其中省略掉了lua栈数据及类型检查等步骤）：</p>\n<ol>\n<li><p>首先定义委托类型<code>LuaCSFunction</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[UnmanagedFunctionPointer(CallingConvention.Cdecl)]</span><br><span class=\"line\">public delegate int LuaCSFunction(IntPtr luaState);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>根据C#函数（<code>CSFunc</code>）得到对应的wrap函数（<code>CSFuncWrap</code>）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int CSFunc(int a, int b)</span><br><span class=\"line\">{</span><br><span class=\"line\">    Console.WriteLine(\"[CS] this is CSFunc with args a = \" + a + \" and b = \" + b);</span><br><span class=\"line\">    int ret = 10 * a + b;</span><br><span class=\"line\">    Console.WriteLine(\"[CS] ret will be \" + ret);</span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">static int CSFuncWrap(IntPtr L)</span><br><span class=\"line\">{</span><br><span class=\"line\">    CppDll.LuaGetTop(L);</span><br><span class=\"line\">    int arg0 = (int)CppDll.LuaToNumber(L, 1);</span><br><span class=\"line\">    int arg1 = (int)CppDll.LuaToNumber(L, 2);</span><br><span class=\"line\">    int o = CSFunc(arg0, arg1);</span><br><span class=\"line\">    CppDll.LuaPushNumber(L, o);</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将wrap函数封送到C++</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntPtr fn = Marshal.GetFunctionPointerForDelegate((LuaCSFunction)   (CSFuncWrap));</span><br><span class=\"line\">CppDll.RegisterCSFunc(L, \"CSFunc\", fn);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>RegisterCSFunc</code>定义如下，将封送的函数以<code>lua_CFunction</code>的方式push到lua</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">DLL_API <span class=\"keyword\">void</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, lua_CFunction fn)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">\tlua_pushcfunction(L, fn);</span><br><span class=\"line\">\tlua_setglobal(L, name);</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>这里是以全局函数的方式注册的，表函数类似，先取表再push。</p>\n</li>\n<li><p>在lua中调用wrap函数</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> ret = CSFunc(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"cs-lua\"><a href=\"https://aillieo.cn/#cs-lua\" class=\"headerlink\" title=\"cs-lua\"></a>cs-lua</h2><p>在C#中调用lua的主要步骤（同样简化省略掉了一些对于lua栈中数据及类型判断的过程）：</p>\n<ol>\n<li><p>在lua中定义函数如下</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LuaFunc = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(x,y)</span></span> </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'[lua] this is LuaFunc with args x = '</span> .. x .. <span class=\"string\">' and y = '</span> .. y); </span><br><span class=\"line\">    <span class=\"keyword\">local</span> ret = x * <span class=\"number\">10</span> + y; </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'[lua] ret will be '</span> .. ret);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;    </span><br><span class=\"line\">   <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将待调用的lua函数放到栈顶（也是全局函数，如果是表中的函数需要先取一次表）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CppDll.LuaGetGlobal(L, \"LuaFunc\");</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>push参数，调用pcall，获取结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CppDll.LuaPushNumber(L, 3);</span><br><span class=\"line\">CppDll.LuaPushNumber(L, 5);</span><br><span class=\"line\">CppDll.LuaPCall(L, 2, 1, 0);</span><br><span class=\"line\">int ret = (int)CppDll.LuaToNumber(L, 1);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这一过程可以进一步封装，并在C#中缓存lua函数以减少lua栈操作。</p>\n<h2 id=\"REFERENCE\"><a href=\"https://aillieo.cn/#REFERENCE\" class=\"headerlink\" title=\"REFERENCE\"></a>REFERENCE</h2><p><a href=\"https://book.douban.com/subject/3076942/\" target=\"_blank\" rel=\"noopener noreferrer\">Lua进程设计（第二版）</a></p>\n<p><a href=\"https://github.com/topameng/tolua_runtime\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/topameng/tolua_runtime</a></p>\n<p><a href=\"https://github.com/topameng/tolua\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/topameng/tolua</a></p>","text":" &lt;p&gt;项目中一直使用tolua框架，底层使用C#开发，逻辑使用lua开发。借助tolua的源码，研究一下lua与C#是如何互相调用的，然后自己写了个简单的demo作为记录。&lt;/p&gt; Demo里没有拿lua的源码编译，而是直接使用lua的静态库，将lua库...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lua-cs\"><span class=\"toc-text\">lua-cs</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cs-lua\"><span class=\"toc-text\">cs-lua</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#REFERENCE\"><span class=\"toc-text\">REFERENCE</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua垃圾回收","uid":"6adcbbf2d5603d93d3c2fd5b3bbe5fbd","slug":"zl/2016-01-01-22_lua垃圾回收","date":"2024-04-03T03:47:33.100Z","updated":"2024-04-03T03:47:33.100Z","comments":true,"path":"api/articles/zl/2016-01-01-22_lua垃圾回收.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"采用垃圾回收机制对所有的lua对象(GCObject)进行管理。Lua虚拟机会定期运行GC，释放掉已经不再被被引用到的lua对象。 基本算法【标记清除】 基本的垃圾回收算法被称为”mark-and-sweep”算法。算法本身其实很简单。 1.系统管理着所有已经创建了的对象。每个对...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Ngx_lua一键截流系统","uid":"46ed0e5beb20815c0cb704981d07aa7a","slug":"zl/2016-01-01-226_Ngx_lua一键截流系统","date":"2024-04-03T03:47:33.099Z","updated":"2024-04-03T03:47:33.099Z","comments":true,"path":"api/articles/zl/2016-01-01-226_Ngx_lua一键截流系统.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;https://fankeke.github.io/#%E8%83%8C%E6%99%AF&quot; class=&quot;headerlink&quot; title=&quot;背...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}