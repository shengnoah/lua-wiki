{"title":"lua","uid":"df60e476b394b1dd4755ec96c53302ff","slug":"zl/2016-01-01-746_lua","date":"2024-04-03T03:47:35.993Z","updated":"2024-04-03T03:47:35.995Z","comments":true,"path":"api/articles/zl/2016-01-01-746_lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"基本使用\">基本使用</h2>\n<figure class=\"highlight\"><pre><code class=\"language-text\" data-lang=\"text\">* 行注释用--\n* 数组和字典都是table，数组下标不是从0开始的，而是从1开始的\n* 函数调用只有一个参数，并且这个参数是字符串字面量或者table构造器时，可以省略括号\n* unpack函数最重要的使用场景就是generic call，即函数的动态参数调用\n* 函数的多值返回。lua会根据调用场景来调整返回的结果数量\n  1. 当函数调用作为一个语句时，忽略所有的结果\n  2. 当函数调用作为一个表达式时，只保留第一个返回结果\n  3. 只有当函数调用在一个表达式列表中是最后一个表达式时，我们会得到所有的返回值。这种表达式\n     列表出现在4种结构中：mutiple assignment, arguments to function calls, table\n     constructors, and return statements</code></pre></figure>\n<h2 id=\"常用操作\">常用操作</h2>\n<figure class=\"highlight\"><pre><code class=\"language-lua\" data-lang=\"lua\"><span class=\"nb\">table.concat</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"s1\">&#39;,&#39;</span><span class=\"p\">)</span> <span class=\"c1\">--连接，相当于join</span>\n<span class=\"nb\">table.insert</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">15</span><span class=\"p\">)</span> <span class=\"c1\">--添加元素，在位置1处添加15。若不带位置参数，则默认添加到最后</span>\n<span class=\"nb\">table.remove</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">)</span> <span class=\"c1\">--删除最后一个元素</span>\n<span class=\"nb\">table.remove</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\">--删除指定位置的元素</span>\n<p><span class=\"nb\">string.sub</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">stop</span><span class=\"p\">)</span> <span class=\"c1\">–包括start和stop</span><br />\n<span class=\"nb\">type</span><span class=\"p\">()</span> <span class=\"c1\">–返回一个变量的类型，table string number</span><br />\n<span class=\"nb\">tostring</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"c1\">–转换成字符串</span><br />\n<span class=\"nb\">tonumber</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">[,</span> <span class=\"n\">base</span><span class=\"p\">])</span> <span class=\"c1\">–转换成数字</span><br />\n<span class=\"k\">repeat</span> <span class=\"k\">while</span> <span class=\"c1\">–相当于do while，while部分可以用until</span></p>\n<p><span class=\"c1\">– 判断table是否为空</span><br />\n<span class=\"k\">if</span> <span class=\"nb\">next</span> <span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">nil</span> <span class=\"k\">then</span><br />\n<span class=\"c1\">– table t is empty</span><br />\n<span class=\"k\">end</span> <span class=\"c1\">– if empty</span></code></pre></figure></p>\n<h2 id=\"redis中的使用\">redis中的使用</h2>\n<figure class=\"highlight\"><pre><code class=\"language-text\" data-lang=\"text\">* KEYS ARGV 两个变量，分别存储需要操作的key和传递给脚本的参数，只能通过这两个变量传入参数\n* 使用lua 5.1的版本\n* redis.call()和redis.pcall()唯一区别在于它们使用不同的方式处理执行命令所产生的错误\n* 脚本里使用的所有键都应该由KEYS数组来传递，一个特别重要的用途是确保redis集群可以将请求\n  发送到正确的集群节点\n* lua数据类型和redis数据类型之间存在着一一对应的转换关系\n  1. redis状态回复转换成lua表，表内的ok字段包含了状态信息\n  2. redis错误回复转换成lua表，表内的err域包含了错误信息\n  3. redis的Nil回复和Nil多条回复转换成lua的布尔值false\n  4. redis的单个回复转换为数字或字符串，多条bulk回复转换成lua表\n* 脚本应该写成纯函数：\n     对于同样的数据集输入，给定相同的参数，脚本执行的redis写命令总是相同的。脚本执行的操作\n  不能依赖于任何隐藏（非显式）数据，不能依赖于脚本在执行过程中、或脚本在不同执行时期之间可能\n  变更的状态，并且它也不能依赖于任何来自I/O设备的外部输入\n* 为了防止不必要的数据泄漏进lua环境，脚本不允许创建全局变量，将脚本中用到的所有变量都使用\n  local关键字定义为局部变量\n* 加载了以下lua库：base, table, string, math, struct, cjson, cmsgpack, bitop,\n  redis.sha1hex函数, redis lua debugger上下文中的redis.breakpoint和redis.debug函数\n  其中struct, cjson和cmsgpack是外部库，其它的都是lua的标准库(redis 3.2)</code></pre></figure>","text":"基本使用 * 行注释用-- * 数组和字典都是table，数组下标不是从0开始的，而是从1开始的 * 函数调用只有一个参数，并且这个参数是字符串字面量或者table构造器时，可以省略括号 * unpack函数最重要的使用场景就是generic call，即函数的动态参数调用 * ...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">基本使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">常用操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#redis%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">redis中的使用</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"深入 Lua Garbage Collector(四)","uid":"4c02a9a4c94fcc525d80ece74d575108","slug":"zl/2016-01-01-748_深入 Lua Garbage Collector(四)","date":"2024-04-03T03:47:35.995Z","updated":"2024-04-03T03:47:35.996Z","comments":true,"path":"api/articles/zl/2016-01-01-748_深入 Lua Garbage Collector(四).json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 早期的 Lua GC 采用的是 stop the world 的实现。一旦发生 gc 就需要等待整个 gc 流程走完。如果你用 lua 处理较少量数据，或是数据增删不频繁，这样做不是问题。但当处理的数据量变大时，对于实时性要求较高的应用，比如网络游戏服务器，这个代价则是不可忽略...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua学习笔记","uid":"d112c00bf05f368c0020529ea6c8efaf","slug":"zl/2016-01-01-743_Lua学习笔记","date":"2024-04-03T03:47:35.992Z","updated":"2024-04-03T03:47:35.992Z","comments":true,"path":"api/articles/zl/2016-01-01-743_Lua学习笔记.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 两个减号是单行注释:1-- 注释内容 多行注释:1234--[[ 注释内容注释内容--]] 数据类型Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。值可以存储在变量中，作为参数传递或结果返回。 nil这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}