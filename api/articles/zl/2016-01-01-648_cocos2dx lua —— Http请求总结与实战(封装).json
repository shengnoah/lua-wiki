{"title":"cocos2dx lua —— Http请求总结与实战(封装)","uid":"dcb7ce12f00b8209eff197aa80b46963","slug":"zl/2016-01-01-648_cocos2dx lua —— Http请求总结与实战(封装)","date":"2024-04-03T03:47:35.870Z","updated":"2024-04-03T03:47:35.870Z","comments":true,"path":"api/articles/zl/2016-01-01-648_cocos2dx lua —— Http请求总结与实战(封装).json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>今天的主题是关于cocos2dx lua实现短链接网络请求，使用Http实现基本的服务器网络数据获取，关于长链接（socket后续文件或者遇到需要的时候回特别实现与处理）</p>\n<blockquote>\n<p>关于Http这里就不多做介绍了，不过，作为一个程序员，网络请求是开发中最多也是最重要的一环节，这里比较建议，搞懂http的整个请求流程！</p>\n</blockquote>\n<p>推荐：<a href=\"https://blog.csdn.net/yezitoo/article/details/78193794\" target=\"_blank\" rel=\"noopener noreferrer\">一次完整的HTTP请求过程\n</a></p>\n<p>在有了基本的Lua知识和cocos2dx lua基本的了解和学习之后，我有了一个初步的cocos2dx lua开发常识，然后就开始在上面实现基本的界面，并根据界面操作请求和响应数据！</p>\n<h3 id=\"入口场景\"><a href=\"#入口场景\" class=\"headerlink\" title=\"入口场景\"></a>入口场景</h3><p>在main中初始化场景中必要的UI.</p>\n<p>创建一个背景图片和一个按钮，实现点击按钮跳转到另外一个场景，进行网络请求和数据获取</p>\n<pre><code>--- @class MainScene\nlocal MainScene = class(&#34;MainScene&#34;,cc.load(&#34;mvc&#34;).ViewBase)\n<p>—onEnter<br />\nfunction MainScene:onEnter()<br />\nprint(&quot;onEnter&quot;)<br />\nend</p>\n<p>—createStaticButton 通用创建按钮方法<br />\n—@param node table<br />\n—@param imageName table<br />\n—@param x table<br />\n—@param y table<br />\n—@param callBack table<br />\nlocal function createStaticButton(node, imageName, x, y, callBack)</p>\n<pre><code>local btn = ccui.Button:create(imageName, imageName)\nbtn:move(x, y)\nbtn:addClickEventListener(callBack)\nbtn:addTo(node)\n</code></pre>\n<h2 id=\"end\"><a class=\"markdownIt-Anchor\" href=\"#end\"></a> end</h2>\n<p>-----onCreate<br />\nfunction MainScene:onCreate()</p>\n<pre><code>-- 初始化背景\ndisplay.newSprite(&amp;#34;HelloWorld.png&amp;#34;)\n    :move(display.center)\n    :addTo(self)\n\n-- 初始化按钮\ncreateStaticButton(self, &amp;#34;button_start.png&amp;#34;, display.cx, display.cy-150, function ()\n    self:getApp():enterScene(&amp;#34;ApiRequest&amp;#34;)\nend)\n</code></pre>\n<p>end</p>\n<p>return MainScene<br />\n</code></pre><h3 id=\"网络应用场景-ApiRequest\"><a href=\"#网络应用场景-ApiRequest\" class=\"headerlink\" title=\"网络应用场景(ApiRequest)\"></a>网络应用场景(ApiRequest)</h3><p>然后开始处理跳转之后的ApiRequest，和相关请求逻辑，这里主要是使用我们封装好的CocosRequest实现基本上的请求逻辑，然后拿到数据之后我们就可以根据实际UI和具体业务逻辑做处理</p></p>\n<blockquote>\n<p>注意</p>\n</blockquote>\n<blockquote>\n<p>测试的时候，将local url = “<a href=\"https://xxxx?cmd=501001&amp;uid=628941&amp;novelid=3782&#34;中的值换成自己的地址就可以\" target=\"_blank\" rel=\"noopener noreferrer\">https://xxxx?cmd=501001&amp;uid=628941&amp;novelid=3782&#34;中的值换成自己的地址就可以</a></p>\n</blockquote>\n<pre><code>require &#34;json&#34;\nlocal CocosRequest = require &#34;app.CocosRequest&#34;\n<p>— @class ApiRequest<br />\nlocal ApiRequest = class(&quot;ApiRequest&quot;, cc.load(&quot;mvc&quot;).ViewBase)<br />\n----local MainScene = class(&quot;MainScene&quot;, function() return display.newScene(&quot;MainScene&quot;) end)</p>\n<p>—onEnter<br />\nfunction ApiRequest:onEnter()<br />\nprint(&quot;onEnter&quot;)<br />\nend</p>\n<p>-----onCreate<br />\nfunction ApiRequest:onCreate()</p>\n<pre><code>----------------------- 创建自定义事件 start\nlocal function eventCustomListener1(event)\n    local str = &amp;#34;response: &amp;#34;..event._usedata\n    --labelStatusCode:setString(str)\n\n    -- 如果返回的是 json 数据，这里解析\n    local data =  json.decode(event._usedata)\n    table.foreach(data,\n     function(key, var)\n         print(&amp;#34;-----&amp;#34;..key)\n         table.foreach(var,\n            function(a, b)\n               print(a..&amp;#34;-&amp;#34;..b)\n            end)\n     end)\nend\n\nlocal listener1 = cc.EventListenerCustom:create(&amp;#34;customEvent1&amp;#34;,eventCustomListener1)\ncc.Director:getInstance():setNotificationNode(cc.Node:create())\nlocal eventDispatcher = cc.Director:getInstance():getNotificationNode():getEventDispatcher()\neventDispatcher:addEventListenerWithFixedPriority(listener1, 6)\n\n-- 将事件分配器赋值到CocosRequest.eventDispatcher\n-- 用来在http请求返回的回调函数中使用，因为回调函数是在异步线程中执行，必须用自定义事件更新ui线程数据\nlocal tmpHttp = CocosRequest:getInstance()\ntmpHttp.eventDispatcher = eventDispatcher\n----------------------- 创建自定义事件 end\n\nlocal tmp = CocosRequest:getInstance()\n\nlocal function callback(xhr)\n    local event = cc.EventCustom:new(&amp;#34;customEvent1&amp;#34;)\n    event._usedata = xhr.response\n    eventDispatcher:dispatchEvent(event)\n    print(&amp;#34;post callback code = &amp;#34;..xhr.statusText)\nend\n\nlocal type = tmp.POST\nlocal url = &amp;#34;https://xxxx?cmd=501001&amp;amp;uid=628941&amp;amp;novelid=3782&amp;#34;\nlocal dataPost = &#123;&#125;\ndataPost.data = &amp;#34;hello&amp;#34;\ndataPost.aaa = &amp;#34;world&amp;#34;\ndataPost.bbb = &amp;#34;yang&amp;#34;\ntmp:send(type, url, dataPost, callback)\n</code></pre>\n<p>end</p>\n<p>return ApiRequest<br />\n</code></pre><h3 id=\"网络请求封装-CocosRequest\"><a href=\"#网络请求封装-CocosRequest\" class=\"headerlink\" title=\"网络请求封装(CocosRequest)\"></a>网络请求封装(CocosRequest)</h3><p>最后才是我们的重头戏，CocosRequest是直接使用cocos2dx lua提供的XMLHttpRequest实现，其实就是做了一套逻辑，具体细节可以根据项目调整(此处已经测试通过，可直接拷贝使用)</p></p>\n<pre><code>require &#34;json&#34;\n\nCocosRequest = &#123;&#125;\nCocosRequest.__index = CocosRequest\nCocosRequest.instance = nil\nCocosRequest.callback = nil\nCocosRequest.POST = &#34;POST&#34;\nCocosRequest.GET = &#34;GET&#34;\n\nfunction CocosRequest:new()\n    local self = &#123;&#125;\n    setmetatable(self,CocosRequest)\n    return self\nend\n\nfunction CocosRequest:getInstance()\n    if nil == self.instance then\n        self.instance = self:new()\n    end\n    return self.instance\nend\n\n-- 数据转换，将请求数据由 table 型转换成 string，参数：table\nfunction CocosRequest:dataParse(data)\n    if &#34;table&#34; ~= type(data) then\n        print(&#34;data is not a table&#34;)\n        return nil\n    end\n\n    local tmp = &#123;&#125;\n    for key, value in pairs(data) do\n        table.insert(tmp,key..&#34;=&#34;..value)\n    end\n\n    local newData = &#34;&#34;\n    for i=1,#tmp do\n        newData = newData..tostring(tmp[i])\n        if i&lt;#tmp then\n            newData = newData..&#34;&amp;&amp;&#34;\n        end\n    end\n    print(&#34;------- name is &#34;..newData)\n    return newData\nend\n\n-- 发送数据，参数：string，string，table\nfunction CocosRequest:send(type, url, data, callback)\n    local xhr = cc.XMLHttpRequest:new() --new 一个http request 实例\n    self.callback = callback    --设置需要执行的函数\n\n    local newData = self:dataParse(data)\n    if nil == newData or &#34;&#34; == newData then\n        return\n    end\n\n    -- response回调函数\n    local function responseCallback()\n        print(&#34;CocosRequest - &#34;..xhr.response)\n        if nil ~= self.callback then\n            self.callback(xhr)\n        else\n            print(&#34;callback is nil&#34;)\n        end\n    end\n\n    -- 设置返回值类型及回调函数\n    xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING\n    xhr:registerScriptHandler(responseCallback)\n\n    -- 请求方式判断\n    if self.POST == type then\n        xhr:open(self.POST, url)\n        xhr:registerScriptHandler(responseCallback)\n        xhr:send(newData)\n    elseif self.GET == type then\n        xhr:open(self.GET, url..&#34;?&#34;..newData)\n        xhr:send()\n    else\n        print(&#34;ERROR : type only can be &#34;Post&#34; or &#34;GET&#34;&#34;)\n    end\nend\n\n---------------------\n\nreturn CocosRequest\n</code></pre><p>由于在Web中使用XMLHTTPRequest对象发出HTTP请求很普遍,Cocos2dx Lua对其进行了移植,可以在 Cocos2 d-x LumP中使用 XMLHTTPRequest对象</p>\n<p>XMLHTTPRequest对象中几个常用的函数和属性如下</p>\n<ul>\n<li>(1)open(),与服务器连接,创建新的请求</li>\n<li>(2)send(),向服务器发送请求</li>\n<li>(3)abort(),退出当前请求</li>\n<li>(4)readyState属性,提供当前请求的就绪状态,其中4表示准备就绪</li>\n<li>(5)tatus属性,提供当前HTTP请求状态码,其中200表示成功请求</li>\n<li>(6)respomseText属性,服务器返回的请求响应</li>\n<li>(7) onreadystatechange属性。设置回调函数,当服务器处理完请求后就会自动调用该<br/>函数。</li>\n</ul>\n<p>其中open和send函数,以及onreadystatechange属性是HTTP请求的关键。open函<br/>数有以下5个参数可以使用</p>\n<ul>\n<li>(1) request-type:发送请求的类型。典型的值是GET或POST,也可以发送HEAD<br/>请求</li>\n<li>(2) url:要请求连接的URL</li>\n<li>(3) asynch:如果希望使用异步连接则为true,否则为 false。该参数是可选的,默认为</li>\n<li>(4) username:如果需要身份验证,则可以在此指定用户名。该可选参数没有默认值</li>\n<li>(5) password:如果需要身份验证,则可以在此指定口令。该可选参数没有默认值。</li>\n</ul>\n<h3 id=\"服务器响应\"><a href=\"#服务器响应\" class=\"headerlink\" title=\"服务器响应\"></a>服务器响应</h3><p>下面是我们验证返回后的服务器数据(未做处理)</p>\n<pre><code>[\n    &#123;\n        &#34;code&#34;:1,\n        &#34;msg&#34;:&#34;操作成功&#34;,\n        &#34;data&#34;:[\n            &#123;\n                &#34;novelid&#34;:&#34;3782&#34;,\n                &#34;uid&#34;:&#34;628875&#34;,\n                &#34;cid&#34;:&#34;5&#34;,\n                &#34;title&#34;:&#34;零下记忆&#34;,\n                &#34;cover&#34;:&#34;http://xxxx/img/cb/2f/f1/cb2ff155bbda8387f4b8efe917c46cd3.jpg&#34;,\n                &#34;scover&#34;:&#34;http://xxxx/img/cb/2f/f1/cb2ff155bbda8387f4b8efe917c46cd3.jpg&#34;,\n                &#34;shareimg&#34;:&#34;http://xxxx/img/ed/68/e6/ed68e67f77841ac76be189f0a04aa030.jpg&#34;,\n                &#34;intro&#34;:&#34;&#34;,\n                &#34;tags&#34;:&#34;悬疑&#34;,\n                &#34;reason&#34;:&#34;&#34;,\n                &#34;issingle&#34;:&#34;1&#34;,\n                &#34;sort&#34;:&#34;0&#34;,\n                &#34;hits&#34;:&#34;0&#34;,\n                &#34;reads&#34;:&#34;18753&#34;,\n                &#34;clues&#34;:20,\n                &#34;likes&#34;:&#34;1&#34;,\n                &#34;unlikes&#34;:&#34;0&#34;,\n                &#34;cmts&#34;:&#34;0&#34;,\n                &#34;favs&#34;:&#34;2&#34;,\n                &#34;words&#34;:&#34;18420&#34;,\n                &#34;chapters&#34;:&#34;35&#34;,\n                &#34;pub_chapters&#34;:&#34;35&#34;,\n                &#34;chapter_index&#34;:&#34;1&#34;,\n                &#34;pubtime&#34;:&#34;0&#34;,\n                &#34;updatetime&#34;:&#34;1539337440&#34;,\n                &#34;addtime&#34;:&#34;1534222233&#34;,\n                &#34;resversion&#34;:&#34;30&#34;,\n                &#34;isuser&#34;:&#34;0&#34;,\n                &#34;status&#34;:&#34;1&#34;,\n                &#34;wstatus&#34;:&#34;1&#34;,\n                &#34;offsale&#34;:&#34;0&#34;,\n                &#34;chapterstatus&#34;:&#34;-1&#34;,\n                &#34;leadrole&#34;:&#123;\n                    &#34;roleid&#34;:&#34;8478&#34;,\n                    &#34;rolename&#34;:&#34;炽念&#34;\n                &#125;,\n                &#34;cname&#34;:&#34;推理&#34;,\n                &#34;isnew&#34;:0,\n                &#34;fatime&#34;:&#34;8月14日&#34;,\n                &#34;isreading&#34;:1,\n                &#34;iscomplete&#34;:1,\n                &#34;isfav&#34;:0,\n                &#34;liketype&#34;:0,\n                &#34;shareinfo&#34;:&#123;\n                    &#34;type&#34;:1,\n                    &#34;title&#34;:&#34;零下记忆&#34;,\n                    &#34;intro&#34;:&#34;&#34;,\n                    &#34;img&#34;:&#34;http://xxxx/img/ed/68/e6/ed68e67f77841ac76be189f0a04aa030.jpg&#34;,\n                    &#34;url&#34;:&#34;http://xxxx/novel/startReading?novelid=3782&amp;chl=jmt&#34;\n                &#125;,\n                &#34;userinfo&#34;:&#123;\n                    &#34;uid&#34;:&#34;628875&#34;,\n                    &#34;username&#34;:&#34;writer10&#34;,\n                    &#34;nickname&#34;:&#34;离经易道&#34;,\n                    &#34;headurl&#34;:&#34;http://xxxx/headimg/bb/d3/b6/628875_1_bbd3b631717ad615f38a6670573a375c_300x300.jpg?v=1526708983&#34;,\n                    &#34;sex&#34;:&#34;1&#34;,\n                    &#34;vtype&#34;:&#34;0&#34;,\n                    &#34;regtype&#34;:&#34;2&#34;,\n                    &#34;vname&#34;:&#34;&#34;,\n                    &#34;vicon&#34;:&#34;&#34;,\n                    &#34;isfollow&#34;:0\n                &#125;\n            &#125;\n        ],\n        &#34;cmd&#34;:501001,\n        &#34;time&#34;:1539677040\n    &#125;\n]\n</code></pre>","text":"今天的主题是关于cocos2dx lua实现短链接网络请求，使用Http实现基本的服务器网络数据获取，关于长链接（socket后续文件或者遇到需要的时候回特别实现与处理） 关于Http这里就不多做介绍了，不过，作为一个程序员，网络请求是开发中最多也是最重要的一环节，这里比较建议，...","link":"","photos":[],"count_time":{"symbolsCount":"9.8k","symbolsTime":"9 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A5%E5%8F%A3%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">入口场景</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#end\"><span class=\"toc-text\"> end</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-ApiRequest\"><span class=\"toc-text\">网络应用场景(ApiRequest)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85-CocosRequest\"><span class=\"toc-text\">网络请求封装(CocosRequest)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94\"><span class=\"toc-text\">服务器响应</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua","uid":"df60e476b394b1dd4755ec96c53302ff","slug":"zl/2016-01-01-651_lua","date":"2024-04-03T03:47:35.871Z","updated":"2024-04-03T03:47:35.872Z","comments":true,"path":"api/articles/zl/2016-01-01-651_lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" | 分类 &lt;a href=&quot;/categories/#lua之基础&quot; title=&quot;lua之基础&quot;&gt;lua之基础&lt;/a&gt; | “翻译”自https://github.com/SteveKChiu/lua-intf ...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"使用元表优化 Lua 配置文件","uid":"d1bdeff7322e20d503cfc9f8f1831c97","slug":"zl/2016-01-01-649_使用元表优化 Lua 配置文件","date":"2024-04-03T03:47:35.870Z","updated":"2024-04-03T03:47:35.871Z","comments":true,"path":"api/articles/zl/2016-01-01-649_使用元表优化 Lua 配置文件.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 配置文件 在游戏工程中，通常有大量配置是由策划提供，再转换成程序方便读取的格式添加到工程中。 在我参与的Cocos2dx-Lua工程中，策划通常在Excel中配置，再通过脚本转换为Lua-Table的文件。 比如常见的道具表转换后： -- PropModel.lua PropM...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}