{"title":"Lua_Trace","uid":"0c6a1f60edcd64859d101b7cc62dd1cb","slug":"zl/2016-01-01-6_[Lua_Trace] 1. Lua数据结构 ","date":"2024-04-03T03:47:35.933Z","updated":"2024-04-03T03:47:35.933Z","comments":true,"path":"api/articles/zl/2016-01-01-6_[Lua_Trace] 1. Lua数据结构 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>                    &lt;p&gt;摘要:[Lua_Trace] 1. Lua数据结构 - TString&lt;/p&gt;\n                &lt;br /&gt;\n                &lt;p&gt;\n此源码分析的版本为 : &lt;strong&gt;Lua 5.3.1&lt;/strong&gt;&lt;/p&gt;\n</code></pre>\n<p>\n\t<strong>2. TString : 字符串结构</strong></p>\n<pre><code>\n//lobject.h\n<p>/*<br />\nHeader for string value; string bytes follow the end of this structure<br />\n(aligned according to ‘UTString’; see next).<br />\n<em>/<br />\ntypedef struct TString &#123;<br />\nCommonHeader;<br />\nlu_byte extra;  /</em> reserved words for short strings; “has hash” for longs <em>/<br />\nlu_byte shrlen;  /</em> length for short strings <em>/<br />\nunsigned int hash;<br />\nunion &#123;<br />\nsize_t lnglen;  /</em> length for long strings */<br />\nstruct TString <em>hnext;  /</em> linked list for hash table */<br />\n&#125; u;<br />\n&#125; TString;</code></pre></p>\n<p>\n\tTString结构由上而下的元素共有：</p>\n<p>\n\tCommonHeader : GCObject的共有定义。</p>\n<p>\n\textra : 短字符串(LUA_TSHRSTR)下，非0之数值表示GC不回收的保留字，如下luaX_tokens定义了Lua所有的保留字。</p>\n<pre><code>\n//llex.c\n<p>/* ORDER RESERVED */<br />\nstatic const char *const luaX_tokens [] = &#123;<br />\n“and”, “break”, “do”, “else”, “elseif”,<br />\n“end”, “false”, “for”, “function”, “goto”, “if”,<br />\n“in”, “local”, “nil”, “not”, “or”, “repeat”,<br />\n“return”, “then”, “true”, “until”, “while”,<br />\n“//”, “…”, “…”, “==”, “&gt;=”, “&lt;=”, “~=”,<br />\n“&lt;&lt;”, “&gt;&gt;”, “::”, “”,<br />\n“”, “”, “”, “”<br />\n&#125;;</p>\n<p>void luaX_init (lua_State *L) &#123;<br />\nint i;<br />\nTString <em>e = luaS_newliteral(L, LUA_ENV);  /</em> create env name <em>/<br />\nluaC_fix(L, obj2gco(e));  /</em> never collect this name <em>/<br />\nfor (i=0; iextra = cast_byte(i+1);  /</em> reserved word */<br />\n&#125;<br />\n&#125;;&gt;</code></pre></p>\n<p>\n\textra : 长字符串(LUA_TLNGSTR)则表示是否有私有的hash table，有，设定为1。</p>\n<p>\n\tshrlen : 字符串长度 (LUA_TSHRSTR使用)。</p>\n<p>\n\thash : 杂凑值，由杂凑算法产生。</p>\n<p>\n\tu : LUA_TLNGSTR下表示为字符串长度(lnglen)，LUA_TSHRSTR则表示为hash table的链接(*hnext)。</p>\n<p>\n</p>\n<p>\n\t创建TString时，Lua会在TString(16 bytes)后开一空间存储字符串数据，这样的行为可由如下源码中察觉。</p>\n<pre><code>\n//lstring.c\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n</li>\n</ul>\n<p>creates a new string object<br />\n*/<br />\nstatic TString *createstrobj (lua_State *L, const char *str, size_t l,<br />\nint tag, unsigned int h) &#123;<br />\nTString *ts;<br />\nGCObject <em>o;<br />\nsize_t totalsize;  /</em> total size of TString object <em>/<br />\ntotalsize = sizelstring(l);<br />\no = luaC_newobj(L, tag, totalsize);<br />\nts = gco2ts(o);<br />\nts-&gt;hash = h;<br />\nts-&gt;extra = 0;<br />\nmemcpy(getaddrstr(ts), str, l * sizeof(char));<br />\ngetaddrstr(ts)[l] = ‘’;  /</em> ending 0 */<br />\nreturn ts;<br />\n&#125;</code></pre></p>\n<p>\n\t<img border=\"0\" src=\"https://az787680.vo.msecnd.net/user/iounegpf/1507/201571391157172.png\"></p>\n<p>\n\t换句话说，欲取得字符串的方法可透过如下方式：</p>\n<pre><code>\nTString* p;\nchar* str=(char*)(p+1); //TString的字符串指针</code></pre>\n<p>\n\tLua有针对短字符串(LUA_TSHRSTR : 长度小于40)采取节省内存与性能优化的措施，当多个同为短字符串且内容皆相同的情境下，那它们皆使用同一份TString对象，实现方式是通过字符串来得到一个hash值，并透过全域hash表(g->strt)查找是否存在相同的hash值(重复的字符串)，如果已经有了，那么就直接引用该对象(并进行引用数据++操作)，反之，Lua会创建一TString放在hash表中对应的位置。</p>\n<pre><code>\n//lstring.c\n<p>/*<br />\nnew string (with explicit length)<br />\n*/<br />\nTString *luaS_newlstr (lua_State *L, const char <em>str, size_t l) &#123;<br />\nif (l &lt;= LUAI_MAXSHORTLEN)  /</em> short string? */<br />\nreturn internshrstr(L, str, l);<br />\nelse &#123;<br />\nTString *ts;<br />\nif (l + 1 &gt; (MAX_SIZE - sizeof(TString))/sizeof(char))<br />\nluaM_toobig(L);<br />\nts = createstrobj(L, str, l, LUA_TLNGSTR, G(L)-&gt;seed);<br />\nts-&gt;u.lnglen = l;<br />\nreturn ts;<br />\n&#125;<br />\n&#125;</p>\n<p>/*<br />\nchecks whether short string exists and reuses it or creates a new one<br />\n*/<br />\nstatic TString *internshrstr (lua_State *L, const char *str, size_t l) &#123;<br />\nTString *ts;<br />\nglobal_State *g = G(L);<br />\nunsigned int h = luaS_hash(str, l, g-&gt;seed);<br />\nTString list = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)];<br />\nfor (ts = <em>list; ts != NULL; ts = ts-&gt;u.hnext) &#123;<br />\nif (l == ts-&gt;shrlen &amp;&amp;<br />\n(memcmp(str, getstr(ts), l * sizeof(char)) == 0)) &#123;<br />\n/</em> found! <em>/<br />\nif (isdead(g, ts))  /</em> dead (but not collected yet)? <em>/<br />\nchangewhite(ts);  /</em> resurrect it <em>/<br />\nreturn ts;<br />\n&#125;<br />\n&#125;<br />\nif (g-&gt;strt.nuse &gt;= g-&gt;strt.size &amp;&amp; g-&gt;strt.size &lt;= MAX_INT/2) &#123;<br />\nluaS_resize(L, g-&gt;strt.size * 2);<br />\nlist = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)];  /</em> recompute with new size */<br />\n&#125;<br />\nts = createstrobj(L, str, l, LUA_TSHRSTR, h);<br />\nts-&gt;shrlen = cast_byte(l);<br />\nts-&gt;u.hnext = *list;<br />\n*list = ts;<br />\ng-&gt;strt.nuse++;<br />\nreturn ts;<br />\n&#125;</code></pre></p>\n<p>\n\t有任何错误请指正，后续我将尽可能的再补充详细</p>","text":" &lt;p&gt;摘要:[Lua_Trace] 1. Lua数据结构 - TString&lt;/p&gt; &lt;br /&gt; &lt;p&gt; 此源码分析的版本为 : &lt;strong&gt;Lua 5.3.1&lt;/strong&gt;&lt;/p&gt; ...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"redis学习5 lua脚本 · 老白开发","uid":"348337c0a12434a59d910b67816fcdda","slug":"zl/2016-01-01-69_redis学习5 lua脚本 · 老白开发","date":"2024-04-03T03:47:35.933Z","updated":"2024-04-03T03:47:35.933Z","comments":true,"path":"api/articles/zl/2016-01-01-69_redis学习5 lua脚本 · 老白开发.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"redis内置的 Lua 解释器，可以使用lua对redis进行操作。使用脚本有以下好处: 减少网络开销:批量执行redis命令。 原子性操作:Redis也保证脚本会以原子性的方式执行:当某个脚本正在运行的时候，不会有其他脚本或Redis 命令被执行。 复用：客户端发送的脚本会永...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"redis入门指南之Lua脚本","uid":"0f56cef4f602038120f84f18282a9056","slug":"zl/2016-01-01-695_redis入门指南之Lua脚本","date":"2024-04-03T03:47:35.932Z","updated":"2024-04-03T03:47:35.932Z","comments":true,"path":"api/articles/zl/2016-01-01-695_redis入门指南之Lua脚本.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"重要星级 ★★★★★ 在进阶章节讲到实现访问频率限制功能，用来限制一个IP地址1分钟最多只能访问100次： $isKeyExists=EXISTS rate.limiting:$IP if $isKeyExists is 1 $times=INCR rate.limiting:$...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}