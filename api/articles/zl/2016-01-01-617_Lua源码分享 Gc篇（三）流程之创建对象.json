{"title":"Lua源码分享 Gc篇（三）流程之创建对象","uid":"1dfa68e18bc15f978e17b4ce78c93aaa","slug":"zl/2016-01-01-617_Lua源码分享 Gc篇（三）流程之创建对象","date":"2024-04-03T03:47:35.840Z","updated":"2024-04-03T03:47:35.841Z","comments":true,"path":"api/articles/zl/2016-01-01-617_Lua源码分享 Gc篇（三）流程之创建对象.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>[TOC]</p>\n<p>前面两篇主要介绍一些基础，帮助后面gc流程理解的。像是饭前的开胃菜一般，让你后面容易吃的更多。接下来几篇都是gc流程相关</p>\n<p>这里列出几个问题，你可以直接跳过。当然，有所了解的按照自己的理解去回答一下，或许会有一些新的想法。如果你都会回答的很清晰了，那么接下来的系列几乎可以不怎么看了。</p>\n<p>（1）对象的颜色变化过程？\n（2）新创建对象和gc流程是怎么关联的？\n（3）什么时候gc？\n（4）增量式gc体现在哪？</p>\n<p>gc的流程，按照程序状态分为：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/*\n** Possible states of the Garbage Collector\n*/\n#define GCSpause    0\n#define GCSpropagate    1\n#define GCSsweepstring    2\n#define GCSsweep    3\n#define GCSfinalize    4\n</code></pre></div></div>\n<ul>\n  <li>1.初始化阶段</li>\n  <li>2.扫描阶段</li>\n  <li>3.回收阶段（字符串）</li>\n  <li>4.回收阶段</li>\n  <li>5.结束阶段</li>\n</ul>\n<p>接下来，主要讲一下新创建对象是怎么和gc关联的。因为gc所需要的对象都是在某个地方创建出来的，并且在创建的时候就会和<a href=\"\">第二篇</a>提到的数据结构关联上了</p>\n<h1 id=\"新创建对象\">新创建对象</h1>\n<p>测试代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// main 函数\n    int nCount = 0;\n    while(true)&#123;\n        int bEven = nCount %2 == 0;\n        if(!bEven)\n        &#123;\n            Sleep(1000);\n            ++nCount;\n            continue;\n        &#125;\n        ++nCount;\n        // do something\n        LuaTest();\n    &#125;\n// LuaTest函数\ng_luaReg-&gt;DoScript(&#34;Test.lua&#34;);\n<p>// Test.lua</p>\n<p></code></pre></div></div></p>\n<h2 id=\"luac_link函数\">luaC_link函数</h2>\n<p>这个是新生成对象和gc绑定关系的关键函数，也就是把新创建的对象放在gc链表上[1]：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>void luaC_link (lua_State *L, GCObject *o, lu_byte tt) &#123;\n  global_State *g = G(L);\n  o-&gt;gch.next = g-&gt;rootgc;\n  g-&gt;rootgc = o;\n  o-&gt;gch.marked = luaC_white(g);\n  o-&gt;gch.tt = tt;\n&#125;\n</code></pre></div></div>\n<p>这个函数只做了三件事：</p>\n<ul>\n  <li>把新创建的对象放在gc链表的开头，因为是单向链表[1]</li>\n  <li>把新创建的对象标记为当前白色（currentwhite）</li>\n  <li>设置对象的类型</li>\n</ul>\n<p>下面分别介绍一下各需要gc的类型的创建对象部分</p>\n<h2 id=\"table\">table</h2>\n<p>Test.lua中新建一个table测试代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local t = &#123;1, 2, 3&#125;\n</code></pre></div></div>\n<blockquote>\n  <p>ps:这里给table放了三个元素是为了让自己调试的好找到是创建的这个table。因为虽然Test.lua中只有一行代码，创建了一个table t。但是在虚拟机启动和加载文件的时候，会创建很多其他的table。</p>\n</blockquote>\n<p>源码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Table *luaH_new (lua_State *L, int narray, int nhash) &#123;\n  Table *t = luaM_new(L, Table);\n  luaC_link(L, obj2gco(t), LUA_TTABLE);\n  t-&gt;metatable = NULL;\n  t-&gt;flags = cast_byte(~0);\n  /* temporary values (kept only if some malloc fails) */\n  t-&gt;array = NULL;\n  t-&gt;sizearray = 0;\n  t-&gt;lsizenode = 0;\n  t-&gt;node = cast(Node *, dummynode);\n  setarrayvector(L, t, narray);\n  setnodevector(L, t, nhash);\n  return t;\n&#125;\n</code></pre></div></div>\n<p><strong>说明：</strong></p>\n<ul>\n  <li>new一个table的地方有很多，但是最终都是调用到这个函数，new出来的是一个堆上的一块内存</li>\n  <li>对象类型设置为LUA_TABLE</li>\n  <li>放到gc链表上</li>\n  <li>再把这个指针封装的TValue放到虚拟机的栈上。sethvalue等系列函数，就是把new出来的对象封装到TValue中，然后找到一个栈的元素，把这个value.gc赋值为这个新的对象，看下面代码。有些地方是放在栈顶，那么就需要有栈的操作，比如top++(<em>incr_top(L)</em>)\n    <div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#define sethvalue(L,obj,x) \n&#123; TValue *i_o=(obj); \n  i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TTABLE; \n  checkliveness(G(L),i_o); &#125;\n</code></pre></div>    </div>\n    <p>可以看到，需要GC的对象都会放在TValue的gc这个字段，在数据结构篇可以看到有解释[1]。</p>\n  </li>\n</ul>\n<h2 id=\"lua-function\">lua function</h2>\n<p>创建函数，测试代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local a = 3\nfunction f()\n    local b = a\n    print(&#34;test function&#34;)\nend\n</code></pre></div></div>\n<p>源码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Closure *luaF_newLclosure (lua_State *L, int nelems, Table *e) &#123;\n  Closure *c = cast(Closure *, luaM_malloc(L, sizeLclosure(nelems)));\n  luaC_link(L, obj2gco(c), LUA_TFUNCTION);\n  c-&gt;l.isC = 0;\n  c-&gt;l.env = e;\n  c-&gt;l.nupvalues = cast_byte(nelems);\n  while (nelems--) c-&gt;l.upvals[nelems] = NULL;\n  return c;\n&#125;\n</code></pre></div></div>\n<p><strong>说明：</strong></p>\n<ul>\n  <li>luaC_link放在gc链表上</li>\n  <li>把对象类型为LUA_TFUNCTION</li>\n</ul>\n<h2 id=\"proto\">PROTO</h2>\n<p>目前自己的理解这是一个以文件为单位的chunk，所以每个文件都是以一个个独立的Proto类型在代码里存在的。这一块没有仔细去研究，所以主要是自己理解，以做抛砖引玉之用！</p>\n<p>代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Proto *luaF_newproto (lua_State *L) &#123;\n  Proto *f = luaM_new(L, Proto);\n  luaC_link(L, obj2gco(f), LUA_TPROTO);\n// 省略...\n  return f;\n&#125;\n</code></pre></div></div>\n<p><strong>说明：</strong></p>\n<ul>\n  <li>luaC_link放到gc链表上</li>\n  <li>看<strong>f_parser</strong>函数，发现新建Proto之后，会新建一个lua函数(luaF_newLclosure)。所以，Proto是和Closure绑定的，也很好理解，函数是需要和某个文件有关联的</li>\n</ul>\n<h2 id=\"thread\">THREAD</h2>\n<p>创建携程测试代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>co = coroutine.create(function (a,b)\n    print(111, a, b)\nend)\n</code></pre></div></div>\n<p>代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>LUA_API lua_State *lua_newthread (lua_State *L) &#123;\n  lua_State *L1;\n  lua_lock(L);\n  luaC_checkGC(L);\n  L1 = luaE_newthread(L);\n  setthvalue(L, L-&gt;top, L1);\n  api_incr_top(L);\n  lua_unlock(L);\n  luai_userstatethread(L, L1);\n  return L1;\n&#125;\n</code></pre></div></div>\n<p><strong>说明：</strong></p>\n<ul>\n  <li>放在gc链表的luaC_link是在luaE_newthread中调用的</li>\n</ul>\n<h2 id=\"string\">String</h2>\n<p>代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>static TString *newlstr (lua_State *L, const char *str, size_t l,\n                                       unsigned int h) {\n  TString *ts;\n  stringtable *tb;\n  if (l+1 &gt; (MAX_SIZET - sizeof(TString))/sizeof(char))\n    luaM_toobig(L);\n  ts = cast(TString *, luaM_malloc(L, (l+1)*sizeof(char)+sizeof(TString)));\n  ts-&gt;tsv.len = l;\n  ts-&gt;tsv.hash = h;\n  ts-&gt;tsv.marked = luaC_white(G(L));\n  ts-&gt;tsv.tt = LUA_TSTRING;\n  ts-&gt;tsv.reserved = 0;\n  memcpy(ts+1, str, l*sizeof(char));\n  ((char *)(ts+1))[l] = &#39;","text":"[TOC] 前面两篇主要介绍一些基础，帮助后面gc流程理解的。像是饭前的开胃菜一般，让你后面容易吃的更多。接下来几篇都是gc流程相关 这里列出几个问题，你可以直接跳过。当然，有所了解的按照自己的理解去回答一下，或许会有一些新的想法。如果你都会回答的很清晰了，那么接下来的系列几乎可...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">新创建对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#luac_link%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">luaC_link函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#table\"><span class=\"toc-text\">table</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lua-function\"><span class=\"toc-text\">lua function</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#proto\"><span class=\"toc-text\">PROTO</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#thread\"><span class=\"toc-text\">THREAD</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#string\"><span class=\"toc-text\">String</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"2.3 lua 表达式","uid":"dbea4ef0040d964bfdee0e07b0e19da7","slug":"zl/2016-01-01-614_2.3 lua 表达式","date":"2024-04-03T03:47:35.840Z","updated":"2024-04-03T03:47:35.840Z","comments":true,"path":"api/articles/zl/2016-01-01-614_2.3 lua 表达式.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"算术表达式Lua 的算术运算符如下表所示： 表达符 备注 + 加法 - 减法 * 乘法 / 除法 ^ 指数 % 取模 实例123456789print(1 + 2) print(5 / 10) --&gt;打印 0.5。 这是Lua不同于c语言的print(5.0 / 10) -...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua的require机制","uid":"cf3af81c47f105a555a6bc972ab03ba4","slug":"zl/2016-01-01-616_Lua的require机制","date":"2024-04-03T03:47:35.840Z","updated":"2024-04-03T03:47:35.840Z","comments":true,"path":"api/articles/zl/2016-01-01-616_Lua的require机制.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"今天仔细读了文档，弄清楚了Lua的模块require机制。 Lua是通过require函数来加载模块的，只需提供模块的名字，即可通过require(modname)来加载模块。 Lua是如何通过modname来载入.lua或.so的呢？ 默认加载过程 package.loaded...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}