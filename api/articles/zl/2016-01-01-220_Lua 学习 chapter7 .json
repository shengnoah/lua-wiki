{"title":"Lua 学习 chapter7","uid":"d1f12ad6b4cafc4f9e33f041f7e58f17","slug":"zl/2016-01-01-220_Lua 学习 chapter7 ","date":"2024-04-03T03:47:33.094Z","updated":"2024-04-03T03:47:33.094Z","comments":true,"path":"api/articles/zl/2016-01-01-220_Lua 学习 chapter7 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>\t\t\t&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;\n</code></pre>\n<ol>\n  <li>简单I/O模型</li>\n  <li>完整I/O模型</li>\n  <li>其它文档操作</li>\n  <li>其它系统调用</li>\n</ol>\n<h2 id=\"简单io模型\">简单I/O模型</h2>\n<p>对于文档操作，I/O提供了两种不同的模型。简单模型虚拟了一个当前输入流和一个当前的输出流，其I/O是通过这些流实现的。\nI/O库把当前的输入流初始化为进程的标准输入(C中的stdin),将当前的输出流初始化进程的标准输出(C中的stdout)。因此当执行io.read()这样的语句的时候就可以从标准的输入中读取一行。</p>\n<p>函数的io.input和函数io.output用来改变当前的输入输出流。\nio.input(fileName)会以只读的方式打开指定的文档，并将文档设置为当前的输入流。之后所有的输入都将来自于这个文档，除非重新调用io.input函数来改变。对于输出与之类似。</p>\n<p><strong>函数write()</strong>:\n由于调用该函数可以传入多个参数，所以应该避免使用io.write(a..b..b),而是使用write(a,b,c)。\n作为原则应该只在用后<strong>即弃</strong>的代码或者调试代码的时候调用print输出，当需要完全控制输出是，应该使用io.write()输出，和print不同，\n函数io.write最终的输出不会添加诸如制表符或者换行符这样的额外内容。\n此外函数io.write允许对输出进行重定向，而函数print只能使用标准输出。函数print会为其参数调用tostring函数。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n</pre></td><td class=\"rouge-code\"><pre><span class=\"nb\">io.write</span><span class=\"p\">(</span><span class=\"s2\">\"sin(3)=\"</span><span class=\"p\">,</span><span class=\"nb\">math.sin</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">),</span><span class=\"s2\">\"</span><span class=\"se\">n</span><span class=\"s2\">\"</span><span class=\"p\">)</span> <span class=\"c1\">-- &gt;sin(3) = 0.1411200080</span>\n<span class=\"nb\">io.write</span><span class=\"p\">(</span><span class=\"nb\">string.format</span><span class=\"p\">(</span><span class=\"s2\">\"sin(3)=%.4fn\"</span><span class=\"p\">,</span><span class=\"nb\">math.sin</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)))</span> <span class=\"c1\">-- &gt;sin(3) = 0.1411</span>\n<p><span class=\"nb\">io.read</span><span class=\"p\">(</span><span class=\"s2\">“a”</span><span class=\"p\">)</span> <span class=\"c1\">–&gt;从当前位置开始的读取当前输入文档的全部内容</span><br />\n</pre></td></tr></tbody></table></code></pre></div></div></p>\n<p>函数io.read可以从当前的输入流中读取字符串，其参数决定了其要读取的数据：</p>\n<ol>\n  <li>“a”  读取整个文档</li>\n  <li>“l”  读取下一行 （丢弃换行符）  默认参数</li>\n  <li>“L”  读取下一行（保留换行符）</li>\n  <li>“n”  读取一个数值(number 类型)</li>\n  <li>num  以字符串读取num个字符</li>\n</ol>\n<p>获取一个文档的所有行数可以使用 io.lines() 函数</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n</pre></td><td class=\"rouge-code\"><pre><span class=\"kd\">local</span> <span class=\"n\">lines</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span>\n<span class=\"k\">for</span> <span class=\"n\">line</span> <span class=\"k\">in</span> <span class=\"nb\">io.lines</span><span class=\"p\">()</span> <span class=\"k\">do</span>\n    <span class=\"n\">lines</span><span class=\"p\">[</span><span class=\"o\">#</span><span class=\"n\">lines</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">line</span>\n<span class=\"k\">end</span>\n<p><span class=\"nb\">table.sort</span><span class=\"p\">(</span><span class=\"n\">lines</span><span class=\"p\">)</span></p>\n<p><span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"k\">in</span> <span class=\"nb\">ipairs</span><span class=\"p\">(</span><span class=\"n\">lines</span><span class=\"p\">)</span> <span class=\"k\">do</span><br />\n<span class=\"nb\">io.write</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"s2\">“</span><span class=\"se\">n</span><span class=\"s2\">”</span><span class=\"p\">)</span><br />\n<span class=\"k\">end</span><br />\n</pre></td></tr></tbody></table></code></pre></div></div></p>\n<p>io.write(n) 从当前的输入流中最多读取n个字符，如果没有字符返回nil,io.write(0)是一个特烈，它常用于测试是否达到了文档末尾。如果仍然有数据可供读取，他就会返回一个空字符串，否则返回nil。</p>\n<h2 id=\"完整io模型\">完整I/O模型</h2>\n<p>可以使用io.open来打开一个文档。该函数拥有两个参数，一个是文档名，一个是打开的模式。</p>\n<ol>\n  <li>“r”  只读</li>\n  <li>“w”  只写(可以用来删除文档中原来的内容)</li>\n  <li>“a”  追加</li>\n  <li>“b”  打开二进制文档</li>\n</ol>\n<p>io.open函数打开发生错的时候会返回两个值，一个是nil另一个是系统相关错误的错误码</p>\n<p>检测错误的一种典型方法是使用函数assert:\nlocal f = assert(io.open(fileName,mode))  发生错的时候错误信息会作为函数assert的第二个餐宿被传入。 然后assert会将错误信息展示出来。</p>\n<p>文档打开之后可以使用从流中读取和写入。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n</pre></td><td class=\"rouge-code\"><pre><span class=\"kd\">local</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"nb\">assert</span><span class=\"p\">(</span><span class=\"nb\">io.open</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">,</span><span class=\"s2\">\"r\"</span><span class=\"p\">))</span>\n<span class=\"kd\">local</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"p\">:</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"s2\">\"a\"</span><span class=\"p\">)</span>\n<span class=\"n\">f</span><span class=\"p\">:</span><span class=\"n\">close</span><span class=\"p\">()</span>\n<span class=\"c1\">-- io.stdin, io.stdout, io.stderr</span>\n<span class=\"nb\">io.stderr</span><span class=\"p\">:</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">)</span>\n</pre></td></tr></tbody></table></code></pre></div></div>\n<p>Io库提供了三个预定义的C语言流的句柄，可以直接调用。</p>\n<p>可以通过io.input 和 io.output 来改变的当前的输入输出流</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n</pre></td><td class=\"rouge-code\"><pre><span class=\"kd\">local</span> <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"nb\">io.input</span><span class=\"p\">()</span>\n<span class=\"nb\">io.input</span><span class=\"p\">(</span><span class=\"s2\">\"newInput\"</span><span class=\"p\">)</span>\n<span class=\"c1\">--对新的输入流进行操作</span>\n<span class=\"nb\">io.input</span><span class=\"p\">():</span><span class=\"n\">close</span>\n<span class=\"nb\">io.input</span><span class=\"p\">(</span><span class=\"n\">temp</span><span class=\"p\">)</span>  <span class=\"c1\">--恢复之前的输入流</span>\n</pre></td></tr></tbody></table></code></pre></div></div>\n<p><strong>注意：</strong> io.read(args) 实际上是io.input():read(args)，同样的io.write(args)和io.output():write(args)的简写。\nio.lines() 函数可以带参数，filename,读取文档中的内容，不带参数就是从当前输入流中读，现在次函数还可以接收像read函数一样的参数。</p>\n<h2 id=\"其他文档操作\">其他文档操作</h2>\n<p>io.tmpfile返回一个操作临时文档的句柄，该句柄是以读写模式打开的，当进程运行完成后，该句柄就会被回收。\n函数flush将所有的缓冲数据写入到文档中。与函数write一样，我们也可以把它当作io.flush()使用，以刷新当前的输出流，或者f:flush()，用来刷新当前流。</p>\n<p>函数setvbuf用于设置流的缓冲模式。</p>\n<ol>\n  <li>“no” 不缓冲</li>\n  <li>“full” 缓冲区满或者显示刷新文档时才写入数据</li>\n  <li>“line” 遇到换行符或从特定文档中读到了数据</li>\n</ol>\n<p>对于后面两个模式，可以跟第二个参数来设置缓冲区大小。\n一般情况下:io.stderr 是不缓冲的，io.stdout是按行缓冲的。</p>\n<p>函数seek用来获取和设置文档当前位置。常使用f:seek(whence,offset)的形式来调用。whence有一下三种模式：</p>\n<ol>\n  <li>“set”  文档开头</li>\n  <li>“cur”  文档当前位置</li>\n  <li>“end”  文档结尾</li>\n</ol>\n<p>偏移是以字节为单位的。\nwhence默认值为”cur”,offset的默认值是0。file:seek() 返回当前位置且不改变当前位置。file:seek(“set”)会将位置重置到文档开头并返回0，file:seek(“end”)会将文档当前位置重置到文档结尾，并返回文档的大小。</p>\n<p>os.rename改变文档名字 os.remove删除文档。</p>\n<h2 id=\"其它系统调用\">其它系统调用</h2>\n<p>os.exit用于终止进程的执行。\nos.getev用于获取环境变量。</p>\n<p>os.execute用来运行系统命令，等价于c中的system。还用io.popen也是运行一条系统命令,但是该函数可以重定向命令的输入输出流。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n</pre></td><td class=\"rouge-code\"><pre><span class=\"k\">function</span> <span class=\"nf\">create</span><span class=\"p\">(</span><span class=\"n\">dirname</span><span class=\"p\">)</span>\n\t<span class=\"nb\">os.execute</span><span class=\"p\">(</span><span class=\"s2\">\"mkdir \"</span><span class=\"o\">...</span><span class=\"n\">dirname</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n<p><span class=\"kd\">local</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"nb\">io.popen</span><span class=\"p\">(</span><span class=\"s2\">“dir /B”</span><span class=\"p\">,</span><span class=\"s2\">“r”</span><span class=\"p\">)</span> <span class=\"c1\">– 只读</span><br />\n<span class=\"kd\">local</span> <span class=\"n\">dir</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span><br />\n<span class=\"k\">for</span> <span class=\"n\">entry</span> <span class=\"k\">in</span> <span class=\"n\">f</span><span class=\"p\">:</span><span class=\"n\">lines</span><span class=\"p\">()</span> <span class=\"k\">do</span><br />\n<span class=\"n\">dir</span><span class=\"p\">[</span><span class=\"o\">#</span><span class=\"n\">dir</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">entry</span><br />\n<span class=\"k\">end</span><br />\n</pre></td></tr></tbody></table></code></pre></div></div></p>\n<pre><code>            &lt;hr style=&quot;visibility: hidden;&quot;&gt;\n</code></pre>\n","text":" &lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt; 简单I/O模型 完整I/O模型 其它文档操作 其它系统调用 简单I/O模型 对于文档操作，I/O提供了两种不同的模型。简单模型虚拟了一个当前输入流和一个当前的输出流，其I/O是通过这些流实现的。...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95io%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">简单I&#x2F;O模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4io%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">完整I&#x2F;O模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">其他文档操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E5%AE%83%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">其它系统调用</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 在 Android 中应用下,具体使用","uid":"11792273231c1e7281436c1496534663","slug":"zl/2016-01-01-222_Lua 在 Android 中应用下,具体使用","date":"2024-04-03T03:47:33.097Z","updated":"2024-04-03T03:47:33.097Z","comments":true,"path":"api/articles/zl/2016-01-01-222_Lua 在 Android 中应用下,具体使用.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;转载请附原文链接：&lt;a href=&quot;http://yongyu.itscoder.com/2018/04/16/yongyu_20180416_lua_android_two/#more&quot; target=&quot;_blank&qu...","link":"","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"python和lua数据类型的比较","uid":"ccf67b3289618f0a2dc00d8aa2b25e73","slug":"zl/2016-01-01-221_python和lua数据类型的比较","date":"2024-04-03T03:47:33.094Z","updated":"2024-04-03T03:47:33.094Z","comments":true,"path":"api/articles/zl/2016-01-01-221_python和lua数据类型的比较.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;div class=&quot;post-nav&quot;&gt; &lt;div class=&quot;post-nav-next post-nav-item&quot;&gt; &lt;a href=&quot;https://hulinhong.com/201...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}