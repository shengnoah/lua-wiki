{"title":"Lua入门教程：协程","uid":"232cd6ffbc023c95e155925cdcdc79a4","slug":"zl/2016-01-01-165_Lua入门教程：协程","date":"2024-04-03T03:47:33.053Z","updated":"2024-04-03T03:47:33.053Z","comments":true,"path":"api/articles/zl/2016-01-01-165_Lua入门教程：协程.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>从多线程的角度来看，协程（coroutine）与线程（thread）类似：协程时一系列的可执行语句，拥有自己的栈、局部变量和指令指针，同时协程又与其他协程共享全局变量和其他几乎一切资源。</p>\n<p>协程与线程的主要区别在于，一个多线程程序可以并行运行多个线程，而协程则需要彼此协作运行，即在任意时刻只能有一个协程运行，且只有当正在运行的协程要求挂起时其执行才会暂停。</p>\n<h2 id=\"协程基础\"><a href=\"#协程基础\" class=\"headerlink\" title=\"协程基础\"></a>协程基础</h2><p>与协程相关的函数都放在表 coroutine 中。没个新建立的协程都拥有一个完整的生命周期，其包含四种状态：挂起（suspended）、运行（running）、正常（normal）和死亡（dead)。</p>\n<h3 id=\"创建协程\"><a href=\"#创建协程\" class=\"headerlink\" title=\"创建协程\"></a>创建协程</h3><p>coroutine.create(f)，创建一个以执行代码的函数 f（协程体）的新协程，并返回以类型 <code>thread</code> 为标志的新协程。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">co = coroutine.<span class=\"built_in\">create</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> <span class=\"built_in\">print</span>(<span class=\"string\">&#34;hello&#34;</span>) <span class=\"keyword\">end</span>)</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(co)) </span><br/></pre></td></tr></tbody></table></figure>\n<p>当协程被创建时，默认处于<strong>挂起状态</strong>，即协程不会在被创建时自动运行，我们可以通过 <code>coroutine.status</code> 来检查协程的状态：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(coroutine.<span class=\"built_in\">status</span>(co)) <span class=\"comment\">--&gt; suspended</span></span><br/></pre></td></tr></tbody></table></figure>\n<h3 id=\"运行协程\"><a href=\"#运行协程\" class=\"headerlink\" title=\"运行协程\"></a>运行协程</h3><p>要想启动或再启动一个协程，我们可以使用函数 <code>coroutine.resume</code> 来执行，并将去状态改为运行：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">coroutine.<span class=\"built_in\">resume</span>(co) <span class=\"comment\">--&gt; hello</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>上面的协程创建后运行的函数会输出 <code>hello</code> 然后该协程就终止了，最后协程执行完成后会变为<strong>死亡状态</strong>：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(coroutine.<span class=\"built_in\">status</span>(co)) <span class=\"comment\">--&gt; dead</span></span><br/></pre></td></tr></tbody></table></figure>\n<h3 id=\"挂起协程\"><a href=\"#挂起协程\" class=\"headerlink\" title=\"挂起协程\"></a>挂起协程</h3><p>协程的强大之处在于函数 <code>coroutine.yield</code>，该函数可以让一个运行中的协程挂起自己，然后在后续执行中恢复运行：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">co = coroutine.<span class=\"built_in\">create</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, <span class=\"number\">10</span> <span class=\"keyword\">do</span></span><br/><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#34;co&#34;</span>, i)</span><br/><span class=\"line\">        coroutine.<span class=\"built_in\">yield</span>()</span><br/><span class=\"line\">    <span class=\"keyword\">end</span></span><br/><span class=\"line\"><span class=\"keyword\">end</span>)</span><br/></pre></td></tr></tbody></table></figure>\n<p>上面协程运行着一个循环，在循环中打印输出一个数字后遇到 <code>yield</code> 进入挂起状态：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">coroutine.<span class=\"built_in\">resume</span>(co) <span class=\"comment\">--&gt; co 1</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>此时我们可以查看协程状态，会发现协程处于挂起状态：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(coroutine.<span class=\"built_in\">status</span>(co)) <span class=\"comment\">--&gt; suspended</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>我们可以继续运行，直到上面 for 循环执行结束：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">coroutine.<span class=\"built_in\">resume</span>(co) <span class=\"comment\">--&gt; co 2</span></span><br/><span class=\"line\">coroutine.<span class=\"built_in\">resume</span>(co) <span class=\"comment\">--&gt; co 3</span></span><br/><span class=\"line\">    ...</span><br/><span class=\"line\">coroutine.<span class=\"built_in\">resume</span>(co) <span class=\"comment\">--&gt; co 10</span></span><br/><span class=\"line\">coroutine.<span class=\"built_in\">resume</span>(co) <span class=\"comment\">--&gt; 不输出任何数据</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>当最后一次调用 resume 时，协程体执行完毕并返回，不会输出任何数据，如果我们试图再次唤醒它，函数 resume 会返回 false 已经一条错误信息：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(coroutine.<span class=\"built_in\">resume</span>(co)) <span class=\"comment\">--&gt; false  cannot resume dead coroutine</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>请注意，resume 函数运行在保护模式中，如果协程出错，Lua 不会显示错误信息，而是将错误信息返回给 resume 函数。</p>\n<p>当协程 A 唤醒协程 B 时，协程 A 不是挂起状态（因为不能唤醒协程A），而不是运行状态（因为正在运行协程B），此时的状态称之为<strong>正常状态</strong>。</p>\n<h3 id=\"交换数据\"><a href=\"#交换数据\" class=\"headerlink\" title=\"交换数据\"></a>交换数据</h3><p>协程中一个非常有用的机制是通过一对 <code>resume-yield</code> 来交换数据。第一个 <code>resume</code> 函数会把所有的额外参数传递给协程的主函数：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">co = coroutine.<span class=\"built_in\">create</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(a, b, c)</span></span></span><br/><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#34;co&#34;</span>, a, b, c)</span><br/><span class=\"line\">    <span class=\"keyword\">end</span>)</span><br/><span class=\"line\"></span><br/><span class=\"line\">coroutine.<span class=\"built_in\">resume</span>(co, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">--&gt; co 1 2 3</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>函数 <code>resume</code> 第一个返回值为 <code>true</code> 时表示没有错误，之后的返回值对应函数 <code>yield</code> 的参数：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">co = coroutine.<span class=\"built_in\">create</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(a, b)</span></span></span><br/><span class=\"line\">        coroutine.<span class=\"built_in\">yield</span>(a + b, a - b)</span><br/><span class=\"line\">    <span class=\"keyword\">end</span>)</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"built_in\">print</span>(coroutine.<span class=\"built_in\">resume</span>(co, <span class=\"number\">10</span>, <span class=\"number\">20</span>)) <span class=\"comment\">--&gt; true  30  -10</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>函数 <code>yield</code> 返回值则会对应 <code>resume</code> 的参数：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">co = coroutine.<span class=\"built_in\">create</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(x)</span></span></span><br/><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#34;co1&#34;</span>, x)</span><br/><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#34;co2&#34;</span>, coroutine.<span class=\"built_in\">yield</span>())</span><br/><span class=\"line\">    <span class=\"keyword\">end</span>)</span><br/><span class=\"line\"></span><br/><span class=\"line\">coroutine.<span class=\"built_in\">resume</span>(co, <span class=\"string\">&#34;hi&#34;</span>) <span class=\"comment\">--&gt; co1    hi</span></span><br/><span class=\"line\">coroutine.<span class=\"built_in\">resume</span>(co, <span class=\"number\">4</span>, <span class=\"number\">5</span>) <span class=\"comment\">--&gt; co2    4    5</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>当协程运行结束后，主函数所返回的值将变成对应函数 <code>resume</code> 的返回值：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">co = coroutine.<span class=\"built_in\">create</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br/><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br/><span class=\"line\">    <span class=\"keyword\">end</span>)</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"built_in\">print</span>(coroutine.<span class=\"built_in\">resume</span>(co)) <span class=\"comment\">--&gt; true    1    2</span></span><br/></pre></td></tr></tbody></table></figure>\n<h2 id=\"使用协程解决生产者于消费者问题\"><a href=\"#使用协程解决生产者于消费者问题\" class=\"headerlink\" title=\"使用协程解决生产者于消费者问题\"></a>使用协程解决生产者于消费者问题</h2><p>生产者-消费者设计两个函数，一个函数不断的生成值，而另外一个函数则不断的消费这些值，我们可以看以下代码实现：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">true</span> <span class=\"keyword\">do</span></span><br/><span class=\"line\">        <span class=\"keyword\">local</span> x = <span class=\"built_in\">io</span>.<span class=\"built_in\">read</span>() <span class=\"comment\">-- 生产新值</span></span><br/><span class=\"line\">        send(x)             <span class=\"comment\">-- 发送给消费者</span></span><br/><span class=\"line\">    <span class=\"keyword\">end</span></span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">send</span><span class=\"params\">(x)</span></span></span><br/><span class=\"line\">    coroutine.<span class=\"built_in\">yield</span>(x)</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">consume</span><span class=\"params\">()</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">true</span> <span class=\"keyword\">do</span></span><br/><span class=\"line\">        <span class=\"keyword\">local</span> x = receive() <span class=\"comment\">-- 接受来自生产者的值</span></span><br/><span class=\"line\">        <span class=\"built_in\">io</span>.<span class=\"built_in\">write</span>(x, <span class=\"string\">&#34;n&#34;</span>)   <span class=\"comment\">-- 消费</span></span><br/><span class=\"line\">    <span class=\"keyword\">end</span></span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">receive</span><span class=\"params\">()</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">local</span> <span class=\"built_in\">status</span>, value = coroutine.<span class=\"built_in\">resume</span>(producer)</span><br/><span class=\"line\">    <span class=\"keyword\">return</span> value</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">producer = coroutine.<span class=\"built_in\">create</span>(producer) <span class=\"comment\">-- 生成者在协程里面运行</span></span><br/><span class=\"line\">consume() <span class=\"comment\">-- 通过消费者启动</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>上面这种设计中，程序通过消费者启动。当消费者需要新值时就唤醒生成者，生成者向消费者返回新值后挂起，知道消费者再次将其唤醒。因此这种设计称之为消费者驱动式设计。</p>","text":"从多线程的角度来看，协程（coroutine）与线程（thread）类似：协程时一系列的可执行语句，拥有自己的栈、局部变量和指令指针，同时协程又与其他协程共享全局变量和其他几乎一切资源。 协程与线程的主要区别在于，一个多线程程序可以并行运行多个线程，而协程则需要彼此协作运行，即在...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">协程基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">创建协程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">运行协程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%82%E8%B5%B7%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">挂起协程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">交换数据</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85%E4%BA%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">使用协程解决生产者于消费者问题</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"nginx+lua+kafka实现日志统一收集汇总","uid":"3c02d14da55f3251895a502fc2ba732a","slug":"zl/2016-01-01-167_nginx+lua+kafka实现日志统一收集汇总","date":"2024-04-03T03:47:33.054Z","updated":"2024-04-03T03:47:33.055Z","comments":true,"path":"api/articles/zl/2016-01-01-167_nginx+lua+kafka实现日志统一收集汇总.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"一:场景描述对于线上大流量服务或者需要上报日志的nginx服务，每天会产生大量的日志，这些日志非常有价值。可用于计数上报、用户行为分析、接口质量、性能监控等需求。但传统nginx记录日志的方式数据会散落在各自nginx上，而且大流量日志本身对磁盘也是一种冲击。 我们需要把这部分n...","link":"","photos":[],"count_time":{"symbolsCount":"9.9k","symbolsTime":"9 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua 字节码(bytecode)","uid":"fda0c45591840129c17ad8c1798634bd","slug":"zl/2016-01-01-166_lua 字节码(bytecode)","date":"2024-04-03T03:47:33.053Z","updated":"2024-04-03T03:47:33.054Z","comments":true,"path":"api/articles/zl/2016-01-01-166_lua 字节码(bytecode).json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" lua字节码 字节码格式 源码案例： 对应字节码： 指令解释： 指令分类 所有指令 lua字节码 lua虚拟机最终执行的是经过lua编译器编译的字节码，这里暂不关系Chunk生成字节码过程， 只关系字节码本身，字节码的格式到底是什么样？具体的含义是什么？ 字节码格式 lua字节...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}