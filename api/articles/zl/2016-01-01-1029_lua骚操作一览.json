{"title":"lua骚操作一览","uid":"3d246ac977a7b510c17a843ba9ddc5b7","slug":"zl/2016-01-01-1029_lua骚操作一览","date":"2024-04-03T03:47:32.972Z","updated":"2024-04-03T03:47:32.973Z","comments":true,"path":"api/articles/zl/2016-01-01-1029_lua骚操作一览.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>做了三年的游戏开发，其中有两年都在使用Lua这一脚本语言，想着是时候写点什么东西输出一下，算是给个交代。本文既不是讲Lua入门，也不会讲到Lua虚拟机那么深，读者尽可放大心随意看。</p>\n<h2 id=\"类的实现\"><a href=\"#类的实现\" class=\"headerlink\" title=\"类的实现\"></a>类的实现</h2><p>原生Lua是不支持面向对象编程的。那怎么办呢？使用prototype模式即可。</p>\n<p>首先读者需要知道Lua的原方法和原表这一知识点。如果接触过c++或者c#的同学应该知道我们可以对一些类的操作做重载(<em>overload</em>)，改变诸如加减乘除，甚至一些更高级的操作。而在像是Lua这种脚本语言来说是没有重载这一操作的。取而代之的，我们可以通过重写元表来改变table原有的操作逻辑。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> theMetaTable = {}</span><br/><span class=\"line\"></span><br/><span class=\"line\">theMetaTable.<span class=\"built_in\">__add</span> = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(leftVal, rightVal)</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">local</span> ret = {}</span><br/><span class=\"line\">    ret.age = leftVal.age + rightVal.age</span><br/><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">local</span> tA = {age = <span class=\"number\">1</span>}</span><br/><span class=\"line\"><span class=\"keyword\">local</span> tB = {age = <span class=\"number\">99</span>}</span><br/><span class=\"line\"><span class=\"built_in\">setmetatable</span>(tA, theMetaTable)</span><br/><span class=\"line\"><span class=\"built_in\">setmetatable</span>(tB, theMetaTable)</span><br/><span class=\"line\"><span class=\"keyword\">local</span> tC = tA + tB</span><br/><span class=\"line\"><span class=\"comment\">-- tC = {age = 100}</span></span><br/><span class=\"line\"><span class=\"built_in\">print</span>(tc.age)</span><br/></pre></td></tr></tbody></table></figure>\n<p>在这么多元方法里面有一个最值得关注的，称为<code>__index</code>。顾名思义，传入一个key，返回一个value。接下来就来讲解如何使用这个元方法实现面向对象。首先我们假设有一个方法叫做<code>class(string name)</code>，会生成一个带有构造方法和其他各种方法的类原型（类原型是啥意思？类似于Java里的Class，c#里的Type），我们使用这个类原型就可以实例化出我们的实例来。使用方法大概是这样子的：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">Person = class(<span class=\"string\">&#39;class&#39;</span>)</span><br/><span class=\"line\">Person.name = <span class=\"string\">&#39;DefaultName&#39;</span></span><br/><span class=\"line\">Person.age = <span class=\"number\">-1</span>;</span><br/><span class=\"line\">Person.sex = <span class=\"string\">&#39;male&#39;</span></span><br/><span class=\"line\">Person.<span class=\"built_in\">create</span> = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(name, age)</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">local</span> ret = Person.new()</span><br/><span class=\"line\">    ret.name = name</span><br/><span class=\"line\">    ret.age = age</span><br/><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\">Person.introduce = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(self)</span></span></span><br/><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&#39;i am %s, and i am %d&#39;</span>, self.name, self.age))</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">local</span> oldWong = Person.<span class=\"built_in\">create</span>(<span class=\"string\">&#39;oldWong&#39;</span>, <span class=\"number\">45</span>)</span><br/><span class=\"line\">oldWong.sex = <span class=\"string\">&#39;female&#39;</span></span><br/><span class=\"line\">oldWong:introduce()</span><br/><span class=\"line\"><span class=\"comment\">-- console print: I am oldWong, and i am 45.</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>明眼的读者可以发现了：从class函数返回的<code>Person</code>一定是一个带着new方法的table。但是为什么这个new方法会生成新的实例呢？我改变oldWong实例的<code>sex</code>属性之后，再用Person去实例化一个实例，会是什么性别？有兴趣的读者可自行试试。</p>\n<p>接下来笔者将为你揭秘<code>__index</code>方法在<code>class(string name)</code>函数中的应用。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(clzName)</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">local</span> ret = {}</span><br/><span class=\"line\">    ret.__class = {}</span><br/><span class=\"line\">    ret.__class.__name = clzName</span><br/><span class=\"line\">    ret.new = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br/><span class=\"line\">        <span class=\"keyword\">local</span> instance</span><br/><span class=\"line\">        <span class=\"comment\">-- metatable</span></span><br/><span class=\"line\">        <span class=\"keyword\">local</span> mt = {}</span><br/><span class=\"line\">        mt.<span class=\"built_in\">__index</span> = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(t, key)</span></span></span><br/><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">rawget</span>(instance, key) <span class=\"keyword\">or</span> ret[key]</span><br/><span class=\"line\">        <span class=\"keyword\">end</span></span><br/><span class=\"line\">        <span class=\"built_in\">setmetatable</span>(instance, mt)</span><br/><span class=\"line\">        <span class=\"keyword\">return</span> instance</span><br/><span class=\"line\">    <span class=\"keyword\">end</span></span><br/><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>看一个函数我习惯先看最后return了什么东西，再看这个返回值是怎么被创建的，内容是啥。在这个<code>class</code>方法中，返回值是一个被命名为ret的表，这个表被填进了两个东西：</p>\n<ul>\n<li>类的信息，暂时只有类名</li>\n<li>一个叫做new的方法</li>\n</ul>\n<p>看起来这个new方法就是关键了。</p>\n<p>new方法最后返回了一个叫instance的table，这个看似什么内容都没有。等等…并不是什么东西都没有，这个table被塞进了一个元表(metatable)，而这个元表被重写了<code>__index</code>方法。</p>\n<p><code>__index</code>方法实际上是为了定义一种行为：传进一个key，返回一个value。也就是说根据上面的代码，当mt这个表被设置为instance的元表之后，当以后外界要从instance取东西出去的时候，会先在表本身里面找(rawget)，如果找不到了，再继续在找ret表里面找。</p>\n<p>看完上面的解释，我相信还是有一部分读者会睁着大眼睛问我，你说了这么多，那和面向对象有鸡毛关系？没事，笔者这篇文章本来就是想写给对Lua了解不深的朋友看的，所以一定会解释清楚。</p>\n<p>我们要知道，在Lua中，方法其实是一个内置类型，成为function。当一个表想调用自己拥有的一个方法的时候有两种形式：</p>\n<ul>\n<li>t.function(t)</li>\n<li>t:function()</li>\n</ul>\n<p>上面两种形式是等效的，使用冒号连接的时候，会把冒号前面的变量作为后面方法的第一个变量传入。</p>\n<p>在上面关于Person的代码例子中，有一句代码我们来看看是怎么最后调用成功的。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">oldWong:introduce()</span><br/></pre></td></tr></tbody></table></figure>\n<p>在调用<code>introduce()</code>之前，Lua需要先从oldWong这个表中拿出这个属性。这是一种以key换value的操作，于是自然会调用到<code>__index</code>元方法。首先Lua会在oldWong本身中找这个方法，找不到，然后就会在<code>__index</code>那段代码里的ret表里面找。还记得ret最后被返回，被我们持有为叫做Person的表了吗？</p>\n<p>所以’oldWong:introduce()’的实质调用，可以看做是</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">Person.introduce(oldWong)</span><br/></pre></td></tr></tbody></table></figure>\n<p>明白了吧。</p>\n<h3 id=\"老王的叛逆\"><a href=\"#老王的叛逆\" class=\"headerlink\" title=\"老王的叛逆\"></a>老王的叛逆</h3><p>接下来，我们假设老王是一个很叛逆的人，他不想按照我们给他的方法进行自我介绍，想要用自己的方式来展示足够骚的自己，他怎么做呢：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">oldWong.introduce = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(self)</span></span></span><br/><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#39;i am Xiao Wang, bu yiyang de Xiao Wang&#39;</span>)</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">oldWong.introduce()</span><br/></pre></td></tr></tbody></table></figure>\n<p>老王他重写了自己的introduce方法。现在再从老王这个<del>婊</del>表中再读出introdce这个成员变量的时候，由于老王本身就已经拥有了自我介绍这个方法，于是就直接返回这个方法，不需要再从类里面去寻找原始的introduce方法了。于是老王的自我介绍就自成一派了。</p>\n<p>在老王叛逆的故事中，我们可以学到一种debug的方法。在我两年的lua使用时间中，其中一年半是在使用cocos2dx的，以这里为例子解释一下如何使用这个原理来快速debug。</p>\n<p>cocos2dx的节点Node类有一个<code>addChild(self, childNode)</code>方法，用来添加一个子节点。现在我发现游戏中有一个节点oldWongNode，莫名其妙地添加了一个叫做runNode的节点，但是由于前人写的代码太冗长太垃圾，找了半天都找不到究竟这个子节点是在哪里被添加的。这个时候我想起了老王的故事，这么写了一段代码，然后发现了究竟是哪个<del>凶手</del>同事调用了调用了这个方法添加了runNode：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> rawAddChild = oldWongNode.addChild</span><br/><span class=\"line\">oldWongNode.addChild = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(self, child)</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">if</span> child.name == <span class=\"string\">&#39;runNode&#39;</span>:</span><br/><span class=\"line\">        printTraceback()</span><br/><span class=\"line\">    <span class=\"keyword\">end</span></span><br/><span class=\"line\">    rawAddChild(self, child)</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>未完待续。。。</p>","text":"前言做了三年的游戏开发，其中有两年都在使用Lua这一脚本语言，想着是时候写点什么东西输出一下，算是给个交代。本文既不是讲Lua入门，也不会讲到Lua虚拟机那么深，读者尽可放大心随意看。 类的实现原生Lua是不支持面向对象编程的。那怎么办呢？使用prototype模式即可。 首先读...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">类的实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%80%81%E7%8E%8B%E7%9A%84%E5%8F%9B%E9%80%86\"><span class=\"toc-text\">老王的叛逆</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"编译找不到lua","uid":"b728025e73cbf76259fbac850d16605b","slug":"zl/2016-01-01-1027_编译找不到lua","date":"2024-04-03T03:47:32.972Z","updated":"2024-04-03T03:47:32.972Z","comments":true,"path":"api/articles/zl/2016-01-01-1027_编译找不到lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"cmake . -DLUA_INCLUDE_DIR=/usr/local/include/ -DLUA_LIBRARY=/usr/local/lib/liblua.a &lt;h4&gt;See also&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;&lt;a...","link":"","photos":[],"count_time":{"symbolsCount":853,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"服务器端图片压缩之nginx+lua_nginx module+graphicsmagick","uid":"be939c17a900adc440adcbd16c0ca61d","slug":"zl/2016-01-01-1028_服务器端图片压缩之nginx+lua_nginx module+graphicsmagick","date":"2024-04-03T03:47:32.972Z","updated":"2024-04-03T03:47:32.972Z","comments":true,"path":"api/articles/zl/2016-01-01-1028_服务器端图片压缩之nginx+lua_nginx module+graphicsmagick.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 在开发电子商务网站时，同一个图片需要不同尺寸的缩略图片，一般有两种策略生成缩略图，一种在上传图片时，生成需要的缩略图，另一种是请求指定尺寸的图片时生存缩略图片，第一种方式有一定限制，就是需要提前知道所有尺寸的图片，如果前端ui设计改变了图片大小，需要重新生成。而第二种方式更加灵...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}