{"title":"十七、考虑使用Lazy evaluation(缓式评估)","uid":"32bd7dd57d3e1030842c4b81dd5b8aea","slug":"zl/2016-01-01-714_十七、考虑使用Lazy evaluation(缓式评估)","date":"2024-04-03T03:47:35.946Z","updated":"2024-04-03T03:47:35.947Z","comments":true,"path":"api/articles/zl/2016-01-01-714_十七、考虑使用Lazy evaluation(缓式评估).json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p><strong>从效率上看，最好的运算是从未执行过的运算。</strong></p>\n<p><strong>拖延战术——缓式评估</strong></p>\n<ul>\n<li>在真正需要之前，不必急着为某物做一个副本，取而代之的是以拖延战术的方式——只要能够，就是使用其它副本</li>\n</ul>\n<h1 id=\"二、区分读和写\"><a href=\"#二、区分读和写\" class=\"headerlink\" title=\"二、区分读和写\"></a>二、区分读和写</h1><ul>\n<li>运用lazy evaluation和proxy classes（条款30），可以延迟决定读还是写</li>\n</ul>\n<h1 id=\"三、Lazy-Fetching（缓式取出）\"><a href=\"#三、Lazy-Fetching（缓式取出）\" class=\"headerlink\" title=\"三、Lazy Fetching（缓式取出）\"></a>三、Lazy Fetching（缓式取出）</h1><ol>\n<li>当程序使用大型对象，内含许多字段。</li>\n<li>在产生对象时，只产生一个该对象的外壳，不从磁盘读取数据。当对象内的某个字段被需要了，才取回对应数据。</li>\n<li>mutable的意思是这个属性的变量可以在任何member function内被修改，即使是const member function内产生一个pointer-to-non-const指向this所指对象，当需要修改某个data member时，通过这个冒牌的this指针来修改，可以在const member function内部利用<code>const_cast</code>将<code>* this</code>的常量性滤掉，如果编译器不支持<code>const_cast</code>就用C语法的类型转换。</li>\n</ol>\n<h1 id=\"四、Lazy-Expression-Evaluation（表达式缓式评估）\"><a href=\"#四、Lazy-Expression-Evaluation（表达式缓式评估）\" class=\"headerlink\" title=\"四、Lazy Expression Evaluation（表达式缓式评估）\"></a>四、Lazy Expression Evaluation（表达式缓式评估）</h1><h1 id=\"五、摘要\"><a href=\"#五、摘要\" class=\"headerlink\" title=\"五、摘要\"></a>五、摘要</h1><ol>\n<li>Lazy evaluation在许多领域都有应用，可避免非必要的对象复制，可以区别operator[]的读写动作，可以避免非必要的数据库读取动作，可以避免非必要的数值计算动作。</li>\n<li>只有当你的软件被要求执行某些计算，而那些计算其实可以避免的情况下，lazy evaluation才有用处</li>\n<li>C++特别合适作为“用户完成的Lazy evaluation”的载体，因为它支持封装性质，是我们可以把Lazy evaluation加入某个class内而不必让客户知道。</li>\n</ol>\n<pre><code>杜鹏\n2013-7-23\n</code></pre>","text":"从效率上看，最好的运算是从未执行过的运算。 拖延战术——缓式评估 在真正需要之前，不必急着为某物做一个副本，取而代之的是以拖延战术的方式——只要能够，就是使用其它副本 二、区分读和写 运用lazy evaluation和proxy classes（条款30），可以延迟决定读还是写...","link":"","photos":[],"count_time":{"symbolsCount":742,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%8C%BA%E5%88%86%E8%AF%BB%E5%92%8C%E5%86%99\"><span class=\"toc-text\">二、区分读和写</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81Lazy-Fetching%EF%BC%88%E7%BC%93%E5%BC%8F%E5%8F%96%E5%87%BA%EF%BC%89\"><span class=\"toc-text\">三、Lazy Fetching（缓式取出）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81Lazy-Expression-Evaluation%EF%BC%88%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BC%93%E5%BC%8F%E8%AF%84%E4%BC%B0%EF%BC%89\"><span class=\"toc-text\">四、Lazy Expression Evaluation（表达式缓式评估）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E6%91%98%E8%A6%81\"><span class=\"toc-text\">五、摘要</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"In place iterative policy evaluation","uid":"e2c63129883e8fe4288a47221458cc20","slug":"zl/2016-01-01-713_In place iterative policy evaluation","date":"2024-04-03T03:47:35.946Z","updated":"2024-04-03T03:47:35.946Z","comments":true,"path":"api/articles/zl/2016-01-01-713_In place iterative policy evaluation.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;Iterative Policy Evaluation的迭代过程一般有两种方式：&lt;/p&gt; 使用两个数组，其中一个数组存储上一轮迭代的状态价值，另外一个数组存储本轮迭代中的状态价值，本轮迭代总是从上一轮迭代（老的）的状态价值取值，这样在迭代过程中老的...","link":"","photos":[],"count_time":{"symbolsCount":448,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua读取redis数据的null判断","uid":"f3a7845e6db0af3e539b51ace62eadf8","slug":"zl/2016-01-01-712_lua读取redis数据的null判断","date":"2024-04-03T03:47:35.946Z","updated":"2024-04-03T03:47:35.946Z","comments":true,"path":"api/articles/zl/2016-01-01-712_lua读取redis数据的null判断.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"最近在配合移动端调试的时候，被抓去debug一个在清除redis缓存之后才会出现的网关错误。于是打开服务器上的log定位到类似错误: 1[error] 7#7: *12030 lua entry thread aborted: runtime error: /data/share...","link":"","photos":[],"count_time":{"symbolsCount":964,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}