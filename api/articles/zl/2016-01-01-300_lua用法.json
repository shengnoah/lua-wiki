{"title":"lua用法","uid":"df9754f22ae84a5478ce5d4d534e5759","slug":"zl/2016-01-01-300_lua用法","date":"2024-04-03T03:47:35.574Z","updated":"2024-04-03T03:47:35.575Z","comments":true,"path":"api/articles/zl/2016-01-01-300_lua用法.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>从给定的字符串得到块(函数)。lua5.3使用load()替换loadstring(). </p>\n<p>一般如下用法：<br/><code>assert(loadstring(script))()</code><br/><code>f = loadstring(&#34;a = 1&#34;)</code><br/>语义上相当于：<br/><code>f = loadstring(&#34;function() a = 1 end&#34;)</code><br/>复杂用法如下：<br/>下面是动态加载字符串，并执行，结果为一个table       </p>\n<pre><code>local script = &#34;localee=&#123;[0]=&#123;id=0,lv=5,text=&#39;yy&#39;&#125;,[1]=&#123;id=1,lv=3,text=&#39;zz&#39;&#125;&#125;  return ee&#34;  \nlocal tb=assert(loadstring(script))()  \nprint(tb[0].text)  \n</code></pre><p>下面是动态加载字符串，并执行，结果为方法</p>\n<pre><code>local addscript=&#34;function dadd(a,b) return a+b  end&#34;  \nassert(loadstring(addscript))()  \nprint(tostring(dadd(2,3)))  \n</code></pre><pre><code>local f = load(&#34;a=1+2&#34;)\nprint(type(f))  --function\n</code></pre><h1 id=\"loadfile\"><a href=\"#loadfile\" class=\"headerlink\" title=\"loadfile\"></a>loadfile</h1><p>loadfile 编译Lua外部代码块，但不会运行代码，将会以函数的形式返回编译结果.返回编译结果函数.</p>\n<pre><code>local f = laodfile(&#34;a.lua&#34;)\nprint(type(f)) --function\n</code></pre><h1 id=\"dofile\"><a href=\"#dofile\" class=\"headerlink\" title=\"dofile\"></a>dofile</h1><p>dofile 直接编译运行Lua外部代码块，并不返回任何结果。编译错误会返回nil.  </p>\n<pre><code>function dofile(filename)\n    local func = assert(loadfile(filename))\n    func()\nend\n</code></pre><h1 id=\"load\"><a href=\"#load\" class=\"headerlink\" title=\"load\"></a>load</h1><p><code>load (chunk [, chunkname [, mode [, env]]])</code><br/>加载一个代码块。<br/>如果 chunk 是一个字符串，代码块指这个字符串。 如果 chunk 是一个函数， load 不断地调用它获取代码块的片断。 每次对 chunk 的调用都必须返回一个字符串紧紧连接在上次调用的返回串之后。 当返回空串、nil、或是不返回值时，都表示代码块结束。</p>\n<p>如果结果函数有上值， env 被设为第一个上值。 若不提供此参数，将全局环境替代它。<br/>chunkname 在错误消息和调试消息中，用于代码块的名字。<br/>字符串 mode 用于控制代码块是文本还是二进制（即预编译代码块）。 它可以是字符串 “b” （只能是二进制代码块）， “t” （只能是文本代码块）， 或 “bt” （可以是二进制也可以是文本）。 默认值为 “bt”。       </p>\n<h1 id=\"ENV\"><a href=\"#ENV\" class=\"headerlink\" title=\"_ENV\"></a>_ENV</h1><p>引用一个叫 var 的自由名字在句法上都被翻译为 _ENV.var 。 此外，每个被编译的 Lua 代码块都会有一个外部的局部变量叫 _ENV。</p>\n<p> 这里特别指出，你可以定义一个新变量或指定一个参数叫这个名字。    当编译器在转译自由名字时所用到的 _ENV ， 指的是你的程序在那个点上可见的那个名为 _ENV 的变量<br/>被 _ENV 用于值的那张表被称为 环境。   </p>\n<p>Lua保有一个被称为 全局环境 特别环境。它被保存在 C 注册表的一个特别索引下。<br/>在 Lua 中，全局变量 _G 被初始化为这个值。 </p>\n<p>当 Lua 加载一个代码块，_ENV 这个上值的默认值就是这个全局环境。         因此，在默认情况下，Lua 代码中提及的自由名字都指的全局环境中的相关项        （它们也被称为 全局变量 ）。<br/>此外，所有的标准库都被加载入全局环境，一些函数也针对这个环境做操作。 你可以用 load （或 loadfile）加载代码块，并赋予它们不同的环境。 （在 C 里，当你加载一个代码块后，可以通过改变它的第一个上值来改变它的环境。）    </p>\n<h1 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h1><p>如果 index 是个数字， 那么返回参数中第 index 个之后的部分； 负的数字会从后向前索引（-1 指最后一个参数）。 否则，index 必须是字符串 “#”， 此时 select 返回参数的个数。 </p>\n<pre><code>do  \n    function foo(...)  \n        for i = 1, select(&#39;#&#39;, ...) do //get the count of the params  \n            local arg = select(i, ...);//select the param  \n            print(&#34;arg&#34;, arg);  \n        end  \n    end  \n<pre><code>foo(1, 2, 3, 4);  \n</code></pre>\n<p>end<br />\n</code></pre><h1 id=\"next\"><a href=\"#next\" class=\"headerlink\" title=\"next\"></a>next</h1><p><code>next (table [, index])</code><br/>允许程序遍历表的所有字段。它的第一个参数是一个表，它的第二个参数是该表的索引。接下来返回表及其关联值的一个索引。</p></p>\n<pre><code>local tee = &#123;1, 3, 4, 6, 8&#125;\n\nt = &#123;3,7,10,17, pi=3.14159, banana=&#34;yellow&#34;&#125;\nfor key,value in next,t,nil do\n print(key,value)\nend\n\nfunction pairs (t)\n    return next, t, nil\nend\n\nfor k, v in pairs(t) do\n    print(k, v)\nend\n</code></pre><h1 id=\"pcall\"><a href=\"#pcall\" class=\"headerlink\" title=\"pcall\"></a>pcall</h1><p><code>pcall (f [, arg1, ···])</code></p>\n<p>传入参数，以 保护模式 调用函数 f 。 这意味着 f 中的任何错误不会抛出； 取而代之的是，pcall 会将错误捕获到，并返回一个状态码。 第一个返回值是状态码（一个布尔量）， 当没有错误时，其为真。 此时，pcall 同样会在状态码后返回所有调用的结果。 在有错误时，pcall 返回 false 加错误消息。</p>\n<p><code>local ret, msg = pcall(function(i) print(i) end, 33)</code></p>\n<h1 id=\"xpcall\"><a href=\"#xpcall\" class=\"headerlink\" title=\"xpcall\"></a>xpcall</h1><p><code>xpcall (f, msgh [, arg1, ···])</code><br/>这个函数和 pcall 类似。 不过它可以额外设置一个消息处理器 msgh。</p>\n<pre><code>local function __TRACKBACK__(errmsg)\n    local track_text = debug.traceback(tostring(errmsg), 6);\n    print(track_text, &#34;LUA ERROR&#34;);\n    return false;\nend\n<p>local function trycall(func, …)<br />\nlocal args = &#123; … &#125;;<br />\nreturn xpcall(function() func(unpack(args)) end, <strong>TRACKBACK</strong>);<br />\nend</p>\n<p>local function test(aaa)<br />\nprint(&quot;#&quot;…aaa)<br />\nend</p>\n<p>trycall(test, nil)<br />\n</code></pre><h1 id=\"多行文本\"><a href=\"#多行文本\" class=\"headerlink\" title=\"多行文本\"></a>多行文本</h1><p>使用[[ sun feng sunfeng ]]  定义多行文本。</p></p>\n","text":"从给定的字符串得到块(函数)。lua5.3使用load()替换loadstring(). 一般如下用法：assert(loadstring(script))()f = loadstring(&#34;a = 1&#34;)语义上相当于：f = loadstring(&#34;fu...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#loadfile\"><span class=\"toc-text\">loadfile</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#dofile\"><span class=\"toc-text\">dofile</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#load\"><span class=\"toc-text\">load</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ENV\"><span class=\"toc-text\">_ENV</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#select\"><span class=\"toc-text\">select</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#next\"><span class=\"toc-text\">next</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pcall\"><span class=\"toc-text\">pcall</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#xpcall\"><span class=\"toc-text\">xpcall</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC\"><span class=\"toc-text\">多行文本</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"luasocket getaddrinfo nil 问题","uid":"f597dc45b4c99d9cbe30780591e468ce","slug":"zl/2016-01-01-301_luasocket getaddrinfo nil 问题 ","date":"2024-04-03T03:47:35.576Z","updated":"2024-04-03T03:47:35.577Z","comments":true,"path":"api/articles/zl/2016-01-01-301_luasocket getaddrinfo nil 问题 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"使用 luarocks 安装 luasocket，在调用 bind 时，报： socket.lua:29: attempt to call field ‘getaddrinfo’ (a nil value) 继续执行以下 lua 代码片段： Lua 5.1.4 Copyright...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua用法2","uid":"c37eb63e9dd840d90dbfe0cd24262c50","slug":"zl/2016-01-01-298_lua用法2","date":"2024-04-03T03:47:33.154Z","updated":"2024-04-03T03:47:33.154Z","comments":true,"path":"api/articles/zl/2016-01-01-298_lua用法2.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"从给定的字符串得到块(函数)。lua5.3使用load()替换loadstring(). 一般如下用法：assert(loadstring(script))()f = loadstring(&#34;a = 1&#34;)语义上相当于：f = loadstring(&#34;fu...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}