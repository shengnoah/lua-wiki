{"title":"lua","uid":"df60e476b394b1dd4755ec96c53302ff","slug":"zl/2016-01-01-258_lua","date":"2024-04-03T03:47:33.121Z","updated":"2024-04-03T03:47:33.121Z","comments":true,"path":"api/articles/zl/2016-01-01-258_lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>    &lt;p&gt;Lua支持两种形式的函数调用，一种对调用过程的堆栈进行保护，即使中间过程出错，也不至于让进程退出，也就是pcall，一般在使用C调用Lua写的脚本函数时，都采用pcall方式。&lt;/p&gt;\n</code></pre>\n<p>对比起一般的函数调用方式，pcall多做了这些事情：</p>\n<p>对函数调用前的Lua堆栈进行保护在调用完毕之后恢复，支持传入出错时的函数在调用出错时调用。</p>\n<p>来依次看这个过程。</p>\n<ol>\n<li>首先看入口函数lua_pcall：</li>\n</ol>\n<pre><code>LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc) &#123;\n  struct CallS c;\n  int status;\n  ptrdiff_t func;\n  lua_lock(L);\n  api_checknelems(L, nargs+1);\n  checkresults(L, nargs, nresults);\n  if (errfunc == 0)\n    func = 0;\n  else &#123;\n    StkId o = index2adr(L, errfunc);\n    api_checkvalidindex(L, o);\n    func = savestack(L, o);\n  &#125;\n  c.func = L-&gt;top - (nargs+1);  /* function to be called */\n  c.nresults = nresults;\n  status = luaD_pcall(L, f_call, &amp;c, savestack(L, c.func), func);\n  adjustresults(L, nresults);\n  lua_unlock(L);\n  return status;\n&#125;\n</code></pre><p>lua_pcall函数与lua_call相比，多了第四个参数，该函数用于传入错误处理函数在Lua栈中的地址。所以第一步将根据传入的参数得到它的值在函数栈中的地址。然后根据这些参数调用函数luaD_pcall函数。</p>\n<ol start=\"2\">\n<li>luaD_pcall的实现</li>\n</ol>\n<pre><code>int luaD_pcall (lua_State *L, Pfunc func, void *u,\n                ptrdiff_t old_top, ptrdiff_t ef) &#123;\n  int status;\n  unsigned short oldnCcalls = L-&gt;nCcalls;\n  ptrdiff_t old_ci = saveci(L, L-&gt;ci);\n  lu_byte old_allowhooks = L-&gt;allowhook;\n  ptrdiff_t old_errfunc = L-&gt;errfunc;\n  L-&gt;errfunc = ef;\n  status = luaD_rawrunprotected(L, func, u);\n  if (status != 0) &#123;  /* an error occurred? */\n    StkId oldtop = restorestack(L, old_top);\n    luaF_close(L, oldtop);  /* close eventual pending closures */\n    luaD_seterrorobj(L, status, oldtop);\n    L-&gt;nCcalls = oldnCcalls;\n    L-&gt;ci = restoreci(L, old_ci);\n    L-&gt;base = L-&gt;ci-&gt;base;\n    L-&gt;savedpc = L-&gt;ci-&gt;savedpc;\n    L-&gt;allowhook = old_allowhooks;\n    restore_stack_limit(L);\n  &#125;\n  L-&gt;errfunc = old_errfunc;\n  return status;\n&#125;\n</code></pre><p>这个函数首先将一些需要保存以便以后进行错误恢复的值保存，然后调用函数luaD_rawrunprotected。</p>\n<ol start=\"3\">\n<li>在luaD_rawrunprotected中，</li>\n</ol>\n<pre><code>int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) &#123;\n  struct lua_longjmp lj;\n  lj.status = 0;\n  lj.previous = L-&gt;errorJmp;  /* chain new error handler */\n  L-&gt;errorJmp = &amp;lj;\n  LUAI_TRY(L, &amp;lj,\n    (*f)(L, ud);\n  );\n  L-&gt;errorJmp = lj.previous;  /* restore old error handler */\n  return lj.status;\n&#125;\n</code></pre><p>可以看到的是，在Lua中，涉及到这些错误恢复的数据，实际上形成一个链条关系，这个函数首先将之前的错误链保存起来。而LUAI_TRY这个宏，会根据不同的编译器进行实现，比如C++中使用的try…catch，C中使用longjmp等。</p>\n<ol start=\"4\">\n<li>再来看看真正出错的时候是如何处理的。</li>\n</ol>\n<pre><code>void luaG_errormsg (lua_State *L) &#123;\n  if (L-&gt;errfunc != 0) &#123;  /* is there an error handling function? */\n    StkId errfunc = restorestack(L, L-&gt;errfunc);\n    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);\n    setobjs2s(L, L-&gt;top, L-&gt;top - 1);  /* move argument */\n    setobjs2s(L, L-&gt;top - 1, errfunc);  /* push function */\n    incr_top(L);\n    luaD_call(L, L-&gt;top - 2, 1);  /* call it */\n  &#125;\n  luaD_throw(L, LUA_ERRRUN);\n&#125;\n</code></pre><p><strong>首先如果之前保存的errfunc不为空，则首先从Lua栈中得到该函数，如果判断这个地址存放的不是一个函数则直接抛出错误。否则将错误参数压入栈中调用该错误处理函数。最后调用LuaD_throw函数，这个函数与前面的LUAI_TRY宏是对应的。这样就可以回到原来保存的错误恢复地点，恢复调用前的Lua栈，继续执行下去，而不是导致宿主进程退出。</strong></p>","text":" &lt;p&gt;Lua支持两种形式的函数调用，一种对调用过程的堆栈进行保护，即使中间过程出错，也不至于让进程退出，也就是pcall，一般在使用C调用Lua写的脚本函数时，都采用pcall方式。&lt;/p&gt; 对比起一般的函数调用方式，pcall多做了这些事情： 对函数调...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 正确处理可变参数","uid":"9073ce92e645b93c4caec3a7c43f9966","slug":"zl/2016-01-01-260_Lua 正确处理可变参数 ","date":"2024-04-03T03:47:33.122Z","updated":"2024-04-03T03:47:33.123Z","comments":true,"path":"api/articles/zl/2016-01-01-260_Lua 正确处理可变参数 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;为了在 Lua 里处理可变参数，我们可能会写下面这样的代码：&lt;/p&gt; local function args(...) if next(&#123;...&#125;) then for _, v in ipairs&#123;...&#125; ...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua 快速入门","uid":"283f8685b3892ee900dfb7aaef57d552","slug":"zl/2016-01-01-259_Lua 快速入门","date":"2024-04-03T03:47:33.121Z","updated":"2024-04-03T03:47:33.122Z","comments":true,"path":"api/articles/zl/2016-01-01-259_Lua 快速入门.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;Lua 是一门强大、快速、轻量的嵌入式脚本语言，那么我们如何才能够快速学习和掌握 Lua 语言呢？在这我将分享一下我的 Lua 快速入门经验，希望对大家有所帮助。&lt;/p&gt; Lua 的安装过程可以参考 Lua 官网 或云风翻译的 Lua 5.3 参考...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}