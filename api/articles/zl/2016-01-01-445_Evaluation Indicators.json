{"title":"Evaluation Indicators","uid":"af49e7e1d9026cd0fabd98674e33c50c","slug":"zl/2016-01-01-445_Evaluation Indicators","date":"2024-04-03T03:47:35.727Z","updated":"2024-04-03T03:47:35.728Z","comments":true,"path":"api/articles/zl/2016-01-01-445_Evaluation Indicators.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>假设测试集中有类别为A、B、C的三种class。现在要对class A 的recall、precision和AP进行评估。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$quad$</th>\n<th style=\"text-align:center\">class A</th>\n<th style=\"text-align:center\">class not A</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Test says “A”</td>\n<td style=\"text-align:center\">True positive</td>\n<td style=\"text-align:center\">False Positive</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Test says “not A”</td>\n<td style=\"text-align:center\">False positive</td>\n<td style=\"text-align:center\">True Positive</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>公式为：<br/><code>召回率 Recall = TP / (TP + FN)</code><br/><code>准确率 Precision = TP / (TP + FP)</code></p>\n<p><strong>也就是说，recall是一张图片中检测出来的目标占所有目标的比例，即“召回”的比例；precision是每个检测出来的目标的准确率。</strong></p>\n<p>代码如下：<br/></p><figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/><span class=\"line\">26</span><br/><span class=\"line\">27</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br/><span class=\"line\"></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"params\">(preds, labels)</span>:</span></span><br/><span class=\"line\">    num_cls = preds.shape[<span class=\"number\">1</span>]</span><br/><span class=\"line\">    batch_size = preds.shape[<span class=\"number\">0</span>]</span><br/><span class=\"line\"></span><br/><span class=\"line\">    labels_hot = np.zeros((batch_size, num_cls))</span><br/><span class=\"line\">    labels_hot[np.arange(batch_size), labels] = <span class=\"number\">1</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">    max_pred_idx = np.argmax(preds, axis=<span class=\"number\">1</span>)</span><br/><span class=\"line\">    preds_hot = np.zeros((batch_size, num_cls))</span><br/><span class=\"line\">    preds_hot[np.arange(batch_size), max_pred_idx] = <span class=\"number\">1</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">    tp, tn, fp, fn = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br/><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(num_cls):</span><br/><span class=\"line\">        pred = preds_hot[:, i]</span><br/><span class=\"line\">        label = labels_hot[:, i]</span><br/><span class=\"line\">        tp += int(np.sum(label[np.where(pred == label)[<span class=\"number\">0</span>]]))</span><br/><span class=\"line\">        tn += int(np.sum(<span class=\"number\">1</span> - label[np.where(pred == label)[<span class=\"number\">0</span>]]))</span><br/><span class=\"line\">        fp += np.sum(label[np.where(pred == <span class=\"number\">1</span>)] == <span class=\"number\">0</span>)</span><br/><span class=\"line\">        fn += np.sum(label[np.where(pred == <span class=\"number\">0</span>)] == <span class=\"number\">1</span>)</span><br/><span class=\"line\"></span><br/><span class=\"line\">    precision = tp / (tp + fp)</span><br/><span class=\"line\">    recall = tp / (tp + fn)</span><br/><span class=\"line\"></span><br/><span class=\"line\">    <span class=\"keyword\">return</span> precision, recall</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<h1 id=\"二、AP-amp-mAP\"><a href=\"#二、AP-amp-mAP\" class=\"headerlink\" title=\"二、AP &amp; mAP\"></a>二、AP &amp; mAP</h1><p>单个类别的平均精度叫AP。先求出原precision-recall曲线的包络曲线，然后将转折点的precision值相加取平均即为该类的AP。<br/>而mAP就是将所有类别的AP相加取平均。</p>\n<h1 id=\"三、CMC\"><a href=\"#三、CMC\" class=\"headerlink\" title=\"三、CMC\"></a>三、CMC</h1><p>CMC（cumulated matching characteristic curve），即累计匹配特征曲线。</p>\n<p>假如有一个类别为c1的样本，得到的匹配分数为：<br/><code>c1:0.9\nc2:0.8\nc3:0.7</code><br/>那么rank1（第一次即命中）=100%，则后面的rank2、rank3也为100%</p>\n<p>如果得到的匹配分数为：<br/><code>c1:0.8\nc2:0.9\nc3:0.7</code><br/>那么rank1=0%，rank2=100%，rank3=100%</p>\n<p>多类别的评估求和取平均即可。</p>\n<p><strong>车辆reid的mAP和CMC代码如下：</strong><br/></p><figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/><span class=\"line\">26</span><br/><span class=\"line\">27</span><br/><span class=\"line\">28</span><br/><span class=\"line\">29</span><br/><span class=\"line\">30</span><br/><span class=\"line\">31</span><br/><span class=\"line\">32</span><br/><span class=\"line\">33</span><br/><span class=\"line\">34</span><br/><span class=\"line\">35</span><br/><span class=\"line\">36</span><br/><span class=\"line\">37</span><br/><span class=\"line\">38</span><br/><span class=\"line\">39</span><br/><span class=\"line\">40</span><br/><span class=\"line\">41</span><br/><span class=\"line\">42</span><br/><span class=\"line\">43</span><br/><span class=\"line\">44</span><br/><span class=\"line\">45</span><br/><span class=\"line\">46</span><br/><span class=\"line\">47</span><br/><span class=\"line\">48</span><br/><span class=\"line\">49</span><br/><span class=\"line\">50</span><br/><span class=\"line\">51</span><br/><span class=\"line\">52</span><br/><span class=\"line\">53</span><br/><span class=\"line\">54</span><br/><span class=\"line\">55</span><br/><span class=\"line\">56</span><br/><span class=\"line\">57</span><br/><span class=\"line\">58</span><br/><span class=\"line\">59</span><br/><span class=\"line\">60</span><br/><span class=\"line\">61</span><br/><span class=\"line\">62</span><br/><span class=\"line\">63</span><br/><span class=\"line\">64</span><br/><span class=\"line\">65</span><br/><span class=\"line\">66</span><br/><span class=\"line\">67</span><br/><span class=\"line\">68</span><br/><span class=\"line\">69</span><br/><span class=\"line\">70</span><br/><span class=\"line\">71</span><br/><span class=\"line\">72</span><br/><span class=\"line\">73</span><br/><span class=\"line\">74</span><br/><span class=\"line\">75</span><br/><span class=\"line\">76</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">eval_market1501</span><span class=\"params\">(distmat, q_pids, g_pids, q_camids, g_camids, max_rank)</span>:</span></span><br/><span class=\"line\">    <span class=\"string\">&#34;&#34;&#34;Evaluation with market1501 metric</span></span><br/><span class=\"line\"><span class=\"string\">    Key: for each query identity, its gallery images from the same camera view are discarded.</span></span><br/><span class=\"line\"><span class=\"string\">    &#34;&#34;&#34;</span></span><br/><span class=\"line\">    num_q, num_g = distmat.shape</span><br/><span class=\"line\">    <span class=\"keyword\">if</span> num_g &lt; max_rank:</span><br/><span class=\"line\">        max_rank = num_g</span><br/><span class=\"line\">        print(<span class=\"string\">&#34;Note: number of gallery samples is quite small, got {}&#34;</span>.format(num_g))</span><br/><span class=\"line\">    indices = np.argsort(distmat, axis=<span class=\"number\">1</span>)</span><br/><span class=\"line\">    matches = (g_pids[indices] == q_pids[:, np.newaxis]).astype(np.int32)</span><br/><span class=\"line\"></span><br/><span class=\"line\">    </span><br/><span class=\"line\">    all_cmc = []</span><br/><span class=\"line\">    all_AP = []</span><br/><span class=\"line\">    num_valid_q = <span class=\"number\">0.</span> <span class=\"comment\"># number of valid query</span></span><br/><span class=\"line\">    <span class=\"keyword\">for</span> q_idx <span class=\"keyword\">in</span> range(num_q):</span><br/><span class=\"line\">        <span class=\"comment\"># get query pid and camid</span></span><br/><span class=\"line\">        q_pid = q_pids[q_idx]</span><br/><span class=\"line\">        q_camid = q_camids[q_idx]</span><br/><span class=\"line\"></span><br/><span class=\"line\">        <span class=\"comment\"># remove gallery samples that have the same pid and camid with query</span></span><br/><span class=\"line\">        order = indices[q_idx]</span><br/><span class=\"line\">        remove = (g_pids[order] == q_pid) &amp; (g_camids[order] == q_camid)</span><br/><span class=\"line\">        keep = np.invert(remove)</span><br/><span class=\"line\"></span><br/><span class=\"line\">        <span class=\"comment\"># compute cmc curve</span></span><br/><span class=\"line\">        orig_cmc = matches[q_idx][keep] <span class=\"comment\"># binary vector, positions with value 1 are correct matches</span></span><br/><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> np.any(orig_cmc):</span><br/><span class=\"line\">            <span class=\"comment\"># this condition is true when query identity does not appear in gallery</span></span><br/><span class=\"line\">            <span class=\"keyword\">continue</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">        cmc = orig_cmc.cumsum()</span><br/><span class=\"line\">        cmc[cmc &gt; <span class=\"number\">1</span>] = <span class=\"number\">1</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">        all_cmc.append(cmc[:max_rank])</span><br/><span class=\"line\">        num_valid_q += <span class=\"number\">1.</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">        good_idx = []</span><br/><span class=\"line\">        keep_ap = (g_pids[order] == q_pid) &amp; (g_camids[order] != q_camid)</span><br/><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(keep_ap.shape[<span class=\"number\">0</span>]):</span><br/><span class=\"line\">            <span class=\"keyword\">if</span> keep_ap[i]:</span><br/><span class=\"line\">                good_idx.append(order[i])</span><br/><span class=\"line\"></span><br/><span class=\"line\">        <span class=\"comment\"># compute average precision</span></span><br/><span class=\"line\">        ngood = len(good_idx)</span><br/><span class=\"line\">        intersect_sz = <span class=\"number\">0</span></span><br/><span class=\"line\">        ap = <span class=\"number\">0</span></span><br/><span class=\"line\">        good_now = <span class=\"number\">0</span></span><br/><span class=\"line\">        old_recall = <span class=\"number\">0</span></span><br/><span class=\"line\">        old_precision = <span class=\"number\">0</span></span><br/><span class=\"line\">        counter = <span class=\"number\">0</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">        <span class=\"keyword\">for</span> idx <span class=\"keyword\">in</span> order:</span><br/><span class=\"line\">            <span class=\"keyword\">if</span> idx <span class=\"keyword\">in</span> good_idx:</span><br/><span class=\"line\">                intersect_sz += <span class=\"number\">1</span></span><br/><span class=\"line\">                good_now += <span class=\"number\">1</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">            recall = intersect_sz / ngood</span><br/><span class=\"line\">            precision = intersect_sz / (counter + <span class=\"number\">1</span>)</span><br/><span class=\"line\">            ap += (recall - old_recall) * ((old_precision + precision) / <span class=\"number\">2</span>)</span><br/><span class=\"line\">            old_recall = recall</span><br/><span class=\"line\">            old_precision = precision</span><br/><span class=\"line\">            counter += <span class=\"number\">1</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">            <span class=\"keyword\">if</span> good_now == ngood:</span><br/><span class=\"line\">                <span class=\"keyword\">break</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">        all_AP.append(ap)</span><br/><span class=\"line\"></span><br/><span class=\"line\">    <span class=\"keyword\">assert</span> num_valid_q &gt; <span class=\"number\">0</span>, <span class=\"string\">&#34;Error: all query identities do not appear in gallery&#34;</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">    all_cmc = np.asarray(all_cmc).astype(np.float32)</span><br/><span class=\"line\">    all_cmc = all_cmc.sum(<span class=\"number\">0</span>) / num_valid_q</span><br/><span class=\"line\">    mAP = np.mean(all_AP)</span><br/><span class=\"line\"></span><br/><span class=\"line\">    <span class=\"keyword\">return</span> all_cmc, mAP</span><br/></pre></td></tr></tbody></table></figure><p></p>","text":"假设测试集中有类别为A、B、C的三种class。现在要对class A 的recall、precision和AP进行评估。 $quad$ class A class not A Test says “A” True positive False Positive Test say...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81AP-amp-mAP\"><span class=\"toc-text\">二、AP &amp; mAP</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81CMC\"><span class=\"toc-text\">三、CMC</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"财务分析与估值 Financial Analysis and Valuation","uid":"afc7ef521a1f73dbeedc0e71e86df3ec","slug":"zl/2016-01-01-444_财务分析与估值 Financial Analysis and Valuation","date":"2024-04-03T03:47:35.727Z","updated":"2024-04-03T03:47:35.727Z","comments":true,"path":"api/articles/zl/2016-01-01-444_财务分析与估值 Financial Analysis and Valuation.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 入门别放弃。 企业的价值评估和资产评估是两个不同的概念。 估值——对企业或股权进行估值的过程。 价值组成/来源：主营业务、非经营性净资产——&gt;企业价值 ——&gt;价值分配：负债、其他资本索取权、普通股权益 两类思路： 贴现现金流方法：通过企业创造的（或者股东能够获得的）...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua 排序算法","uid":"18c65ae79c1521b9ec150d64b8237a42","slug":"zl/2016-01-01-440_Lua 排序算法 ","date":"2024-04-03T03:47:35.726Z","updated":"2024-04-03T03:47:35.726Z","comments":true,"path":"api/articles/zl/2016-01-01-440_Lua 排序算法 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。 分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。 算法步骤 从数列中...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}