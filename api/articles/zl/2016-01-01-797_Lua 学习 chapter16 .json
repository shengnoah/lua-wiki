{"title":"Lua 学习 chapter16","uid":"7adfb56756654d77e1864a70e15ff21c","slug":"zl/2016-01-01-797_Lua 学习 chapter16 ","date":"2024-04-03T03:47:36.035Z","updated":"2024-04-03T03:47:36.040Z","comments":true,"path":"api/articles/zl/2016-01-01-797_Lua 学习 chapter16 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h3 id=\"目录\">目录</h3>\n<ol>\n  <li>编译</li>\n  <li>错误</li>\n  <li>错误信息和栈回溯</li>\n</ol>\n<blockquote>\n  <p>You must try your best. Then you will have a good improvement.</p>\n</blockquote>\n<h2 id=\"编译\">编译</h2>\n<p>dofile函数，加载文件并且执行文件中的代码。其实dofile并不是运行lua代码的核心，核心是loadfile函数。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n</pre></td><td class=\"rouge-code\"><pre><span class=\"k\">function</span> <span class=\"nf\">dofile</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"p\">)</span>\n\t<span class=\"kd\">local</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"nb\">assert</span><span class=\"p\">(</span><span class=\"nb\">loadfile</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"p\">))</span>\n\t<span class=\"k\">return</span> <span class=\"n\">f</span><span class=\"p\">()</span>\n<span class=\"k\">end</span>\n</pre></td></tr></tbody></table></code></pre></div></div>\n<p>如果loadfile执行失败，那么函数assert会引发一个错误。相较于dofile，loadfile在发生错的时候会返回nil以及错误信息。而且在多次运行这个文件的时候，loadfile只需要加载一次后面可以多次调用。</p>\n<p>函数load函数和loadfile函数非常的相似，但是加载的不是文件而是字符串。函数load总是在全局环境中编译代码片段，所以里面的值也都是针对于全局变量的。</p>\n<ul>\n  <li>loadfile() 只加载编译代码，不执行, 返回一个function. loadfile的时候必须使用文件全名（带上后缀）</li>\n  <li>dofile() 加载执行代码，每调用dofile一次，都会重新编译执行一次。</li>\n  <li>require() 只执行一次，会保存已加载过的文件，不会重复加载执行。（常用）加载文件时，require会在packeage.loader中查找模块是否存在，若存在直接返回，否则，加载模块文件。不用加上文件后缀名。</li>\n</ul>\n<p>loadfile的思考：</p>\n<p>执行下面的代码，为什么会报错呢？这有点类似于只是把代码段里面的程序代码换掉了，但是这些全局变量并没有被执行过，当然找不到了，所以这里只是更换代码，要想代码生效还需要执行一下。</p>\n<p>在require的时候我们发现代码被执行了，而不是简单的loadfile，所以我们推测应该是dofile而不是loadfile。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n</pre></td><td class=\"rouge-code\"><pre><span class=\"c1\">--local test = require(&#34;moduleTest&#34;)</span>\n<span class=\"kd\">local</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"nb\">loadfile</span><span class=\"p\">(</span><span class=\"s2\">&#34;moduleTest.lua&#34;</span><span class=\"p\">)</span>\n<span class=\"c1\">--t()</span>\n<span class=\"n\">Pack</span><span class=\"p\">.</span><span class=\"n\">Print</span><span class=\"p\">()</span>\n<p><span class=\"c1\">–lua.exe: hello.lua:4: attempt to index a nil value (global 'Pack')</span><br />\n<span class=\"c1\">–stack traceback:</span><br />\n<span class=\"c1\">–hello.lua:4: in main chunk</span><br />\n<span class=\"c1\">–[C]: in ?</span><br />\n</pre></td></tr></tbody></table></code></pre></div></div></p>\n<h2 id=\"错误\">错误</h2>\n<p>可以通过assert函数来判断一个函数是否成功执行，没有成功执行则会返回错误信息。assert函数第二个参数为可选的错误信息，可以输出你想要输出的错误信息。</p>\n<p>通过assert函数抛出错误信息可以让函数继续执行。</p>\n<p>如果想要在lua代码中处理错误，那么就应该使用函数pcall来封装代码。函数pcall能够返回传递给error的任意lua语言类型的值。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n</pre></td><td class=\"rouge-code\"><pre><span class=\"kd\">local</span> <span class=\"n\">ok</span><span class=\"p\">,</span> <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"nb\">pcall</span><span class=\"p\">(</span><span class=\"n\">functionname</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"n\">ok</span> <span class=\"k\">then</span>\n\t<span class=\"n\">regular</span> <span class=\"n\">code</span>\n<span class=\"k\">else</span>\n\t<span class=\"nb\">error</span><span class=\"o\">-</span><span class=\"n\">handling</span> <span class=\"n\">code</span>\n<span class=\"k\">end</span>\n</pre></td></tr></tbody></table></code></pre></div></div>\n<p>函数pcall会以一种保护模式来调用它的第一个参数，以便来捕捉该函数执行中的错误。无论是否发生错误pcall都不会引发错误。</p>\n<h2 id=\"错误信息和栈回溯\">错误信息和栈回溯</h2>\n<p>当遇到内部错误时，lua语言负责产生错误对象，如果错误对象是一个字符串，那么lua语言还会尝试把一些有关错误发生的位置信息附上：</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n</pre></td><td class=\"rouge-code\"><pre><span class=\"kd\">local</span> <span class=\"n\">status</span><span class=\"p\">,</span><span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"nb\">pcall</span><span class=\"p\">(</span><span class=\"k\">function</span><span class=\"p\">()</span> <span class=\"nb\">error</span><span class=\"p\">(</span><span class=\"s2\">&#34;my error&#34;</span><span class=\"p\">)</span><span class=\"k\">end</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">err</span><span class=\"p\">)</span> <span class=\"c1\">--&gt;stdin:i:my error</span>\n</pre></td></tr></tbody></table></code></pre></div></div>\n<pre><code>            &lt;hr style=&quot;visibility: hidden;&quot;/&gt;\n            \n            &lt;hr style=&quot;visibility: hidden;&quot;/&gt;\n</code></pre>\n","text":"目录 编译 错误 错误信息和栈回溯 You must try your best. Then you will have a good improvement. 编译 dofile函数，加载文件并且执行文件中的代码。其实dofile并不是运行lua代码的核心，核心是loadfil...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">目录</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">编译</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">错误</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E5%92%8C%E6%A0%88%E5%9B%9E%E6%BA%AF\"><span class=\"toc-text\">错误信息和栈回溯</span></a>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua面向对象学习","uid":"670b7a60e57dc8637ace9a6fd82af9ef","slug":"zl/2016-01-01-799_lua面向对象学习","date":"2024-04-03T03:47:36.041Z","updated":"2024-04-03T03:47:36.042Z","comments":true,"path":"api/articles/zl/2016-01-01-799_lua面向对象学习.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 元表和元方法 在Lua中，每个值都有一个元表，table和userdata类型的每个变量都可以有各自独立的元表， 其他类型的值则共享其类型所属的单一元表。 基本的metatable 创建新的table时不会创建元表 getmetatable(table) 获取table或者us...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua性能优化技巧","uid":"9975cef0cac07289d180dc9800308309","slug":"zl/2016-01-01-796_[Lua] lua性能优化技巧 ","date":"2024-04-03T03:47:36.034Z","updated":"2024-04-03T03:47:36.035Z","comments":true,"path":"api/articles/zl/2016-01-01-796_[Lua] lua性能优化技巧 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"前言 和在所有其他编程语言中一样，在Lua中，我们依然应当遵循下述两条有关程序优化的箴言： 原则1：不要做优化。 原则2：暂时不要做优化（对专家而言）。 这两条原则对于Lua编程来说尤其有意义，Lua正是因其性能而在脚本语言中鹤立鸡群。 当然，我们都知道性能是编程中要考量的一个重...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}