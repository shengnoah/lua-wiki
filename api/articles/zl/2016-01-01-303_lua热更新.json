{"title":"lua热更新","uid":"ada7d00f75876f789304534bf2794597","slug":"zl/2016-01-01-303_lua热更新","date":"2024-04-03T03:47:35.582Z","updated":"2024-04-03T03:47:35.583Z","comments":true,"path":"api/articles/zl/2016-01-01-303_lua热更新.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h4 id=\"单纯热更新\"><a href=\"#单纯热更新\" class=\"headerlink\" title=\"单纯热更新\"></a>单纯热更新</h4><p>Lua热更新<br/>最简单粗暴的热更新就是将package.loaded[modelname]的值置为nil，强制重新加载：</p>\n<pre><code>function reload_module(module_name)\n    package.loaded[modulename] = nil\n    require(modulename)\nend\n</code></pre><p>这样做虽然能完成热更，但问题是已经引用了该模块的地方不会得到更新， 因此我们需要将引用该模块的地方的值也做对应的更新。</p>\n<pre><code>function reload_module(module_name)\n    local old_module = _G[module_name]\n    package.loaded[module_name] = nil\n    require (module_name)\n<pre><code>local new_module = _G[module_name]\nfor k, v in pairs(new_module) do\n  old_module[k] = v\nend\n\npackage.loaded[module_name] = old_module\n</code></pre>\n<p>end<br />\n</code></pre><h3 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h3><blockquote></p>\n<p>在生产环境上，总有可能出现不可预知的Bug，而通常修改好Bug仅仅又修改几句，停机维护的成本又太高，对于游戏来说，通常每个服就是单独的进程，也做不到像分布式环境下，关掉一部分机器，先升级一部分，再升级另一部分的无缝升级。这时候如果有热更就可以迅速的把Bug修复方案通过热更新进行修复，不会对用户任何的影响。例如：</p>\n</blockquote>\n<blockquote>\n<ol>\n<li>业务逻辑有Bug</li>\n<li>配置的数据有误</li>\n<li>需求发生变更</li>\n</ol>\n</blockquote>\n<h3 id=\"热更新的原则\"><a href=\"#热更新的原则\" class=\"headerlink\" title=\"热更新的原则\"></a>热更新的原则</h3><p>1、热更新不破坏原有数据</p>\n<blockquote>\n<p>热更新更新的基本内容就是更新服务的逻辑，通常只是逻辑发生变化，但原有的值并不能被改变，例如：</p>\n</blockquote>\n<pre><code>local a = 1\nfunction get_a()\n    return a\nend\n</code></pre><p>此时，我们调用get_a()返回是的1，我们将热更成</p>\n<pre><code>local a = 2\nfunction get_a()\n    print(&#34;get_a function&#34;)\n    return a\nend\n</code></pre><p>此时我们改变了a的初始值，但我们并不知道之前服务a的值是不是被重新赋过值，假设热更前a的值仍然为1，那么我们热更后调用get_a()返回的应该是1，而不应受新的初始值影响，而且同能打印出了”get_a function”，这时候则认为热更正常。</p>\n<p>2、不为热更新写更多的代码</p>\n<blockquote>\n<p>热更新可以通过很多种方法实现，比如说模块为了支持数据不变的特性，需要在模块里额外写一些代码来记录旧值，热更新之后再把旧值copy过来，或者用一些特殊的语法来支撑。这种方法将会对项目增加很多的负担，而且一旦发生意料之外的Bug，热更系统几乎处于半瘫痪状态。应该来说，代码原本该怎么实现就怎么实现，对于99%的lua代码都是支持的，不需要修改来迎合热更新。通常热更新不改变原有变量值的类型。</p>\n</blockquote>\n<h3 id=\"热更新的实现，代码适用于5-2以上\"><a href=\"#热更新的实现，代码适用于5-2以上\" class=\"headerlink\" title=\"热更新的实现，代码适用于5.2以上\"></a>热更新的实现，代码适用于5.2以上</h3><h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><blockquote>\n<p>利用_ENV环境，在加载的时候把数据加载到_ENV下，然后再通过对比的方式修改_G底下的值，从而实现热更新，函数</p>\n</blockquote>\n<pre><code>function hotfix(chunk, check_name)\n</code></pre><p>定义env的table，并为env设置_G访问权限，然后调用load实现把数据重新加载进来</p>\n<pre><code>local env = &#123;&#125;\nsetmetatable(env, &#123; __index = _G &#125;)\nlocal _ENV = env\nlocal f, err = load(chunk, check_name,  &#39;t&#39;, env)\nassert(f,err)\nlocal ok, err = pcall(f)\nassert(ok,err)\n</code></pre><p>此时env我们可以得到新函数有变更的部分，我们替换的为可见变量，也就是可直接访问的变量</p>\n<pre><code>for name,value in pairs(env) do\n    local g_value = _G[name]\n    if type(g_value) ~= type(value) then\n        _G[name] = value\n    elseif type(value) == &#39;function&#39; then\n        update_func(value, g_value, name, &#39;G&#39;..&#39;  &#39;)\n        _G[name] = value\n    elseif type(value) == &#39;table&#39; then\n        update_table(value, g_value, name, &#39;G&#39;..&#39;  &#39;)\n    end\nend\n</code></pre><blockquote>\n<p>通过env当前的值和_G当前的值进行对比</p>\n</blockquote>\n<blockquote>\n<ol>\n<li>如果类型不同我们直接覆盖原值，此时value不为nil，不会出现原则被覆盖成nil的情况</li>\n<li>如果当前值为函数，我们进行函数的upvalue值比对</li>\n</ol>\n</blockquote>\n<pre><code>function update_func(env_f, g_f, name, deep)\n    --取得原值所有的upvalue，保存起来\n    local old_upvalue_map = &#123;&#125;\n    for i = 1, math.huge do\n        local name, value = debug.getupvalue(g_f, i)\n        if not name then break end\n        old_upvalue_map[name] = value\n    end\n    --遍历所有新的upvalue，根据名字和原值对比，如果原值不存在则进行跳过，如果为其它值则进行遍历env类似的步骤\n    for i = 1, math.huge do\n        local name, value = debug.getupvalue(env_f, i)\n        if not name then break end\n        local old_value = old_upvalue_map[name]\n        if old_value then\n            if type(old_value) ~= type(value) then\n                debug.setupvalue(env_f, i, old_value)\n            elseif type(old_value) == &#39;function&#39; then\n                update_func(value, old_value, name, deep..&#39;  &#39;..name..&#39;  &#39;)\n            elseif type(old_value) == &#39;table&#39; then\n                update_table(value, old_value, name, deep..&#39;  &#39;..name..&#39;  &#39;)\n                debug.setupvalue(env_f, i, old_value)\n            else\n                debug.setupvalue(env_f, i, old_value)\n            end\n        end\n    end\nend\n</code></pre><blockquote>\n<ol>\n<li>如果当前值为table，我们遍历table值进行对比</li>\n</ol>\n</blockquote>\n<pre><code>local protection = &#123;\n    setmetatable = true,\n    pairs = true,\n    ipairs = true,\n    next = true,\n    require = true,\n    _ENV = true,\n&#125;\n--防止重复的table替换，造成死循环\nlocal visited_sig = &#123;&#125;\nfunction update_table(env_t, g_t, name, deep)\n    --对某些关键函数不进行比对\n    if protection[env_t] or protection[g_t] then return end\n    --如果原值与当前值内存一致，值一样不进行对比\n    if env_t == g_t then return end\n    local signature = tostring(g_t)..tostring(env_t)\n    if visited_sig[signature] then return end\n    visited_sig[signature] = true\n    --遍历对比值，如进行遍历env类似的步骤\n    for name, value in pairs(env_t) do\n        local old_value = g_t[name]\n        if type(value) == type(old_value) then\n            if type(value) == &#39;function&#39; then\n                update_func(value, old_value, name, deep..&#39;  &#39;..name..&#39;  &#39;)\n                g_t[name] = value\n            elseif type(value) == &#39;table&#39; then\n                update_table(value, old_value, name, deep..&#39;  &#39;..name..&#39;  &#39;)\n            end\n        else\n            g_t[name] = value\n        end\n    end\n    --遍历table的元表，进行对比\n    local old_meta = debug.getmetatable(g_t)\n    local new_meta = debug.getmetatable(env_t)\n    if type(old_meta) == &#39;table&#39; and type(new_meta) == &#39;table&#39; then\n        update_table(new_meta, old_meta, name..&#39;s Meta&#39;, deep..&#39;  &#39;..name..&#39;s Meta&#39;..&#39;  &#39; )\n    end\nend\n</code></pre><h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><p>1、可以调用hotfix_file对整个文件进行热更</p>\n<pre><code>function hotfix_file(name)\n    local file_str\n    local fp = io.open(name)\n    if fp then\n        io.input(name)\n        file_str = io.read(&#39;*all&#39;)\n        io.close(fp)\n    end\n<pre><code>if not file_str then\n    return -1\nend\nreturn hotfix(file_str, name)\n</code></pre>\n<p>end<br />\n</code></pre><p>2、可以通过hotfix进行代码的更新</p></p>\n<pre><code>function hotfix(chunk, check_name)\n</code></pre><h4 id=\"关于坑\"><a href=\"#关于坑\" class=\"headerlink\" title=\"关于坑\"></a>关于坑</h4><blockquote>\n<p>这里有一个注意事项，lua的module模块，如：</p>\n</blockquote>\n<pre><code>module(&#34;AA&#34;, package.seeall)\n</code></pre><p>当我们加载lua模块的时候，这时候这个模块信息并不像初始化全局代码一样，就算提前设置了package.loaded[“AA”] = nil, 也不会出现在env中同时也不会调用_G的__newindex函数，也就是说env[“AA”]为空，故这种写法无法进行热更新，所以通常模块的写法改成如下</p>\n<pre><code>--定义模块AA\nAA = &#123;&#125;\n--相当于package.seeall\nsetmetatable(AA, &#123;__index = _G&#125;)\n--环境隔离\nlocal _ENV = AA\n</code></pre>","text":"单纯热更新Lua热更新最简单粗暴的热更新就是将package.loaded[modelname]的值置为nil，强制重新加载： function reload_module(module_name) package.loaded[modulename] = nil require...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E7%BA%AF%E7%83%AD%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">单纯热更新</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E9%80%94\"><span class=\"toc-text\">用途</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">热更新的原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BB%A3%E7%A0%81%E9%80%82%E7%94%A8%E4%BA%8E5-2%E4%BB%A5%E4%B8%8A\"><span class=\"toc-text\">热更新的实现，代码适用于5.2以上</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">更新</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E5%9D%91\"><span class=\"toc-text\">关于坑</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua c api","uid":"a088e52eeedd5a2e08a78395ae73ef54","slug":"zl/2016-01-01-304_lua c api ","date":"2024-04-03T03:47:35.584Z","updated":"2024-04-03T03:47:35.584Z","comments":true,"path":"api/articles/zl/2016-01-01-304_lua c api .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"一 概述 《lua c api》系列文章描述的是 C 语言作为宿主语言，与 Lua 程序通讯的 API 接口。 二 stack Lua 使用虚拟的栈与宿主 C 语言进行通讯，在栈中的每个元素都是 Lua 识别的数据类型。每当 Lua 调用 C 时，被调用的 C 函数都会得到一个新...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua学习笔记","uid":"d112c00bf05f368c0020529ea6c8efaf","slug":"zl/2016-01-01-302_Lua学习笔记","date":"2024-04-03T03:47:35.578Z","updated":"2024-04-03T03:47:35.578Z","comments":true,"path":"api/articles/zl/2016-01-01-302_Lua学习笔记.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" LUA读书笔记 What’s in a name? Why choose Lua? LuaJIT-Lua即时编译器 下载源码 INSTALL LUA读书笔记 在Lua中，一切都是变量，除了关键字。请记住这句话。 语句块在C++中是用”{“和”}”括起来的，在Lua中，它是用do...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}