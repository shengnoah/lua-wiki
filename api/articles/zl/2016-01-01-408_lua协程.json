{"title":"lua协程","uid":"d36ba769edad58e74315b8433c498d4c","slug":"zl/2016-01-01-408_lua协程","date":"2024-04-03T03:47:35.698Z","updated":"2024-04-03T03:47:35.699Z","comments":true,"path":"api/articles/zl/2016-01-01-408_lua协程.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>协程是个很好的东西，它能做的事情与线程相似，区别在于：协程是使用者可控的，有API给使用者来暂停和继续执行，而线程由操作系统内核控制；另外，协程也更加轻量级。这样，在遇到某些可能阻塞的操作时，可以使用暂停协程让出CPU；而当条件满足时，可以继续执行这个协程。目前在网络服务器领域，使用Lua协程最好的范例就是ngx_lua了</p>\n<p>来看看Lua协程内部是如何实现的。</p>\n<p>本质上，每个Lua协程其实也是对应一个LuaState指针，所以其实它内部也是一个完整的Lua虚拟机—有完整的Lua堆栈结构，函数调用栈等等等等，绝大部分之前对Lua虚拟机的分析都可以直接套用到Lua协程中。于是，由Lua虚拟机管理着这些隶属于它的协程，当需要暂停当前运行协程的时候，就保存它的运行环境，切换到别的协程继续执行。很简单的实现。</p>\n<p>来看看相关的API。</p>\n<ol>\n<li>lua_newthread</li>\n</ol>\n<p>创建一个Lua协程，最终会调用的API是luaE_newthread，Lua协程在Lua中也是一个独立的Lua类型数据，它的类型是LUA_TTHREAD，创建完毕之后会照例初始化Lua的栈等结构，有一点需要注意的是，调用preinit_state初始化Lua协程的时候，传入的global表指针是来自于Lua虚拟机，换句话说，任何在Lua协程修改的全局变量，也会影响到其他的Lua协程包括Lua虚拟机本身。</p>\n<ol start=\"2\">\n<li>加载一个Lua文件并且执行</li>\n</ol>\n<p>对于一般的Lua虚拟机，大可以直接调用luaL_dofile即可，它其实是一个宏：</p>\n<pre><code>#define luaL_dofile(L, fn) \n        (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))\n</code></pre><p>展开来也就是当调用luaL_loadfile函数完成对该Lua文件的解析，并且没有错误时，调用lua_pcall函数执行这个Lua脚本。</p>\n<p>但是对于Lua协程而言，却不能这么做，需要调用luaL_loadfile然后再调用lua_resume函数。所以两者的区别在于lua_pcall函数和lua_resume函数。来看看lua_resume函数的实现。这个函数做的几件事情：首先查看当前Lua协程的状态对不对，然后修改计数器：</p>\n<pre><code> L-&gt;baseCcalls = ++L-&gt;nCcalls;\n</code></pre><p>其次调用status = luaD_rawrunprotected(L, resume, L-&gt;top – nargs);，可以看到这个保护Lua函数堆栈的调用luaD_rawrunprotected最终调用了函数resume:</p>\n<pre><code>static void resume (lua_State *L, void *ud) &#123;\n  StkId firstArg = cast(StkId, ud);\n  CallInfo *ci = L-&gt;ci;\n  if (L-&gt;status == 0) &#123;  /* start coroutine? */\n    lua_assert(ci == L-&gt;base_ci &amp;&amp; firstArg &gt; L-&gt;base);\n    if (luaD_precall(L, firstArg - 1, LUA_MULTRET) != PCRLUA)\n      return;\n  &#125;\n  else &#123;  /* resuming from previous yield */\n    lua_assert(L-&gt;status == LUA_YIELD);\n    L-&gt;status = 0;\n    if (!f_isLua(ci)) &#123;  /* `common&#39; yield? */\n      /* finish interrupted execution of `OP_CALL&#39; */\n      lua_assert(GET_OPCODE(*((ci-1)-&gt;savedpc - 1)) == OP_CALL ||\n                 GET_OPCODE(*((ci-1)-&gt;savedpc - 1)) == OP_TAILCALL);\n      if (luaD_poscall(L, firstArg))  /* complete it... */\n        L-&gt;top = L-&gt;ci-&gt;top;  /* and correct top if not multiple results */\n    &#125;\n    else  /* yielded inside a hook: just continue its execution */\n      L-&gt;base = L-&gt;ci-&gt;base;\n  &#125;\n  luaV_execute(L, cast_int(L-&gt;ci - L-&gt;base_ci));\n&#125;\n</code></pre><p>这个函数将执行Lua代码的流程划分成了几个阶段，如果调用</p>\n<pre><code>luaD_precall(L, firstArg - 1, LUA_MULTRET) != PCRLUA\n</code></pre><p>那么说明这次调用返回的结果小于0，可以跟进luaD_precall函数看看什么情况下会出现这样的情况：</p>\n<pre><code>    n = (*curr_func(L)-&gt;c.f)(L);  /* do the actual call */\n    lua_lock(L);\n    if (n &lt; 0)  /* yielding? */\n      return PCRYIELD;\n    else &#123;\n      luaD_poscall(L, L-&gt;top - n);\n      return PCRC;\n    &#125;\n</code></pre><p>继续回到resume函数中，如果之前该Lua协程的状态是YIELD，那么说明之前被中断了，则调用luaD_poscall完成这个函数的调用。<br/>然后紧跟着调用luaV_execute继续Lua虚拟机的继续执行。</p>\n<p>可以看到，resume函数做的事情其实有那么几件：</p>\n<ol>\n<li>如果调用C函数时被YIELD了，则直接返回</li>\n<li>如果之前被YIELD了，则调用luaD_poscall完成这个函数的执行，接着调用luaV_execute继续Lua虚拟机的执行。</li>\n</ol>\n<p>因此，这个函数对于函数执行中可能出现的YIELD，有充分的准备和判断，因此它不像一般的pcall那样，一股脑的往下执行，而是会在出现YIELD的时候保存现场返回，在继续执行的时候恢复现场。<br/>3）同时，由于resume函数是由luaD_rawrunprotected进行保护调用的，即使执行出错，也不会造成整个程序的退出。</p>\n<p>这就是Lua协程中，比一般的Lua操作过程做的更多的地方。</p>\n<p>最后给出一个Lua协程的例子：<br/>co.lua</p>\n<pre><code>print(&#34;before&#34;)\ntest(&#34;123&#34;)\nprint(&#34;after resume&#34;)\n</code></pre><p>co.c</p>\n<pre><code> #include \n    #include &#34;lua.h&#34;\n    #include &#34;lualib.h&#34;\n    #include &#34;lauxlib.h&#34;\n<pre><code>static int panic(lua_State *state) &#123;\n  printf(&amp;#34;PANIC: unprotected error in call to Lua API (%s)n&amp;#34;,\n          lua_tostring(state, -1));\n  return 0;\n&#125;\n\nstatic int test(lua_State *state) &#123;\n  printf(&amp;#34;in testn&amp;#34;);\n  printf(&amp;#34;yieldingn&amp;#34;);\n  return lua_yield(state, 0);\n&#125;\n\nint main(int argc, char *argv[]) &#123;\n  char *name = NULL;\n  name = &amp;#34;co.lua&amp;#34;;\n  lua_State*  L1 = NULL;\n  L1 = lua_open();\n  lua_atpanic(L1, panic);\n  luaL_openlibs( L1 );\n\n  lua_register(L1, &amp;#34;test&amp;#34;, test);\n  lua_State*  L = lua_newthread(L1);\n\n  luaL_loadfile(L, name);\n  lua_resume(L, 0);\n  printf(&amp;#34;sleepingn&amp;#34;);\n  sleep(1);\n  lua_resume(L, 0);\n  printf(&amp;#34;after resume testn&amp;#34;);\n\n  return 0;\n&#125;\n</code></pre>\n<p></code></pre><p>你可以使用coroutine.create来创建协程,协程有三种状态：挂起，运行，停止。创建后是挂起状态，即不自动运行。status函数可以查看当前状态。协程真正强大的地方在于他可以通过yield函数将一段正在运行的代码挂起。</p></p>\n<p>lua的resume-yield可以互相交换数据</p>\n<pre><code>co = coroutine.create(function (a, b)\n     coroutine.yield(a+b, a-b)\nend)\nprint(coroutine.resume(co, 3, 8))\n</code></pre>","text":"协程是个很好的东西，它能做的事情与线程相似，区别在于：协程是使用者可控的，有API给使用者来暂停和继续执行，而线程由操作系统内核控制；另外，协程也更加轻量级。这样，在遇到某些可能阻塞的操作时，可以使用暂停协程让出CPU；而当条件满足时，可以继续执行这个协程。目前在网络服务器领域，...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Nginx+Lua实现访问日志收集系统","uid":"1ad348135c696541ad6f75c24b1aefdb","slug":"zl/2016-01-01-407_Nginx+Lua实现访问日志收集系统","date":"2024-04-03T03:47:35.698Z","updated":"2024-04-03T03:47:35.698Z","comments":true,"path":"api/articles/zl/2016-01-01-407_Nginx+Lua实现访问日志收集系统.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"网站数据统计分析工具是网站站长和运营人员经常使用的一种工具，比较常用的有谷歌分析、百度统计和腾讯分析等等。所有这些统计分析工具的第一步都是网站访问数据的收集。目前主流的数据收集方式基本都是基于javascript的。名称途径备注访问时间web serverNginx $msecI...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua源码阅读：虚拟机概述","uid":"ded0ecbc9cc716717b8e535e4c5bec2b","slug":"zl/2016-01-01-405_Lua源码阅读：虚拟机概述","date":"2024-04-03T03:47:35.697Z","updated":"2024-04-03T03:47:35.698Z","comments":true,"path":"api/articles/zl/2016-01-01-405_Lua源码阅读：虚拟机概述.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua 虚拟机的执行过程。 Lua 执行过程概述：解释型脚本语言与编译型语言的区别如下： 由于每个脚本语言都有自己的一套字节码，与具体的硬件平台无关，所以不用修改脚本代码，就能运行在各个平台上。硬件、软件平台的差异都由语言自身的虚拟机解决。 由于脚本语言的字节码需要虚拟机执行，而...","link":"","photos":[],"count_time":{"symbolsCount":"9.4k","symbolsTime":"9 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}