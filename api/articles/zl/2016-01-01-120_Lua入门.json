{"title":"Lua入门","uid":"09cde711228cba9ba4505d40c71d393c","slug":"zl/2016-01-01-120_Lua入门","date":"2024-04-03T03:47:33.029Z","updated":"2024-04-03T03:47:33.029Z","comments":true,"path":"api/articles/zl/2016-01-01-120_Lua入门.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h4 id=\"1-注释\"><a href=\"#1-注释\" class=\"headerlink\" title=\"1 注释\"></a>1 注释</h4><p>行注释：<code>--</code>；<br/>块注释：<code>--[[注释内容]]</code>，推荐用<code>--[=[注释内容]=]</code>，其中<code>=</code>的个数前后一致。</p>\n<h4 id=\"2-数据类型\"><a href=\"#2-数据类型\" class=\"headerlink\" title=\"2 数据类型\"></a>2 数据类型</h4><p>基础类型有8种：</p>\n<ol>\n<li><code>nil</code><br/>未初始化的变量默认为<code>nil</code>；删除一个全局变量<code>b=nil</code></li>\n<li><code>boolean</code><br/>只有false和nil视为<code>false</code>，其他值都为<code>true</code></li>\n<li><code>number</code><br/>默认只有一种<code>double</code>类型</li>\n<li><code>string</code><br/>一对单引号或双引号；表示一块字符串<code>[[]]</code>；字符串连接符<code>..</code>；长度操作符<code>#</code>；计算时数字与字符串自动转换</li>\n<li><code>table</code><br/>数组+哈希表，一种动态分配的对象，程序仅持有一个对他们的引用；注意<code>a[&#39;x&#39;]</code>和<code>a.x</code>等价，但容易出错；索引的起始值为1；包含空隙Hole的数组，#会认为nil就是结尾标记，这时应该用<code>table.maxn()</code>，Lua5.2之后该方法不存在</li>\n<li><code>function</code><br/>看做“第一类值”，可以赋给变量；允许以匿名函数的形式通过参数传递</li>\n<li><code>thread</code><br/>在Lua里主要是协同程序，跟线程差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西；线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起<code>suspend</code>时才会暂停。</li>\n<li><code>userdata</code><br/>用户自定义数据，可以将C/C++的任意数据类型（通常是 struct 和 指针）存储到 Lua 变量中调用。</li>\n</ol>\n<p>注意：对于 <code>table/userdata/function</code>，只做引用的比较，<code>a~=b</code>。</p>\n<h4 id=\"3-变量\"><a href=\"#3-变量\" class=\"headerlink\" title=\"3 变量\"></a>3 变量</h4><ul>\n<li>Lua中的变量全是全局变量，哪怕是语句块或是函数里，除非用 <code>local</code> 显式声明；</li>\n<li>局部变量的作用域为从声明位置开始到所在语句块结束，缩短变量的作用域能提高代码的可读性，块作用域 <code>do-end</code>；</li>\n<li>尽可能使用局部变量：<code>local foo = foo</code>，避免命名冲突，同时加速在当前作用域对 foo 的访问；</li>\n<li>对 table 的索引使用方括号 <code>[]</code>，<code>.</code> 操作符是索引为字符串类型时的一种简化写法。</li>\n</ul>\n<h4 id=\"4-表达式\"><a href=\"#4-表达式\" class=\"headerlink\" title=\"4 表达式\"></a>4 表达式</h4><ul>\n<li>先计算右边所有的值然后再执行赋值操作：<code>x, y = y, x</code>；</li>\n<li>变量和值的个数不一致时：<code>a, b = 0 --b=nil</code>，<code>a, b = 0, 1, 2 --2 is ignored</code>；</li>\n<li>and和or都是短路求值，只在需要时才评估第二个数，<code>x = x or v</code>，<code>max = (x&gt;y) and x or y</code>；</li>\n</ul>\n<h4 id=\"5-迭代器\"><a href=\"#5-迭代器\" class=\"headerlink\" title=\"5 迭代器\"></a>5 迭代器</h4><p>迭代器获取三个值：迭代函数、状态常量、控制变量；<br/>无状态迭代器，避免创建闭包花费额外的代价；多状态迭代器，对应“多个状态信息”，将所有的状态封装到table内，作为迭代函数的唯一参数；<br/>不同类型的迭代器：文件中的每行 <code>io.lines</code>，table元素 <code>pairs</code>（遍历所有的值，包括nil），数组元素 <code>ipairs</code>（不能返回nil），字符串元素 <code>string.gmatch</code>。</p>\n<h4 id=\"6-函数\"><a href=\"#6-函数\" class=\"headerlink\" title=\"6 函数\"></a>6 函数</h4><ul>\n<li>函数的两个用途：作为调用语句，完成指定任务；</li>\n<li>多返回值、可变参数 <code>(fmt, …)</code>、具名实参；</li>\n<li>支持“尾调用消除”：递归不会造成栈溢出；编写“状态机”；</li>\n<li>判断“尾调用”：一个函数在调用完另一个函数后，是否无需做其他事情；完成一条 goto 语句到另一个函数，非传统的函数调用；<code>return &lt;func&gt;(&lt;args&gt;)</code>。</li>\n<li>冒号操作符：面向对象式的调用，<code>o.foo(o, x)</code> 等价于 <code>o:foo(x)</code>；所有Lua标准程序库的函数都是用C语言写的，但对于Lua程序员来说是透明的。</li>\n</ul>","text":"1 注释行注释：--；块注释：--[[注释内容]]，推荐用--[=[注释内容]=]，其中=的个数前后一致。 2 数据类型基础类型有8种： nil未初始化的变量默认为nil；删除一个全局变量b=nil boolean只有false和nil视为false，其他值都为true numb...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">1 注释</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2 数据类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">3 变量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">4 表达式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">5 迭代器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">6 函数</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"HMExpressionEvaluator——一个使用简单又强大的表达式计算库","uid":"4b8f33569d1aab990a4359341a6395b8","slug":"zl/2016-01-01-121_HMExpressionEvaluator——一个使用简单又强大的表达式计算库","date":"2024-04-03T03:47:33.029Z","updated":"2024-04-03T03:47:33.030Z","comments":true,"path":"api/articles/zl/2016-01-01-121_HMExpressionEvaluator——一个使用简单又强大的表达式计算库.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" demo下载地址 一. 简介 一个数学表达式计算器，能实现和 UIWebView 的 stringByEvaluatingJavaScriptFromString: 一样的计算效果，但效率要高很多，可以在子线程中执行； 基本全面覆盖 NSExpression 的 express...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"开发笔记(2) 服务器Lua战斗","uid":"41fdac5ddcf197d3c03efe34a7a44c49","slug":"zl/2016-01-01-119_开发笔记(2) 服务器Lua战斗","date":"2024-04-03T03:47:33.028Z","updated":"2024-04-03T03:47:33.029Z","comments":true,"path":"api/articles/zl/2016-01-01-119_开发笔记(2) 服务器Lua战斗.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"服务器战斗系统是自动战斗的，没有玩家实际操作，因此实际上是一份客户端的Lua战斗代码，这里讨论如何在Erlang中植入Lua代码。 1. Port Driver最开始，出于简单考虑，我使用Port Driver的方式来挂接战斗模块，使用erlualib库，通过luam:one_c...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}