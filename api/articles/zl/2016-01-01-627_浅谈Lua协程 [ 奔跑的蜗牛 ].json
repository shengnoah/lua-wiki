{"title":"浅谈Lua协程 [ 奔跑的蜗牛 ]","uid":"bc6521bfffe786c923335f804481d6ed","slug":"zl/2016-01-01-627_浅谈Lua协程 [ 奔跑的蜗牛 ]","date":"2024-04-03T03:47:35.849Z","updated":"2024-04-03T03:47:35.852Z","comments":true,"path":"api/articles/zl/2016-01-01-627_浅谈Lua协程 [ 奔跑的蜗牛 ].json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p class=\"page-title-sub\">\n      <span id=\"post-title-date\">撰写于 2018-05-09</span>\n<pre><code>    &lt;span id=&quot;post-title-updated&quot;&gt;修改于 2018-05-10&lt;/span&gt;\n  \n  \n  \n&lt;/p&gt;\n\n&lt;p&gt;很多脚本语言都有线程的概念，lua也不例外，但是lua的线程有点特殊，不能算作是真正的线程，叫做协程（coroutine），一般意义上的线程有如下特征：每个线程都有自己的堆栈；可以同时执行（多核）；抢占式执行，无须手动唤醒。但是协程不一样。&lt;/p&gt;\n</code></pre>\n<h4 id=\"协程特点\"><a href=\"#协程特点\" class=\"headerlink\" title=\"协程特点\"></a>协程特点</h4><ol>\n<li>有自己的的堆栈和局部变量</li>\n<li>需要手动切换协程之间的执行</li>\n<li>同一时刻只能有一个协程执行（无论是否是多核）</li>\n</ol>\n<h4 id=\"coroutine库\"><a href=\"#coroutine库\" class=\"headerlink\" title=\"coroutine库\"></a>coroutine库</h4><ol>\n<li><p><strong>coroutine.create(f)</strong><br/> 传递一个函数f，创建一个协程，返回协程句柄。</p>\n</li>\n<li><p><strong>coroutine.isyieldable()</strong><br/> 正在运行的协程是否可以让出，如果可以，返回true，只有主协程和C函数是无法让出的。</p>\n</li>\n<li><p><strong>coroutine.resume(co, [val1,…])</strong><br/> 启动或者再次启动一个协程，由挂起状态（suspended）变为运行状态（running）<br/> 注：<br/> 首次启动协程会把参数[val1,…]，传递给协程co的函数；<br/> 再次启动协程会把参数[val1,…]，作为给协程co上一次yeild的返回值。<br/> 返回值：</p>\n<ul>\n<li>如果协程co的函数执行完毕，则协程正常终止，resume返回true和函数的返回值</li>\n<li>如果协程执行过程中，协程挂起了，即调用yeild()，resume返回true和调用yeild传入的参数</li>\n<li>如果协程执行过程中发生了错误，resume返回false和错误消息</li>\n</ul>\n</li>\n<li><p><strong>coroutine.yeild(…)</strong><br/> 使正在实行的协程挂起<br/> 注：<br/> 传递给yeild的参数会作为resume的额外返回值</p>\n</li>\n<li><p><strong>coroutine.running()</strong><br/> 判断当前线程是不是主线程，如果是，返回true</p>\n</li>\n<li><p><strong>coroutine.status(co)</strong><br/> 返回string，表示协程co的状态</p>\n<ul>\n<li>running：由于当前只能有一个协程在执行，只有在协程的函数中使用status，传入自身句柄，执行到此处才会返回true，作用不大</li>\n<li>suspended：如果协程创建了还没有执行或者调用了yeild，则返回该状态</li>\n<li>normal：在协程A的函数里面resume了协程B，在B的执行过程中，则A就是normal状态。此时A的状态既不是运行，也不是挂起</li>\n<li>dead：协程在执行过程中发生了错误，或者正常执行完毕，就是dead状态。调用resume返回false和错误消息。</li>\n</ul>\n</li>\n<li><p><strong>coroutine.wrap(f)</strong><br/> 这个就是一个语法糖。功能同coroutine.create(f)。但是不返回协程的句柄，而是返回了一个函数。</p>\n<ul>\n<li>每次调用返回的函数，就相当于调用了coroutine.resume()</li>\n<li>如果该协程的函数执行错误，不会像resume一样，在保护模式下进行，返回false，而是直接崩溃，向外跑出异常。</li>\n</ul>\n</li>\n</ol>\n<p>以上都是摘自<a href=\"https://www.cnblogs.com/zrtqsk/p/4374360.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/zrtqsk/p/4374360.html</a></p>\n<h4 id=\"协程的优点\"><a href=\"#协程的优点\" class=\"headerlink\" title=\"协程的优点\"></a>协程的优点</h4><p>通过以上的介绍可以发现，lua的协程很简单，由于是手动控制协程的切换，不用考虑因资源抢占引起的问题。 </p>\n<h4 id=\"协程的缺点\"><a href=\"#协程的缺点\" class=\"headerlink\" title=\"协程的缺点\"></a>协程的缺点</h4><p>因为同一时间只有一个协程拥有执行权，只相当于单线程的能力，也导致了时间片不能公平分享，很是鸡肋，功能上也跟callback有重复。而且不能跨c函数切换协程。总之线程是系统级实现，而协程只是在应用层实现。</p>\n<p>知乎大神的评论：<br/><a href=\"https://www.zhihu.com/question/20511233\" target=\"_blank\" rel=\"noopener noreferrer\">协程不过是一个逻辑控制需求。一些语言原生支持，不支持也可以用原有的材料构建出来。协程的实现，无非是你要维护一组局部状态，在重新进入协程前，保证这些状态不被改变，你能顺利定位到之前的位置。你平时所写的一些逻辑控制代码，经典如状态机或对象等，也许就已经是一种“协程”了。区别在于是否精巧，适用条件是否苛刻，使用是否方便，效率是否足够罢了。面向对象中的对象，函数式语言中过程的chunk实现，都跟协程有些相似的结构。这些语言的表达足够丰富，有没有协程，倒不构成问题。真要说起来，我觉得协程的最大的好处是在写过程式（命令式）风格的代码时，很好的简化了逻辑的流程。</a></p>\n<p>还是不能理解协程的真谛！或许真的很强大，我不能理解！</p>","text":" 撰写于 2018-05-09 &lt;span id=&quot;post-title-updated&quot;&gt;修改于 2018-05-10&lt;/span&gt; &lt;/p&gt; &lt;p&gt;很多脚本语言都有线程的概念，lua也不例外，但是lua的线程...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">协程特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#coroutine%E5%BA%93\"><span class=\"toc-text\">coroutine库</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">协程的优点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">协程的缺点</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua中table常用的四种遍历方式｜qiuzhong's blog","uid":"5f54e1dfbf1c719150010bb064c034cd","slug":"zl/2016-01-01-626_Lua中table常用的四种遍历方式｜qiuzhong's blog","date":"2024-04-03T03:47:35.849Z","updated":"2024-04-03T03:47:35.849Z","comments":true,"path":"api/articles/zl/2016-01-01-626_Lua中table常用的四种遍历方式｜qiuzhong's blog.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"第一种遍历方式：for key, value in ipairs(table) do end 注：这种方式的遍历只会从key为1的地方开始，一直以key递增1的顺序来遍历，若找到一个递增不是1的key就结束遍历，无论后面是否仍然是顺序的key。请看下面例子： Sample_1:l...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"How NOT To Evaluate Your Dialogue System An Empirical Study of Unsupervised Evaluation Metrics for Dialogue Response Generation","uid":"6127ff9c3184f864bc8e9ab0efcbf3da","slug":"zl/2016-01-01-625_How NOT To Evaluate Your Dialogue System An Empiri","date":"2024-04-03T03:47:35.848Z","updated":"2024-04-03T03:47:35.848Z","comments":true,"path":"api/articles/zl/2016-01-01-625_How NOT To Evaluate Your Dialogue System An Empiri.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"如何评价对话生成的质量而不使用人工标注是一个还未解决的问题。这篇文章将证明现在已有的这些评测指标和Twitter domain的人工评测质量只有一点点的相关性，而在Ubuntu domain上则是毫不相关。这些评测值通常来自于机器翻译、文本摘要，比如BLEU、METEOR和ROU...","link":"","photos":[],"count_time":{"symbolsCount":726,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}