{"title":"Lua的元表","uid":"74fdff3e8ba6e278fa488790b194fb21","slug":"zl/2016-01-01-681_Lua的元表","date":"2024-04-03T03:47:35.913Z","updated":"2024-04-03T03:47:35.917Z","comments":true,"path":"api/articles/zl/2016-01-01-681_Lua的元表.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>在 Lua 5.1 语言中，元表 <em>(metatable)</em> 的表现行为类似于 C++ 语言中的操作符重载，例如我们可以重载 “__add” 元方法 <em>(metamethod)</em>，来计算两个 Lua 数组的并集；或者重载 “__index” 方法，来定义我们自己的 Hash 函数。Lua 提供了两个十分重要的用来处理元表的方法，如下：</p>\n<ul>\n<li>setmetatable(table, metatable)：此方法用于为一个表设置元表。</li>\n<li>getmetatable(table)：此方法用于获取表的元表对象。</li>\n</ul>\n<p>设置元表的方法很简单，如下：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> mytable = {}</span><br/><span class=\"line\"><span class=\"keyword\">local</span> mymetatable = {}</span><br/><span class=\"line\"><span class=\"built_in\">setmetatable</span>(mytable, mymetatable)</span><br/></pre></td></tr></tbody></table></figure>\n<p>上面的代码可以简写成如下的一行代码：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> mytable = <span class=\"built_in\">setmetatable</span>({}, {})</span><br/></pre></td></tr></tbody></table></figure>\n<h4 id=\"修改表的操作符行为\"><a href=\"#修改表的操作符行为\" class=\"headerlink\" title=\"修改表的操作符行为\"></a>修改表的操作符行为</h4><p>通过重载 “__add” 元方法来计算集合的并集实例：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> set1 = {<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>}   </span><br/><span class=\"line\"><span class=\"keyword\">local</span> set2 = {<span class=\"number\">20</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>}   </span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"comment\">-- 将用于重载__add的函数，注意第一个参数是self</span></span><br/><span class=\"line\"><span class=\"keyword\">local</span> union = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(self, another)</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">local</span> set = {}</span><br/><span class=\"line\">    <span class=\"keyword\">local</span> result = {}</span><br/><span class=\"line\"></span><br/><span class=\"line\">    <span class=\"comment\">-- 利用数组来确保集合的互异性</span></span><br/><span class=\"line\">    <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(self) <span class=\"keyword\">do</span> set[j] = <span class=\"literal\">true</span> <span class=\"keyword\">end</span></span><br/><span class=\"line\">    <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(another) <span class=\"keyword\">do</span> set[j] = <span class=\"literal\">true</span> <span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">    <span class=\"comment\">-- 加入结果集合</span></span><br/><span class=\"line\">    <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(set) <span class=\"keyword\">do</span> <span class=\"built_in\">table</span>.<span class=\"built_in\">insert</span>(result, i) <span class=\"keyword\">end</span></span><br/><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"><span class=\"built_in\">setmetatable</span>(set1, {<span class=\"built_in\">__add</span> = union}) <span class=\"comment\">-- 重载 set1 表的 __add 元方法</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">local</span> set3 = set1 + set2</span><br/><span class=\"line\"><span class=\"keyword\">for</span> _, j <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(set3) <span class=\"keyword\">do</span></span><br/><span class=\"line\">    <span class=\"built_in\">io</span>.<span class=\"built_in\">write</span>(j..<span class=\"string\">&#34; &#34;</span>)               <span class=\"comment\">--&gt;output：30 50 20 40 10</span></span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>除了加法可以被重载之外，Lua 提供的所有操作符都可以被重载：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">元方法</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">“__add”</td>\n<td style=\"text-align:center\">+ 操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__sub”</td>\n<td style=\"text-align:center\">- 操作 其行为类似于 “add” 操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__mul”</td>\n<td style=\"text-align:center\">* 操作 其行为类似于 “add” 操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__div”</td>\n<td style=\"text-align:center\">/ 操作 其行为类似于 “add” 操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__mod”</td>\n<td style=\"text-align:center\">% 操作 其行为类似于 “add” 操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__pow”</td>\n<td style=\"text-align:center\">^ （幂）操作 其行为类似于 “add” 操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__unm”</td>\n<td style=\"text-align:center\">一元 - 操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__concat”</td>\n<td style=\"text-align:center\">.. （字符串连接）操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__len”</td>\n<td style=\"text-align:center\"># 操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__eq”</td>\n<td style=\"text-align:center\">== 操作 函数 getcomphandler 定义了 Lua 怎样选择一个处理器来作比较操作 仅在两个对象类型相同且有对应操作相同的元方法时才起效</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__lt”</td>\n<td style=\"text-align:center\">&lt; 操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__le”</td>\n<td style=\"text-align:center\">&lt;= 操作</td>\n</tr>\n</tbody>\n</table>\n<p>除了操作符之外，如下元方法也可以被重载，下面会依次解释使用方法：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">元方法</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">“__index”</td>\n<td style=\"text-align:center\">取下标操作用于访问 table[key]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__newindex”</td>\n<td style=\"text-align:center\">赋值给指定下标 table[key] = value</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__tostring”</td>\n<td style=\"text-align:center\">转换成字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__call”</td>\n<td style=\"text-align:center\">当 Lua 调用一个值时调用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__mode”</td>\n<td style=\"text-align:center\">用于弱表(<em>week table</em>)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“__metatable”</td>\n<td style=\"text-align:center\">用于保护metatable不被访问</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"index-元方法\"><a href=\"#index-元方法\" class=\"headerlink\" title=\"__index 元方法\"></a>__index 元方法</h4><p>下面的例子中，我们实现了在表中查找键不存在时转而在元表中查找该键的功能：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">mytable = <span class=\"built_in\">setmetatable</span>({key1 = <span class=\"string\">&#34;value1&#34;</span>},   <span class=\"comment\">--原始表</span></span><br/><span class=\"line\">  {<span class=\"built_in\">__index</span> = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(self, key)</span></span>            <span class=\"comment\">--重载函数</span></span><br/><span class=\"line\">    <span class=\"keyword\">if</span> key == <span class=\"string\">&#34;key2&#34;</span> <span class=\"keyword\">then</span></span><br/><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#34;metatablevalue&#34;</span></span><br/><span class=\"line\">    <span class=\"keyword\">end</span></span><br/><span class=\"line\">  <span class=\"keyword\">end</span></span><br/><span class=\"line\">})</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"built_in\">print</span>(mytable.key1,mytable.key2)  <span class=\"comment\">--&gt; output：value1 metatablevalue</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>关于 __index 元方法，有很多比较高阶的技巧，例如：__index 的元方法不需要非是一个函数，他也可以是一个表。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">t = <span class=\"built_in\">setmetatable</span>({[<span class=\"number\">1</span>] = <span class=\"string\">&#34;hello&#34;</span>}, {<span class=\"built_in\">__index</span> = {[<span class=\"number\">2</span>] = <span class=\"string\">&#34;world&#34;</span>}})</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(t[<span class=\"number\">1</span>], t[<span class=\"number\">2</span>])   <span class=\"comment\">--&gt;hello world</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>第一句代码有点绕，解释一下：先是把 {__index = {}} 作为元表，但 __index 接受一个表，而不是函数，这个表中包含 [2] = “world” 这个键值对。<br/>所以当 t[2] 去在自身的表中找不到时，在 __index 的表中去寻找，然后找到了 [2] = “world” 这个键值对。</p>\n<p>__index 元方法还可以实现给表中每一个值赋上默认值；和 __newindex 元方法联合监控对表的读取、修改等比较高阶的功能，待读者自己去开发吧。</p>\n<h4 id=\"tostring-元方法\"><a href=\"#tostring-元方法\" class=\"headerlink\" title=\"__tostring 元方法\"></a>__tostring 元方法</h4><p>与 Java 中的 toString() 函数类似，可以实现自定义的字符串转换。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">arr = {<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>}</span><br/><span class=\"line\">arr = <span class=\"built_in\">setmetatable</span>(arr, {<span class=\"built_in\">__tostring</span> = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(self)</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">local</span> result = <span class=\"string\">&#39;{&#39;</span></span><br/><span class=\"line\">    <span class=\"keyword\">local</span> sep = <span class=\"string\">&#39;&#39;</span></span><br/><span class=\"line\">    <span class=\"keyword\">for</span> _, i <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(self) <span class=\"keyword\">do</span></span><br/><span class=\"line\">        result = result ..sep .. i</span><br/><span class=\"line\">        sep = <span class=\"string\">&#39;, &#39;</span></span><br/><span class=\"line\">    <span class=\"keyword\">end</span></span><br/><span class=\"line\">    result = result .. <span class=\"string\">&#39;}&#39;</span></span><br/><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br/><span class=\"line\"><span class=\"keyword\">end</span>})</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(arr)  <span class=\"comment\">--&gt; {1, 2, 3, 4}</span></span><br/></pre></td></tr></tbody></table></figure>\n<h4 id=\"call-元方法\"><a href=\"#call-元方法\" class=\"headerlink\" title=\"__call 元方法\"></a>__call 元方法</h4><p>__call 元方法的功能类似于 C++ 中的仿函数，使得普通的表也可以被调用。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">functor = {}</span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(self, arg)</span></span></span><br/><span class=\"line\">  <span class=\"built_in\">print</span> (<span class=\"string\">&#34;called from&#34;</span>, <span class=\"built_in\">arg</span>)</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"built_in\">setmetatable</span>(functor, {<span class=\"built_in\">__call</span> = func1})</span><br/><span class=\"line\"></span><br/><span class=\"line\">functor(<span class=\"string\">&#34;functor&#34;</span>)  <span class=\"comment\">--&gt; called from functor</span></span><br/><span class=\"line\"><span class=\"built_in\">print</span>(functor)      <span class=\"comment\">--&gt; output：0x00076fc8 （后面这串数字可能不一样）</span></span><br/></pre></td></tr></tbody></table></figure>\n<h4 id=\"metatable-元方法\"><a href=\"#metatable-元方法\" class=\"headerlink\" title=\"__metatable 元方法\"></a>__metatable 元方法</h4><p>假如我们想保护我们的对象使其使用者既看不到也不能修改 metatables。我们可以对 metatable 设置了 __metatable 的值，getmetatable 将返回这个域的值，而调用 setmetatable 将会出错：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">Object = <span class=\"built_in\">setmetatable</span>({}, {<span class=\"built_in\">__metatable</span> = <span class=\"string\">&#34;You cannot access here&#34;</span>})</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">getmetatable</span>(Object)) <span class=\"comment\">--&gt; You cannot access here</span></span><br/><span class=\"line\"><span class=\"built_in\">setmetatable</span>(Object, {})    <span class=\"comment\">--&gt; 引发编译器报错</span></span><br/></pre></td></tr></tbody></table></figure>","text":"在 Lua 5.1 语言中，元表 (metatable) 的表现行为类似于 C++ 语言中的操作符重载，例如我们可以重载 “__add” 元方法 (metamethod)，来计算两个 Lua 数组的并集；或者重载 “__index” 方法，来定义我们自己的 Hash 函数。Lua...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">修改表的操作符行为</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#index-%E5%85%83%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">__index 元方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#tostring-%E5%85%83%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">__tostring 元方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#call-%E5%85%83%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">__call 元方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#metatable-%E5%85%83%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">__metatable 元方法</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua语言","uid":"f2ad1fdbae5984109e0546da0f31ad6f","slug":"zl/2016-01-01-680_Lua语言","date":"2024-04-03T03:47:35.913Z","updated":"2024-04-03T03:47:35.913Z","comments":true,"path":"api/articles/zl/2016-01-01-680_Lua语言.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 1. 数据类型 数据类型 描述 nil 只有值为 nil 属于该类，表示一个无效值（在条件表达式中相当于 false） boolean false or true number 双精度类型的实浮点数 string 双引号或单引号表示 function 由 C 或 Lua 编写的...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"搭建ngx_lua_waf","uid":"5b06da96654ab629a54d2007eebfe28b","slug":"zl/2016-01-01-67_搭建ngx_lua_waf [ Hexo ]","date":"2024-04-03T03:47:35.912Z","updated":"2024-04-03T03:47:35.912Z","comments":true,"path":"api/articles/zl/2016-01-01-67_搭建ngx_lua_waf [ Hexo ].json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" Created at 2019-05-26 &lt;span id=&quot;post-title-updated&quot;&gt;Updated at 2019-08-15&lt;/span&gt; &lt;span id=&quot;post-title-categor...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}