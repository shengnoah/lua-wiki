{"title":"lua 与 C 交互","uid":"408a8e44ab8f1937b2d50b08485e1398","slug":"zl/2016-01-01-793_lua 与 C 交互","date":"2024-04-03T03:47:36.033Z","updated":"2024-04-03T03:47:36.033Z","comments":true,"path":"api/articles/zl/2016-01-01-793_lua 与 C 交互.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>lua和C交互的核心就是lua栈，lua和C的所有数据交互都是通过lua栈来完成的。</p>\n<h3 id=\"一-C调用lua\"><a href=\"#一-C调用lua\" class=\"headerlink\" title=\"一. C调用lua\"></a>一. C调用lua</h3><p>C调用lua很简单，通常C以lua作为配置脚本，在运行时读取脚本数据，主要步骤：</p>\n<ol>\n<li>加载脚本    luaL_loadfile </li>\n<li>运行脚本  lua_pcall </li>\n<li>获取数据  lua_getglobal …. </li>\n<li>使用数据  lua_tostring lua_pcall …</li>\n</ol>\n<h3 id=\"二-在lua脚本中调用C：\"><a href=\"#二-在lua脚本中调用C：\" class=\"headerlink\" title=\"二. 在lua脚本中调用C：\"></a>二. 在lua脚本中调用C：</h3><p>在C程序中，使用lua作为脚本，但是要在运行脚本时，访问C中定义的一些变量或函数。</p>\n<ol>\n<li>将C变量或函数(遵从指定函数原型，见下面三 Step 1)push到lua栈中</li>\n<li>通过lua_setglobal为当前lua栈顶的函数或变量命名，这样在lua中可通过该名字完成对变量或函数的使用</li>\n<li>之后可在加载的lua脚本中使用C变量或函数</li>\n</ol>\n<h3 id=\"三-将C函数封装为一个库，为lua所用\"><a href=\"#三-将C函数封装为一个库，为lua所用\" class=\"headerlink\" title=\"三. 将C函数封装为一个库，为lua所用\"></a>三. 将C函数封装为一个库，为lua所用</h3><p>将C函数编译为动态库文件，这样可以在lua主程序中，加载这个库文件，并使用其中的C函数。</p>\n<p><strong>Step 1</strong>. 在mylib.c中定义给lua调用的C函数 函数原型为： int (lua_State*)<br/>如：</p>\n<pre><code>static int c_addsub(lua_State* L)\n&#123;\n    double a = luaL_checknumber(L,1); // 获取参数1\n    double b = luaL_checknumber(L,2); // 获取参数2\n    lua_pushnumber(L, a+b); // 压入返回值1\n    lua_pushnumber(L, a-b); // 压入返回值2\n    return 2; // 两个返回值\n&#125;\n</code></pre><p><strong>Step 2</strong>. 在mylib.c中定义一个注册函数，用于lua在加载C动态库时，调用该函数完成对库中所导出的C函数的注册。<br/>如：</p>\n<pre><code>// 将C模块中要导出的C函数放入到luaL_Reg结构体数组内\nstatic const struct luaL_Reg l[] = &#123;\n    &#123;&#34;addsub&#34;, c_addsub&#125;,\n    &#123;NULL, NULL&#125; // 以NULL标识结束\n&#125;;\n<p>// 该函数在导入C库时调用 完成对库中导出的函数的注册<br />\n// 必须是non-static<br />\nint luaopen_mylib(lua_State* L)<br />\n&#123;<br />\n// 完成实际的注册工作<br />\n// 注册方式一: luaL_openlib(lua_State* L, const char* name, const luaL_Reg* l, int nup)<br />\n//   L : lua_State<br />\n// name: 表明该C库被加载后，所导出的函数位于哪一个全局table之下<br />\n//       这里是&quot;clib&quot; 那么之后lua中通过clib.addsub完成对C函数的调用<br />\n//   l : 要导出的函数的lua_Reg结构体数组<br />\n//         luaL_openlib自动将该数组内的name-function对注册并填充到第二参数指定的table下<br />\n// nup : upvalue的个数，如果不为0，则注册的所有函数都共享这些upvalues<br />\nluaL_openlib(L, &quot;clib&quot;, l, 0);</p>\n<pre><code>// 注册方式二: luaL_newlibtable + luaL_setfuncs (等价于lua_newlib)\n// luaL_newlibtable(L, l);\n// luaL_setfuncs(L, l, 0);\n// 前两句等价于：\n// luaL_newlib(L, l);\n\n// 将包含name-cfunction键值对的table返回给lua\nreturn 1;\n</code></pre>\n<p>}<br />\n</code></pre><p>注意上面方式一和方式二的主要区别：前者(luaL_openlib)为name-cfunction对在lua中注册了一个名字(“clib”)。而后者(luaL_newlib)没有，它只是将这个table返回给了lua。可在lua层通过赋值为其命名。自然，通过 <code>luaL_openlib</code> 和 <code>return 1</code>可以将name-cfuncton对注册到两个lua table下。</p></p>\n<p>关于luaL_openlib函数，在官方文档中没有找到它，lua5.2文档中给出的是luaL_newlibtable和lua_setfuncs等新API用以替代以前的luaL_register，而事实上根据前面lua和C交互的基本元素，我们可以自己实现一个类似lua_openlib的注册函数：</p>\n<pre><code>int luaopen_mylib(lua_State* L)\n&#123;\n    // luaL_openlib(L, &#34;clib&#34;, clib, 0);\n    int i = 0;\n    lua_newtable(L); // push a new table\n    while(clib[i].name != NULL)\n    &#123;\n        lua_pushstring(L, clib[i].name); // push name\n        lua_pushcfunction(L, clib[i].func); // push function\n        lua_settable(L, -3); // table[name] = function\n        ++i;\n    &#125;\n    lua_setglobal(L, &#34;clib&#34;); // set table name\n    return 1;        \n&#125;\n</code></pre><p>因此实际上将C作为动态库和前面二中的交互核心是一样的，只是将C作为动态库时，需要提供一个”入口函数”，用以在加载该动态库后执行，完成对库中所有导出函数的注册。</p>\n<p><strong>Step 3</strong>. 将相关C文件编译成动态链接库:</p>\n<p>需要说明的是Mac OS X需要使用gcc将mylualib.c编译为动态库，编译选项不同于Linux。<br/>具体编译命令（粗体部分不同于Linux，如果不使用这些选项，liblua将会被编译到so文件中并引起“multiple lua vms detected”错误， bundle是Mac使用的文件格式）：</p>\n<p>gcc -c mylib.c</p>\n<p>gcc -O2 <strong>-bundle -undefined dynamic_lookup</strong> -o mylib.so mylib.o</p>\n<p><strong>Step 4</strong>. 在lua中加载C动态库</p>\n<p>方式一 : 使用 loadlib</p>\n<pre><code>--加载C动态库 并将luaopen_mylib函数 导出到mylib变量中\nmylib = loadlib(&#34;./mylib.so&#34;, &#34;luaopen_mylib&#34;) \n<p>–调用mylib() 将执行lua_openmylib函数 完成对C动态库中所有导出函数的注册<br />\n–将C中返回的name-cfunction table赋给clualib变量<br />\nclualib = mylib()</p>\n<p>–通过clualib完成C函数的调用<br />\nsum, diff = clualib.addsub(5.6, 2.4);</p>\n<p>–针对于Step 2中的注册方式一，还可以通过luaL_openlib中传入的clib来使用C函数<br />\nsum, diff = clib.addsub(5.6, 2.4)<br />\n</code></pre><p>loadlib会读取动态库文件的符号表，得到luaopen_mylib函数的实现，并导出到mylib变量中，通过执行mylib()，即可执行luaopen_mylib完成对整个C库导出函数的注册。luaopen_mylib将注册完成后的name-cfunction对返回给lua，lua可以通过<code>clualib = mylib()</code>为这个注册完成之后的table命名。之后可通过clualib调用C函数。</p></p>\n<p>另外，luaL_openlib函数可以直接导出name-cfunction对并为其在lua中注册一个名字，因此通过clib也可以完成对C函数的调用。</p>\n<p>方式二 : 使用 require</p>\n<pre><code>clualib = require(&#34;mylib&#34;)\n<p>sum,diff = clualib.addsub(5.6, 2.4)</p>\n<p>– 对于luaL_openlib完成的注册，仍然可以通过clib来访问C函数<br />\nsum, diff = clib.addsub(5.6, 2.4)<br />\n</code></pre><p>require的工作原理：</p></p>\n<p>当你在脚本中使用require加载一个模块xxx的时候，首先它会在Lua的环境路径中寻找以xxx命名的DLL，如果找到了，则会在这个DLL中寻找luaopen_xxx的函数用于加载模块。我们只需要将自己需要导出给Lua调用的C内容通过这个函数导出就可以了。</p>\n<p>比如我们通过require(“mylib”)来导入模块，lua找到mylib.so库文件，并查找luaopen_mylib函数，然后调用该函数。因此我们需要注意两点：</p>\n<ol>\n<li>设置好库文件路径 确保库文件存在 </li>\n<li>确保库定义了luaopen_mylib函数(而不像前一个方法一样，可以通过loadlib函数手动指定入口函数)</li>\n</ol>\n<p>require的优势在于自动化，而loadlib方式则更加灵活，loadlib可以指定注册函数名字，注册函数可以无需按照luaopen_xxx格式命名。</p>\n<p>在一些库中，使用require(“mylib.core”)之类的格式来导入C模块，没有任何库文件时，通过require的报错可以看到其查找路径和规则：</p>\n<pre><code>lua: testmylib.lua:1: module &#39;mylib.core&#39; not found:\nno field package.preload[&#39;mylib.core&#39;]\nno file &#39;/usr/local/share/lua/5.2/mylib/core.lua&#39;\nno file &#39;/usr/local/share/lua/5.2/mylib/core/init.lua&#39;\nno file &#39;/usr/local/lib/lua/5.2/mylib/core.lua&#39;\nno file &#39;/usr/local/lib/lua/5.2/mylib/core/init.lua&#39;\nno file &#39;./mylib/core.lua&#39;\nno file &#39;/usr/local/lib/lua/5.2/mylib/core.so&#39;\nno file &#39;/usr/local/lib/lua/5.2/loadall.so&#39;\nno file &#39;./mylib/core.so&#39;\nno file &#39;/usr/local/lib/lua/5.2/mylib.so&#39;\nno file &#39;/usr/local/lib/lua/5.2/loadall.so&#39;\nno file &#39;./mylib.so&#39;\n</code></pre><p>先查找 PATH/mylib/core.so 如果没有，则直接使用 PATH/mylib.so。而C中的导出函数命名则必须为: luaopen_mylib_core(lua_State* L)。 </p>","text":"lua和C交互的核心就是lua栈，lua和C的所有数据交互都是通过lua栈来完成的。 一. C调用luaC调用lua很简单，通常C以lua作为配置脚本，在运行时读取脚本数据，主要步骤： 加载脚本 luaL_loadfile 运行脚本 lua_pcall 获取数据 lua_getg...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80-C%E8%B0%83%E7%94%A8lua\"><span class=\"toc-text\">一. C调用lua</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E5%9C%A8lua%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%B0%83%E7%94%A8C%EF%BC%9A\"><span class=\"toc-text\">二. 在lua脚本中调用C：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89-%E5%B0%86C%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%BA%93%EF%BC%8C%E4%B8%BAlua%E6%89%80%E7%94%A8\"><span class=\"toc-text\">三. 将C函数封装为一个库，为lua所用</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua性能优化技巧","uid":"9975cef0cac07289d180dc9800308309","slug":"zl/2016-01-01-796_[Lua] lua性能优化技巧 ","date":"2024-04-03T03:47:36.034Z","updated":"2024-04-03T03:47:36.035Z","comments":true,"path":"api/articles/zl/2016-01-01-796_[Lua] lua性能优化技巧 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"前言 和在所有其他编程语言中一样，在Lua中，我们依然应当遵循下述两条有关程序优化的箴言： 原则1：不要做优化。 原则2：暂时不要做优化（对专家而言）。 这两条原则对于Lua编程来说尤其有意义，Lua正是因其性能而在脚本语言中鹤立鸡群。 当然，我们都知道性能是编程中要考量的一个重...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua迭代器","uid":"eacf32e453764fca08d4d96ce1e78183","slug":"zl/2016-01-01-794_Lua迭代器","date":"2024-04-03T03:47:36.033Z","updated":"2024-04-03T03:47:36.033Z","comments":true,"path":"api/articles/zl/2016-01-01-794_Lua迭代器.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"标准库提供的几种迭代器：io.lines(迭代文件中的每行), pairs(迭代table元素),ipairs(迭代数组元素) string.gmatch(迭代字符串中单词)等。 自定义迭代器迭代器与闭包pairs见next","link":"","photos":[],"count_time":{"symbolsCount":112,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}