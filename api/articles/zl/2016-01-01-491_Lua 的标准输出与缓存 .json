{"title":"Lua 的标准输出与缓存","uid":"eb6769635061336dbbe2c0540f762f81","slug":"zl/2016-01-01-491_Lua 的标准输出与缓存 ","date":"2024-04-03T03:47:35.771Z","updated":"2024-04-03T03:47:35.771Z","comments":true,"path":"api/articles/zl/2016-01-01-491_Lua 的标准输出与缓存 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>最近我遇到了个奇怪的问题，我的一个 Lua 脚本需要通过 shell 的重定向将输出追加到一个日志文件中。但是那个 Lua 脚本的输出在日志文件里看来却不是实时的，输出的文本直到脚本结束时才能看到。</p>\n<p>在 shell 下运行这个程序，是可以看到实时输出的：</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">-- buffer_test.lua</span>\n<span class=\"kd\">local</span> <span class=\"n\">socket</span> <span class=\"o\">=</span> <span class=\"nb\">require</span> <span class=\"s2\">&#34;socket&#34;</span>\n<p><span class=\"kd\">local</span> <span class=\"n\">const</span> <span class=\"o\">=</span> <span class=\"mi\">100</span></p>\n<p><span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">const</span><span class=\"p\">,</span> <span class=\"mi\">1</span> <span class=\"k\">do</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span><br />\n<span class=\"n\">socket</span><span class=\"p\">.</span><span class=\"n\">select</span><span class=\"p\">(</span><span class=\"kc\">nil</span><span class=\"p\">,</span> <span class=\"kc\">nil</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span><br />\n<span class=\"k\">end</span><br />\n</code></pre></div></div></p>\n<p>但是当通过重定向时，只有脚本结束后才能看到文件：</p>\n<div class=\"language-sh highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># lua buffer_test.lua &gt;&gt;log.txt 2&gt;&amp;1 &amp;</span>\n<span class=\"c\"># tail -f log.txt</span>\n</code></pre></div></div>\n<p>看来当 Lua 的标准输出 stdout 连接的是终端时，采用了行缓存模式，而重定向到文件时则变成了完全缓存。翻遍了 Lua 的官方文档也没有找到这样的说明。但是在查看 stdio 的手册页时发现了下面的一段话：</p>\n<blockquote>\n  <p>The stdio library is a part of the library libc and routines are auto-matically loaded as needed by the compilers cc(1) and pc(1).\n<br/><br/>\nAt program startup, three text streams are predefined and need not be opened explicitly — standard input (for reading conventional input), — standard output (for writing conventional input), and standard error (for writing diagnostic output). These streams are abbreviated stdin,stdout and stderr. <span style=\"background-color: #FFFB00;\">When opened, the standard error stream is not fully buffered; the standard input and output streams are fully buffered if and only if the streams do not to refer to an interactive device.</span>\n<br/><br/>\nOutput streams that refer to terminal devices are always line buffered by default;</p>\n</blockquote>\n<p>原来 stdio 都是由 libc 提供，而我在 <code class=\"highlighter-rouge\">ldd lua</code> 时发现 Lua 确实也依赖于 libc。这下就可以解释了：Lua 在连接是终端的时候采用的是行缓存，而连接的是非活跃的设备时是采用的是完全缓存。</p>\n<p>但是假如我们中途终止脚本，查看日志：</p>\n<div class=\"language-sh highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># nl log.txt</span>\n 1\tlua: io.lua:9: interrupted!\n 2\tstack traceback:\n 3\t\t<span class=\"o\">[</span>C]: <span class=\"k\">in function</span> <span class=\"s1\">&#39;select&#39;</span>\n 4\t\tio.lua:9: <span class=\"k\">in </span>main chunk\n 5\t\t<span class=\"o\">[</span>C]: ?\n 6\t1\n 7\t2\n 8\t3\n</code></pre></div></div>\n<p>可以发现异常的日志难道不应该在最后面吗？其实上面的引用已经帮我们回答了：stderr 并不是完全缓存，当发生异常时，stderr 首先被写入日志，接着缓存区的 stdout 才会被刷入文件。</p>\n<p><strong>回顾这个问题，给我们留下的经验是 Lua 的很多库的实现原理其实在 libc 与系统调用那儿，不要只把目光局限在 Lua 的文档上。其实在其他的语言中，我估计也差不多。我们在查找问题的时候，一定要跳出自己的固有思维，有时候自己非常有把握的知识恰恰是不准确的。</strong></p>\n<pre><code>            &lt;hr style=&quot;visibility: hidden;&quot;/&gt;\n</code></pre>\n","text":"最近我遇到了个奇怪的问题，我的一个 Lua 脚本需要通过 shell 的重定向将输出追加到一个日志文件中。但是那个 Lua 脚本的输出在日志文件里看来却不是实时的，输出的文本直到脚本结束时才能看到。 在 shell 下运行这个程序，是可以看到实时输出的： -- buffer_te...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling","uid":"6b55ea064b627951a749da509664ef2b","slug":"zl/2016-01-01-496_An Empirical Evaluation of Generic Convolutional a","date":"2024-04-03T03:47:35.776Z","updated":"2024-04-03T03:47:35.776Z","comments":true,"path":"api/articles/zl/2016-01-01-496_An Empirical Evaluation of Generic Convolutional a.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"目录： TCN 论文总结 基础知识 1. 时间序列 2. RNN, LSTM, GRU 3. CNN TCN Causal Convolutions Dilate Convolutions Residual Convolutions TCN 的结构 实验 总结 参考文献 基础知识...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"浅析C++与Lua数据交互层","uid":"c72d78f454d2a2acb9fdf206046327ce","slug":"zl/2016-01-01-492_浅析C++与Lua数据交互层","date":"2024-04-03T03:47:35.771Z","updated":"2024-04-03T03:47:35.775Z","comments":true,"path":"api/articles/zl/2016-01-01-492_浅析C++与Lua数据交互层.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"背景 ​ C++作为服务器端开发的主流语言，相比其他语言有明显的性能优势，但是它的技术门槛比较高，不支持热更新，无法进行迅速的需求迭代和线上问题的响应。另外，C++内存管理的特点，技术人员对指针的使用不当，可能会造成宕机。因此，现在越来越多的技术团队会选择在C++中嵌入脚本语言，...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}