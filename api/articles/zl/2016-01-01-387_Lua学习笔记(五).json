{"title":"Lua学习笔记(五)","uid":"aa87979226eb6b10ddf77cb719096bc6","slug":"zl/2016-01-01-387_Lua学习笔记(五)","date":"2024-04-03T03:47:35.675Z","updated":"2024-04-03T03:47:35.676Z","comments":true,"path":"api/articles/zl/2016-01-01-387_Lua学习笔记(五).json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<ul>\n<li><a href=\"#错误处理\">错误处理</a><ul>\n<li><a href=\"#assert\">assert</a></li>\n<li><a href=\"#error\">error</a></li>\n<li><a href=\"#pcall\">pcall</a></li>\n<li><a href=\"#xpcall\">xpcall</a></li>\n<li><a href=\"#debug\">debug</a></li>\n</ul>\n</li>\n<li><a href=\"#调试\">调试</a></li>\n<li><a href=\"#垃圾回收\">垃圾回收</a><ul>\n<li><a href=\"#垃圾回收函数\">垃圾回收函数</a></li>\n</ul>\n</li>\n</ul>\n<h2><span id=\"错误处理\">错误处理</span></h2><p>平时写代码的时候出现错误其实是一件十分平常的事情，自然，如何处理错误也是需要联系的方法。</p>\n<p>一般在Lua中可以使用<strong>assert</strong>和<strong>error</strong>来处理错误。</p>\n<h3><span id=\"assert\">assert</span></h3><p>简单实例：</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">local function add(a,b)</span><br/><span class=\"line\">    assert(type(a)==&#34;number&#34;,&#34;a不是数字&#34;)</span><br/><span class=\"line\">    assert(type(b)==&#34;number&#34;,&#34;b不是数字&#34;)</span><br/><span class=\"line\">    return a+b</span><br/><span class=\"line\">end</span><br/><span class=\"line\">add(10)</span><br/></pre></td></tr></tbody></table></figure>\n<p>输出结果：</p>\n<p><img src=\"https://thbelief.github.io//2019/04/29/Lua学习笔记-五/assert输出.jpg\" alt=\"\"/></p>\n<p>在这个过程中，assert先检查第一个参数，如果没问题什么也不做，如果有问题的话，就把第二个参数作为错误信息抛出来。</p>\n<h3><span id=\"error\">error</span></h3><p>语法：</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">error (message [, level])</span><br/></pre></td></tr></tbody></table></figure>\n<p>error的功能主要就是<strong>终止在执行的函数，</strong>同时返回message的内容作为错误信息（error永远不会返回），一般情况就是，error附加一些错误位置的信息到message的头部。</p>\n<p>level参数：</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">Level=1[默认]：为调用error位置(文件+行号)</span><br/><span class=\"line\">Level=2：指出哪个调用error的函数的函数</span><br/><span class=\"line\">Level=0:不添加错误位置信息</span><br/></pre></td></tr></tbody></table></figure>\n<h3><span id=\"pcall\">pcall</span></h3><p>Lua中处理错误，可以使用<strong>函数pcall（protected call）来包装需要执行的代码。</strong></p>\n<p><strong>pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo。</strong></p>\n<p>语法如下：</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">if pcall(function_name, ….) then</span><br/><span class=\"line\">-- 没有错误</span><br/><span class=\"line\">else</span><br/><span class=\"line\">-- 一些错误</span><br/><span class=\"line\">end</span><br/></pre></td></tr></tbody></table></figure>\n<p>值得注意的是，由于pcall是使用<strong>保护模式</strong>来调用第一个参数，所以可以捕获函数中执行时所有的错误。</p>\n<h3><span id=\"xpcall\">xpcall</span></h3><p>通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经<strong>销毁了调用桟的部分内容。</strong></p>\n<p>Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取<strong>关于错误的额外信息</strong>了。</p>\n<h3><span id=\"debug\">debug</span></h3><p>debug库提供的两个方法：</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">debug.debug：提供一个Lua提示符，让用户来检查错误的原因</span><br/><span class=\"line\">debug.traceback：根据调用桟来构建一个扩展的错误消息</span><br/></pre></td></tr></tbody></table></figure>\n<h2><span id=\"调试\">调试</span></h2><p><strong>Lua中提供了debug库用于用户自定义调试器。</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">方法 &amp; 用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1.</td>\n<td style=\"text-align:left\"><strong>debug():</strong>进入一个用户交互模式，运行用户输入的每个字符串。 使用简单的命令以及其它调试设置，用户可以检阅全局变量和局部变量， 改变变量的值，计算一些表达式，等等。  输入一行仅包含 cont 的字符串将结束这个函数， 这样调用者就可以继续向下运行。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2.</td>\n<td style=\"text-align:left\"><strong>getfenv(object):</strong>返回对象的环境变量。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3.</td>\n<td style=\"text-align:left\"><strong>gethook(optional thread):</strong>返回三个表示线程钩子设置的值： 当前钩子函数，当前钩子掩码，当前钩子计数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4.</td>\n<td style=\"text-align:left\"><strong>getinfo ([thread,] f [, what]):</strong>返回关于一个函数信息的表。 你可以直接提供该函数， 也可以用一个数字 f 表示该函数。 数字 f 表示运行在指定线程的调用栈对应层次上的函数： 0 层表示当前函数（getinfo 自身）； 1 层表示调用 getinfo 的函数 （除非是尾调用，这种情况不计入栈）；等等。 如果 f 是一个比活动函数数量还大的数字， getinfo 返回 nil。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5.</td>\n<td style=\"text-align:left\"><strong>debug.getlocal ([thread,] f, local):</strong>此函数返回在栈的 f 层处函数的索引为 local 的局部变量 的名字和值。 这个函数不仅用于访问显式定义的局部变量，也包括形参、临时变量等。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6.</td>\n<td style=\"text-align:left\"><strong>getmetatable(value):</strong>把给定索引指向的值的元表压入堆栈。如果索引无效，或是这个值没有元表，函数将返回 0 并且不会向栈上压任何东西。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7.</td>\n<td style=\"text-align:left\"><strong>getregistry():</strong>返回注册表表，这是一个预定义出来的表， 可以用来保存任何 C 代码想保存的 Lua 值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8.</td>\n<td style=\"text-align:left\"><strong>getupvalue (f, up)</strong>此函数返回函数 f 的第 up 个上值的名字和值。 如果该函数没有那个上值，返回 nil 。  以 ‘(‘ （开括号）打头的变量名表示没有名字的变量 （去除了调试信息的代码块）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">10.</td>\n<td style=\"text-align:left\"><strong>sethook ([thread,] hook, mask [, count]):</strong>将一个函数作为钩子函数设入。 字符串 mask 以及数字 count 决定了钩子将在何时调用。 掩码是由下列字符组合成的字符串，每个字符有其含义：<strong>‘c’:</strong> 每当 Lua 调用一个函数时，调用钩子；<strong>‘r’:</strong> 每当 Lua 从一个函数内返回时，调用钩子；<strong>‘l’:</strong> 每当 Lua 进入新的一行时，调用钩子。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11.</td>\n<td style=\"text-align:left\"><strong>setlocal ([thread,] level, local, value):</strong>这个函数将 value 赋给 栈上第 level 层函数的第 local 个局部变量。 如果没有那个变量，函数返回 nil 。 如果 level 越界，抛出一个错误。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">12.</td>\n<td style=\"text-align:left\"><strong>setmetatable (value, table):</strong>将 value 的元表设为 table （可以是 nil）。 返回 value。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">13.</td>\n<td style=\"text-align:left\"><strong>setupvalue (f, up, value):</strong>这个函数将 value 设为函数 f 的第 up 个上值。 如果函数没有那个上值，返回 nil 否则，返回该上值的名字。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">14.</td>\n<td style=\"text-align:left\"><strong>traceback ([thread,] [message [, level]]):</strong>如果 message 有，且不是字符串或 nil， 函数不做任何处理直接返回 message。 否则，它返回调用栈的栈回溯信息。 字符串可选项 message 被添加在栈回溯信息的开头。 数字可选项 level 指明从栈的哪一层开始回溯 （默认为 1 ，即调用 traceback 的那里）。</td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"垃圾回收\">垃圾回收</span></h2><p>Lua中有<strong>自动内存管理</strong>功能，不需要主动释放内存，十分的方便。</p>\n<p>Lua 运行了一个<strong>垃圾收集器</strong>来收集所有<strong>死对象</strong> （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。</p>\n<h3><span id=\"垃圾回收函数\">垃圾回收函数</span></h3><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">collectgarbage(&#34;collect&#34;): 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：</span><br/><span class=\"line\"></span><br/><span class=\"line\">collectgarbage(&#34;count&#34;): 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。</span><br/><span class=\"line\"></span><br/><span class=\"line\">collectgarbage(&#34;restart&#34;): 重启垃圾收集器的自动运行。</span><br/><span class=\"line\"></span><br/><span class=\"line\">collectgarbage(&#34;setpause&#34;): 将 arg 设为收集器的 间歇率 （参见 §2.5）。 返回 间歇率 的前一个值。</span><br/><span class=\"line\"></span><br/><span class=\"line\">collectgarbage(&#34;setstepmul&#34;): 返回 步进倍率 的前一个值。</span><br/><span class=\"line\"></span><br/><span class=\"line\">collectgarbage(&#34;step&#34;): 单步运行垃圾收集器。 步长&#34;大小&#34;由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。</span><br/><span class=\"line\"></span><br/><span class=\"line\">collectgarbage(&#34;stop&#34;): 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。</span><br/></pre></td></tr></tbody></table></figure>\n<p>简单实例：</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">--这是一个简单的垃圾回收实例</span><br/><span class=\"line\">array={&#34;hello&#34;,&#34;world&#34;,&#34;thbelief&#34;}</span><br/><span class=\"line\"></span><br/><span class=\"line\">print(collectgarbage(&#34;count&#34;))</span><br/><span class=\"line\"></span><br/><span class=\"line\">array=nil</span><br/><span class=\"line\"></span><br/><span class=\"line\">print(collectgarbage(&#34;count&#34;))</span><br/><span class=\"line\"></span><br/><span class=\"line\">print(collectgarbage(&#34;collect&#34;))</span><br/><span class=\"line\"></span><br/><span class=\"line\">print(collectgarbage(&#34;count&#34;))</span><br/></pre></td></tr></tbody></table></figure>\n<p>输出结果：</p>\n<p><img src=\"https://thbelief.github.io//2019/04/29/Lua学习笔记-五/垃圾回收.jpg\" alt=\"\"/></p>","text":" 错误处理 assert error pcall xpcall debug 调试 垃圾回收 垃圾回收函数 错误处理平时写代码的时候出现错误其实是一件十分平常的事情，自然，如何处理错误也是需要联系的方法。 一般在Lua中可以使用assert和error来处理错误。 assert简单...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">错误处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">assert</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">error</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">pcall</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">xpcall</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">debug</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">调试</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">垃圾回收</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">垃圾回收函数</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua之Table个人总结","uid":"8e148f7d0ca183bc864d5f807e1a3198","slug":"zl/2016-01-01-389_Lua之Table个人总结","date":"2024-04-03T03:47:35.676Z","updated":"2024-04-03T03:47:35.677Z","comments":true,"path":"api/articles/zl/2016-01-01-389_Lua之Table个人总结.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 在lua中Table是数组和集合的混合物。作为数组时，可以使用除了nil以外的值作为索引。 Table的构造利用下标来标明元素123456local table = {}table[1]=&#39;hello&#39;table[5]=&#39;world&#39;for i,...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Redis Lua脚本中学教程（下）","uid":"83bf5d539c88e7810a3454ec632f2306","slug":"zl/2016-01-01-385_Redis Lua脚本中学教程（下）","date":"2024-04-03T03:47:35.671Z","updated":"2024-04-03T03:47:35.671Z","comments":true,"path":"api/articles/zl/2016-01-01-385_Redis Lua脚本中学教程（下）.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 在中学教程的上半部分我们介绍了Redis Lua相关的命令，没有看过或者忘记的同学可以步行前往直接使用机票Redis Lua脚本中学教程（上）。今天我们来简单学习一下Lua的语法。 在介绍Lua语法之前，先来介绍一下Lua的身世。Lua是由简称为PUC-Rio的团队设计、开发和...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}