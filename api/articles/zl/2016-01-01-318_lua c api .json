{"title":"lua c api","uid":"a088e52eeedd5a2e08a78395ae73ef54","slug":"zl/2016-01-01-318_lua c api ","date":"2024-04-03T03:47:35.598Z","updated":"2024-04-03T03:47:35.598Z","comments":true,"path":"api/articles/zl/2016-01-01-318_lua c api .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"一-registry\">一 <code class=\"highlighter-rouge\">registry</code></h2> <p><code class=\"highlighter-rouge\">registry</code> 是一个单独的表，用来保存 <code class=\"highlighter-rouge\">lua</code> 中的全局变量，同时 <code class=\"highlighter-rouge\">lua</code> 代码不能直接访问（只能通过 <code class=\"highlighter-rouge\">c</code> 函数接口访问）。<code class=\"highlighter-rouge\">registry</code> 通过伪索引（<code class=\"highlighter-rouge\">LUA_REGISTRYINDEX</code>）访问，<strong>伪索引类似于栈上的索引，但是它的关联数据并未在栈中</strong>。</p> <p><code class=\"highlighter-rouge\">registry</code> 的存在是用来解决一个问题：在 <code class=\"highlighter-rouge\">c</code> 动态库中如何保存一个 <code class=\"highlighter-rouge\">lua</code> 状态机的全局变量。如果使用 <code class=\"highlighter-rouge\">c</code> 的全局变量、静态变量，相同进程内的所有 <code class=\"highlighter-rouge\">lua</code> 状态机会共享此变量。如果将值保存在 <code class=\"highlighter-rouge\">lua</code> 中的全局 <code class=\"highlighter-rouge\">table</code> 中，<code class=\"highlighter-rouge\">lua</code> 代码是可以直接访问、修改的；没有限制措施，数据被修改后非常容易导致 <code class=\"highlighter-rouge\">c</code> 动态库崩溃。</p> <p>使用 <code class=\"highlighter-rouge\">registry</code> 可以实现针对每个 <code class=\"highlighter-rouge\">state</code> 保存全局变量，同时不同动态库直接可以通过约定的 <code class=\"highlighter-rouge\">key</code> 从 <code class=\"highlighter-rouge\">registry</code> 中获得值，进行交互。</p> <p>如果动态库（<code class=\"highlighter-rouge\">.so</code>）不希望其他库修改自己设置的全局变量，一个好的方法是使用全局变量的地址作为 <code class=\"highlighter-rouge\">key</code>。此时需要取全局变量地址，并转换为 <code class=\"highlighter-rouge\">lightuserdata</code> 作为 <code class=\"highlighter-rouge\">registry</code> 的 <code class=\"highlighter-rouge\">key</code>。</p> <h3 id=\"1-示例代码\">1. 示例代码</h3> <div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/*\n * 在 registry 全局表中保存一条记录 \n * registry[key] = value\n */</span>\n<span class=\"kt\">void</span> \n<span class=\"nf\">state_store_global_var</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\">*</span><span class=\"n\">state</span><span class=\"p\">,</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">value</span><span class=\"p\">)</span>\n<span class=\"p\">&#123;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">state</span><span class=\"o\">||!</span><span class=\"n\">key</span><span class=\"o\">||!</span><span class=\"n\">value</span><span class=\"p\">)</span> <span class=\"k\">return</span><span class=\"p\">;</span>\n<pre><code>&lt;span class=&quot;n&quot;&gt;lua_pushstring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 入栈\n</code></pre>\n<p></span>    <span class=\"n\">lua_pushstring</span><span class=\"p\">(</span><span class=\"n\">state</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">);</span>   <span class=\"c1\">// 入栈<br />\n</span>    <span class=\"c1\">// 操作 registy table<br />\n</span>    <span class=\"c1\">// registy[key] = value<br />\n</span>    <span class=\"n\">lua_settable</span><span class=\"p\">(</span><span class=\"n\">state</span><span class=\"p\">,</span> <span class=\"n\">LUA_REGISTRYINDEX</span><span class=\"p\">);</span><br />\n<span class=\"p\">}</span><br />\n</code></pre></div></div> <h2 id=\"二-references\">二 <code class=\"highlighter-rouge\">references</code></h2> <p>如果想在 <code class=\"highlighter-rouge\">registry</code> 中添加记录而又不想费劲考虑如何分配 <code class=\"highlighter-rouge\">key</code>，可以使用 <code class=\"highlighter-rouge\">reference</code> 系统。<code class=\"highlighter-rouge\">reference</code> 系统可以自动生成一个唯一 <code class=\"highlighter-rouge\">key</code>。</p> <div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">luaL_ref</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">LUA_REGISTRYINDEX</span><span class=\"p\">);</span><br />\n</code></pre></div></div> <p>这个函数会从栈顶弹出一个元素，并保存到 <code class=\"highlighter-rouge\">registry</code> 中，同时返回唯一数值 <code class=\"highlighter-rouge\">r</code> 作为索引。数值 <code class=\"highlighter-rouge\">r</code> 就叫做栈顶值的“引用”（reference）。</p> <p>从这可以看出，用户不能在 <code class=\"highlighter-rouge\">registry</code> 中使用数值作为 <code class=\"highlighter-rouge\">key</code>，避免影响 <code class=\"highlighter-rouge\">reference</code> 系统。</p> <p>在 <code class=\"highlighter-rouge\">c</code> 中无法直接使用指向 <code class=\"highlighter-rouge\">lua</code> 的 <code class=\"highlighter-rouge\">table</code>、<code class=\"highlighter-rouge\">function</code> 类型指针（未提供此类接口），我们可以使用引用实现类似指针的功能。假设上面的例子中栈顶元素为 <code class=\"highlighter-rouge\">table</code>，我们已经创建了它的一个引用，下面我们将其再次放入栈顶：</p> <div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">lua_rawgeti</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">LUA_REGISTRYINDEX</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">);</span><br />\n</code></pre></div></div> <p>在引用使用结束后，我们需要使用 <code class=\"highlighter-rouge\">luaL_unref</code> 释放引用值与引用自身：</p> <div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">luaL_unref</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">LUA_REGISTRYINDEX</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">);</span><br />\n</code></pre></div></div> <h2 id=\"三-upvalues\">三 <code class=\"highlighter-rouge\">Upvalues</code></h2> <p><code class=\"highlighter-rouge\">Upvalue</code> 存在的目的是为了在 <code class=\"highlighter-rouge\">c</code> 中实现闭包功能。<code class=\"highlighter-rouge\">Upvalue</code> 仅在函数内可见，并且在每个函数中是相互独立的。示例代码：</p> <div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 定义函数<br />\n</span><span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"n\">counter</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\">*</span><span class=\"n\">L</span><span class=\"p\">);</span></p>\n<p><span class=\"kt\">int</span> <span class=\"nf\">newCounter</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\">*</span><span class=\"n\">L</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"n\">lua_pushnumber</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span> <span class=\"c1\">// 栈顶增加数字，后续作为闭包的值<br />\n</span>  <span class=\"c1\">// 创建闭包<br />\n</span>  <span class=\"c1\">// &amp;counter 是闭包基函数；注意是函数名取地址<br />\n</span>  <span class=\"c1\">// 1 告诉闭包 upvalue 的数目<br />\n</span>  <span class=\"n\">lua_pushcclosure</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">counter</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span><br />\n<span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span><br />\n<span class=\"p\">&#125;</span></p>\n<p><span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"nf\">counter</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"><em></span><span class=\"n\">L</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"c1\">// lua_upvalueindex 同样适用伪索引技术，取 counter 函数的第一个 upvale<br />\n</span>  <span class=\"kt\">double</span> <span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"n\">lua_tonumber</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">lua_upvalueindex</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">));</span><br />\n<span class=\"n\">lua_pushnumber</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">++</span><span class=\"n\">val</span><span class=\"p\">);</span> <span class=\"c1\">// 栈顶值为 upvalue 值加 1<br />\n</span>  <span class=\"n\">lua_pushvalue</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">);</span> <span class=\"c1\">// 栈顶增加一个相同值，用来更新 upvalue 值<br />\n</span>  <span class=\"n\">lua_replace</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">lua_upvalueindex</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">));</span> <span class=\"c1\">// 更新 upvalue 值<br />\n</span>  <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span><br />\n<span class=\"p\">&#125;</span><br />\n</code></pre></div></div> <h3 id=\"1-闭包示例代码\">1. 闭包示例代码</h3> <div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// gcc -fPIC -I/usr/local/lua5.1.5/include  -g -c counter.c -Wall<br />\n// gcc -shared -I/usr/local/lua5.1.5/include  -L/usr/local/lua5.1.5/lib -llua -o <a href=\"http://counter.so\">counter.so</a> counter.o<br />\n</span><br />\n<span class=\"cp\">#include &lt;stdio.h&gt;<br />\n#include &lt;stdlib.h&gt;<br />\n#include &lt;unistd.h&gt;<br />\n</span><br />\n<span class=\"cp\">#include &quot;lua.h&quot;<br />\n#include &quot;lauxlib.h&quot;<br />\n#include &quot;lualib.h&quot;<br />\n</span><br />\n<span class=\"k\">static</span> <span class=\"kt\">int</span><br />\n<span class=\"nf\">counter</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"></em></span><span class=\"n\">L</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"c1\">// lua_upvalueindex 同样适用伪索引技术，取 counter 函数的第一个 upvale<br />\n</span>  <span class=\"kt\">double</span> <span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"n\">lua_tonumber</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">lua_upvalueindex</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">));</span><br />\n<span class=\"n\">lua_pushnumber</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">++</span><span class=\"n\">val</span><span class=\"p\">);</span> <span class=\"c1\">// 栈顶值为 upvalue 值加 1<br />\n</span>  <span class=\"n\">lua_pushvalue</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">);</span> <span class=\"c1\">// 栈顶增加一个相同值，用来更新 upvalue 值<br />\n</span>  <span class=\"n\">lua_replace</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">lua_upvalueindex</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">));</span> <span class=\"c1\">// 更新 upvalue 值<br />\n</span>  <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span><br />\n<span class=\"p\">&#125;</span></p>\n<p><span class=\"k\">static</span> <span class=\"kt\">int</span><br />\n<span class=\"nf\">newCounter</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\">*</span><span class=\"n\">L</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"n\">lua_pushnumber</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span> <span class=\"c1\">// 栈顶增加数字，后续作为闭包的值<br />\n</span>  <span class=\"c1\">// 创建闭包<br />\n</span>  <span class=\"c1\">// &amp;counter 是闭包基函数；注意是函数名取地址<br />\n</span>  <span class=\"c1\">// 1 告诉闭包 upvalue 的数目<br />\n</span>  <span class=\"n\">lua_pushcclosure</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">counter</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span><br />\n<span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span><br />\n<span class=\"p\">&#125;</span></p>\n<p><span class=\"k\">static</span> <span class=\"k\">const</span><br />\n<span class=\"k\">struct</span> <span class=\"n\">luaL_reg</span> <span class=\"n\">counter_lib</span><span class=\"p\">[]</span> <span class=\"o\">=</span> <span class=\"p\">&#123;</span><br />\n<span class=\"p\">&#123;</span><span class=\"s\">&quot;newCounter&quot;</span><span class=\"p\">,</span> <span class=\"n\">newCounter</span><span class=\"p\">&#125;,</span><br />\n<span class=\"p\">&#123;</span><span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">&#125;</span><br />\n<span class=\"p\">&#125;;</span></p>\n<p><span class=\"cm\">/******************************************************************************</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-3\">\n<p>注册函数</p>\n</li>\n<li class=\"lvl-3\">\n<p>注意，在 lua 中 require 时，必须与 luaopen_xxxx 相同<br />\n*********************************************************************<em><em><em><em><em><em><em><em><em>/</span><br />\n<span class=\"kt\">int</span><br />\n<span class=\"nf\">luaopen_counter</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"></em></span><span class=\"n\">l</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"n\">luaL_openlib</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"s\">&quot;counter&quot;</span><span class=\"p\">,</span> <span class=\"n\">counter_lib</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span><br />\n<span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span><br />\n<span class=\"p\">&#125;</span><br />\n</code></pre></div></div> <p><code class=\"highlighter-rouge\">newCounter</code> 在 <code class=\"highlighter-rouge\">C</code> 中创建一个闭包，返回给 <code class=\"highlighter-rouge\">lua</code> 使用。</p> <div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">– use package.loadlib or require to dynamic library</span><br />\n<span class=\"c1\">– l,e = package.loadlib(&quot;./counter.so&quot;, &quot;luaopen_counter&quot;)</span><br />\n<span class=\"nb\">require</span> <span class=\"s2\">&quot;counter&quot;</span><br />\n<span class=\"n\">c1</span> <span class=\"o\">=</span> <span class=\"n\">counter</span><span class=\"p\">.</span><span class=\"n\">newCounter</span><span class=\"p\">()</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">c1</span><span class=\"p\">))</span> <span class=\"c1\">–&gt; function</span><br />\n<span class=\"n\">c2</span> <span class=\"o\">=</span> <span class=\"n\">counter</span><span class=\"p\">.</span><span class=\"n\">newCounter</span><span class=\"p\">()</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">c1</span><span class=\"p\">())</span> <span class=\"c1\">–&gt; 1</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">c1</span><span class=\"p\">())</span> <span class=\"c1\">–&gt; 2</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">c2</span><span class=\"p\">())</span> <span class=\"c1\">–&gt; 1</span><br />\n</code></pre></div></div> <h3 id=\"2-程序说明\">2. 程序说明</h3> <div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cp\">#define luaI_openlib luaL_openLib<br />\n</span><span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">luaL_Reg</span> <span class=\"p\">&#123;</span><br />\n<span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\"></em></span><span class=\"n\">name</span><span class=\"p\">;</span><br />\n<span class=\"n\">lua_CFunction</span> <span class=\"n\">func</span><span class=\"p\">;</span><br />\n<span class=\"p\">&#125;</span> <span class=\"n\">luaL_Reg</span><span class=\"p\">;</span><br />\n<span class=\"cm\">/</em> luaL_register 实际调用的也是 luaI_openlib 函数 <em>/</span><br />\n<span class=\"n\">LUALIB_API</span> <span class=\"nf\">void</span><br />\n<span class=\"p\">(</span><span class=\"n\">luaL_register</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"></em></span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\"></em></span><span class=\"n\">libname</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">luaL_Reg</span> <span class=\"o\"></em></span><span class=\"n\">l</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"n\">luaI_openlib</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">libname</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span><br />\n<span class=\"p\">&#125;</span><br />\n<span class=\"n\">LUALIB_API</span> <span class=\"kt\">void</span><br />\n<span class=\"nf\">luaI_openlib</span> <span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"></em></span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\"></em></span><span class=\"n\">libname</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">luaL_Reg</span> <span class=\"o\"></em></span><span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">nup</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">libname</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"kt\">int</span> <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">libsize</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">);</span><br />\n<span class=\"cm\">/</em> check whether lib already exists <em>/</span><br />\n<span class=\"n\">luaL_findtable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">LUA_REGISTRYINDEX</span><span class=\"p\">,</span> <span class=\"s\">&quot;_LOADED&quot;</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span><br />\n<span class=\"n\">lua_getfield</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">libname</span><span class=\"p\">);</span>  <span class=\"cm\">/</em> get _LOADED[libname] <em>/</span><br />\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">lua_istable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"p\">&#123;</span>  <span class=\"cm\">/</em> not found? <em>/</span><br />\n<span class=\"n\">lua_pop</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>  <span class=\"cm\">/</em> remove previous result <em>/</span><br />\n<span class=\"cm\">/</em> try global variable (and create one if it does not exist) <em>/</span><br />\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">luaL_findtable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">LUA_GLOBALSINDEX</span><span class=\"p\">,</span> <span class=\"n\">libname</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span><br />\n<span class=\"n\">luaL_error</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&quot;name conflict for module &quot;</span> <span class=\"n\">LUA_QS</span><span class=\"p\">,</span> <span class=\"n\">libname</span><span class=\"p\">);</span><br />\n<span class=\"n\">lua_pushvalue</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">);</span><br />\n<span class=\"n\">lua_setfield</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">libname</span><span class=\"p\">);</span>  <span class=\"cm\">/</em> _LOADED[libname] = new table <em>/</span><br />\n<span class=\"p\">&#125;</span><br />\n<span class=\"n\">lua_remove</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">);</span>  <span class=\"cm\">/</em> remove _LOADED table <em>/</span><br />\n<span class=\"n\">lua_insert</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"p\">(</span><span class=\"n\">nup</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">));</span>  <span class=\"cm\">/</em> move library table to below upvalues <em>/</span><br />\n<span class=\"p\">&#125;</span><br />\n<span class=\"k\">for</span> <span class=\"p\">(;</span> <span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">name</span><span class=\"p\">;</span> <span class=\"n\">l</span><span class=\"o\"><ins></span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">;</span><br />\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">nup</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\"></ins></span><span class=\"p\">)</span>  <span class=\"cm\">/</em> copy upvalues to the top <em>/</span><br />\n<span class=\"n\">lua_pushvalue</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"n\">nup</span><span class=\"p\">);</span><br />\n<span class=\"n\">lua_pushcclosure</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"n\">nup</span><span class=\"p\">);</span><br />\n<span class=\"n\">lua_setfield</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"p\">(</span><span class=\"n\">nup</span><span class=\"o\">+</span><span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">name</span><span class=\"p\">);</span><br />\n<span class=\"p\">&#125;</span><br />\n<span class=\"n\">lua_pop</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">nup</span><span class=\"p\">);</span>  <span class=\"cm\">/</em> remove upvalues */</span><br />\n<span class=\"p\">&#125;</span><br />\n</code></pre></div></div> <p><code class=\"highlighter-rouge\">luaL_registerluaI_openlibluaL_openlib</code> 三个函数都提供了注册函数列表到 <code class=\"highlighter-rouge\">table</code> 的功能。<code class=\"highlighter-rouge\">luaL_register</code> 是通过调用 <code class=\"highlighter-rouge\">luaI_openlib</code> 函数来实现，提供了无闭包函数的功能。<code class=\"highlighter-rouge\">luaI_openlib</code> 与 <code class=\"highlighter-rouge\">luaL_openlib</code> 是同一个函数都会将函数注册到 <code class=\"highlighter-rouge\">table</code> 中，<code class=\"highlighter-rouge\">nup</code> 指定”上值“数量。 <code class=\"highlighter-rouge\">luaI_openlib</code> 思路是操作栈，将需要注册的函数保存到栈底的 <code class=\"highlighter-rouge\">table</code> 中，函数执行完毕后栈底保留原先 <code class=\"highlighter-rouge\">table</code>。</p> <h2 id=\"四-参考链接\">四 参考链接</h2> <ul> <li><a href=\"https://www.lua.org/pil/27.3.html\">Storing State in C Function</a></li> <li><a href=\"https://www.lua.org/pil/27.3.1.html\">The Registry</a></li> <li><a href=\"https://www.lua.org/pil/27.3.2.html\">References</a></li> <li><a href=\"https://www.lua.org/pil/27.3.3.html\">Upvalues</a></li> </ul></p>\n</li>\n</ul>\n","text":"一 registry registry 是一个单独的表，用来保存 lua 中的全局变量，同时 lua 代码不能直接访问（只能通过 c 函数接口访问）。registry 通过伪索引（LUA_REGISTRYINDEX）访问，伪索引类似于栈上的索引，但是它的关联数据并未在栈中。 re...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80-registry\"><span class=\"toc-text\">一 registry</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">1. 示例代码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C-references\"><span class=\"toc-text\">二 references</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89-upvalues\"><span class=\"toc-text\">三 Upvalues</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%97%AD%E5%8C%85%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">1. 闭包示例代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%A8%8B%E5%BA%8F%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">2. 程序说明</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">四 参考链接</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"基于AndroLua_Pro的Android开发笔记","uid":"fa8a6a5f27aae6005a6ca0b8e749bdc4","slug":"zl/2016-01-01-319_基于AndroLua_Pro的Android开发笔记","date":"2024-04-03T03:47:35.602Z","updated":"2024-04-03T03:47:35.603Z","comments":true,"path":"api/articles/zl/2016-01-01-319_基于AndroLua_Pro的Android开发笔记.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 温馨提示:请使用电脑浏览器打开,以确保最佳的阅读体验,谢谢.(￣▽￣)” 骚年, 学海无涯, 编程你怕不怕? 啥,你说怕? 那么你还看个P啊. [0]英文大小写忽略[1]文章中的 alua 和 AndroLua的含义一样[2]文章中的 AndroLua_Pro 和 AndroL...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"OpenResty运行Lua示例","uid":"bec11e447246adaa267aa86f2f6057b4","slug":"zl/2016-01-01-317_OpenResty运行Lua示例","date":"2024-04-03T03:47:35.597Z","updated":"2024-04-03T03:47:35.598Z","comments":true,"path":"api/articles/zl/2016-01-01-317_OpenResty运行Lua示例.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"OpenResty 是一个基于 Nginx 与 Lua 的高性能 Web 平台。 更多信息，参考 OpenResty 官网。 安装过程跟 Nginx 基本相同，区别在于安装完成之后，默认安装了很多 Module。 安装完成后，执行 ./nginx -V 的结果 nginx ver...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}