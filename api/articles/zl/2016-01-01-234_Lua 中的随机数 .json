{"title":"Lua 中的随机数","uid":"73feeba3e1d1ac59d590841c2286442d","slug":"zl/2016-01-01-234_Lua 中的随机数 ","date":"2024-04-03T03:47:33.102Z","updated":"2024-04-03T03:47:33.106Z","comments":true,"path":"api/articles/zl/2016-01-01-234_Lua 中的随机数 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>\t\t\t&lt;p&gt;Lua 随机数算法用的是 libc 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;rand&lt;/code&gt;, 也就是 LCG。然而这个算法的随机性一般。尤其是在一些平台上，当随机种子变化非常小的时候，产生的随机数变化也非常小。这样再经过 Lua 的精度取舍之后，产生的随机序列仍然很相似（&lt;u&gt;伪随机的结果变成可预知性&lt;/u&gt;）。&lt;/p&gt;\n</code></pre>\n<p>lua-l 上也讨论过这个问题 <a href=\"http://lua-users.org/lists/lua-l/2007-03/msg00564.html\">msg00564</a>，lua 的作者之一 @lhf 给出的解决方案是先弹出前面几个看起来“不怎么随机”的随机数。另外，作者也写过一个基于 MT 算法的 C lib: <a href=\"http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/#lrandom\">lrandom</a>, 有兴趣的同学可以去看下。</p>\n<p>然而在 <a href=\"http://lua-users.org/wiki/MathLibraryTutorial\">lua-wiki</a> 上有一种更为巧妙的实现（<em>这个用例同样是有缺陷的，这里只是为了引出上面的问题。以后我会单独讨论这个问题</em>）：</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">local</span> <span class=\"n\">seed</span> <span class=\"o\">=</span> <span class=\"mi\">123456</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span> <span class=\"k\">do</span>\n    <span class=\"nb\">math.randomseed</span><span class=\"p\">(</span><span class=\"n\">seed</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n    <span class=\"kd\">local</span> <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span>\n    <span class=\"k\">for</span> <span class=\"n\">j</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">10</span> <span class=\"k\">do</span>\n        <span class=\"nb\">table.insert</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">,</span> <span class=\"nb\">math.random</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">))</span>\n    <span class=\"k\">end</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">table.concat</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">,</span> <span class=\"s2\">\",\"</span><span class=\"p\">))</span>\n<span class=\"k\">end</span>\n<p><span class=\"nb\">math.randomseed</span><span class=\"p\">(</span><span class=\"nb\">tostring</span><span class=\"p\">(</span><span class=\"mi\">123456</span><span class=\"p\">.</span><span class=\"mi\">1</span><span class=\"p\">):</span><span class=\"n\">reverse</span><span class=\"p\">())</span><br />\n<span class=\"kd\">local</span> <span class=\"n\">num3</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span><br />\n<span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">10</span> <span class=\"k\">do</span><br />\n<span class=\"nb\">table.insert</span><span class=\"p\">(</span><span class=\"n\">num3</span><span class=\"p\">,</span> <span class=\"nb\">math.random</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">))</span><br />\n<span class=\"k\">end</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">table.concat</span><span class=\"p\">(</span><span class=\"n\">num3</span><span class=\"p\">,</span> <span class=\"s2\">“,”</span><span class=\"p\">))</span><br />\n</code></pre></div></div></p>\n<p>运行结果:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>61,66,19,75,44,61,68,1,33,4\n61,66,19,75,44,61,68,1,33,4\n85,40,79,80,92,20,34,77,28,56\n</code></pre></div></div>\n<p>就是把变化较小的 seed 倒过来（低位变高位），再取高位 6 位。这样，即使 seed 变化很小，但是因为低位变了高位， 种子数值变化将会很大，就可以使伪随机序列生成的更好一些。</p>\n<p>这里我也来介绍一个方法，效果也还不错（利用匿名 table 的地址来生成变化较大的 seed）：</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">math.randomseed</span><span class=\"p\">(</span><span class=\"nb\">os.time</span><span class=\"p\">()</span><span class=\"o\">+</span><span class=\"nb\">assert</span><span class=\"p\">(</span><span class=\"nb\">tonumber</span><span class=\"p\">(</span><span class=\"nb\">tostring</span><span class=\"p\">(&#123;&#125;):</span><span class=\"n\">sub</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">))))</span>\n</code></pre></div></div>\n<p><strong>值得庆幸的是 LuaJIT 已经将随机算法替换为 Tausworthe，也就是 LFSR (亦或 TURN)，循环长度达到 2<sup>223</sup>，并且能产生出质量更高的随机数。</strong></p>\n<p>在 LuaJIT 再次运行上面的用例：</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">local</span> <span class=\"n\">seed</span> <span class=\"o\">=</span> <span class=\"mi\">123456</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span> <span class=\"k\">do</span>\n    <span class=\"nb\">math.randomseed</span><span class=\"p\">(</span><span class=\"n\">seed</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n    <span class=\"kd\">local</span> <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span>\n    <span class=\"k\">for</span> <span class=\"n\">j</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">10</span> <span class=\"k\">do</span>\n        <span class=\"nb\">table.insert</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">,</span> <span class=\"nb\">math.random</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">))</span>\n    <span class=\"k\">end</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">table.concat</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">,</span> <span class=\"s2\">\",\"</span><span class=\"p\">))</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n<p>运行结果:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>96,80,47,13,41,27,81,31,29,13\n93,63,35,31,16,70,79,76,26,72\n</code></pre></div></div>\n<p>可以看到生成的随机数质量已经非常不错了。我们继续来缩小 seed 的差距，看下 LFSR 的表现如何：</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">local</span> <span class=\"n\">seed</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">.</span><span class=\"mi\">5089477744541</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span> <span class=\"k\">do</span>\n    <span class=\"n\">seed</span> <span class=\"o\">=</span> <span class=\"n\">seed</span> <span class=\"o\">+</span> <span class=\"mi\">0</span><span class=\"p\">.</span><span class=\"mi\">0000000000001</span>\n    <span class=\"nb\">math.randomseed</span><span class=\"p\">(</span><span class=\"n\">seed</span><span class=\"p\">)</span>\n    <span class=\"kd\">local</span> <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span>\n    <span class=\"k\">for</span> <span class=\"n\">j</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">10</span> <span class=\"k\">do</span>\n        <span class=\"nb\">table.insert</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">,</span> <span class=\"nb\">math.random</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">))</span>\n    <span class=\"k\">end</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">table.concat</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">,</span> <span class=\"s2\">\",\"</span><span class=\"p\">))</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n<p>运行结果:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>13,8,8,25,15,36,23,84,79,44\n21,8,72,38,74,60,73,6,79,8\n</code></pre></div></div>\n<p>可以看到当 seed 变化非常小的时候 LFSR 同样会表现不俗。综合来说，LFSR 已经是一个很好的随机算法，可足够快速地产生健壮随机数。<u>但是其并不安全（包括 MT 算法，因为 MT 也是基于 LFSR 的），在安全因素比重很大的地方比如 csrf 或密码重置的 token 等等，应该尽量避免使用</u>。</p>","text":" &lt;p&gt;Lua 随机数算法用的是 libc 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;rand&lt;/code&gt;, 也就是 LCG。然而这个算法的随机性一般。尤其是在一些平台上，当随机种子变化非常小的...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua_on_Nginx","uid":"0481568951d740141fe68c4fb1df4db7","slug":"zl/2016-01-01-237_Lua_on_Nginx","date":"2024-04-03T03:47:33.107Z","updated":"2024-04-03T03:47:33.108Z","comments":true,"path":"api/articles/zl/2016-01-01-237_Lua_on_Nginx.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;Nginx的高并发是它的一大显著优势，Lua则是一门较为轻便的脚本语言。把他们组合在一起，则极大的增强了Nginx的能力（灵活性，扩展性）。&lt;br&gt;Nginx-Lua模块是由淘宝开发的第三方模块，使用它可以把Lua内嵌到Nginx中。&lt;/p&...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua编程2之数据类型","uid":"0511ba373e6efe0ed64cccc5235edd14","slug":"zl/2016-01-01-232_Lua编程2之数据类型","date":"2024-04-03T03:47:33.102Z","updated":"2024-04-03T03:47:33.102Z","comments":true,"path":"api/articles/zl/2016-01-01-232_Lua编程2之数据类型.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;思考并回答以下问题：&lt;br&gt;1.nil 的“删除”作用怎么理解？如何删除table里的一个值？&lt;br&gt;2.怎么比较一个变量是否为nil？&lt;br&gt;3.数字零和空字符串为真吗？假有哪些？&lt;br&gt;4.如何表示块字符串？...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}