{"title":"lua栈","uid":"08b7dd8782e6521654ff6a509c9158ff","slug":"zl/2016-01-01-674_lua栈","date":"2024-04-03T03:47:35.904Z","updated":"2024-04-03T03:47:35.905Z","comments":true,"path":"api/articles/zl/2016-01-01-674_lua栈.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>既然Lua虚拟机模拟的是CPU的运作,那么Lua栈模拟的就是内存的角色.在Lua内部,参数的传递是通过Lua栈,同时Lua与C等外部进行交互的时候也是使用的栈.,先关注的是Lua栈的分配,管理和相关的数据结构.</p>\n<p>lua虚拟机在初始化创建lua_State结构体时,会走到stack_init函数中,这个函数主要就是对Lua栈和CallInfo数组的初始化:</p>\n<pre><code>static void stack_init (lua_State *L1, lua_State *L) &#123;\n  /* initialize CallInfo array */\n  L1-&gt;base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);\n  L1-&gt;ci = L1-&gt;base_ci;\n  L1-&gt;size_ci = BASIC_CI_SIZE;\n  L1-&gt;end_ci = L1-&gt;base_ci + L1-&gt;size_ci - 1;\n  /* initialize stack array */\n  L1-&gt;stack = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, TValue);\n  L1-&gt;stacksize = BASIC_STACK_SIZE + EXTRA_STACK;\n  L1-&gt;top = L1-&gt;stack;\n  L1-&gt;stack_last = L1-&gt;stack+(L1-&gt;stacksize - EXTRA_STACK)-1;\n  /* initialize first ci */\n  L1-&gt;ci-&gt;func = L1-&gt;top;\n  setnilvalue(L1-&gt;top++);  /* `function&#39; entry for this `ci&#39; */\n  L1-&gt;base = L1-&gt;ci-&gt;base = L1-&gt;top;\n  L1-&gt;ci-&gt;top = L1-&gt;top + LUA_MINSTACK;\n&#125;\n</code></pre><p>可以看到的是,初始化了两个数组,分别保存Lua栈和CallInfo结构体数组.<br/>其中,与Lua栈相关的lua_State结构体成员变量有base,stack,top,lastfree,stack保存的是数组的初始位置,base会根据每次函数调用的情况发生变化,top指针指向的是当前第一个可用的栈位置,每次向栈中增加/删减元素都要对应的增减top指针,lastfee指针指向的书Lua栈的最后位置.</p>\n<p>CallInfo结构体,是每次有函数调用时都会去初始化的一个结构体,它的成员变量中,也有top,base指针,同样的是指向Lua栈的位置,所不同的是,它关注的仅是函数调用时的相关位置.从代码中可以看出,CallInfo数组是有限制的,换言之,在Lua中的嵌套函数调用层次也是有限制,不能超过一定数量.<br/><img src=\"https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215144229849-16830691.png\" alt=\"\"/></p>\n<p>首先看f_parser函数:</p>\n<pre><code>static void f_parser (lua_State *L, void *ud) &#123;\n  int i;\n  Proto *tf;\n  Closure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  int c = luaZ_lookahead(p-&gt;z);\n  luaC_checkGC(L);\n  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p-&gt;z,\n                                                             &amp;p-&gt;buff, p-&gt;name);\n  cl = luaF_newLclosure(L, tf-&gt;nups, hvalue(gt(L)));\n  cl-&gt;l.p = tf;\n  for (i = 0; i &lt; tf-&gt;nups; i++)  /* initialize eventual upvalues */\n    cl-&gt;l.upvals[i] = luaF_newupval(L);\n  setclvalue(L, L-&gt;top, cl);\n  incr_top(L);\n&#125;\n</code></pre><p>f_parser函数的最后两句,将分析完毕之后的结构Closure指针压入了Lua栈.</p>\n<p>再来看luaD_precall函数,这里为将代码放入Lua虚拟机中执行准备了相关数据,我们只截取其中的一部分来看:</p>\n<pre><code>int luaD_precall (lua_State *L, StkId func, int nresults) &#123;\n  ….\n  if (!cl-&gt;isC) &#123;  /* Lua function? prepare its call */\n    CallInfo *ci;\n    StkId st, base;\n    Proto *p = cl-&gt;p;\n<p>// 1) 根据函数的参数类型,计算出该CallInfo的base指针位置<br />\nif (!p-&gt;is_vararg) &#123;  /* no varargs? <em>/<br />\nbase = func + 1;<br />\nif (L-&gt;top &gt; base + p-&gt;numparams)<br />\nL-&gt;top = base + p-&gt;numparams;<br />\n&#125;<br />\nelse &#123;  /</em> vararg function <em>/<br />\nint nargs = cast_int(L-&gt;top - func) - 1;<br />\nbase = adjust_varargs(L, p, nargs);<br />\nfunc = restorestack(L, funcr);  /</em> previous call may change the stack */<br />\n&#125;</p>\n<p>// 2) 分配一个新的CallInfo结构体,用于保存此次函数调用的相关信息:top,base指针,func函数<br />\nci = inc_ci(L);  /* now `enter' new function */<br />\nci-&gt;func = func;<br />\nL-&gt;base = ci-&gt;base = base;<br />\nci-&gt;top = L-&gt;base + p-&gt;maxstacksize;<br />\nlua_assert(ci-&gt;top &lt;= L-&gt;stack_last);</p>\n<pre><code>// 3) LuaState的PC指针指向函数原型的代码数组\nL-&amp;gt;savedpc = p-&amp;gt;code;  /* starting point */\n// …..\nreturn PCRLUA;\n</code></pre>\n<p>}<br />\n</code></pre><p>到这一步,跟某次具体的Lua代码执行相关的代码(保存在Proto的code数组中)和执行时所需环境(Lua栈),就已经准备完毕了.后面就是进入Lua虚拟机的主循环中解释执行代码了.</p></p>\n","text":"既然Lua虚拟机模拟的是CPU的运作,那么Lua栈模拟的就是内存的角色.在Lua内部,参数的传递是通过Lua栈,同时Lua与C等外部进行交互的时候也是使用的栈.,先关注的是Lua栈的分配,管理和相关的数据结构. lua虚拟机在初始化创建lua_State结构体时,会走到stack...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"17.Lazy evaluation","uid":"3c7e71c1be82be38b25a9c952e02a32d","slug":"zl/2016-01-01-675_17.Lazy evaluation","date":"2024-04-03T03:47:35.905Z","updated":"2024-04-03T03:47:35.906Z","comments":true,"path":"api/articles/zl/2016-01-01-675_17.Lazy evaluation.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 从效率的角度而言，最好的计算就是不计算。如果必须执行计算，我们可以拖到非计算不可的时候再计算。这种操作广泛适用于各个领域。 引用计数123class { ... };String s1 = &#34;Hello&#34;;String s2 = s1; 一般来说，s2被s1初始...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"2.5 lua 变量","uid":"b2787ccd9305bf14b24dde7aef10b55d","slug":"zl/2016-01-01-673_2.5 lua 变量","date":"2024-04-03T03:47:35.899Z","updated":"2024-04-03T03:47:35.900Z","comments":true,"path":"api/articles/zl/2016-01-01-673_2.5 lua 变量.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"全局变量创建一个全局变量全局变量不需要声明，给一个变量赋值即创建了一个全局变量，访问一个没有初始化的变量（默认是全局变量，即，lua的变量默认是全局变量，特别注意）也不会出错，会返回nil。123print(var_a) var_a = 10print(var_a) -- 10 ...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}