{"title":"lua面向对象学习","uid":"670b7a60e57dc8637ace9a6fd82af9ef","slug":"zl/2016-01-01-115_lua面向对象学习","date":"2024-04-03T03:47:33.020Z","updated":"2024-04-03T03:47:33.020Z","comments":true,"path":"api/articles/zl/2016-01-01-115_lua面向对象学习.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<div class=\"content\" itemprop=\"articleBody\">\n    <h2 id=\"元表和元方法\"><a href=\"#元表和元方法\" class=\"headerlink\" title=\"元表和元方法\"></a>元表和元方法</h2><p>   在Lua中，每个值都有一个元表，table和userdata类型的每个变量都可以有各自独立的元表，<br/>   其他类型的值则共享其类型所属的单一元表。</p>\n<h3 id=\"基本的metatable\"><a href=\"#基本的metatable\" class=\"headerlink\" title=\"基本的metatable\"></a>基本的metatable</h3><ul>\n<li>创建新的table时不会创建元表</li>\n<li><strong>getmetatable(table)</strong> 获取table或者userdata类型变量的元表</li>\n<li><p><strong>setmetatable(t,ot)</strong> 设置table或者userdata类型变量的元表</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">local t = {1,1}</div><div class=\"line\">print getmetatable(t)     -- nil</div><div class=\"line\"></div><div class=\"line\">local t1 = {}</div><div class=\"line\">setmetatable(t,t1)</div><div class=\"line\">assert(getmetatable(t) == t1)</div></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>Lua代码中，只能设置table的元表，若要设置其他类型的值的元表，必须通过C代码来完成。</p>\n</li>\n<li>标准的字符串程序库为所有的字符串都设置了一个元表，其他类型在默认情况下没有元表。</li>\n<li><p>table中可以重新定义的元方法：</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">__add(a,b) --加法</div><div class=\"line\">__sub(a,b) --减法</div><div class=\"line\">__mul(a,b) --乘法</div><div class=\"line\">__div(a,b) --除法</div><div class=\"line\">__mod(a,b) --取模</div><div class=\"line\">__pow(a,b) --乘幂</div><div class=\"line\">__unm(a)   --相反数</div><div class=\"line\">__concat(a,b) -- 连接</div><div class=\"line\">__len(a)   --长度</div><div class=\"line\">__eq(a,b)  --相等</div><div class=\"line\">__lt(a,b)  --小于</div><div class=\"line\">__le(a,b)  --小于等于</div><div class=\"line\">__index(a,b) --索引查询</div><div class=\"line\">__newindex(a,b,c) --索引更新</div><div class=\"line\">__call(a,...) --执行方法调用</div><div class=\"line\">__tostring(a) --字符串输出</div><div class=\"line\">__metatable --保护元表</div></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>当操作符的两个操作数都有元表时的函数获取规则：</p>\n<ol>\n<li>对于二元操作符，如果第一个操作数有元表，并且元表中有所需要的字段定义，那么lua就以这个字段为元方法。</li>\n<li>对于二元操作符，如果第一个操作数有元表，但是元表中没有所需要的字段定义，那么lua就去查找第二个操作数的元表。</li>\n<li>如果两个操作数都没有元表，或者都没有对应的元方法定义，lua就会引发一个错误。</li>\n</ol>\n</li>\n<li><p>保护元表：</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Set.new(l)</div><div class=\"line\">    local set = {}</div><div class=\"line\">    setmetatable(set,mt)</div><div class=\"line\">    for _, v in pairs(l) do set[v] = true end</div><div class=\"line\">    mt.__metatable = &#34;You cannot get the metatable&#34;</div><div class=\"line\">    return set</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">local tb = Set.new({1,2})</div><div class=\"line\">print(tb)                -- 输出：{1, 2}</div><div class=\"line\"></div><div class=\"line\">print(getmetatable(tb))  -- 输出__metatable的内容：You cannot get the metatable</div><div class=\"line\">setmetatable(tb,{})      -- 输出错误信息：lua: test.lua:56: cannot change a protected metatable</div></pre></td></tr></tbody></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>当访问一个table中不存在的字段时，lua的处理规则：</p>\n<ol>\n<li>当table有这个字段时，直接返回对应的值；</li>\n<li>当table没有这个字段时，解释器会去查找一个叫__index的元方法，并调用对应的元方法，返回结果</li>\n<li>如果没有这个元方法，返回nil<br/>__index使用的例子：<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">-- 假设要创建一些描述窗口，每个table中都必须描述一些窗口参数，例如颜色，位置和大小等</div><div class=\"line\">Windows = {} -- 创建一个命名空间</div><div class=\"line\"></div><div class=\"line\">-- 创建默认值表</div><div class=\"line\">Window.default = {x = 0, y = 0, width = 100, height = 100, color = {r = 255, g = 255, b = 255}}</div><div class=\"line\"></div><div class=\"line\">Window.mt = {} --创建元表</div><div class=\"line\"></div><div class=\"line\">-- 声明构造函数</div><div class=\"line\">function Windows.new(0)</div><div class=\"line\">    setmetatable(o, Window.mt)</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">-- 定义__lindex元方法</div><div class=\"line\">Window.mt.__index = function (table, key)</div><div class=\"line\">    return Windows.default[key]</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">local win = Window.new({x = 10, y = 10})</div><div class=\"line\">print(win.x)     -- &gt;10 访问自身已经拥有的值</div><div class=\"line\">print(win.width) -- &gt;100 访问default表中的值</div><div class=\"line\">print(win.color.r) -- &gt;255 访问default表中的值</div><div class=\"line\"></div><div class=\"line\">-- __index元方法不一定必须是个函数，它还可以是一个table。</div></pre></td></tr></tbody></table></figure>\n</li>\n</ol>\n<ul>\n<li><p><strong>newindex元方法，与</strong>index类似，<strong>newindex用于更新table中的数据，</strong>index用于查询table中的数据。当对table中不存在的索引赋值时，执行步骤如下：</p>\n<ol>\n<li>Lua解释器先判断这个table是否有元表，如果没有元表，就直接添加这个索引，然后对应赋值</li>\n<li>如果有了元表，就查找元表中是否有__newindex元方法，如果有这个方法，lua解释器就执行这个元方法，而不是赋值</li>\n<li>如果这个__newindex对应的不是一个函数，而是一个table时，lua解释器就在这个table中执行赋值，而不是在原来的table中<br/>示例代码：<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">local tb1 = {}</div><div class=\"line\">local tb2 = {}</div><div class=\"line\"></div><div class=\"line\">tb1.__newindex = tb2</div><div class=\"line\">tb2.__newindex = tb1</div><div class=\"line\"></div><div class=\"line\">setmetatable(tb1,tb2)</div><div class=\"line\">setmetatable(tb2,tb1)</div><div class=\"line\"></div><div class=\"line\">tb1.x = 10</div></pre></td></tr></tbody></table></figure>\n</li>\n</ol>\n<p>上面的代码存在循环引用的问题，lua解释器会抛出如下错误:</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">loop in settable</div></pre></td></tr></tbody></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>- rawget(tb,i); 直接访问tb属性，不使元表，即忽略__index的定义\n- rawset(tb,k,v); 直接设置tb属性，不使用元表，即忽略__newindex的定义\n</code></pre><h4 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h4><pre><code>记录table的访问\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">local t = &#123;&#125; --原来的table</div><div class=\"line\"></div><div class=\"line\">-- 保持对原table的一个引用</div><div class=\"line\">local _t = t</div><div class=\"line\"></div><div class=\"line\">-- 创建代理</div><div class=\"line\">t = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">-- 创建元表</div><div class=\"line\">local mt = &#123;</div><div class=\"line\">__index = function(t, k)</div><div class=\"line\">    print(&#34;access to element &#34; .. tostring(k))</div><div class=\"line\">    return _t[k]</div><div class=\"line\">end,</div><div class=\"line\"></div><div class=\"line\">__newindex = function(t, k, v)</div><div class=\"line\">    print(&#34;update of element &#34; .. tostring(k))</div><div class=\"line\">    _t[k] = v</div><div class=\"line\">end</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">setmetatable(t, mt)</div><div class=\"line\"></div><div class=\"line\">t.x = 10  -- update of element x</div><div class=\"line\">print(t.x) -- access to element x</div></pre></td></tr></tbody></table></figure>\n<p>多个table访问日志，使用代理模式</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">-- 创建唯一索引</div><div class=\"line\">local index = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">-- 创建元表</div><div class=\"line\">local mt = &#123;</div><div class=\"line\">    __index = function(t, k)</div><div class=\"line\">        print(&#34;access to element &#34; .. tostring(k))</div><div class=\"line\">        return t[index][k]</div><div class=\"line\">    end,</div><div class=\"line\">    </div><div class=\"line\">    __newindex = function(t, k, v)</div><div class=\"line\">        print(&#34;update of element &#34; .. tostring(k))</div><div class=\"line\">        t[index][k] = v</div><div class=\"line\">    end</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function track(t)</div><div class=\"line\">    local proxy = &#123;&#125;</div><div class=\"line\">    proxy[index] = t</div><div class=\"line\">    setmetatable(proxy, mt)</div><div class=\"line\">    return proxy</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">local t = &#123;&#125;</div><div class=\"line\">local proxy = track(t)</div><div class=\"line\">proxy.x = 10</div><div class=\"line\">print(proxy.x)</div></pre></td></tr></tbody></table></figure>\n<p>只读的table(代理模式)</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">function readOnly(t)</div><div class=\"line\">    local proxy = &#123;&#125;</div><div class=\"line\">    </div><div class=\"line\">    -- 创建元表</div><div class=\"line\">    local mt = &#123;</div><div class=\"line\">    __index = t,</div><div class=\"line\">    __newindex = function(t, k, v)</div><div class=\"line\">        error(&#34;Attempt to update a read-only table&#34;, 2)</div><div class=\"line\">    end</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    setmetatable(proxy, mt)</div><div class=\"line\">    return proxy</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">local tb = readOnly&#123;1, 2, 3, 4, 5&#125;</div><div class=\"line\">print(tb[1])</div><div class=\"line\">tb[1] = 20  -- Attempt to update a read-only table</div></pre></td></tr></tbody></table></figure>\n</code></pre><h3 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h3><p>lua中，table就是对象，对象就是表，lua中的类本质上也是对象（表），不过是用来做模版的对象。<br/>lua中的类和javascript中的非常类似，也是采用原型(prototype)的概念。lua通过元表实现原型。<br/>像下面这样：<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">setmetatable(a, {__index = b})</div></pre></td></tr></tbody></table></figure><p></p>\n<p>lua中方法的调用：<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">local Account = {balance = 0}</div><div class=\"line\">function Account.withDraw(self, v)  -- 需要明确定义传入self参数</div><div class=\"line\">    self.balance = self.balance - v</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">local a = Account</div><div class=\"line\">a.withDraw(a,10) -- 调用函数，需要明确指定self参数</div><div class=\"line\"></div><div class=\"line\">-- 隐藏self参数的语法糖</div><div class=\"line\">function Account:withDraw(v) -- 注意，是&#34;:&#34;号，且省略了self参数，但是函数仍然可以使用self</div><div class=\"line\">    self.balance = self.balance - v   </div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">a = Account</div><div class=\"line\">a:withDraw(100) -- 注意这里的调用使用&#34;:&#34;并且也不需要传入a本身</div><div class=\"line\">print(a.balance)</div></pre></td></tr></tbody></table></figure><p></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://www.jellythink.com/archives/529\" target=\"_blank\" rel=\"external noopener noreferrer\">Lua中的面向对象编程</a></li>\n<li><a href=\"http://blog.codingnow.com/2006/06/oo_lua.html\" target=\"_blank\" rel=\"external noopener noreferrer\">在Lua中实现面向对象</a></li>\n<li><a href=\"http://www.jellythink.com/archives/511\" target=\"_blank\" rel=\"external noopener noreferrer\">Lua中的元表与元方法</a></li>\n<li><a href=\"http://www.jellythink.com/archives/517\" target=\"_blank\" rel=\"external noopener noreferrer\">Lua中<strong>index和</strong>newindex实践</a></li>\n</ul>\n  </div>","text":" 元表和元方法 在Lua中，每个值都有一个元表，table和userdata类型的每个变量都可以有各自独立的元表， 其他类型的值则共享其类型所属的单一元表。 基本的metatable 创建新的table时不会创建元表 getmetatable(table) 获取table或者us...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%83%E8%A1%A8%E5%92%8C%E5%85%83%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">元表和元方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%9A%84metatable\"><span class=\"toc-text\">基本的metatable</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">代码示例</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">面向对象</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\"><span class=\"toc-text\">参考文章</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"nginx-lua-redis","uid":"d1ab0de5fb0131f1938cebe0ec535ad4","slug":"zl/2016-01-01-1160_nginx-lua-redis","date":"2024-04-03T03:47:33.020Z","updated":"2024-04-03T03:47:33.021Z","comments":true,"path":"api/articles/zl/2016-01-01-1160_nginx-lua-redis.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"lua123apt-get install lua5.1apt-get install liblua5.1-devapt-get install liblua5.1-socket2 如果liblua5.1-socket2安装不上，需要添加源1deb http: 然后执行1sudo...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"serveless-time-evaluation","uid":"e981272d72e39c2be8285c5f81de9657","slug":"zl/2016-01-01-1159_serveless-time-evaluation","date":"2024-04-03T03:47:33.020Z","updated":"2024-04-03T03:47:33.020Z","comments":true,"path":"api/articles/zl/2016-01-01-1159_serveless-time-evaluation.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" Sujet Time Creation du projet 10 col 2 is centered zebra stripes are neat ","link":"","photos":[],"count_time":{"symbolsCount":87,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}