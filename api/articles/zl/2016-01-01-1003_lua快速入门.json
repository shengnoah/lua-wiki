{"title":"lua快速入门","uid":"e2587e48319d030c7c41fb4968ade102","slug":"zl/2016-01-01-1003_lua快速入门","date":"2024-04-03T03:47:32.958Z","updated":"2024-04-03T03:47:32.959Z","comments":true,"path":"api/articles/zl/2016-01-01-1003_lua快速入门.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<div class=\"markdown-body\">\n            <p><strong>概览</strong>：协同程序提供了一种协作式的多线程。每个协同程序都等于是一个线程。一对yield-resume可以将执行权在不同线程间切换。然而与常规多线程不同，协程是非抢先式的。</p>\n<blockquote>\n<p>参照书籍：<strong>《Lua程序设计（第二版）》</strong></p>\n<p>Lua版本：<strong>Lua 5.3.5</strong></p>\n</blockquote>\n<h2 id=\"协同程序\"><a href=\"#协同程序\" class=\"headerlink\" title=\"协同程序\"></a>协同程序</h2><ul>\n<li><p>Lua将所有关于协同程序的函数放在了一个名叫”<strong>coroutine</strong>“的table中。</p>\n</li>\n<li><p>create函数用于创建一个协同程序，只有一个参数，为一个函数。最终返回一个thread类型的值。</p>\n<pre><code class=\"lua\">  &gt; co = coroutine.create(function() print&#34;hi&#34; end)\n  &gt; print(co)\n  thread: 000000000078eba8</code></pre>\n</li>\n<li><p>一个协同程序有四种状态：<strong>挂起(suspended)、运行(running)、死亡(dead)和正常(normal)</strong>.创建一个协同程序后它将储于挂起状态，可以使用status函数来检查协同程序的状态。</p>\n<pre><code class=\"lua\">  &gt; print(coroutine.status(co))\n  suspended</code></pre>\n</li>\n<li><p>使用resume函数来启动执行协同程序，并将其状态从<strong>挂起 –&gt; 运行</strong></p>\n<pre><code class=\"lua\">  &gt; coroutine.resume(co)\n  hi\n  true\n  &gt; print(coroutine.status(co))\n  dead\n  &gt; coroutine.resume(co)\n  false   cannot resume dead coroutine\n  &gt;</code></pre>\n</li>\n<li><p>使用yield函数来让一个运行中的协同程序挂起。</p>\n<pre><code class=\"lua\">  co = coroutine.create(function()\n   for i=1,10 do\n   print(&#34;co&#34;,i)\n   coroutine.yield()\n   end\n  end)\n<p>&gt; coroutine.resume(co)<br />\nco      1<br />\ntrue<br />\n&gt; coroutine.resume(co)<br />\nco      2<br />\ntrue<br />\n&gt; coroutine.resume(co)<br />\nco      3<br />\ntrue<br />\n&gt; print(coroutine.status(co))<br />\nsuspended<br />\n&gt;</code></pre></p>\n<blockquote>\n<p><strong>从协程的角度来看，所有在它挂起时发生的活动都发生在yield调用中。当恢复协同程序的执行时，对于yield的调用才最终返回。然后协同程序继续它的执行，直到下个yield调用或执行的结束。</strong></p>\n</blockquote>\n</li>\n<li><p><strong>正常状态</strong>：当协程A唤醒了另一个协程B时，协程A就处于一个特殊状态，既不是挂起状态(A无法继续执行)也不是运行状态(B在运行)。</p>\n</li>\n<li><p>Lua协同程序的机制：通过一对resume-yield来交换数据。在第一次调用resume时，并没有对应的yield在等待它，因此传<strong>递给resume的额外参数都将视为协同程序主函数的参数。</strong></p>\n<pre><code class=\"lua\">  &gt; co = coroutine.create(function(a,b,c)\n  &gt;&gt; print(&#34;co&#34;,a,b,c)\n  &gt;&gt; end)\n  &gt; coroutine.resume(co,1,2,3)\n  co      1       2       3\n  true\n  &gt;</code></pre>\n<p>  数据由yield传给resume。true表明调用成功，true之后的部分，即是yield的参数.</p>\n<pre><code class=\"lua\">  co = coroutine.create(function (a,b)\n    coroutine.yield(a+b,a-b)\n  end)\n<p>&gt; print(coroutine.resume(co,20,10))<br />\ntrue    30      10</code></pre></p>\n<p>  相应地，resume的参数，会被传递给yield。 </p>\n<pre><code class=\"lua\">  co  = coroutine.create (function ()\n    print(&#34;co&#34;,  coroutine.yield())\n  end)\n  coroutine.resume(co)\n  coroutine.resume(co, 4, 5)   --&gt; co  4 5</code></pre>\n<p>  最后一个，协同代码结束时的返回值，也会传给resume：</p>\n<pre><code class=\"lua\">  co  = coroutine.create(function ()\n    return 6, 7\n  end)\n  print(coroutine.resume(co))   --&gt;  true 6 7</code></pre>\n</li>\n<li><p>Lua的协同称为<strong>不对称协同</strong>（asymmetric coroutines），指“挂起一个正在执行的协同函数”与“使一个被挂起的协同再次执行的函数”是不同的，有些语言提供对称协同（symmetric coroutines），即使用同一个函数负责“执行与挂起间的状态切换”.</p>\n<blockquote>\n<p>与对称的协同和不对称协同的区别不同的是，协同与产生器的区别更大。产生器相对比较简单，他不能完成真正的协同所能完成的一些任务。我们熟练使用不对称的协同之后，可以利用不对称的协同实现比较优越的对称协同。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"协程实例-生产者消费者\"><a href=\"#协程实例-生产者消费者\" class=\"headerlink\" title=\"协程实例-生产者消费者\"></a>协程实例-生产者消费者</h2><p>生产者消费者涉及两个函数，一个负责不断的产生值，另一个负责不断地消费值。</p>\n<pre><code class=\"lua\">-- 两个函数大致的样子\nfunction producer()\n    while true do\n        local x = io.read() --产生新的值\n        send(x) -- 发送给消费者\n    end\nend\n<p>function consumer()<br />\nwhile true do<br />\nlocal x = receive() --从生产者接受值<br />\nio.write(x,&quot;n&quot;)  – 消费新的值<br />\nend<br />\nend</code></pre></p>\n<p>这里的问题在于如何将send与receive匹配起来，这是一个典型的<strong>“谁具有主循环”(who-has-the-main-loop)</strong>的问题。由于生产者与消费者都处于活动状态，他们各自具有一个主循环，并且都将对方视为一个可调用的服务。</p>\n<p><strong>而协调程序被称为是一种匹配生产者与消费者的理想工具，因为调用者与被调用者之间的resume-yield关系会不断颠倒。当一个协同调用yield时，并不会进入一个新的函数，取而代之的是返回一个未决的resume的调用。相似的，调用resume时也不会开始一个新的函数而是返回yield的调用。这种性质正是我们所需要的，与使得send-receive协同工作的方式是一致的。receive唤醒生产者生产新值，send把产生的值送给消费者消费。</strong></p>\n<pre><code class=\"lua\">function receive()\n    local status,value = coroutine.resume(producer)\n    return value\nend\n<p>function send(x)<br />\ncoroutine.yield(x)<br />\nend</p>\n<p>– 因此生产者现在一定是一个协同程序<br />\nproducer = coroutine.create(<br />\nfunction ()<br />\nwhile true do<br />\nlocal x = io.read()  --产生新值<br />\nsend(x)<br />\nend<br />\nend<br />\n)</code></pre></p>\n<p>在这种设计中，程序通过调用消费者来启动。当消费者需要一个新值时，它唤醒生产者。生产者返回一个新值后停止运行，并等待消费者的再次唤醒。这种设计称之为——“消费者驱动”。</p>\n<h3 id=\"过滤器filter\"><a href=\"#过滤器filter\" class=\"headerlink\" title=\"过滤器filter\"></a>过滤器filter</h3><p>扩展上面的设计，实现过滤器</p>\n<p>过滤器是一种位于生产者与消费者之间的处理功能，可用于对数据的一些变换。过滤器既是一个消费者又是一个生产者，它唤醒一个生产者促使其产生新的值，然后又将变换后的值传递给消费者。</p>\n<pre><code class=\"lua\">function receive(prod)\n    local status,value = coroutine.resume(prod)\n    return value\nend\n<p>function send(x)<br />\ncoroutine.yield(x)<br />\nend</p>\n<p>function producer()<br />\nreturn coroutine.create(function()<br />\nwhile true do<br />\nlocal x = io.read()<br />\nsend(x)<br />\nend<br />\nend)<br />\nend</p>\n<p>function filter(prod)<br />\nreturn coroutine.create(function()<br />\nfor line=1,math.huge do<br />\nlocal x = receiver(prod)<br />\nx = string.format(&quot;%5d %s&quot;,line,x)<br />\nsend(x)<br />\nend<br />\nend)<br />\nend</p>\n<p>function consumer(prod)<br />\nwhile true do<br />\nlocal x = receive(prod)  --获取新值<br />\nio.write(x,&quot;n&quot;)  --消费新值<br />\nend<br />\nend</p>\n<p>– 运行代码<br />\np = producer()<br />\nf = filter(p)<br />\nconsumer(f)</p>\n<p>–或者 sonsumer(filter(producer()))</p>\n<p>– 不过貌似无法运行</code></pre></p>\n<p>可能很自然的想到<strong>UNIX的管道（pipe）</strong>，<strong>协同是一种非抢占式的多线程</strong>。管道的方式下，每一个任务在独立的进程中运行，而协同方式下，每个任务运行在独立的协同代码中。管道在读（consumer）与写（producer）之间提供了一个缓冲，因此两者相关的的速度没有什么限制，在上下文管道中这是非常重要的，因为在进程间的切换代价是很高的。协同模式下，任务间的切换代价较小，与函数调用相当，因此读写可以很好的协同处理。</p>\n<h2 id=\"用协同程序实现迭代器\"><a href=\"#用协同程序实现迭代器\" class=\"headerlink\" title=\"用协同程序实现迭代器\"></a>用协同程序实现迭代器</h2><p>我们可以将循环的迭代器看作生产者-消费者模式的特殊的例子。迭代函数产生值给循环体消费。所以可以使用协同来实现迭代器。<strong>协同的一个关键特征是它可以不断颠倒调用者与被调用者之间的关系</strong>，这样我们毫无顾虑的使用它实现一个迭代器，而不用保存迭代函数返回的状态。</p>\n<pre><code class=\"lua\">-- 打印一个数组元素的所有的排列\nfunction permgen(a,n)\n    n = n or #a --默认n为a的大小\n    if n &lt;= 1 then\n        printResult(a)\n    else\n        for i=1,n do\n            a[n],a[i] = a[i],a[n] --将第i个元素放到数组末尾\n            permgen(a,n-1)  -- 生成其余元素的排列\n            a[n],a[i] = a[i],a[n] -- 恢复第i个元素\n        end\n    end\nend\n<p>function printResult(a)<br />\nfor i=1,#a do<br />\nio.write(a[i],&quot; &quot;)<br />\nend<br />\nio.write(&quot;n&quot;)<br />\nend</p>\n<p>– 调用<br />\npermgen(&#123;1,2,3,4&#125;) --只传一个参数也可以，函数中会对第二个参数进行默认赋值操作</p>\n<p>–[[<br />\n2 3 4 1<br />\n3 2 4 1<br />\n3 4 2 1<br />\n4 3 2 1<br />\n2 4 3 1<br />\n4 2 3 1<br />\n4 3 1 2<br />\n3 4 1 2<br />\n3 1 4 2<br />\n1 3 4 2<br />\n4 1 3 2<br />\n1 4 3 2<br />\n2 4 1 3<br />\n4 2 1 3<br />\n4 1 2 3<br />\n1 4 2 3<br />\n2 1 4 3<br />\n1 2 4 3<br />\n2 3 1 4<br />\n3 2 1 4<br />\n3 1 2 4<br />\n1 3 2 4<br />\n2 1 3 4<br />\n1 2 3 4<br />\n–]]</code></pre></p>\n<p>转化为迭代器</p>\n<pre><code class=\"lua\">function permgen(a,n)\n    n = n or #a\n    if n&gt;=1 then\n        coroutine.yield(a)\n    else\n        for i=1,n do\n            a[n],a[i] = a[i],a[n] --将第i个元素放到数组末尾\n            permgen(a,n-1)  -- 生成其余元素的排列\n            a[n],a[i] = a[i],a[n] -- 恢复第i个元素\n        end\n    end\nend\n<p>–定义一个工厂函数<br />\nfunction permutations(a)<br />\nlocal co = coroutine.create(function() permgen(a) end)<br />\nreturn function() --迭代器<br />\nlocal code,res = coroutine.resume(co)<br />\nreturn res<br />\nend<br />\nend</p>\n<p>– for循环中便利<br />\nfor p in permutations(&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;) do<br />\nprintResult(p)<br />\nend</code></pre></p>\n<p>permutations函数使用了lua中常用的模式：<strong>将一个对协同的resume的调用封装在一个函数内部</strong>，这种方式在非常常见，所以专门为此专门提供了一个函数<code>coroutine.wrap</code>。与create相同的是，wrap创建一个协同程序；不同的是wrap不返回协同本身，而是返回一个函数，当这个函数被调用时将resume协同。wrap中resume协同的时候不会返回错误代码作为第一个返回结果，一旦有错误发生，将抛出错误。</p>\n<pre><code class=\"lua\">-- 使用wrap来重写permutations\nfunction permutations(a)\n    return coroutine.wrap(function () permgen(a) end)\nend</code></pre>\n<p>一般情况下，coroutine.wrap比coroutine.create使用起来简单直观，前者更确切的提供了我们所需要的：一个可以resume协同的函数，然而缺少灵活性，没有办法知道wrap所创建的协同的状态，也没有办法检查错误的发生。</p>\n<h2 id=\"非抢占式的多线程-non-preemptive\"><a href=\"#非抢占式的多线程-non-preemptive\" class=\"headerlink\" title=\"非抢占式的多线程(non-preemptive)\"></a>非抢占式的多线程(non-preemptive)</h2><p>对于非抢占式的多线程来说，只要有一个线程调用了阻塞(blocking)的操作，整个程序在该操作完成前，都会停下来。但对于大部分程序来说，这是无法接受的。</p>\n<pre><code class=\"lua\">--未完\n<p>相关模块一直无法安装以及使用</code></pre></p>\n<pre><code>        &lt;hr/&gt;\n      &lt;/div&gt;\n      &lt;br/&gt;\n      &lt;div&gt;\n        &lt;p&gt;\n        \n          &lt;span&gt;\n            &lt;i class=&quot;iconfont icon-inbox&quot;&gt;&lt;/i&gt;\n            \n              &lt;a class=&quot;hover-with-bg&quot; href=&quot;/categories/Lua/&quot;&gt;Lua&lt;/a&gt;\n               \n            \n          &lt;/span&gt;  \n        \n        \n          &lt;span&gt;\n            &lt;i class=&quot;iconfont icon-tag&quot;&gt;&lt;/i&gt;\n            \n              &lt;a class=&quot;hover-with-bg&quot; href=&quot;/tags/Lua/&quot;&gt;Lua&lt;/a&gt;\n            \n          &lt;/span&gt;\n        \n        &lt;/p&gt;\n        \n          &lt;p class=&quot;note note-warning&quot;&gt;本博客所有文章除特别声明外，均采用 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;CC BY-SA 3.0协议&lt;/a&gt; 。转载请注明出处！&lt;/p&gt;\n        \n      &lt;/div&gt;\n</code></pre>\n","text":" 概览：协同程序提供了一种协作式的多线程。每个协同程序都等于是一个线程。一对yield-resume可以将执行权在不同线程间切换。然而与常规多线程不同，协程是非抢先式的。 参照书籍：《Lua程序设计（第二版）》 Lua版本：Lua 5.3.5 协同程序 Lua将所有关于协同程序的...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">协同程序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B%E5%AE%9E%E4%BE%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85\"><span class=\"toc-text\">协程实例-生产者消费者</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E5%99%A8filter\"><span class=\"toc-text\">过滤器filter</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">用协同程序实现迭代器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B-non-preemptive\"><span class=\"toc-text\">非抢占式的多线程(non-preemptive)</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua语言学习（二）","uid":"51cf44d856e3e23c66566852b46bc298","slug":"zl/2016-01-01-1005_Lua语言学习（二）","date":"2024-04-03T03:47:32.960Z","updated":"2024-04-03T03:47:32.961Z","comments":true,"path":"api/articles/zl/2016-01-01-1005_Lua语言学习（二）.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;&lt;strong&gt;接下来的几篇是根据&lt;a href=&quot;http://lua-users.org/wiki/TutorialDirectory&quot;&gt; Lua-Users wiki &lt;/a&gt;梳理的一些细节&lt;...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua 学习 chapter7","uid":"d1f12ad6b4cafc4f9e33f041f7e58f17","slug":"zl/2016-01-01-1002_Lua 学习 chapter7 ","date":"2024-04-03T03:47:32.957Z","updated":"2024-04-03T03:47:32.958Z","comments":true,"path":"api/articles/zl/2016-01-01-1002_Lua 学习 chapter7 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"目录 简单I/O模型 完整I/O模型 其它文件操作 其它系统调用 I want to have a talk with you my heart. 简单I/O模型 对于文件操作，I/O提供了两种不同的模型。简单模型虚拟了一个当前输入流和一个当前的输出流，其I/O是通过这些流实现的...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}