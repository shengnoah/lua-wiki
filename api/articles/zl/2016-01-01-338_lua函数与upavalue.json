{"title":"lua函数与upavalue","uid":"be80d580dc7cc1c589ddcfc242421da2","slug":"zl/2016-01-01-338_lua函数与upavalue","date":"2024-04-03T03:47:35.615Z","updated":"2024-04-03T03:47:35.615Z","comments":true,"path":"api/articles/zl/2016-01-01-338_lua函数与upavalue.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>Lua中的所谓upvalue是一类比较特殊的值，可以理解为在某函数内引用外部的数据。</p>\n<p>函数定义中用到了pushclosure这个函数用于将函数的定义Proto结构体指针push到父函数的数组中，在这个函数内，还建立了有关upvalue相关的逻辑：</p>\n<pre><code>static void pushclosure (LexState *ls, FuncState *func, expdesc *v) &#123;\n  FuncState *fs = ls-&gt;fs;\n  Proto *f = fs-&gt;f;\n  int oldsize = f-&gt;sizep;\n  int i;\n  luaM_growvector(ls-&gt;L, f-&gt;p, fs-&gt;np, f-&gt;sizep, Proto *,\n                  MAXARG_Bx, &#34;constant table overflow&#34;);\n  while (oldsize &lt; f-&gt;sizep) f-&gt;p[oldsize++] = NULL;\n  f-&gt;p[fs-&gt;np++] = func-&gt;f;\n  luaC_objbarrier(ls-&gt;L, f, func-&gt;f);\n  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs-&gt;np-1));\n  for (i=0; if-&gt;nups; i++) &#123;\n    OpCode o = (func-&gt;upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;\n    luaK_codeABC(fs, o, 0, func-&gt;upvalues[i].info, 0);\n  &#125;\n&#125;\n</code></pre><p>注意在这个函数的最后，将遍历upvalue数组，根据该upvalue是否是局部变量，来决定紧跟着的是MOVE指令还是GETUPVAL指令。而这些是如何确定的呢？</p>\n<p>Lua的分析器在解析到一个变量时，会调用singlevaraux函数进行查找：</p>\n<pre><code>static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) &#123;\n  if (fs == NULL) &#123;  /* no more levels? */\n    init_exp(var, VGLOBAL, NO_REG);  /* default is global variable */\n    return VGLOBAL;\n  &#125;\n  else &#123;\n    int v = searchvar(fs, n);  /* look up at current level */\n    if (v &gt;= 0) &#123;\n      init_exp(var, VLOCAL, v);\n      if (!base)\n        markupval(fs, v);  /* local will be used as an upval */\n      return VLOCAL;\n    &#125;\n    else &#123;  /* not found at current level; try upper one */\n      if (singlevaraux(fs-&gt;prev, n, var, 0) == VGLOBAL)\n        return VGLOBAL;\n      var-&gt;u.s.info = indexupvalue(fs, n, var);  /* else was LOCAL or UPVAL */\n      var-&gt;k = VUPVAL;  /* upvalue in this level */\n      return VUPVAL;\n    &#125;\n  &#125;\n&#125;\n</code></pre><p>可以看到，这个函数是一个递归函数，有以下几种情况：</p>\n<ol>\n<li>在函数的当前层找到该变量，则认为一个LOCAL变量</li>\n<li>在函数的上层找到，则认为一个UPVAL</li>\n<li>最后，则认为是一个全局变量。</li>\n</ol>\n<p>如何定义函数的“层次”？来看一个例子就知道了:</p>\n<pre><code>local a = 1\nfunction test1()\n  local b = 100\n  function test2()\n     print(a)\n     print(b)\n  end\nend\ntest1()\n</code></pre><p>在这个例子中，函数test2与变量b是同层的，所以在调用函数test2时，singlevaraux查找变量b返回的LOCAL变量；而变量a是更上一层的LOCAL变量，对于函数test2而言，它就是UPVAL。</p>\n<p>明白了解析部分是怎么处理upvalue的，来看看在虚拟机中是如何处理的。<br/>对应的代码在lvm.c中的这一部分：</p>\n<pre><code>      case OP_CLOSURE: &#123;\n        Proto *p;\n        Closure *ncl;\n        int nup, j;\n        p = cl-&gt;p-&gt;p[GETARG_Bx(i)];\n        nup = p-&gt;nups;\n        ncl = luaF_newLclosure(L, nup, cl-&gt;env);\n        ncl-&gt;l.p = p;\n        for (j=0; jl.upvals[j] = cl-&gt;upvals[GETARG_B(*pc)];\n          else &#123;\n            lua_assert(GET_OPCODE(*pc) == OP_MOVE);\n            ncl-&gt;l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc));\n          &#125;\n        &#125;\n        setclvalue(L, ra, ncl);\n        Protect(luaC_checkGC(L));\n        continue;\n      &#125;\n</code></pre><p>当变量是UPVAL时，此时PC指令对应的B参数是函数结构体的upval数组的索引，根据它直接从upval数组中取出值来；否则，PC指令对应的B参数是基于函数基地址base的一个偏移量，根据它得到相应的变量；再调用函数luaF_findupval：</p>\n<pre><code>UpVal *luaF_findupval (lua_State *L, StkId level) &#123;\n  global_State *g = G(L);\n  GCObject **pp = &amp;L-&gt;openupval;\n  UpVal *p;\n  UpVal *uv;\n  while (*pp != NULL &amp;&amp; (p = ngcotouv(*pp))-&gt;v &gt;= level) &#123;\n    lua_assert(p-&gt;v != &amp;p-&gt;u.value);\n    if (p-&gt;v == level) &#123;  /* found a corresponding upvalue? */\n      if (isdead(g, obj2gco(p)))  /* is it dead? */\n        changewhite(obj2gco(p));  /* ressurect it */\n      return p;\n    &#125;\n    pp = &amp;p-&gt;next;\n  &#125;\n  uv = luaM_new(L, UpVal);  /* not found: create a new one */\n  uv-&gt;tt = LUA_TUPVAL;\n  uv-&gt;marked = luaC_white(g);\n  uv-&gt;v = level;  /* current value lives in the stack */\n  uv-&gt;next = *pp;  /* chain it in the proper position */\n  *pp = obj2gco(uv);\n  uv-&gt;u.l.prev = &amp;g-&gt;uvhead;  /* double link it in `uvhead&#39; list */\n  uv-&gt;u.l.next = g-&gt;uvhead.u.l.next;\n  uv-&gt;u.l.next-&gt;u.l.prev = uv;\n  g-&gt;uvhead.u.l.next = uv;\n  lua_assert(uv-&gt;u.l.next-&gt;u.l.prev == uv &amp;&amp; uv-&gt;u.l.prev-&gt;u.l.next == uv);\n  return uv;\n&#125;\n</code></pre><p>注意到，传入这个函数的参数level，其实是前面已经根据base基址定位到的变量。这个函数分为两个部分：</p>\n<ol>\n<li>首先，遍历当前的openupval数组，查找这个变量。由于这个变量肯定是前面已经定义过的，所以查找的条件就是（(p = ngcotouv(*pp))-&gt;v &gt;= level）。当查找到这个变量时，如果是准备释放的变量，则将它重新置为不可释放。</li>\n<li>如果在openval数组中没有找到，说明之前没有别的地方引用过这个upval。如此则重新分配一个upvalue指向待引用的值。</li>\n<li>最后，当函数调用完毕时，有相应的close指令，将upvalue的引用关系去除。具体见函数luaF_close。</li>\n</ol>","text":"Lua中的所谓upvalue是一类比较特殊的值，可以理解为在某函数内引用外部的数据。 函数定义中用到了pushclosure这个函数用于将函数的定义Proto结构体指针push到父函数的数组中，在这个函数内，还建立了有关upvalue相关的逻辑： static void push...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 学习 chapter10","uid":"6dd173d5288df05b5ec75744db2e59c2","slug":"zl/2016-01-01-337_Lua 学习 chapter10 ","date":"2024-04-03T03:47:35.615Z","updated":"2024-04-03T03:47:35.615Z","comments":true,"path":"api/articles/zl/2016-01-01-337_Lua 学习 chapter10 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"目录 正则表达式 模式匹配相关的函数 URL编码 制表符的展开 诀窍 Just be handsome. 正则表达式 . 任意字符 %a 字母 %c 控制字符 %d 数字 %g 除空格外的可打印字符 %l 小写字母 %p标点符号 %s 空白字符 %u 大写字母 %w 字母和数字 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"C++与Lua本质原始交互API","uid":"14791ba8de1523e6c9b46be1ecbacc51","slug":"zl/2016-01-01-339_C++与Lua本质原始交互API","date":"2024-04-03T03:47:35.615Z","updated":"2024-04-03T03:47:35.616Z","comments":true,"path":"api/articles/zl/2016-01-01-339_C++与Lua本质原始交互API.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;a href=&quot;/2015/11/11/lua_pairs_ipairs/&quot; rel=&quot;next&quot; title=&quot;Lua中ipairs和pairs的区别与使用&quot;&gt; &lt;i class=&quot;fa...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}