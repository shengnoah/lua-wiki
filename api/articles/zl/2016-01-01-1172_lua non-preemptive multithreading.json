{"title":"lua non-preemptive multithreading","uid":"4209e3efeb07621725054217d1ce7edf","slug":"zl/2016-01-01-1172_lua non-preemptive multithreading","date":"2024-04-03T03:47:33.024Z","updated":"2024-04-03T03:47:33.024Z","comments":true,"path":"api/articles/zl/2016-01-01-1172_lua non-preemptive multithreading.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<hr/>\n    <div id=\"content\">\n      <h2 id=\"lua-coroutine\">Lua Coroutine</h2>\n<p>Lua Coroutine is a kind of collaborative multithreading, equivalent to a thread. A pair yield-resume switches control from one thread to another.\nHowever, unlike “real” multithreading, coroutines are non preemptive. A coroutine only suspends its execution by explicitly calling a <code class=\"highlighter-rouge\">yield</code> function.</p>\n<h3 id=\"coroutine-grammar\">Coroutine Grammar</h3>\n<table>\n  <thead>\n    <tr>\n      <th>Method</th>\n      <th>Description</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>coroutine.create (f)</td>\n      <td>Creates a new coroutine, with f must be a function, Returns this new coroutine, an object with type “thread”.</td>\n    </tr>\n    <tr>\n      <td>coroutine.resume (co [, val1, ···])</td>\n      <td>Starts or continues the execution of coroutine</td>\n    </tr>\n    <tr>\n      <td>coroutine.yield (…)</td>\n      <td>Suspends the execution of the calling coroutine. Any arguments to yield are passed as extra results to resume.</td>\n    </tr>\n    <tr>\n      <td>coroutine.running ()</td>\n      <td>Returns the running coroutine plus a boolean, true when the running coroutine is the main one.</td>\n    </tr>\n    <tr>\n      <td>coroutine.status (co)</td>\n      <td>Returns the status of coroutine co, as a string: “running”, “suspended”,”normal” “dead”</td>\n    </tr>\n    <tr>\n      <td>coroutine.wrap (f)</td>\n      <td>Creates a new coroutine, Returns a function that resumes the coroutine each time it is called.</td>\n    </tr>\n    <tr>\n      <td>coroutine.isyieldable ()</td>\n      <td>Returns true when the running coroutine can yield.</td>\n    </tr>\n  </tbody>\n</table>\n<h2 id=\"multithreading-example\">Multithreading Example</h2>\n<p>Let us assume a typical multithreading situation: We want to download several remote files through HTTP. Of course, to download several remote files, we must know how to download one remote file. In this example, we will use the <code class=\"highlighter-rouge\">LuaSocket</code> library. To download a file, we must:</p>\n<ol>\n  <li>open a connection to its site</li>\n  <li>send a request to the file</li>\n  <li>receive the file (in blocks)</li>\n  <li>close the connection.</li>\n</ol>\n<p>In Lua, we can write this task as follows.</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">local</span> <span class=\"n\">socket</span> <span class=\"o\">=</span> <span class=\"nb\">require</span> <span class=\"s2\">&#34;socket&#34;</span>\n<p><span class=\"kd\">local</span> <span class=\"n\">host</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;www.w3.org&quot;</span><br />\n<span class=\"kd\">local</span> <span class=\"n\">file</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;/TR/REC-html32.html&quot;</span></p>\n<p><span class=\"kd\">local</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"nb\">assert</span><span class=\"p\">(</span><span class=\"n\">socket</span><span class=\"p\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"mi\">80</span><span class=\"p\">))</span><br />\n<span class=\"n\">c</span><span class=\"p\">:</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"s2\">&quot;GET &quot;</span> <span class=\"o\">…</span> <span class=\"n\">file</span> <span class=\"o\">…</span> <span class=\"s2\">&quot; HTTP/1.0rnrn&quot;</span><span class=\"p\">)</span><br />\n<span class=\"n\">c</span><span class=\"p\">:</span><span class=\"n\">close</span><span class=\"p\">()</span><br />\n</code></pre></div></div></p>\n<p>To rewrite the program with coroutines, let us first rewrite the previous download code as a function:</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">function</span> <span class=\"nf\">download</span> <span class=\"p\">(</span><span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"n\">file</span><span class=\"p\">)</span>\n    <span class=\"kd\">local</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"nb\">assert</span><span class=\"p\">(</span><span class=\"n\">socket</span><span class=\"p\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"mi\">80</span><span class=\"p\">))</span>\n    <span class=\"kd\">local</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>    <span class=\"c1\">-- counts number of bytes read</span>\n    <span class=\"n\">c</span><span class=\"p\">:</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"s2\">&#34;GET &#34;</span> <span class=\"o\">..</span> <span class=\"n\">file</span> <span class=\"o\">..</span> <span class=\"s2\">&#34; HTTP/1.0rnrn&#34;</span><span class=\"p\">)</span>\n    <span class=\"k\">while</span> <span class=\"kc\">true</span> <span class=\"k\">do</span>\n        <span class=\"kd\">local</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">status</span> <span class=\"o\">=</span> <span class=\"n\">receive</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span>\n        <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">count</span> <span class=\"o\">+</span> <span class=\"nb\">string.len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">status</span> <span class=\"o\">==</span> <span class=\"s2\">&#34;closed&#34;</span> <span class=\"k\">then</span> <span class=\"k\">break</span> <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">c</span><span class=\"p\">:</span><span class=\"n\">close</span><span class=\"p\">()</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n<p><span class=\"k\">function</span> <span class=\"nf\">receive</span> <span class=\"p\">(</span><span class=\"n\">connection</span><span class=\"p\">)</span><br />\n<span class=\"k\">return</span> <span class=\"n\">connection</span><span class=\"p\">:</span><span class=\"n\">receive</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"mi\">10</span><span class=\"p\">)</span><br />\n<span class=\"k\">end</span><br />\n</code></pre></div></div></p>\n<p>For the concurrent implementation, this function must receive data without blocking. Instead, if there is not enough data available, it yields. The new code is like this:</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">function</span> <span class=\"nf\">receive</span> <span class=\"p\">(</span><span class=\"n\">connection</span><span class=\"p\">)</span>\n    <span class=\"n\">connection</span><span class=\"p\">:</span><span class=\"n\">timeout</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>   <span class=\"c1\">-- do not block</span>\n    <span class=\"kd\">local</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">status</span> <span class=\"o\">=</span> <span class=\"n\">connection</span><span class=\"p\">:</span><span class=\"n\">receive</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">status</span> <span class=\"o\">==</span> <span class=\"s2\">&#34;timeout&#34;</span> <span class=\"k\">then</span>\n        <span class=\"nb\">coroutine.yield</span><span class=\"p\">(</span><span class=\"n\">connection</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n    <span class=\"k\">return</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">status</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n<p>The call to timeout(0) makes any operation over the connection a non-blocking operation. When the operation status is “timeout”, it means that the operation returned without completion. In this case, the thread yields. The non-false argument passed to yield signals to the dispatcher that the thread is still performing its task. (Later we will see another version where the dispatcher needs the timed-out connection.) Notice that, even in case of a timeout, the connection returns what it read until the timeout, so receive always returns s to its caller.\nThe next function ensures that each download runs in an individual thread:</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">threads</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span>    <span class=\"c1\">-- list of all live threads</span>\n<span class=\"k\">function</span> <span class=\"nf\">get</span> <span class=\"p\">(</span><span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"n\">file</span><span class=\"p\">)</span>\n    <span class=\"c1\">-- create coroutine</span>\n    <span class=\"kd\">local</span> <span class=\"n\">co</span> <span class=\"o\">=</span> <span class=\"nb\">coroutine.create</span><span class=\"p\">(</span><span class=\"k\">function</span> <span class=\"p\">()</span>\n        <span class=\"n\">download</span><span class=\"p\">(</span><span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"n\">file</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span><span class=\"p\">)</span>\n    <span class=\"c1\">-- insert it in the list</span>\n    <span class=\"nb\">table.insert</span><span class=\"p\">(</span><span class=\"n\">threads</span><span class=\"p\">,</span> <span class=\"n\">co</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n<p>The table threads keeps a list of all live threads, for the dispatcher.\nThe dispatcher is simple. It is mainly a loop that goes through all threads, calling one by one. It must also remove from the list the threads that finish their tasks. It stops the loop when there are no more threads to run:</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">function</span> <span class=\"nf\">dispatcher</span> <span class=\"p\">()</span>\n    <span class=\"k\">while</span> <span class=\"kc\">true</span> <span class=\"k\">do</span>\n        <span class=\"kd\">local</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"p\">.</span><span class=\"n\">getn</span><span class=\"p\">(</span><span class=\"n\">threads</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"k\">break</span> <span class=\"k\">end</span>   <span class=\"c1\">-- no more threads to run</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span> <span class=\"k\">do</span>\n          <span class=\"kd\">local</span> <span class=\"n\">status</span><span class=\"p\">,</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"nb\">coroutine.resume</span><span class=\"p\">(</span><span class=\"n\">threads</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n          <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">res</span> <span class=\"k\">then</span>    <span class=\"c1\">-- thread finished its task?</span>\n            <span class=\"nb\">table.remove</span><span class=\"p\">(</span><span class=\"n\">threads</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n            <span class=\"k\">break</span>\n          <span class=\"k\">end</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n<p>Finally, the main program creates the threads it needs and calls the dispatcher. For instance, to download four documents from the W3C site, the main program could be like this:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    host = &#34;www.w3.org&#34;\n<pre><code>get(host, &amp;#34;/TR/html401/html40.txt&amp;#34;)\nget(host,&amp;#34;/TR/2002/REC-xhtml1-20020801/xhtml1.pdf&amp;#34;)\nget(host,&amp;#34;/TR/REC-html32.html&amp;#34;)\nget(host,\n    &amp;#34;/TR/2000/REC-DOM-Level-2-Core-20001113/DOM2-Core.txt&amp;#34;)\n\ndispatcher()   -- main loop\n</code></pre>\n<p></code></pre></div></div></p>\n<p>My machine takes six seconds to download those four files using coroutines. With the sequential implementation, it takes more than twice that time (15 seconds).\nDespite the speedup, this last implementation is far from optimal. Everything goes fine while at least one thread has something to read. However, when no thread has data to read, the dispatcher does a busy wait, going from thread to thread only to check that they still have no data. As a result, this coroutine implementation uses almost 30 times more CPU than the sequential solution.</p>\n<p>To avoid this behavior, we can use the select function from LuaSocket. It allows a program to block while waiting for a status change in a group of sockets. The changes in our implementation are small. We only have to change the dispatcher. The new version is like this:</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">function</span> <span class=\"nf\">dispatcher</span> <span class=\"p\">()</span>\n    <span class=\"k\">while</span> <span class=\"kc\">true</span> <span class=\"k\">do</span>\n        <span class=\"kd\">local</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"p\">.</span><span class=\"n\">getn</span><span class=\"p\">(</span><span class=\"n\">threads</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"k\">break</span> <span class=\"k\">end</span>   <span class=\"c1\">-- no more threads to run</span>\n        <span class=\"kd\">local</span> <span class=\"n\">connections</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span> <span class=\"k\">do</span>\n          <span class=\"kd\">local</span> <span class=\"n\">status</span><span class=\"p\">,</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"nb\">coroutine.resume</span><span class=\"p\">(</span><span class=\"n\">threads</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n          <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">res</span> <span class=\"k\">then</span>    <span class=\"c1\">-- thread finished its task?</span>\n            <span class=\"nb\">table.remove</span><span class=\"p\">(</span><span class=\"n\">threads</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n            <span class=\"k\">break</span>\n          <span class=\"k\">else</span>    <span class=\"c1\">-- timeout</span>\n            <span class=\"nb\">table.insert</span><span class=\"p\">(</span><span class=\"n\">connections</span><span class=\"p\">,</span> <span class=\"n\">res</span><span class=\"p\">)</span>\n          <span class=\"k\">end</span>\n        <span class=\"k\">end</span>\n        <span class=\"k\">if</span> <span class=\"n\">table</span><span class=\"p\">.</span><span class=\"n\">getn</span><span class=\"p\">(</span><span class=\"n\">connections</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n          <span class=\"n\">socket</span><span class=\"p\">.</span><span class=\"n\">select</span><span class=\"p\">(</span><span class=\"n\">connections</span><span class=\"p\">)</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n<p>Along the inner loop, this new dispatcher collects the timed-out connections in table connections. Remember that receive passes such connections to yield; thus resume returns them. When all connections time out, the dispatcher calls select to wait for any of those connections to change status. This final implementation runs as fast as the first implementation with coroutines. Moreover, as it does no busy waits, it uses just a little more CPU than the sequential implementation.</p>\n<pre><code>&lt;/div&gt;\n&lt;hr/&gt;\n</code></pre>\n","text":" Lua Coroutine Lua Coroutine is a kind of collaborative multithreading, equivalent to a thread. A pair yield-resume switches control from on...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lua-coroutine\"><span class=\"toc-text\">Lua Coroutine</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#coroutine-grammar\"><span class=\"toc-text\">Coroutine Grammar</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#multithreading-example\"><span class=\"toc-text\">Multithreading Example</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"cse201w4_queryevaluation","uid":"60a7de5ab6ccb358bbfbd5eaeba812f8","slug":"zl/2016-01-01-1178_cse201w4_queryevaluation","date":"2024-04-03T03:47:33.025Z","updated":"2024-04-03T03:47:33.026Z","comments":true,"path":"api/articles/zl/2016-01-01-1178_cse201w4_queryevaluation.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"查询处理概述查询处理的基本步骤： 语法分析与翻译查询处理中系统首先必须把查询语句翻译成系统的内部表示形式。该翻译过程类似于编译器的语法分析器所做的工作。在此过程中，语法分析器检查用户查询的语法，验证查询中出现的关系名是数据库中的关系名等。系统构造该查询语句的语法分析树表示，然后将...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua tutorial","uid":"afe3397b930037cfdd0a57af33e6bbca","slug":"zl/2016-01-01-1173_lua tutorial","date":"2024-04-03T03:47:33.024Z","updated":"2024-04-03T03:47:33.024Z","comments":true,"path":"api/articles/zl/2016-01-01-1173_lua tutorial.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" What is Lua ? Lua is a powerful, efficient, lightweight, embeddable scripting language, 用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}