{"title":"Lua中关于table对象引用传递的注意事项","uid":"701786e387900af8ad697a179cb3c175","slug":"zl/2016-01-01-478_Lua中关于table对象引用传递的注意事项","date":"2024-04-03T03:47:35.760Z","updated":"2024-04-03T03:47:35.760Z","comments":true,"path":"api/articles/zl/2016-01-01-478_Lua中关于table对象引用传递的注意事项.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>最近写了挺长一段时间的Lua，发现Lua这个语言真的是很随意，产生这种感觉的根本原因应该是它把“函数” 作为了“第一类值”，也就是说函数也可以作为变量的“值”，这使得Lua可以随处定义函数，进而改变逻辑的走向，整个流程任你摆布。</p>\n<p>虽说把一个函数来回设置方便了许多，但是同样带来了一些不容易发现的问题，如果搞不清定义域和引用关系，常常会导致程序错误，比如最近用Lua写按钮的触发事件时，使用公有函数创建了对应的闭包，一开始感觉table的引用有问题，写了很多中转的代码，最后发现直接就可以使用，浪费了不少时间，最后仔细分析就是闭包最根本的形式，只不过被业务逻辑给干扰了视线，接下来我们一起看看，table和闭包究竟会发生什么关系！</p>\n<h1 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h1><ol>\n<li><p>table作为函数参数时的操作</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#34;nexample 1:&#34;</span>);</span><br/><span class=\"line\">data_table = {a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>};</span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(data_tb)</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">for</span> k,v <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(data_tb) <span class=\"keyword\">do</span></span><br/><span class=\"line\">        <span class=\"keyword\">if</span> v % <span class=\"number\">2</span> == <span class=\"number\">0</span> <span class=\"keyword\">then</span></span><br/><span class=\"line\">            data_tb[k] = <span class=\"literal\">nil</span>;</span><br/><span class=\"line\">        <span class=\"keyword\">end</span></span><br/><span class=\"line\">    <span class=\"keyword\">end</span></span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"></span><br/><span class=\"line\">filter(data_table);</span><br/><span class=\"line\"><span class=\"keyword\">for</span> k,v <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(data_table) <span class=\"keyword\">do</span></span><br/><span class=\"line\">    <span class=\"built_in\">print</span>(k,v)</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">example 1:</span><br/><span class=\"line\">1   3</span><br/><span class=\"line\">3   5</span><br/><span class=\"line\">a   1</span><br/></pre></td></tr></tbody></table></figure>\n<p>以上为去掉table中的偶数的代码，直接操作参数<code>data_tb</code>就可以对传入的<code>data_table</code>进行改变，这样的逻辑一般不会出错，接着我们看下接下来需求，直接将表中数据清空。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#34;nexample 2:&#34;</span>);</span><br/><span class=\"line\">data_table = {a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>};</span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">destroy</span><span class=\"params\">(data_tb)</span></span></span><br/><span class=\"line\">    data_tb = {};</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"comment\">-- 销毁整个表</span></span><br/><span class=\"line\">destroy(data_table);</span><br/><span class=\"line\"><span class=\"keyword\">for</span> k,v <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(data_table) <span class=\"keyword\">do</span></span><br/><span class=\"line\">    <span class=\"built_in\">print</span>(k,v)</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">example 2:</span><br/><span class=\"line\">1   3</span><br/><span class=\"line\">2   4</span><br/><span class=\"line\">3   5</span><br/><span class=\"line\">4   6</span><br/><span class=\"line\">b   2</span><br/><span class=\"line\">a   1</span><br/></pre></td></tr></tbody></table></figure>\n<p>看到这次的输出可能有些人就感到奇怪了，怎么上个例子改变元素可以，而这里直接给变量<code>data_tb</code>赋值，变成空表怎么不行了？这是因为<code>data_tb</code>是对变量<code>data_table</code>的整体引用，所以可以通过<code>data_tb</code>来改变变量<code>data_table</code>内部的值，但是当执行<code>data_tb = &#123;&#125;;</code>代码时表示<code>data_tb</code>不再引用<code>data_table</code>，而去引用<code>&#123;&#125;</code>了，也就是<code>data_tb</code>和<code>data_table</code>脱离了关系，这一点可以类比C++代码：</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">change_string</span><span class=\"params\">(<span class=\"keyword\">char</span>* pStr)</span></span></span><br/><span class=\"line\"><span class=\"function\"></span>{</span><br/><span class=\"line\">    pStr[<span class=\"number\">0</span>] = <span class=\"string\">&#39;5&#39;</span>;</span><br/><span class=\"line\">    pStr[<span class=\"number\">1</span>] = <span class=\"string\">&#39;0&#39;</span>;</span><br/><span class=\"line\"></span><br/><span class=\"line\">    pStr = <span class=\"string\">&#34;only testn&#34;</span>;</span><br/><span class=\"line\">}</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br/><span class=\"line\"><span class=\"function\"></span>{</span><br/><span class=\"line\">    <span class=\"keyword\">char</span> szContent[<span class=\"number\">32</span>] = <span class=\"string\">&#34;help&#34;</span>;</span><br/><span class=\"line\">    </span><br/><span class=\"line\">    change_string(szContent);</span><br/><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; szContent &lt;&lt; <span class=\"built_in\">endl</span>;</span><br/><span class=\"line\"></span><br/><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure>\n<p>分析一下这段代码的输出结果，如果你能知道结果为<code>50lp</code>，那说明你的C++水平已经超过了入门级别，理解了这段代码有助于清楚的理解前两段Lua代码。</p>\n</li>\n<li><p>看一个标准闭包实现的计数器</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#34;nexample 3:&#34;</span>);</span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span><span class=\"params\">()</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">local</span> count = <span class=\"number\">0</span>;</span><br/><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br/><span class=\"line\">        count = count + <span class=\"number\">1</span>;</span><br/><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br/><span class=\"line\">    <span class=\"keyword\">end</span></span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">func = counter();</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(func());</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(func());</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(func());</span><br/></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">example 3:</span><br/><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/></pre></td></tr></tbody></table></figure>\n<p>这段代码的不同之处就在于变量<code>count</code>，这是一个标准的计数器，也是一个标准的闭包，也就是说Lua支持这样的语法，闭包中可以在定义之后一直引用外部的变量，并且在返回函数的整个使用生命周期内都可以引用这个变量，加入外部修改了这个变量，闭包中引用的值也会改变，换句话来说就是闭包这种引用是引用的变量，而不是仅仅保存了一个值。</p>\n</li>\n<li><p>lua中常见的table引用</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#34;nexample 4:&#34;</span>);</span><br/><span class=\"line\"><span class=\"keyword\">local</span> t1 = {i = <span class=\"number\">1</span>};</span><br/><span class=\"line\"><span class=\"keyword\">local</span> t2 = t1;</span><br/><span class=\"line\">t1.i = <span class=\"number\">666</span>;</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(t2.i)</span><br/></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">example 4:</span><br/><span class=\"line\">666</span><br/></pre></td></tr></tbody></table></figure>\n<p>这个例子类似于前面“过滤掉偶数”的代码，首先定义了表<code>t1</code>，然后定义了变量<code>t2</code>引用了变量<code>t1</code>，实际上这里<code>t2</code>不是定义了变量<code>t1</code>本身，而是引用了<code>t1</code>的值，也就是引用的是<code>&#123;i=1&#125;</code>，这里通过<code>t1.i = 666</code>也可以影响到变量<code>t2</code>，其实这个例子看不出引用的究竟是变量<code>t1</code>还是<code>t1</code>的值，可以接着看下面的例子。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#34;nexample 5:&#34;</span>);</span><br/><span class=\"line\"><span class=\"keyword\">local</span> t1 = {i = <span class=\"number\">1</span>};</span><br/><span class=\"line\"><span class=\"keyword\">local</span> t2 = t1;</span><br/><span class=\"line\">t1 = {i = <span class=\"number\">11</span>};</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(t2.i)</span><br/></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">example 5:</span><br/><span class=\"line\">1</span><br/></pre></td></tr></tbody></table></figure>\n<p>通过这个例子就很清楚了，前面的部分和上个例子一致，但是后面直接给变量<code>t1</code>赋值时并没有改变<code>t2</code>的值，由此可以看出<code>t1</code>和<code>t2</code>已经“分离”了。</p>\n</li>\n<li><p>table引用和闭包结合的例子</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#34;nexample 6:&#34;</span>);</span><br/><span class=\"line\"><span class=\"keyword\">local</span> tb = {i= <span class=\"number\">1</span>};</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outer</span><span class=\"params\">()</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br/><span class=\"line\">        <span class=\"keyword\">local</span> t = tb;</span><br/><span class=\"line\">        <span class=\"built_in\">print</span>(t.i);</span><br/><span class=\"line\">    <span class=\"keyword\">end</span></span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">local</span> show = outer();</span><br/><span class=\"line\">tb = {i = <span class=\"number\">6</span>};</span><br/><span class=\"line\">show();</span><br/></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">example 6:</span><br/><span class=\"line\">6</span><br/></pre></td></tr></tbody></table></figure>\n<p>这个例子应该会有猜错结果的人，我自己就是在类似的代码中搞糊涂的，一种想法是函数<code>outer</code>定义的时候变量<code>t</code>的值已经定义了，还有一种就是认为在返回函数<code>show</code>的时候变量<code>t</code>的值会定义，但是这两种想法都是错误的，实际上是调用函数<code>show</code>的时候才给<code>t</code>赋值，这时变量<code>t</code>引用的是拥有最新值的<code>tb</code>，所以<code>t.i</code>的值是6，如果你猜对了这个例子的结果，接下来看看下面的代码。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#34;nexample 7:&#34;</span>);</span><br/><span class=\"line\"><span class=\"keyword\">local</span> tb = {i= <span class=\"number\">1</span>};</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outer</span><span class=\"params\">()</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">local</span> t = tb;</span><br/><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br/><span class=\"line\">        <span class=\"built_in\">print</span>(t.i);</span><br/><span class=\"line\">    <span class=\"keyword\">end</span></span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">local</span> show = outer();</span><br/><span class=\"line\">tb = {i = <span class=\"number\">7</span>};</span><br/><span class=\"line\">show();</span><br/></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">example 7:</span><br/><span class=\"line\">1</span><br/></pre></td></tr></tbody></table></figure>\n<p>如果清楚了上个例子的运行过程，就应该很容易知道这个例子的结果，其中变量<code>t</code>的值是在调用函数<code>outer</code>时确定的，所以后面的赋值<code>tb = &#123;i = 7&#125;;</code>对变量<code>t</code>的值没有影响。</p>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>lua中操作变量注意值和引用，其实很多语言都有这种区分。</li>\n<li>注意闭包可以访问外部变量的特性，程序中使用起来非常方便。</li>\n<li>实际使用过程中往往还夹杂着业务逻辑，要学会挖掘本质问题，这样往往可以看到真正的运行逻辑。</li>\n</ol>\n<h1 id=\"测试源码\"><a href=\"#测试源码\" class=\"headerlink\" title=\"测试源码\"></a>测试源码</h1><p><a href=\"https://github.com/AlbertGithubHome/Bella/blob/master/lua/problem/table_refrence.lua\" target=\"_blank\" rel=\"noopener noreferrer\">示例传送门：lua中table引用</a></p>","text":"最近写了挺长一段时间的Lua，发现Lua这个语言真的是很随意，产生这种感觉的根本原因应该是它把“函数” 作为了“第一类值”，也就是说函数也可以作为变量的“值”，这使得Lua可以随处定义函数，进而改变逻辑的走向，整个流程任你摆布。 虽说把一个函数来回设置方便了许多，但是同样带来了一...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">代码测试</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">测试源码</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 有趣的语法特性","uid":"84ea8062aa5bfb9f0b90119d5879542b","slug":"zl/2016-01-01-479_Lua 有趣的语法特性","date":"2024-04-03T03:47:35.760Z","updated":"2024-04-03T03:47:35.761Z","comments":true,"path":"api/articles/zl/2016-01-01-479_Lua 有趣的语法特性.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 使用函数作为函数返回 table关联数组的多种访问形式 table计数的问题 函数其实也是变量 local 和 global 函数在调用的时候会有所区别 可变参数（5.1） 参数默认值 三元表达式 不同变量类型比较时不存在自动转换 只有 nil 和 false 是假，0,&#1...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua中的表及面向对象","uid":"1ad5c690a0087b80478637ac337433fb","slug":"zl/2016-01-01-475_lua中的表及面向对象","date":"2024-04-03T03:47:35.757Z","updated":"2024-04-03T03:47:35.757Z","comments":true,"path":"api/articles/zl/2016-01-01-475_lua中的表及面向对象.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"在lua中，只有唯一的一种数据结构，表。通过表，却可以用来实现类一样的形式，其关键是对于表的元方法的使用，可以有很多奇妙的用处。 Lua中，所有的值都可以有一个有一个元表(metatable)，元表中的元素定义了对于值特定操作的方法，就叫做元方法。当然，这些元表是有默认值的，但我...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}