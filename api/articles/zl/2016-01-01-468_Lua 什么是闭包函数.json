{"title":"Lua 什么是闭包函数","uid":"5a779acb102a1de04b14659eedba112c","slug":"zl/2016-01-01-468_Lua 什么是闭包函数","date":"2024-04-03T03:47:35.749Z","updated":"2024-04-03T03:47:35.749Z","comments":true,"path":"api/articles/zl/2016-01-01-468_Lua 什么是闭包函数.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>为路由器写脚本，顺带学了一下lua.对闭包函数做个理解笔记<br/></p>\n<p>普通函数内部可以直接读取全局变量。如：<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">local n = 1</div><div class=\"line\"></div><div class=\"line\">function f1( ... )</div><div class=\"line\">    return n</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">print(f1())        --1</div></pre></td></tr></tbody></table></figure><p></p>\n<p>但普通函数内部却无法读取一个与自己不同作用域的局部变量。如：<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">function f1( ... )</div><div class=\"line\">    local n = 1</div><div class=\"line\">    return n</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">function f2( ... )</div><div class=\"line\">    print(n)</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">f2()        --nil</div></pre></td></tr></tbody></table></figure><p></p>\n<p>但是通过下列这种特殊的函数写法，就可以让一个函数读取一个与自己不同作用域的局部变量：<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function f1( ... )</div><div class=\"line\">    local n = 1</div><div class=\"line\">    function f2( ... )</div><div class=\"line\">        n = n + 1</div><div class=\"line\">        return n</div><div class=\"line\">    end</div><div class=\"line\">    return f2</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">local result = f1()</div><div class=\"line\">print(result())        --2</div></pre></td></tr></tbody></table></figure><p></p>\n<p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。</p>\n<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们就可以在f1外部读取它的内部变量！<br/>这种函数叫称之为闭包函数。</p>\n<p>所以，如果要用一句话说明白闭包函数，那就是：&gt;函数内在包含子函数，并最终return子函数。</p>\n<p>而闭包函数的最大价值在于：我们可以在函数的外部（即子函数），直接读取该函数的局部变量。</p>\n<p>再仔细研究，就会发现f1()函数就如同一个“类”，而其定义的局部变量就如同该“类”的全局变量；而子函数f2()函数，则如同这个“类”的方法，可以直接使用这个“类”的全局变量n。神奇吧？<br/><br/></p>\n<h2 id=\"现在总算明白什么是闭包函数了，虽然其实现很神奇，但闭包函数有什么用？\"><a href=\"#现在总算明白什么是闭包函数了，虽然其实现很神奇，但闭包函数有什么用？\" class=\"headerlink\" title=\"现在总算明白什么是闭包函数了，虽然其实现很神奇，但闭包函数有什么用？\"></a>现在总算明白什么是闭包函数了，虽然其实现很神奇，但闭包函数有什么用？</h2><h3 id=\"1、缓存：最显而易见的好处，就是可以实现数据缓存，我们可以把一个需要长期用到的变量设为闭包函数的局部变量，在子函数里面直接使用它。因此局部变量只定义初始化一次，但我们可以多次调用子函数并使用该变量。这比起我们在子函数中定义初始化变量，多次调用则多次初始化的做法，效率更高。闭包函数常见的一种用途就是，我们可以通过此实现计数功能。在闭包函数定义一个计数变量，而在子函数中对其进行-的操作。这样每次调用闭包函数，计数变量就会加1。\"><a href=\"#1、缓存：最显而易见的好处，就是可以实现数据缓存，我们可以把一个需要长期用到的变量设为闭包函数的局部变量，在子函数里面直接使用它。因此局部变量只定义初始化一次，但我们可以多次调用子函数并使用该变量。这比起我们在子函数中定义初始化变量，多次调用则多次初始化的做法，效率更高。闭包函数常见的一种用途就是，我们可以通过此实现计数功能。在闭包函数定义一个计数变量，而在子函数中对其进行-的操作。这样每次调用闭包函数，计数变量就会加1。\" class=\"headerlink\" title=\"1、缓存：最显而易见的好处，就是可以实现数据缓存，我们可以把一个需要长期用到的变量设为闭包函数的局部变量，在子函数里面直接使用它。因此局部变量只定义初始化一次，但我们可以多次调用子函数并使用该变量。这比起我们在子函数中定义初始化变量，多次调用则多次初始化的做法，效率更高。闭包函数常见的一种用途就是，我们可以通过此实现计数功能。在闭包函数定义一个计数变量，而在子函数中对其进行++的操作。这样每次调用闭包函数，计数变量就会加1。\"></a>1、缓存：最显而易见的好处，就是可以实现数据缓存，我们可以把一个需要长期用到的变量设为闭包函数的局部变量，在子函数里面直接使用它。因此局部变量只定义初始化一次，但我们可以多次调用子函数并使用该变量。这比起我们在子函数中定义初始化变量，多次调用则多次初始化的做法，效率更高。闭包函数常见的一种用途就是，我们可以通过此实现计数功能。在闭包函数定义一个计数变量，而在子函数中对其进行++的操作。这样每次调用闭包函数，计数变量就会加1。</h3><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function f1( ... )</div><div class=\"line\">    local n = 0</div><div class=\"line\">    function f2( ... )</div><div class=\"line\">        n = n + 1</div><div class=\"line\">        return n</div><div class=\"line\">    end</div><div class=\"line\">    return f2</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">local count = f1()</div><div class=\"line\">print(count())        --1</div><div class=\"line\">print(count())        --2</div><div class=\"line\">print(count())        --3</div><div class=\"line\">print(count())        --4</div><div class=\"line\">print(count())        --5</div></pre></td></tr></tbody></table></figure>\n<p><br/></p>\n<h3 id=\"2、实现封装：如同前面所说，闭包函数就如同一个“类”，只有在该闭包函数里的方法才可以使用其局部变量，闭包函数之外的方法是不能读取其局部变量的。这就实现了面向对象的封装性，更安全更可靠。\"><a href=\"#2、实现封装：如同前面所说，闭包函数就如同一个“类”，只有在该闭包函数里的方法才可以使用其局部变量，闭包函数之外的方法是不能读取其局部变量的。这就实现了面向对象的封装性，更安全更可靠。\" class=\"headerlink\" title=\"2、实现封装：如同前面所说，闭包函数就如同一个“类”，只有在该闭包函数里的方法才可以使用其局部变量，闭包函数之外的方法是不能读取其局部变量的。这就实现了面向对象的封装性，更安全更可靠。\"></a>2、实现封装：如同前面所说，闭包函数就如同一个“类”，只有在该闭包函数里的方法才可以使用其局部变量，闭包函数之外的方法是不能读取其局部变量的。这就实现了面向对象的封装性，更安全更可靠。</h3>","text":"为路由器写脚本，顺带学了一下lua.对闭包函数做个理解笔记 普通函数内部可以直接读取全局变量。如：1234567local n = 1function f1( ... ) return nendprint(f1()) --1 但普通函数内部却无法读取一个与自己不同作用域的局部变量...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8E%B0%E5%9C%A8%E6%80%BB%E7%AE%97%E6%98%8E%E7%99%BD%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E4%BA%86%EF%BC%8C%E8%99%BD%E7%84%B6%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%BE%88%E7%A5%9E%E5%A5%87%EF%BC%8C%E4%BD%86%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">现在总算明白什么是闭包函数了，虽然其实现很神奇，但闭包函数有什么用？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81%E7%BC%93%E5%AD%98%EF%BC%9A%E6%9C%80%E6%98%BE%E8%80%8C%E6%98%93%E8%A7%81%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%8A%8A%E4%B8%80%E4%B8%AA%E9%9C%80%E8%A6%81%E9%95%BF%E6%9C%9F%E7%94%A8%E5%88%B0%E7%9A%84%E5%8F%98%E9%87%8F%E8%AE%BE%E4%B8%BA%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E5%9C%A8%E5%AD%90%E5%87%BD%E6%95%B0%E9%87%8C%E9%9D%A2%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%AE%83%E3%80%82%E5%9B%A0%E6%AD%A4%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%8F%AA%E5%AE%9A%E4%B9%89%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E6%AC%A1%EF%BC%8C%E4%BD%86%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8%E5%AD%90%E5%87%BD%E6%95%B0%E5%B9%B6%E4%BD%BF%E7%94%A8%E8%AF%A5%E5%8F%98%E9%87%8F%E3%80%82%E8%BF%99%E6%AF%94%E8%B5%B7%E6%88%91%E4%BB%AC%E5%9C%A8%E5%AD%90%E5%87%BD%E6%95%B0%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%98%E9%87%8F%EF%BC%8C%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8%E5%88%99%E5%A4%9A%E6%AC%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%8C%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%E3%80%82%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%80%E7%A7%8D%E7%94%A8%E9%80%94%E5%B0%B1%E6%98%AF%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%AD%A4%E5%AE%9E%E7%8E%B0%E8%AE%A1%E6%95%B0%E5%8A%9F%E8%83%BD%E3%80%82%E5%9C%A8%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%AE%A1%E6%95%B0%E5%8F%98%E9%87%8F%EF%BC%8C%E8%80%8C%E5%9C%A8%E5%AD%90%E5%87%BD%E6%95%B0%E4%B8%AD%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C-%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82%E8%BF%99%E6%A0%B7%E6%AF%8F%E6%AC%A1%E8%B0%83%E7%94%A8%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%EF%BC%8C%E8%AE%A1%E6%95%B0%E5%8F%98%E9%87%8F%E5%B0%B1%E4%BC%9A%E5%8A%A01%E3%80%82\"><span class=\"toc-text\">1、缓存：最显而易见的好处，就是可以实现数据缓存，我们可以把一个需要长期用到的变量设为闭包函数的局部变量，在子函数里面直接使用它。因此局部变量只定义初始化一次，但我们可以多次调用子函数并使用该变量。这比起我们在子函数中定义初始化变量，多次调用则多次初始化的做法，效率更高。闭包函数常见的一种用途就是，我们可以通过此实现计数功能。在闭包函数定义一个计数变量，而在子函数中对其进行++的操作。这样每次调用闭包函数，计数变量就会加1。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%AE%9E%E7%8E%B0%E5%B0%81%E8%A3%85%EF%BC%9A%E5%A6%82%E5%90%8C%E5%89%8D%E9%9D%A2%E6%89%80%E8%AF%B4%EF%BC%8C%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%B0%B1%E5%A6%82%E5%90%8C%E4%B8%80%E4%B8%AA%E2%80%9C%E7%B1%BB%E2%80%9D%EF%BC%8C%E5%8F%AA%E6%9C%89%E5%9C%A8%E8%AF%A5%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95%E6%89%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%85%B6%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E4%B9%8B%E5%A4%96%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E4%B8%8D%E8%83%BD%E8%AF%BB%E5%8F%96%E5%85%B6%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E3%80%82%E8%BF%99%E5%B0%B1%E5%AE%9E%E7%8E%B0%E4%BA%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B0%81%E8%A3%85%E6%80%A7%EF%BC%8C%E6%9B%B4%E5%AE%89%E5%85%A8%E6%9B%B4%E5%8F%AF%E9%9D%A0%E3%80%82\"><span class=\"toc-text\">2、实现封装：如同前面所说，闭包函数就如同一个“类”，只有在该闭包函数里的方法才可以使用其局部变量，闭包函数之外的方法是不能读取其局部变量的。这就实现了面向对象的封装性，更安全更可靠。</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"nginx_lua 扩展让 nginx 拥有可编程能力","uid":"a0f5de90db401eb853c427c4ba1b6602","slug":"zl/2016-01-01-46_nginx_lua 扩展让 nginx 拥有可编程能力","date":"2024-04-03T03:47:35.750Z","updated":"2024-04-03T03:47:35.751Z","comments":true,"path":"api/articles/zl/2016-01-01-46_nginx_lua 扩展让 nginx 拥有可编程能力.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"公司使用 lighttpd 的比较多, 主要是接入层的一些工作，而且增加了一些很多自己的模块防火墙等等. 后来nginx开始流行起来因为 lighttpd 和 nginx整体是实现方式比较类似(个人感觉nginx 借鉴了 lighttpd的实现方式)，都使用了多进程异步非阻塞处理...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua与C交互相关","uid":"6987918132963fa97d63d894b303d6a0","slug":"zl/2016-01-01-469_Lua与C交互相关","date":"2024-04-03T03:47:35.749Z","updated":"2024-04-03T03:47:35.750Z","comments":true,"path":"api/articles/zl/2016-01-01-469_Lua与C交互相关.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"C语言API总览。 C语言和Lua语言的两种交互形式： C语言拥有控制权，而Lua语言被用作库，这种交互形式中的C代码被称为应用代码。 Lua语言拥有控制权，而C语言被用作库，此时的C代码被称为库代码。 应用代码和库代码都适用相同的API和Lua语言通信，这些API称为C API...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}