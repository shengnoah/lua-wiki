{"title":"lua 原生api解读","uid":"295283d9501912df4611655107bb5066","slug":"zl/2016-01-01-532_lua 原生api解读","date":"2024-04-03T03:47:35.804Z","updated":"2024-04-03T03:47:35.807Z","comments":true,"path":"api/articles/zl/2016-01-01-532_lua 原生api解读.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<ul id=\"markdown-toc\">\n  <li><a href=\"#简介\" id=\"markdown-toc-简介\">简介</a></li>\n  <li><a href=\"#luaapi\" id=\"markdown-toc-luaapi\">LuaAPI</a>    <ul>\n      <li><a href=\"#1创建新表\" id=\"markdown-toc-1创建新表\">1.创建新表</a></li>\n      <li><a href=\"#2取表中元素\" id=\"markdown-toc-2取表中元素\">2.取表中元素</a></li>\n      <li><a href=\"#3表中的元素赋值\" id=\"markdown-toc-3表中的元素赋值\">3.表中的元素赋值</a></li>\n      <li><a href=\"#4取表元素\" id=\"markdown-toc-4取表元素\">4.取表元素</a></li>\n      <li><a href=\"#4表元素赋值\" id=\"markdown-toc-4表元素赋值\">4.表元素赋值</a></li>\n      <li><a href=\"#5对table的一些操作不引发原方法\" id=\"markdown-toc-5对table的一些操作不引发原方法\">5.对table的一些操作[不引发原方法]</a></li>\n      <li><a href=\"#6复制栈上元素并压入栈\" id=\"markdown-toc-6复制栈上元素并压入栈\">6.复制栈上元素并压入栈</a></li>\n    </ul>\n  </li>\n  <li><a href=\"#参考资料\" id=\"markdown-toc-参考资料\">参考资料</a></li>\n</ul>\n<h2 id=\"简介\">简介</h2>\n<p>研究lua也有一段时间了，对lua也算是小有了解，对于lua的api可能和其他脚本语言不是\n很相同，使用lua来编写，lua原生api都采用C语言开发的，理解这些api含义对于理解lua\n语言设计的本身又起着至关重要的作用，故此在这里记录下，lua-api具体含义。</p>\n<h2 id=\"luaapi\">LuaAPI</h2>\n<h4 id=\"1创建新表\">1.创建新表</h4>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>void lua_createtable(lua_State *L, int narr, int nrec)\n<p>创建一个新表，并将它放在栈顶，narr和nrec分别制定该table的array和hash部分的预分配<br />\n元素的数量。<br />\n无返回值<br />\n栈高度+1，栈顶元素是新的table。<br />\n#define lua_newtable(L) lua_createtable(L, 0, 0)<br />\n创建表的另一个api，常用这个api,上面的宏一定很清楚不多介绍。<br />\n</code></pre></div></div></p>\n<h4 id=\"2取表中元素\">2.取表中元素</h4>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>void lua_getfield (lua_State *L, int index, const char *k)\n操作:   arr = Stack[index]\n        Stack.push( arr[k] )\n取表中键为k的元素, 这里的表是由index指向的栈上的一个表\n无返回值\n栈高度+1, 栈顶元素是(Stack[index])[k]\n注意, 该操作将触发 __index 元方法\n</code></pre></div></div>\n<h4 id=\"3表中的元素赋值\">3.表中的元素赋值</h4>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>void lua_setfield (lua_State *L, int index, const char *k)\n操作:   arr = Stack[index]\n        arr[k] = Stack.top()\n        Stack.pop()\n给表中键为k的元素赋值value(value就是栈顶元素), 这里的表是由index指向的栈上的一个表\n无返回值\n栈高度-1, 被弹出的是value\n注意, 该操作将触发 __newindex 元方法\n</code></pre></div></div>\n<h4 id=\"4取表元素\">4.取表元素</h4>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>void lua_gettable (lua_State *L, int index)\n操作:   ele  = Stack[index]\n        key = Stack.top()\n        Stack.pop()\n        value = ele[key]\n        Stack.push(value)\n根据index指定取到相应的表; 取栈顶元素为key, 并弹出栈; 获取表中key的值压入栈顶.\n无返回值\n栈高度不变, 但是发生了一次弹出和压入的操作, 弹出的是key, 压入的是value\n注意, 该操作将触发 __index 元方法\n</code></pre></div></div>\n<h4 id=\"4表元素赋值\">4.表元素赋值</h4>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>void lua_settable (lua_State *L, int index)\n操作:   ele = Stack[index]\n        value = Stack.top()\n        Stack.pop()\n        key = Stack.top()\n        Stack.pop()\n        ele[key] = value\n根据index指定取到相应的表; 取栈顶元素做value, 弹出之; 再取当前栈顶元素做key, 亦弹出之; 然后将表的键为key的元素赋值为value\n无返回值\n栈高度-2, 第一次弹出value, 第二次弹出key\n注意, 该操作将触发 __newindex 元方法\n</code></pre></div></div>\n<h4 id=\"5对table的一些操作不引发原方法\">5.对table的一些操作[不引发原方法]</h4>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>void lua_rawget (lua_State *L, int index)和lua_gettable操作一样，但是不触发相应的元方法 \nvoid lua_rawgeti(lua_State *L, int index, int n)\n操作:   ele = Stack[index]\n        value = ele[n]\n        Stack.push(value)\n无返回值\n栈+1， 栈顶新增元素就是 value\n不触发相应的元方法\n<p>void lua_rawset (lua_State *L, int index) 和lua_settable操作一样，但是不触发相应的原方法<br />\nvoid lua_rawseti (lua_State *L, int index, int n)<br />\n操作:   ele = Stack[index]<br />\nvalue = Stack.top()<br />\nStack.pop()<br />\nele[n] = value<br />\n无返回值<br />\n栈-1, 栈顶将value弹出<br />\n不触发相应的元方法<br />\n</code></pre></div></div></p>\n<h4 id=\"6复制栈上元素并压入栈\">6.复制栈上元素并压入栈</h4>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>void lua_pushvalue (lua_State *L, int index)\n操作:   value = Stack[index]       \n        Stack.push(value)\n无返回值\n栈+1 \n</code></pre></div></div>\n<h2 id=\"参考资料\">参考资料</h2>\n<p><a href=\"https://github.com/lua/lua\">lua源码</a></p>\n<p><a href=\"https://github.com/xebecnan/UniLua\">UniLua源码</a></p>\n<p><a href=\"https://github.com/abaojin/csharp-lua\">Csharp-lua源码</a></p>\n<p><a href=\"http://www.cnblogs.com/ringofthec/archive/2010/10/22/lua.html\">lua-api论坛</a></p>","text":" 简介 LuaAPI 1.创建新表 2.取表中元素 3.表中的元素赋值 4.取表元素 4.表元素赋值 5.对table的一些操作[不引发原方法] 6.复制栈上元素并压入栈 参考资料 简介 研究lua也有一段时间了，对lua也算是小有了解，对于lua的api可能和其他脚本语言不是 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#luaapi\"><span class=\"toc-text\">LuaAPI</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E5%88%9B%E5%BB%BA%E6%96%B0%E8%A1%A8\"><span class=\"toc-text\">1.创建新表</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E5%8F%96%E8%A1%A8%E4%B8%AD%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">2.取表中元素</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">3.表中的元素赋值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E5%8F%96%E8%A1%A8%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">4.取表元素</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E8%A1%A8%E5%85%83%E7%B4%A0%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">4.表元素赋值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E5%AF%B9table%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%B8%8D%E5%BC%95%E5%8F%91%E5%8E%9F%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">5.对table的一些操作[不引发原方法]</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%E5%A4%8D%E5%88%B6%E6%A0%88%E4%B8%8A%E5%85%83%E7%B4%A0%E5%B9%B6%E5%8E%8B%E5%85%A5%E6%A0%88\"><span class=\"toc-text\">6.复制栈上元素并压入栈</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\"><span class=\"toc-text\">参考资料</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"LUA面向对象编程技巧","uid":"7b688055584efd19ee44e4529173196a","slug":"zl/2016-01-01-531_LUA面向对象编程技巧","date":"2024-04-03T03:47:35.804Z","updated":"2024-04-03T03:47:35.804Z","comments":true,"path":"api/articles/zl/2016-01-01-531_LUA面向对象编程技巧.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"LUA中的对象我们知道，对象由属性和方法组成。LUA中最基本的结构是table，So 必须用table描述对象的属性。lua中的function可以用来表示方法。那么LUA中的类可以通过table + function模拟出来。至于继承，可以通过metetable模拟出来（不推荐...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua函数定义","uid":"83698ed043c00a6ae2036e425e46e554","slug":"zl/2016-01-01-52_lua函数定义","date":"2024-04-03T03:47:35.803Z","updated":"2024-04-03T03:47:35.803Z","comments":true,"path":"api/articles/zl/2016-01-01-52_lua函数定义.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"FuncStateproto结构数组保存函数原型信息;prev保存父函数体指针；actvar保存定义的局部变量；upvalues保存upvalue Lua源码中,专门有一个结构体FuncState用来保存函数相关的信息.其实,即使没有创建任何函数,对于Lua而言也有一个最外层的F...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}