{"title":"lua 字节码(bytecode)","uid":"fda0c45591840129c17ad8c1798634bd","slug":"zl/2016-01-01-166_lua 字节码(bytecode)","date":"2024-04-03T03:47:33.053Z","updated":"2024-04-03T03:47:33.054Z","comments":true,"path":"api/articles/zl/2016-01-01-166_lua 字节码(bytecode).json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<ul id=\"markdown-toc\">\n  <li><a href=\"#lua字节码\" id=\"markdown-toc-lua字节码\">lua字节码</a></li>\n  <li><a href=\"#字节码格式\" id=\"markdown-toc-字节码格式\">字节码格式</a>    <ul>\n      <li><a href=\"#源码案例\" id=\"markdown-toc-源码案例\">源码案例：</a></li>\n      <li><a href=\"#对应字节码\" id=\"markdown-toc-对应字节码\">对应字节码：</a></li>\n      <li><a href=\"#指令解释\" id=\"markdown-toc-指令解释\">指令解释：</a></li>\n    </ul>\n  </li>\n  <li><a href=\"#指令分类\" id=\"markdown-toc-指令分类\">指令分类</a></li>\n  <li><a href=\"#所有指令\" id=\"markdown-toc-所有指令\">所有指令</a></li>\n</ul>\n<h2 id=\"lua字节码\">lua字节码</h2>\n<p>lua虚拟机最终执行的是经过lua编译器编译的字节码，这里暂不关系Chunk生成字节码过程，\n只关系字节码本身，字节码的格式到底是什么样？具体的含义是什么？</p>\n<h2 id=\"字节码格式\">字节码格式</h2>\n<p>lua字节码指令是由4个字节32位组成, 这时32是如何规划的，简单说那些位代表这个指令是\n什么，那些位是操作数据，这里通过一个案例来看看bytecode结构，然后再解释bytecode具\n体的结构。</p>\n<h3 id=\"源码案例\">源码案例：</h3>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>--test function 1\nfunction max(num1, num2)\n   if (num1 &gt; num2) then\n\t  r = num1\n   else\n\t  r = num2\n   end\n   return r\nend\n--test function 2\nfunction add(num1, num2)\n\treturn num1 + num2\nend\nprint(&#34;hello world&#34;)\nprint(&#34;max &#34;, max(10,8))\n</code></pre></div></div>\n<p>定义了两个函数，max和add函数，函数实现比较简单，暂且不关心，然后调用系统函数print\n输出hello world，接着调用max函数，add函数没有调用。看看这段代码被lua编译器编译后\n的结果到底是什么？使用lua5.2.1版本lauc编译器，指令为luac -l test.lua进行编译。</p>\n<h3 id=\"对应字节码\">对应字节码：</h3>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>main &lt;test.lua:0,0&gt; (15 instructions at 0000000000180370)\n0+ params, 5 slots, 1 upvalue, 0 locals, 7 constants, 2 functions\n\t1\t[9]\tCLOSURE  \t0 0\t; 0000000000180640\n\t2\t[2]\tSETTABUP \t0 -1 0\t; _ENV &#34;max&#34;\n\t3\t[14]\tCLOSURE  \t0 1\t; 00000000001809C0\n\t4\t[12]\tSETTABUP \t0 -2 0\t; _ENV &#34;add&#34;\n\t5\t[16]\tGETTABUP \t0 0 -3\t; _ENV &#34;console&#34;\n\t6\t[16]\tLOADK    \t1 -4\t; &#34;hello world&#34;\n\t7\t[16]\tCALL     \t0 2 1\n\t8\t[17]\tGETTABUP \t0 0 -3\t; _ENV &#34;console&#34;\n\t9\t[17]\tLOADK    \t1 -5\t; &#34;max &#34;\n\t10\t[17]\tGETTABUP \t2 0 -1\t; _ENV &#34;max&#34;\n\t11\t[17]\tLOADK    \t3 -6\t; 10\n\t12\t[17]\tLOADK    \t4 -7\t; 8\n\t13\t[17]\tCALL     \t2 3 0\n\t14\t[17]\tCALL     \t0 0 1\n\t15\t[17]\tRETURN   \t0 1\nfunction &lt;test.lua:2,9&gt; (8 instructions at 0000000000180640)\n2 params, 3 slots, 1 upvalue, 2 locals, 1 constant, 0 functions\n\t1\t[3]\tLT       \t0 1 0\n\t2\t[3]\tJMP      \t0 2\t; to 5\n\t3\t[4]\tSETTABUP \t0 -1 0\t; _ENV &#34;r&#34;\n\t4\t[4]\tJMP      \t0 1\t; to 6\n\t5\t[6]\tSETTABUP \t0 -1 1\t; _ENV &#34;r&#34;\n\t6\t[8]\tGETTABUP \t2 0 -1\t; _ENV &#34;r&#34;\n\t7\t[8]\tRETURN   \t2 2\n\t8\t[9]\tRETURN   \t0 1\nfunction &lt;test.lua:12,14&gt; (3 instructions at 00000000001809C0)\n2 params, 3 slots, 0 upvalues, 2 locals, 0 constants, 0 functions\n\t1\t[13]\tADD      \t2 0 1\n\t2\t[13]\tRETURN   \t2 2\n\t3\t[14]\tRETURN   \t0 1\n</code></pre></div></div>\n<h3 id=\"指令解释\">指令解释：</h3>\n<p>上面的源码生成指令可以看出来，每一行是一个指令，每一行指令由5部分组成，分别为：\n\t指令行号\t源码行号\t指令\t操作数\t\t指令描述\n通过上面的结果我们可以看出来，每一个lua函数，lua都会生成一段指令块，该指令块包含该\n函数的内容指令。值得注意是lua源码会默认生成一个main function，该指令块主要包含lua的\n执行过程。</p>\n<h2 id=\"指令分类\">指令分类</h2>\n<p>四种指令：iABC\tiABx\tiAsBx\tiAx,代码中定义：enum OpMode {iABC, iABx, iAsBx, iAx};\nlua所有指令前6位是操作码opcode,剩下组成部分如下：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Instructions can have the following fields:\n\t`A&#39; : 8 bits\n\t`B&#39; : 9 bits\n\t`C&#39; : 9 bits\n\t&#39;Ax&#39; : 26 bits (&#39;A&#39;, &#39;B&#39;, and &#39;C&#39; together)\n\t`Bx&#39; : 18 bits (`B&#39; and `C&#39; together)\n\t`sBx&#39; : signed Bx\n</code></pre></div></div>\n<h2 id=\"所有指令\">所有指令</h2>\n<p>这里的指令是5.2.1版本里面所有的指令都定义在lopcode.h头文件中定义，代码如下：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/*----------------------------------------------------------------------\nname\t\targs\tdescription\n------------------------------------------------------------------------*/\nOP_MOVE,/*\tA B\tR(A) := R(B)\t\t\t\t\t*/\nOP_LOADK,/*\tA Bx\tR(A) := Kst(Bx)\t\t\t\t\t*/\nOP_LOADKX,/*\tA \tR(A) := Kst(extra arg)\t\t\t\t*/\nOP_LOADBOOL,/*\tA B C\tR(A) := (Bool)B; if (C) pc++\t\t\t*/\nOP_LOADNIL,/*\tA B\tR(A), R(A+1), ..., R(A+B) := nil\t\t*/\nOP_GETUPVAL,/*\tA B\tR(A) := UpValue[B]\t\t\t\t*/\n<p>OP_GETTABUP,/*\tA B C\tR(A) := UpValue[B][RK©]\t\t\t<em>/<br />\nOP_GETTABLE,/</em>\tA B C\tR(A) := R(B)[RK©]\t\t\t\t*/</p>\n<p>OP_SETTABUP,/*\tA B C\tUpValue[A][RK(B)] := RK©\t\t\t<em>/<br />\nOP_SETUPVAL,/</em>\tA B\tUpValue[B] := R(A)\t\t\t\t<em>/<br />\nOP_SETTABLE,/</em>\tA B C\tR(A)[RK(B)] := RK©\t\t\t\t*/</p>\n<p>OP_NEWTABLE,/*\tA B C\tR(A) := &#123;&#125; (size = B,C)\t\t\t\t*/</p>\n<p>OP_SELF,/*\tA B C\tR(A+1) := R(B); R(A) := R(B)[RK©]\t\t*/</p>\n<p>OP_ADD,/*\tA B C\tR(A) := RK(B) + RK©\t\t\t\t<em>/<br />\nOP_SUB,/</em>\tA B C\tR(A) := RK(B) - RK©\t\t\t\t<em>/<br />\nOP_MUL,/</em>\tA B C\tR(A) := RK(B) * RK©\t\t\t\t<em>/<br />\nOP_DIV,/</em>\tA B C\tR(A) := RK(B) / RK©\t\t\t\t<em>/<br />\nOP_MOD,/</em>\tA B C\tR(A) := RK(B) % RK©\t\t\t\t<em>/<br />\nOP_POW,/</em>\tA B C\tR(A) := RK(B) ^ RK©\t\t\t\t<em>/<br />\nOP_UNM,/</em>\tA B\tR(A) := -R(B)\t\t\t\t\t<em>/<br />\nOP_NOT,/</em>\tA B\tR(A) := not R(B)\t\t\t\t<em>/<br />\nOP_LEN,/</em>\tA B\tR(A) := length of R(B)\t\t\t\t*/</p>\n<p>OP_CONCAT,/*\tA B C\tR(A) := R(B)… … …R©\t\t\t*/</p>\n<p>OP_JMP,/*\tA sBx\tpc+=sBx; if (A) close all upvalues &gt;= R(A) + 1\t<em>/<br />\nOP_EQ,/</em>\tA B C\tif ((RK(B) == RK©) ~= A) then pc++\t\t<em>/<br />\nOP_LT,/</em>\tA B C\tif ((RK(B) &lt;  RK©) ~= A) then pc++\t\t<em>/<br />\nOP_LE,/</em>\tA B C\tif ((RK(B) &lt;= RK©) ~= A) then pc++\t\t*/</p>\n<p>OP_TEST,/*\tA C\tif not (R(A) &lt;=&gt; C) then pc++\t\t\t<em>/<br />\nOP_TESTSET,/</em>\tA B C\tif (R(B) &lt;=&gt; C) then R(A) := R(B) else pc++\t*/</p>\n<p>OP_CALL,/*\tA B C\tR(A), … ,R(A+C-2) := R(A)(R(A+1), … ,R(A+B-1)) <em>/<br />\nOP_TAILCALL,/</em>\tA B C\treturn R(A)(R(A+1), … ,R(A+B-1))\t\t<em>/<br />\nOP_RETURN,/</em>\tA B\treturn R(A), … ,R(A+B-2)\t(see note)\t*/</p>\n<p>OP_FORLOOP,/*\tA sBx\tR(A)+=R(A+2);<br />\nif R(A) &lt;?= R(A+1) then &#123; pc+=sBx; R(A+3)=R(A) &#125;<em>/<br />\nOP_FORPREP,/</em>\tA sBx\tR(A)-=R(A+2); pc+=sBx\t\t\t\t*/</p>\n<p>OP_TFORCALL,/*\tA C\tR(A+3), … ,R(A+2+C) := R(A)(R(A+1), R(A+2));\t<em>/<br />\nOP_TFORLOOP,/</em>\tA sBx\tif R(A+1) ~= nil then &#123; R(A)=R(A+1); pc += sBx &#125;*/</p>\n<p>OP_SETLIST,/*\tA B C\tR(A)[(C-1)*FPF+i] := R(A+i), 1 &lt;= i &lt;= B\t*/</p>\n<p>OP_CLOSURE,/*\tA Bx\tR(A) := closure(KPROTO[Bx])\t\t\t*/</p>\n<p>OP_VARARG,/*\tA B\tR(A), R(A+1), …, R(A+B-2) = vararg\t\t*/</p>\n<p>OP_EXTRAARG/*\tAx\textra (larger) argument for previous opcode\t*/<br />\n</code></pre></div></div></p>\n","text":" lua字节码 字节码格式 源码案例： 对应字节码： 指令解释： 指令分类 所有指令 lua字节码 lua虚拟机最终执行的是经过lua编译器编译的字节码，这里暂不关系Chunk生成字节码过程， 只关系字节码本身，字节码的格式到底是什么样？具体的含义是什么？ 字节码格式 lua字节...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lua%E5%AD%97%E8%8A%82%E7%A0%81\"><span class=\"toc-text\">lua字节码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">字节码格式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">源码案例：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E5%BA%94%E5%AD%97%E8%8A%82%E7%A0%81\"><span class=\"toc-text\">对应字节码：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E8%A7%A3%E9%87%8A\"><span class=\"toc-text\">指令解释：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">指令分类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%80%E6%9C%89%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">所有指令</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua入门教程：协程","uid":"232cd6ffbc023c95e155925cdcdc79a4","slug":"zl/2016-01-01-165_Lua入门教程：协程","date":"2024-04-03T03:47:33.053Z","updated":"2024-04-03T03:47:33.053Z","comments":true,"path":"api/articles/zl/2016-01-01-165_Lua入门教程：协程.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"从多线程的角度来看，协程（coroutine）与线程（thread）类似：协程时一系列的可执行语句，拥有自己的栈、局部变量和指令指针，同时协程又与其他协程共享全局变量和其他几乎一切资源。 协程与线程的主要区别在于，一个多线程程序可以并行运行多个线程，而协程则需要彼此协作运行，即在...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"golua虚拟机的使用_linux 应用_黑光技术","uid":"e4e3a037cf04e3d0b6725beb21862025","slug":"zl/2016-01-01-164_golua虚拟机的使用_linux 应用_黑光技术","date":"2024-04-03T03:47:33.053Z","updated":"2024-04-03T03:47:33.053Z","comments":true,"path":"api/articles/zl/2016-01-01-164_golua虚拟机的使用_linux 应用_黑光技术.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;/div&gt; &lt;div class=&quot;article_content&quot;&gt; &lt;p&gt;&lt;/p&gt;&lt;h1&gt;前言&lt;/h1&gt; ​ 之前一直想把openflow这样的分布式流程系统做起来，但是时间和应用...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}