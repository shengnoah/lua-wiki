{"title":"cocos2dx lua 闭包(匿名函数)入门实战","uid":"3a6e858fce4d017b7e8aa41a71c3f0de","slug":"zl/2016-01-01-393_cocos2dx lua 闭包(匿名函数)入门实战","date":"2024-04-03T03:47:35.683Z","updated":"2024-04-03T03:47:35.684Z","comments":true,"path":"api/articles/zl/2016-01-01-393_cocos2dx lua 闭包(匿名函数)入门实战.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>本文首先通过具体的例子讲解了Lua中闭包的概念，然后总结了闭包的应用场合，最后探讨了Lua中闭包的实现原理。</p>\n<blockquote>\n<p>闭包的概念</p>\n<blockquote>\n<p>在Lua中，闭包（closure）是由一个函数和该函数会访问到的非局部变量（或者是upvalue）组成的，其中非局部变量（non-local variable）是指不是在局部作用范围内定义的一个变量，但同时又不是一个全局变量，主要应用在嵌套函数和匿名函数里，因此若一个闭包没有会访问的非局部变量，那么它就是通常说的函数。也就是说，在Lua中，函数是闭包一种特殊情况。</p>\n</blockquote>\n</blockquote>\n<p>不知道c++的lambda和lua的闭包是谁先谁后，不过就我来说，是先学了c++，最近才接触到现代lua。因此把一切向c++看齐，会不自觉地把一切和c++做对比。</p>\n<p>就闭包来说，不就是c++的lambda嘛！</p>\n<p>前面所说的upvalue，也就是一开始按引用捕获，在变量退出生命期时，拷贝到Functor的成员变量里来，变成了按值捕获。这算是解释性语言特有的灵活性吧，变量可以在运行时按解释器的便利来移动位置，而不必像苦哈哈的编译性语言，一旦决定好位置，就无法移动了。</p>\n<blockquote>\n<p>在Lua的C API中，所有关于Lua中的函数的核心API都是以closure来命名的，也可视为这一观点的延续。在Lua中，函数是一种第一类型值（First-Class Value），它们具有特定的词法域（Lexical Scoping）。</p>\n</blockquote>\n<ul>\n<li>Lua使用结构体upvalue来实现闭包。外面的局部变量可以直接通过upvalue进行访问。</li>\n<li>upvalue最开始的时候指向栈中的一个变量，此时这个变量还在它的生存周期内。</li>\n<li>当变量离开作用域（译者注：就是函数返回后，变量的生存周期结束时），这个变量就从栈转移到了upvalue中。</li>\n<li>虽然这个变量存储在upvalue中，但是访问这个变量还是间接通过upvalue中的一个指针进行的（译者注：和在栈中时候的访问方式一样）。</li>\n<li>因此，变量位置的转移对任何试图读写这个变量的代码都是透明的。</li>\n<li>有别于这个变量在一个函数内部时候的行为，函数声明、访问这个变量，就是直接对栈的操作。</li>\n</ul>\n<p>看下具体例子：</p>\n<pre><code>function f1(n)\n--函数参数n也是局部变量\nlocal function f2()\nprint(n)   --引用外部函数的局部变量\nend\nreturn f2\nend\ng1 = f1(2015)\ng1() -- 打印出2015\n<p>g2 = f1(2016)<br />\ng2() – 打印出2016<br />\n</code></pre><p>这里的n就是upvalue。upvalue实际指的是变量而不是值，这些变量可以在内部函数之间共享，即upvalue提供一种闭包之间共享数据的方法，</p></p>\n<p>再看个例子：</p>\n<pre><code>function Create(n)\nlocal function foo1()\nprint(n)\nend\nlocal function foo2()\nn = n + 10\nend\nreturn foo1,foo2\nend\n<p>f1,f2 = Create(2015)<br />\nf1() – 打印2015</p>\n<p>f2()<br />\nf1() – 打印2025</p>\n<p>f2()<br />\nf1() – 打印2035<br />\n</code></pre><p>上面的例子中，闭包f1和f2共享同一个upvalue了，这是因为当Lua发现两个闭包的upvalue指向的是当前堆栈上的相同变量时，会聪明地只生成一个拷贝，然后让这两个闭包共享该拷贝，这样任一个闭包对该upvalue进行修改都会被另一个探知。</p></p>\n<ul>\n<li>为什么会这样，我们看下面的解释：<ul>\n<li>通过为每个变量最多创建一个upvalue并按需要重复利用这个upvalue，保证了未决状态（未超过生命周期）的局部变量（pending vars）能够在闭包之间正确地共享。</li>\n<li>为了保证这种唯一性，Lua维护这一条链表，该链表中每个节点对应一个打开的upvalue（opend upvalue）结构，打开的upvalue是指当前正指向栈局部变量的upvalue，如上图的未决状态的局部变量链表（the pending vars list）。</li>\n<li>当Lua创建一个新的闭包时，Lua会遍历当前函数所有的外部的局部变量，对于每一个外部的局部变量，若在上面的链表中能找到该变量，则重复使用该打开的upvalue，否则，Lua会创建一个新的打开的upvalue，并把它插入链表中。</li>\n<li>当局部变量离开作用域时（即超过变量生命周期），这个打开的upvalue就会变成关闭的upvalue（closed upvalue），并把它从链表中删除，一旦某个关闭的upvalue不再被任何闭包所引用，那么它的存储空间就会被回收。</li>\n</ul>\n</li>\n</ul>\n<p>最后看下闭包的应用。</p>\n<p>闭包最常用的一个应用就是实现迭代器。所谓迭代器就是一种可以遍历一种集合中所谓元素的机制。每个迭代器都需要在每次成功调用之间保持一些状态，这样才能知道它所在的位置及如何进到下一个位置。闭包刚好适合这种场景。比如下面的代码：</p>\n<pre><code>function values(t)\nlocal i = 0\nreturn function () i = i + 1 return t[i] end\nend\n<p>t = &#123;10, 20, 30&#125;</p>\n<p>iter = values(t)<br />\nwhile true do<br />\nlocal element = iter()<br />\nif element == nil then break end<br />\nprint(element)<br />\nend<br />\n</code></pre><p>总结下lua闭包，关键点是upvalue，然后注意下如何申明一个背包，函数（A）里面返回的是函数（B），B引用了A的局部变量。</p></p>\n","text":"本文首先通过具体的例子讲解了Lua中闭包的概念，然后总结了闭包的应用场合，最后探讨了Lua中闭包的实现原理。 闭包的概念 在Lua中，闭包（closure）是由一个函数和该函数会访问到的非局部变量（或者是upvalue）组成的，其中非局部变量（non-local variable...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua类机制","uid":"06e23d8cbe40b86c0fe447e69c088be2","slug":"zl/2016-01-01-392_lua类机制","date":"2024-04-03T03:47:35.683Z","updated":"2024-04-03T03:47:35.683Z","comments":true,"path":"api/articles/zl/2016-01-01-392_lua类机制.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"lua类机制的简易实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"PIL.9Lua中的闭包","uid":"66065dc59985b4408d9fe81f872d389b","slug":"zl/2016-01-01-390_PIL.9Lua中的闭包","date":"2024-04-03T03:47:35.678Z","updated":"2024-04-03T03:47:35.683Z","comments":true,"path":"api/articles/zl/2016-01-01-390_PIL.9Lua中的闭包.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua中的函数是 第一类的值加上合适的词法域。那么，函数是第一类值意味着什么呢？这是说，在Lua中，一个函数，就是一个和 数字或字符串一样具有某些权限的值。一个程序可以把函数存储在变量中（全局或者局部都可以）和表中，把函数作为参数传递给其他函数，或者以函数作为值返回。 函数具有词...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}