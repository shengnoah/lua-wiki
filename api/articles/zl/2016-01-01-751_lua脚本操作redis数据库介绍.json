{"title":"lua脚本操作redis数据库介绍","uid":"2e7e7b57997168e59f14cfb535f20397","slug":"zl/2016-01-01-751_lua脚本操作redis数据库介绍","date":"2024-04-03T03:47:35.999Z","updated":"2024-04-03T03:47:35.999Z","comments":true,"path":"api/articles/zl/2016-01-01-751_lua脚本操作redis数据库介绍.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p> 为什么要用lua脚本操作redis数据库?<br/>1.减少开销—减少向redis服务器的请求次数<br/>2.原子操作—redis将lua脚本作为一个原子执行<br/>3.可复用—其他客户端可以使用已经执行过的lua脚本<br/>4.增加redis灵活性—lua脚本可以帮助redis做更多的事情</p>\n<p>lua脚本本身体积小,启动速度快.</p>\n<p>因此,从redis 2.6.0开始,redis在服务器端内置lua解释器<br/></p>\n<h2 id=\"EVAL命令语法\"><a href=\"#EVAL命令语法\" class=\"headerlink\" title=\"EVAL命令语法\"></a>EVAL命令语法</h2><p>EVAL script numkeys key [key …] arg [arg …]</p>\n<p>EVAL  —-lua程序的运行环境上下文<br/>script   —-lua脚本<br/>numkeys —-参数的个数(key的个数)<br/>key  —-redis键   访问下标从1开始,例如:KEYS[1]<br/>arg  —-redis键的附加参数</p>\n<h3 id=\"lua脚本\"><a href=\"#lua脚本\" class=\"headerlink\" title=\"lua脚本\"></a>lua脚本</h3><p>EVAL和EVALSHA用redis内置的lua编译器执行脚本<br/>举例说明:<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">127.0.0.1:6379&gt; eval &#34;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&#34; 2 username password test 123456</div><div class=\"line\">1) &#34;username&#34;</div><div class=\"line\">2) &#34;password&#34;</div><div class=\"line\">3) &#34;test&#34;</div><div class=\"line\">4) &#34;123456&#34;</div><div class=\"line\">127.0.0.1:6379&gt;</div></pre></td></tr></tbody></table></figure><p></p>\n<p>上面lua脚本的意思是返回以lua数组的形式返回key1,key2和value1,value2,2是key的个数.</p>\n<h3 id=\"lua函数\"><a href=\"#lua函数\" class=\"headerlink\" title=\"lua函数\"></a>lua函数</h3><p>主要有两个函数来执行redis命令<br/>redis.call()   —  出错时返回具体错误信息,并且终止脚本执行<br/>redis.pcall()  —出错时返回lua  table的包装错误,但不引发错误<br/>举例说明:</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">127.0.0.1:6379&gt; eval &#34;return redis.call(&#39;set&#39;,KEYS[1],ARGV[1])&#34; 1 name  redis</div><div class=\"line\">OK</div><div class=\"line\">127.0.0.1:6379&gt;</div></pre></td></tr></tbody></table></figure>\n<p>该脚本中的函数作用是类似于执行  set  name redis   的redis命令.并返回执行结果,ok</p>\n<p>redis.call()出错时:<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">127.0.0.1:6379&gt; eval &#34;return redis.call(&#39;get&#39;,KEYS[1],ARGV[1])&#34; 1 name  redis</div><div class=\"line\">(error) ERR Error running script (call to f_b943d620b079a29d99eccaaa7317e05f8eb8ce88): @user_script:1: @user_script: 1: Wrong number of args calling Redis command From Lua script </div><div class=\"line\">127.0.0.1:6379&gt;</div></pre></td></tr></tbody></table></figure><p></p>\n<p>redis.pcall()出错时:<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">127.0.0.1:6379&gt; eval &#34;return redis.pcall(&#39;get&#39;,KEYS[1],ARGV[1])&#34; 1 name  redis</div><div class=\"line\">(error) @user_script: 1: Wrong number of args calling Redis command From Lua script</div><div class=\"line\">127.0.0.1:6379&gt;</div></pre></td></tr></tbody></table></figure><p></p>\n<h2 id=\"lua与redis数据类型转换\"><a href=\"#lua与redis数据类型转换\" class=\"headerlink\" title=\"lua与redis数据类型转换\"></a>lua与redis数据类型转换</h2><p>lua通过redis.call()或者redis.pcall()函数执行redis命令的返回值被转换成了lua数据结构,当然了,当lua脚本在redis的内置解释器里运行时,lua脚本的返回值也会被转换成redis数据结构,然后由EVAL将值返回给客户端.</p>\n<p>那么lua和redis数据类型之间时如何转换的呢?对应关系又是怎样的呢?</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>redis数据类型</th>\n<th>lua数据类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>integer</td>\n<td>number</td>\n</tr>\n<tr>\n<td>bulk</td>\n<td>string</td>\n</tr>\n<tr>\n<td>multi bulk</td>\n<td>table</td>\n</tr>\n<tr>\n<td>status</td>\n<td>包含ok域的table</td>\n</tr>\n<tr>\n<td>error</td>\n<td>包含err域的table</td>\n</tr>\n<tr>\n<td>nil bulk</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>从redis数据类型到lua数据类型或者从lua数据类型到redis数据类型,都有以上对应规则,但是从</p>\n<p><em>从lua转换到redis有一条额外的对应规则</em></p>\n<ul>\n<li>lua boolean  true   —&gt;   redis   1<br/>即,lua的true对应redis 的整型1.</li>\n</ul>\n<h2 id=\"EVAL和EVALSHA\"><a href=\"#EVAL和EVALSHA\" class=\"headerlink\" title=\"EVAL和EVALSHA\"></a>EVAL和EVALSHA</h2><p>EVAL命令在每次执行脚本时,都发送一次脚本主体,而EVALSHA并非如此,它的第一个参数时脚本的sha1校验和.</p>\n<p>EVALSHA命令的机制如下:</p>\n<ul>\n<li>如果服务器记得SHA1校验和指定的脚本,那么执行该脚本</li>\n<li>如果服务器不记得SHA1校验和指定的脚本,那么它返回一个错误,提醒用户使用EVAl代替EVALSHA</li>\n</ul>\n<p>因此在脚本主体不变的情况下使用EVALSHA,可以使脚本复用,而<strong>节省带宽</strong></p>\n<h2 id=\"lua脚本要求\"><a href=\"#lua脚本要求\" class=\"headerlink\" title=\"lua脚本要求\"></a>lua脚本要求</h2><p><strong>脚本需要被写成纯函数</strong></p>\n<p> 对于同样的数据输入,给定相同的参数,脚本执行的redis写命令的结果总是相同的.<br/>为此,redis做了以下事情:</p>\n<ul>\n<li>lua没有访问系统时间或者其他内部状态的命令</li>\n<li>redis阻止上面所提到的脚本执行</li>\n<li>lua脚本调用返回序命令的返回数据会被排序(字典序.)</li>\n<li>对 Lua 的伪随机数生成函数 math.random 和 math.randomseed 进行修改，使得每次在运行新脚本的时候，总是拥有同样的 seed 值.</li>\n</ul>\n<p><strong>不允许创建全局变量</strong></p>\n<p>为了防止数据泄露进lua环境,redis脚本不循序创建全局变量.</p>\n<p>访问一个全局变量(无论是否存在)都会引起脚本停止</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>使用lua操作redis数据库能够带来很多便利,后续将提供实例展示lua脚本是如何操作redis数据库的.</p>","text":"前言 为什么要用lua脚本操作redis数据库?1.减少开销—减少向redis服务器的请求次数2.原子操作—redis将lua脚本作为一个原子执行3.可复用—其他客户端可以使用已经执行过的lua脚本4.增加redis灵活性—lua脚本可以帮助redis做更多的事情 lua脚本本身...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EVAL%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">EVAL命令语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#lua%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">lua脚本</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#lua%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">lua函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lua%E4%B8%8Eredis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">lua与redis数据类型转换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EVAL%E5%92%8CEVALSHA\"><span class=\"toc-text\">EVAL和EVALSHA</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lua%E8%84%9A%E6%9C%AC%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">lua脚本要求</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua入门教程：元表与元方法","uid":"64f9ed342e14e866e9e527ca6ae2582c","slug":"zl/2016-01-01-754_Lua入门教程：元表与元方法","date":"2024-04-03T03:47:36.000Z","updated":"2024-04-03T03:47:36.002Z","comments":true,"path":"api/articles/zl/2016-01-01-754_Lua入门教程：元表与元方法.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua 语言中每中类型的值都有一套可预见的操作集合，比如可以将数字相加，将字符串连接，还可以在表中插入键值对。但我们却无法直接将两个表相加，无法对表进行直接比较，除非我们使用元表。元表可以修改一个值在面对未知操作时的行为。例如，我们对两个表 a 和 b 执行 a + b 操作，L...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua 排序算法","uid":"18c65ae79c1521b9ec150d64b8237a42","slug":"zl/2016-01-01-752_Lua 排序算法 ","date":"2024-04-03T03:47:35.999Z","updated":"2024-04-03T03:47:36.000Z","comments":true,"path":"api/articles/zl/2016-01-01-752_Lua 排序算法 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经...","link":"","photos":[],"count_time":{"symbolsCount":883,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}