{"title":"Lua之 loadfile ,dofile, loadstring，require","uid":"f40c013476c88f6f6476f708dff98be8","slug":"zl/2016-01-01-637_Lua之 loadfile ,dofile, loadstring，require","date":"2024-04-03T03:47:35.861Z","updated":"2024-04-03T03:47:35.861Z","comments":true,"path":"api/articles/zl/2016-01-01-637_Lua之 loadfile ,dofile, loadstring，require.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<script src=\"/assets/js/DPlayer.min.js\"> </script><script src=\"/assets/js/APlayer.min.js\"> </script><hr/>\n<h3 id=\"loadfile——只编译，不运行\"><a href=\"#loadfile——只编译，不运行\" class=\"headerlink\" title=\"loadfile——只编译，不运行\"></a>loadfile——只编译，不运行</h3><pre><code>1.功能：载入文件但不执行代码块，对于相同的文件每次都会执行。只是编译代码，然后将编译结果作为一个函数返回\n2.调用：loadfile(&#34;filename&#34;)\n3.错误处理：不引发错误，只返回错误值但不处理错误,即返回nil和错误消息\n4.优点：调用一次之后可以多次调用返回的结果（即函数），\n  即“多次调用”只需编译一次（注：这里的多次调用   是指多次调用返回的函数，而不是多次调用loadfile）\n</code></pre>\n<p><strong>dofile可如下定义：</strong><br/></p><figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(filename)</span></span></div><div class=\"line\">　　<span class=\"keyword\">local</span> f = <span class=\"built_in\">assert</span>(<span class=\"built_in\">loadfile</span>(filename)) </div><div class=\"line\"><span class=\"keyword\">return</span> f()</div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></tbody></table></figure><p></p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">注：加载了程序块并没有定义其中的函数。在Lua中，函数定义是一种赋值操作，是在运行时才完成的操作。</div><div class=\"line\">例如：一个文件test.lua中有一个函数 function foo(x) print(x) end ,执行如下代码：</div><div class=\"line\">　　　f = loadfile(test.lua) --加载程序块，此时还没有定义函数foo</div><div class=\"line\">　　　f() --运行加载的程序块，此时就定义了函数foo</div><div class=\"line\">     foo(&#34;hello lua&#34;) --&gt;hello lua --经过上面的步骤才能调用foo</div></pre></td></tr></tbody></table></figure>\n<h3 id=\"dofile——执行\"><a href=\"#dofile——执行\" class=\"headerlink\" title=\"dofile——执行\"></a>dofile——执行</h3><pre><code>1.功能：载入文件并执行代码块，对于相同的文件每次都会执行\n2.调用：dofile(&#34;filename&#34;)\n3.错误处理：如果代码块中有错误则会引发错误\n4.优点：对简单任务而言，非常便捷\n5.缺点：每次载入文件时都会执行程序块\n6.定位：内置操作，辅助函数\n</code></pre><h3 id=\"require——我只执行一次\"><a href=\"#require——我只执行一次\" class=\"headerlink\" title=\"require——我只执行一次\"></a>require——我只执行一次</h3><pre><code>require和dofile有点像，不过又很不一样，require在第一次加载文件的时候，会执行里面的代码。\n但是，第二次之后，再次加载文件，则不会重复执行了。换句话说，它会保存已经加载过的文件，不会重复加载。\n</code></pre><h3 id=\"loadstring\"><a href=\"#loadstring\" class=\"headerlink\" title=\"loadstring\"></a>loadstring</h3><pre><code>1.特点：功能强大，但开销大；\n2.典型用处：执行外部代码，如：用户的输入\n3.错误错里：代码中如果有语法错误就会返回nil\n4.理解：f = loadstring(&#34;i = i+1&#34;)  可理解为（但不完全是）f = function()  i = i+1  end \n(注：这里的变量&#34;i&#34;是全局变量，不是指局部变量，如果没有定义全局变量&#34;i&#34;,调用f()则会报错！，即loadstring   不涉及词法域)\n</code></pre>","text":" loadfile——只编译，不运行1.功能：载入文件但不执行代码块，对于相同的文件每次都会执行。只是编译代码，然后将编译结果作为一个函数返回 2.调用：loadfile(&#34;filename&#34;) 3.错误处理：不引发错误，只返回错误值但不处理错误,即返回nil和错...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#loadfile%E2%80%94%E2%80%94%E5%8F%AA%E7%BC%96%E8%AF%91%EF%BC%8C%E4%B8%8D%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">loadfile——只编译，不运行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#dofile%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">dofile——执行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#require%E2%80%94%E2%80%94%E6%88%91%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1\"><span class=\"toc-text\">require——我只执行一次</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#loadstring\"><span class=\"toc-text\">loadstring</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"SLua for Unity简要技术原理","uid":"a8f379394d3cb6faff62e23fa8836f70","slug":"zl/2016-01-01-636_SLua for Unity简要技术原理","date":"2024-04-03T03:47:35.861Z","updated":"2024-04-03T03:47:35.861Z","comments":true,"path":"api/articles/zl/2016-01-01-636_SLua for Unity简要技术原理.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"动态更新对于游戏来说非常重要，它可以极大缩短bug修复、新功能添加的时间成本，同时强制版本更新造成的用户流失也是一大痛点。对于Unity游戏开发者来说，Slua是一个不错的选择。 这里简要介绍一下Slua的技术原理，Slua Github的项目主页好像没有提及，一些关键代码看起来...","link":"","photos":[],"count_time":{"symbolsCount":223,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua C API 教程","uid":"908a0f416a79b3abf4106994c55b122c","slug":"zl/2016-01-01-638_Lua C API 教程 ","date":"2024-04-03T03:47:35.861Z","updated":"2024-04-03T03:47:35.862Z","comments":true,"path":"api/articles/zl/2016-01-01-638_Lua C API 教程 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"前一篇文章介绍了怎么从 C 程序中调用 Lua 代码。但内容并没有深入，还有很多东西需要反复去尝试，并且需要通过 Lua 辅助来调用 C 程序。 本章将着重介绍如何继续扩展你的 Lua 程序 - 在Lua中调用C函数。 剖析一个 Lua 程序对 C 的调用从 Lua 的角度来看，...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}