{"title":"lua读取redis数据的null判断","uid":"f3a7845e6db0af3e539b51ace62eadf8","slug":"zl/2016-01-01-712_lua读取redis数据的null判断","date":"2024-04-03T03:47:35.946Z","updated":"2024-04-03T03:47:35.946Z","comments":true,"path":"api/articles/zl/2016-01-01-712_lua读取redis数据的null判断.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>最近在配合移动端调试的时候，被抓去debug一个在清除redis缓存之后才会出现的网关错误。于是打开服务器上的log定位到类似错误:</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">[error] 7#7: *12030 lua entry thread aborted: runtime error: /data/share/apps/lua/access_check.lua:133: bad argument #1 to &#39;decode&#39; (string expected, got userdata)</span><br/></pre></td></tr></tbody></table></figure>\n<p>该段代码的主要作用是在<code>openresty</code>中<code>lua</code>读取<code>redis</code>中数据并解码为<code>json</code>：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> access_token = redis_client:read_by_key(token_key)</span><br/><span class=\"line\">   <span class=\"keyword\">if</span> access_token == <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br/><span class=\"line\">       </span><br/><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br/><span class=\"line\">   <span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">   <span class=\"keyword\">local</span> obj_token = cjson.decode(access_token)</span><br/><span class=\"line\">   <span class=\"comment\">-- do something</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>通过查询资料得知原因：<strong><code>lua</code>读取<code>redis</code>数据返回结果为空时，返回的结果不是<code>nil</code>而是<code>userdata</code>类型的<code>ngx.null</code>。</strong></p>\n<hr/>\n<h4 id=\"为什么要这么设计？\"><a href=\"#为什么要这么设计？\" class=\"headerlink\" title=\"为什么要这么设计？\"></a><a href=\"https://github.com/openresty/lua-resty-redis/issues/90\" target=\"_blank\" rel=\"noopener noreferrer\">为什么要这么设计？</a></h4><blockquote>\n<p>因为<code>nil</code>在<code>lua</code>中有特殊的意义，如果一个变量被设置为<code>nil</code>相当于告知该变量<code>未定义</code>(不存在)一样，如果把<code>redis</code>查询的结果为空设置为<code>nil</code>，而该查询的<code>key</code>对应在<code>redis</code>中又是存在的，就无法把<code>查询为空</code>和<code>未定义</code>区分开来了，这样显然是不合理的。所以必须使用一个<code>userdata</code>类型的值来表示这个查询记录为空，但是又不等同于<code>未定义变量</code>（ngx.null)。</p>\n</blockquote>\n<hr/>\n<p>因此，代码做如下修改即可:</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> access_token = redis_client:read_by_key(token_key)</span><br/><span class=\"line\">   <span class=\"keyword\">if</span> access_token == ngx.null <span class=\"keyword\">or</span> access_token == <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br/><span class=\"line\">       </span><br/><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br/><span class=\"line\">   <span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">   <span class=\"keyword\">local</span> obj_token = cjson.decode(access_token)</span><br/><span class=\"line\">   <span class=\"comment\">-- do something</span></span><br/></pre></td></tr></tbody></table></figure>","text":"最近在配合移动端调试的时候，被抓去debug一个在清除redis缓存之后才会出现的网关错误。于是打开服务器上的log定位到类似错误: 1[error] 7#7: *12030 lua entry thread aborted: runtime error: /data/share...","link":"","photos":[],"count_time":{"symbolsCount":964,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E8%AE%BE%E8%AE%A1%EF%BC%9F\"><span class=\"toc-text\">为什么要这么设计？</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"十七、考虑使用Lazy evaluation(缓式评估)","uid":"32bd7dd57d3e1030842c4b81dd5b8aea","slug":"zl/2016-01-01-714_十七、考虑使用Lazy evaluation(缓式评估)","date":"2024-04-03T03:47:35.946Z","updated":"2024-04-03T03:47:35.947Z","comments":true,"path":"api/articles/zl/2016-01-01-714_十七、考虑使用Lazy evaluation(缓式评估).json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"从效率上看，最好的运算是从未执行过的运算。 拖延战术——缓式评估 在真正需要之前，不必急着为某物做一个副本，取而代之的是以拖延战术的方式——只要能够，就是使用其它副本 二、区分读和写 运用lazy evaluation和proxy classes（条款30），可以延迟决定读还是写...","link":"","photos":[],"count_time":{"symbolsCount":742,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua Module 实践 · Pan's paper","uid":"c28313c3ad519923794454007fb8295e","slug":"zl/2016-01-01-711_Lua Module 实践 · Pan's paper","date":"2024-04-03T03:47:35.945Z","updated":"2024-04-03T03:47:35.946Z","comments":true,"path":"api/articles/zl/2016-01-01-711_Lua Module 实践 · Pan's paper.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"最近用openresty写接口，每个接口都要要链接数据库，写一个通用的模块来实现，顺便学习下lua module的相关知识。 lua 模块Lua中的一个模块就是一个table，table元素包括变量，函数等。“因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}