{"title":"lua垃圾回收","uid":"6adcbbf2d5603d93d3c2fd5b3bbe5fbd","slug":"zl/2016-01-01-22_lua垃圾回收","date":"2024-04-03T03:47:33.100Z","updated":"2024-04-03T03:47:33.100Z","comments":true,"path":"api/articles/zl/2016-01-01-22_lua垃圾回收.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>采用垃圾回收机制对所有的lua对象(GCObject)进行管理。Lua虚拟机会定期运行GC，释放掉已经不再被被引用到的lua对象。</p>\n<p>基本算法【标记清除】</p>\n<p>基本的垃圾回收算法被称为”mark-and-sweep”算法。算法本身其实很简单。</p>\n<p>1.系统管理着所有已经创建了的对象。每个对象都有对其他对象的引用。</p>\n<p>2.root集合代表着已知的系统级别的对象引用。</p>\n<p>3.从root集合出发，就可以访问到系统引用到的所有对象。而没有被访问到的对象就是垃圾对象，需要被销毁。</p>\n<p>我们可以将所有对象分成三个状态：</p>\n<ol>\n<li>White状态，也就是待访问状态。表示对象还没有被垃圾回收的标记过程访问到。</li>\n<li>Gray状态，也就是待扫描状态。表示对象已经被垃圾回收访问到了，但是对象本身对于其他对象的引用还没有进行遍历访问。</li>\n<li>Black状态，也就是已扫描状态。表示对象已经被访问到了，并且也已经遍历了对象本身对其他对象的引用。</li>\n</ol>\n<p>基本的算法可以描述如下：</p>\n<ol>\n<li>当前所有对象都是White状态;  </li>\n<li>将root集合引用到的对象从White设置成Gray，并放到Gray集合中;  </li>\n<li>while(Gray集合不为空)  </li>\n<li>{  </li>\n<li>​    从Gray集合中移除一个对象O，并将O设置成Black状态;  </li>\n<li>​    for(O中每一个引用到的对象O1) {  </li>\n<li>​        if(O1在White状态) {  </li>\n<li>​            将O1从White设置成Gray，并放到到Gray集合中；  </li>\n<li>​        }  </li>\n<li>​    }  </li>\n<li>}  </li>\n<li>for(任意一个对象O){  </li>\n<li>​    if(O在White状态)  </li>\n<li>​        销毁对象O;  </li>\n<li>​    else  </li>\n<li>​        将O设置成White状态;  </li>\n<li>}  </li>\n</ol>\n<p>Incremental Garbage Collection</p>\n<p>上面的算法如果一次性执行，在对象很多的情况下，会执行很长时间，严重影响程序本身的响应速度。其中一个解决办法就是，可以将上面的算法分步执行，这样每个步骤所耗费的时间就比较小了。我们可以将上述算法改为以下下几个步骤。</p>\n<p>首先标识所有的root对象：</p>\n<ol>\n<li>当前所有对象都是White状态;  </li>\n<li>将root集合引用到的对象从White设置成Gray，并放到Gray集合中;  </li>\n</ol>\n<p>遍历访问所有的gray对象。如果超出了本次计算量上限，退出等待下一次遍历:</p>\n<ol>\n<li>while(Gray集合不为空,并且没有超过本次计算量的上限){  </li>\n<li>​    从Gray集合中移除一个对象O，并将O设置成Black状态;  </li>\n<li>​    for(O中每一个引用到的对象O1) {  </li>\n<li>​        if(O1在White状态) {  </li>\n<li>​            将O1从White设置成Gray，并放到到Gray集合中；  </li>\n<li>​        }  </li>\n<li>​    }  </li>\n<li>}  </li>\n</ol>\n<p>销毁垃圾对象：</p>\n<ol>\n<li>for(任意一个对象O){  </li>\n<li>​    if(O在White状态)  </li>\n<li>​        销毁对象O;  </li>\n<li>​    else  </li>\n<li>​        将O设置成White状态;  </li>\n<li>}  </li>\n</ol>\n<p>在每个步骤之间，由于程序可以正常执行，所以会破坏当前对象之间的引用关系。black对象表示已经被扫描的对象，所以他应该不可能引用到一个white对象。当程序的改变使得一个black对象引用到一个white对象时，就会造成错误。解决这个问题的办法就是设置barrier。barrier在程序正常运行过程中，监控所有的引用改变。如果一个black对象需要引用一个white对象，存在两种处理办法：</p>\n<ol>\n<li>将white对象设置成gray，并添加到gray列表中等待扫描。这样等于帮助整个GC的标识过程向前推进了一步。</li>\n<li>将black对象该回成gray，并添加到gray列表中等待扫描。这样等于使整个GC的标识过程后退了一步。</li>\n</ol>\n<p>这种垃圾回收方式被称为”Incremental Garbage Collection”(简称为”IGC”，Lua所采用的就是这种方法。使用”IGC”并不是没有代价的。IGC所检测出来的垃圾对象集合比实际的集合要小，也就是说，有些在GC过程中变成垃圾的对象，有可能在本轮GC中检测不到。不过，这些残余的垃圾对象一定会在下一轮GC被检测出来，不会造成泄露。</p>","text":"采用垃圾回收机制对所有的lua对象(GCObject)进行管理。Lua虚拟机会定期运行GC，释放掉已经不再被被引用到的lua对象。 基本算法【标记清除】 基本的垃圾回收算法被称为”mark-and-sweep”算法。算法本身其实很简单。 1.系统管理着所有已经创建了的对象。每个对...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 排序算法","uid":"18c65ae79c1521b9ec150d64b8237a42","slug":"zl/2016-01-01-229_Lua 排序算法 ","date":"2024-04-03T03:47:33.100Z","updated":"2024-04-03T03:47:33.100Z","comments":true,"path":"api/articles/zl/2016-01-01-229_Lua 排序算法 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&...","link":"","photos":[],"count_time":{"symbolsCount":917,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua和C#交互","uid":"53e30d434ce1eee1be8eac653667cc03","slug":"zl/2016-01-01-230_Lua和C#交互","date":"2024-04-03T03:47:33.100Z","updated":"2024-04-03T03:47:33.101Z","comments":true,"path":"api/articles/zl/2016-01-01-230_Lua和C#交互.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;项目中一直使用tolua框架，底层使用C#开发，逻辑使用lua开发。借助tolua的源码，研究一下lua与C#是如何互相调用的，然后自己写了个简单的demo作为记录。&lt;/p&gt; Demo里没有拿lua的源码编译，而是直接使用lua的静态库，将lua库...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}