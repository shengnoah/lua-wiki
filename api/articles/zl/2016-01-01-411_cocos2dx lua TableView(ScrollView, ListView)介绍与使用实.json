{"title":"cocos2dx lua TableView(ScrollView, ListView)介绍与使用实战","uid":"c693db45be4097337f085e0e5cc0d97d","slug":"zl/2016-01-01-411_cocos2dx lua TableView(ScrollView, ListView)介绍与使用实","date":"2024-04-03T03:47:35.700Z","updated":"2024-04-03T03:47:35.703Z","comments":true,"path":"api/articles/zl/2016-01-01-411_cocos2dx lua TableView(ScrollView, ListView)介绍与使用实.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>在众多移动应用中，能看到各式各样的列表/表格数据</p>\n<blockquote>\n<p>不管是iOS中的UITableView/UICollectionView/UIScrollView,还是Android中的ListView/CircleView，都是实际项目开发中使用最平凡，也是最重要的功能。</p>\n</blockquote>\n<p>为了用户考虑，也为了性能考虑， 我们一般都会重复利用所创建的列表项，这样就避免了界面卡顿。cocos2dx lua 3.x中有一个TabeView，效果和上面列举的那些做列表的一样，尤其与iOS中UITableView方法属性，使用方式都有很多相似的地方。</p>\n<blockquote>\n<p>游戏开发中，虽然没有和普通应用那么多列表，但是也会有些消息列表，用户，排行榜等，所以，这篇我们就来看看如何用TableView以及解决在实际开发中的一些问题。</p>\n</blockquote>\n<h3 id=\"TableView使用\"><a href=\"#TableView使用\" class=\"headerlink\" title=\"TableView使用\"></a>TableView使用</h3><p>直接上代码，这里我们使用cocos2dx lua提供TableView实现水平和垂直的列表，基本满足常见功能，具体细节，可以根据注释或者代码逻辑，结合实际需求进行调整和优化</p>\n<pre><code>local TableScene = class(&#34;TableScene&#34;)\nTableScene.__index = TableScene\n<p>–这里是为了让layer能调用TableViewTestLayer的方法<br />\nfunction TableScene.extend(target)<br />\nlocal t = tolua.getpeer(target)<br />\nif not t then<br />\nt = &#123;&#125;<br />\ntolua.setpeer(target, t)<br />\nend<br />\nsetmetatable(t, TableScene)<br />\nreturn target<br />\nend</p>\n<p>–滚动事件<br />\nfunction TableScene.scrollViewDidScroll(view)<br />\n–print(&quot;滚动事件&quot;)<br />\nend</p>\n<p>function TableScene.scrollViewDidZoom(view)<br />\nprint(&quot;scrollViewDidZoom&quot;)<br />\nend</p>\n<p>–cell点击事件<br />\nfunction TableScene.tableCellTouched(table,cell)<br />\nprint(&quot;点击了cell：&quot; … cell:getIdx())<br />\nend</p>\n<p>–cell的大小，注册事件就能直接影响界面，不需要主动调用<br />\nfunction TableScene.cellSizeForTable(table,idx)<br />\nreturn 150,150<br />\nend</p>\n<p>–显示出可视部分的界面，出了裁剪区域的cell就会被复用<br />\nfunction TableScene.tableCellAtIndex(table, idx)<br />\nlocal strValue = string.format(&quot;%d&quot;,idx)<br />\nprint(&quot;数据加载&quot;…strValue)<br />\nlocal cell = table:dequeueCell()<br />\nlocal label = nil<br />\nif nil == cell then<br />\nprint(&quot;创建了新的cell&quot;)<br />\ncell = cc.TableViewCell:new()</p>\n<pre><code>    --添加cell内容\n    local sprite = display.newSprite(&amp;#34;res/apple.png&amp;#34;)\n    sprite:setAnchorPoint(cc.p(0,0))\n    sprite:setPosition(cc.p(0, 0))\n    cell:addChild(sprite)\n\n    label = cc.Label:createWithSystemFont(strValue, &amp;#34;Helvetica&amp;#34;, 40)\n    label:setPosition(cc.p(0,0))\n    label:setAnchorPoint(cc.p(0,0))\n    label:setColor(cc.c3b(255,0,0))\n    label:setTag(123)\n    cell:addChild(label)\nelse\n    print(&amp;#34;使用已经创建过的cell&amp;#34;)\n    label = cell:getChildByTag(123)\n    if nil ~= label then\n        label:setString(strValue)\n    end\nend\n\nreturn cell\n</code></pre>\n<p>end</p>\n<p>–设置cell个数，注册就能生效，不用主动调用<br />\nfunction TableScene.numberOfCellsInTableView(table)<br />\nreturn 100<br />\nend</p>\n<p>function TableScene:init()</p>\n<pre><code>local visiableSize = cc.Director:getInstance():getVisibleSize()\nlocal origin = cc.Director:getInstance():getVisibleOrigin()\n\nlocal winSize = cc.Director:getInstance():getWinSize()\n\nlocal isVERTICAL = false\n\nif isVERTICAL then\n\n\n    -----------------------------------------------------------\n    --创建TableView\n    local tableView = cc.TableView:create(cc.size(winSize.width - 20,150))\n    --设置滚动方向  水平滚动\n    tableView:setDirection(cc.SCROLLVIEW_DIRECTION_HORIZONTAL)\n    tableView:setPosition(cc.p(10, winSize.height / 2))\n    tableView:setDelegate()\n    self:addChild(tableView)\n    --registerScriptHandler functions must be before the reloadData funtion\n    --注册脚本编写器函数必须在reloadData函数之前（有道自动翻译）\n\n    --cell个数\n    tableView:registerScriptHandler(TableScene.numberOfCellsInTableView,cc.NUMBER_OF_CELLS_IN_TABLEVIEW)\n    --滚动事件\n    tableView:registerScriptHandler(TableScene.scrollViewDidScroll,cc.SCROLLVIEW_SCRIPT_SCROLL)\n    tableView:registerScriptHandler(TableScene.scrollViewDidZoom,cc.SCROLLVIEW_SCRIPT_ZOOM)\n    --cell点击事件\n    tableView:registerScriptHandler(TableScene.tableCellTouched,cc.TABLECELL_TOUCHED)\n    --cell尺寸、大小\n    tableView:registerScriptHandler(TableScene.cellSizeForTable,cc.TABLECELL_SIZE_FOR_INDEX)\n    --显示出可视部分的cell\n    tableView:registerScriptHandler(TableScene.tableCellAtIndex,cc.TABLECELL_SIZE_AT_INDEX)\n    --调用这个才会显示界面\n    tableView:reloadData()\n    -----------------------------------------------------------\n\nelse\n\n    -----------------------------------------------------------\n    --跟上面差不多，这里是创建一个“垂直滚动”的TableView\n    tableView = cc.TableView:create(cc.size(200, winSize.height - 20))\n    tableView:setDirection(cc.SCROLLVIEW_DIRECTION_VERTICAL)\n    tableView:setPosition(cc.p(winSize.width / 2, 10))\n    tableView:setDelegate()\n    tableView:setVerticalFillOrder(cc.TABLEVIEW_FILL_TOPDOWN)\n    self:addChild(tableView)\n    --registerScriptHandler functions must be before the reloadData funtion\n    --注册脚本编写器函数必须在reloadData函数之前（有道自动翻译）\n\n    --cell个数\n    tableView:registerScriptHandler(TableScene.numberOfCellsInTableView,cc.NUMBER_OF_CELLS_IN_TABLEVIEW)\n    --滚动事件\n    tableView:registerScriptHandler(TableScene.scrollViewDidScroll,cc.SCROLLVIEW_SCRIPT_SCROLL)\n    tableView:registerScriptHandler(TableScene.scrollViewDidZoom,cc.SCROLLVIEW_SCRIPT_ZOOM)\n    --cell点击事件\n    tableView:registerScriptHandler(TableScene.tableCellTouched,cc.TABLECELL_TOUCHED)\n    --cell尺寸、大小\n    tableView:registerScriptHandler(TableScene.cellSizeForTable,cc.TABLECELL_SIZE_FOR_INDEX)\n    --显示出可视部分的cell\n    tableView:registerScriptHandler(TableScene.tableCellAtIndex,cc.TABLECELL_SIZE_AT_INDEX)\n    --调用这个才会显示界面\n    tableView:reloadData()\n    -----------------------------------------------------------\n\nend\n\nreturn true\n</code></pre>\n<p>end</p>\n<p>–这里是为了让layer能调用TableViewTestLayer的方法<br />\nfunction TableScene.create()<br />\nlocal layer = TableScene.extend(cc.Layer:create())<br />\nif nil ~= layer then<br />\nlayer:init()<br />\nend</p>\n<pre><code>return layer\n</code></pre>\n<p>end</p>\n<p>return TableScene<br />\n</code></pre><h3 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h3><pre><code>–[LUA-print] 数据加载0<br />\n–[LUA-print] 创建了新的cell<br />\n–[LUA-print] 数据加载1<br />\n–[LUA-print] 创建了新的cell<br />\n–[LUA-print] 数据加载2<br />\n–[LUA-print] 创建了新的cell<br />\n–[LUA-print] 数据加载3<br />\n–[LUA-print] 创建了新的cell<br />\n–[LUA-print] 数据加载4<br />\n–[LUA-print] 创建了新的cell<br />\n–[LUA-print] 数据加载5<br />\n–[LUA-print] 创建了新的cell<br />\n–[LUA-print] 数据加载6<br />\n–[LUA-print] 创建了新的cell<br />\n–[LUA-print] 数据加载7<br />\n–[LUA-print] 创建了新的cell<br />\n–[LUA-print] 数据加载8<br />\n–[LUA-print] 创建了新的cell<br />\n–[LUA-print] 数据加载9<br />\n–[LUA-print] 使用已经创建过的cell<br />\n–[LUA-print] 数据加载10<br />\n–[LUA-print] 使用已经创建过的cell<br />\n–[LUA-print] 数据加载11<br />\n–[LUA-print] 使用已经创建过的cell<br />\n–[LUA-print] 数据加载12<br />\n–[LUA-print] 使用已经创建过的cell<br />\n–[LUA-print] 数据加载13<br />\n–[LUA-print] 使用已经创建过的cell<br />\n–[LUA-print] 数据加载14<br />\n–[LUA-print] 使用已经创建过的cell<br />\n–[LUA-print] 数据加载15<br />\n–[LUA-print] 使用已经创建过的cell<br />\n–[LUA-print] 数据加载16<br />\n–[LUA-print] 使用已经创建过的cell<br />\n–[LUA-print] 数据加载17<br />\n–[LUA-print] 使用已经创建过的cell<br />\n–[LUA-print] 数据加载18<br />\n–[LUA-print] 使用已经创建过的cell<br />\n–[LUA-print] 数据加载19<br />\n–[LUA-print] 使用已经创建过的cell<br />\n–[LUA-print] 数据加载20<br />\n</code></pre><p>基本上重用了iOS中的UITableView机制，并且非常流畅的滑动显示一个完整的列表</p></p>\n<blockquote>\n<p>注意点：reloadData()的调用和上面图层之前的关系</p>\n</blockquote>\n<p>美中不足的是cocos创建的这个tableView也是有bug的，如果你的这个tableView有点击事件，不妨你上下滑动几下item，然后在隐藏的上下方点击，是不是仍然有点击事件呢。简单一招，添加Panel遮挡，勾上交互性轻松搞定。</p>\n<p>cocos2dx lua中老版的listView也可以实现统一的功能，但是只能加载少量的item,多了就会很卡，所以推荐以后直接使用TableView。</p>\n<h3 id=\"其他拓展\"><a href=\"#其他拓展\" class=\"headerlink\" title=\"其他拓展\"></a>其他拓展</h3><p>网上有其他相关的一些教程，可以省去UI的搭建</p>\n<ol>\n<li>先用CocosStudio或CocosCreator制作UI界面<ul>\n<li>看这篇文章：<a href=\"http://blog.csdn.net/fjdmy001/article/details/52982515\" target=\"_blank\" rel=\"noopener noreferrer\">http://blog.csdn.net/fjdmy001/article/details/52982515</a></li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>然后修改config.json,</p>\n<blockquote>\n<p>窗口的配置文件，想设置模拟器的大小就在这里设置</p>\n</blockquote>\n<p> 竖屏：”isLandscape” = false<br/> 尺寸：”width” = 540, “height” = 960</p>\n</li>\n<li><p>修改config.lua</p>\n<blockquote>\n<p>游戏的配置文件</p>\n</blockquote>\n<p> 开启全局变量：CC_DISABLE_GLOBAL = false<br/> 设计尺寸：width = 1080，height = 1920，autoscale = “FIXED_HEIGHT”    </p>\n</li>\n</ol>\n<p>使用cocos2dx的相关方法加载对应的文件，然后类似的方法去加载对应的内容(和iOS中定义tableview与cell类似)</p>\n<p>具体可参考这里：</p>\n<ul>\n<li>排行榜之ScrollView：<a href=\"https://blog.csdn.net/fjdmy001/article/details/52997012\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/fjdmy001/article/details/52997012</a></li>\n<li>排行榜之TableView：<a href=\"https://blog.csdn.net/fjdmy001/article/details/52998376\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/fjdmy001/article/details/52998376</a></li>\n</ul>","text":"在众多移动应用中，能看到各式各样的列表/表格数据 不管是iOS中的UITableView/UICollectionView/UIScrollView,还是Android中的ListView/CircleView，都是实际项目开发中使用最平凡，也是最重要的功能。 为了用户考虑，也为...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TableView%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">TableView使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">测试验证</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E6%8B%93%E5%B1%95\"><span class=\"toc-text\">其他拓展</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua语法基础 · 花生肉泥","uid":"e1e4f6137e4bd3266be4f52c61dcd858","slug":"zl/2016-01-01-410_Lua语法基础 · 花生肉泥","date":"2024-04-03T03:47:35.700Z","updated":"2024-04-03T03:47:35.700Z","comments":true,"path":"api/articles/zl/2016-01-01-410_Lua语法基础 · 花生肉泥.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"词法约定标识符标识符可以是任意非数字开头的字母、数字、下划线组成的字符串 标识符用来命名变量，或作为表的域名 Lua是一个大小写敏感的语言 1234andAndAND三者不一样 关键字一下列出了lua的保留关键字。保留关键字不能作为常量或者变量或者其他用户自定义标识符123456...","link":"","photos":[],"count_time":{"symbolsCount":539,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"一个简单的Lua (Memory) Profiler","uid":"5b690cfc8daed9e0e24f168f448fdb9c","slug":"zl/2016-01-01-409_一个简单的Lua (Memory) Profiler","date":"2024-04-03T03:47:35.699Z","updated":"2024-04-03T03:47:35.699Z","comments":true,"path":"api/articles/zl/2016-01-01-409_一个简单的Lua (Memory) Profiler.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua没有内置的Profiler，但是提供了一些相关的接口，可以用来实现一个简单的Lua Profiler。 一个Profiler至少需要统计以下信息, 用函数名+调用位置(保留一层堆栈信息)作为key: 执行次数 总时间 单次最大时间 尚未gc的内存数量 分配内存的最大值 二、...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}