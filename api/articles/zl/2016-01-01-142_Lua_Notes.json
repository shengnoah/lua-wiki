{"title":"Lua_Notes","uid":"a21d0e5f84f6851e30a51261b5834ec0","slug":"zl/2016-01-01-142_Lua_Notes","date":"2024-04-03T03:47:33.038Z","updated":"2024-04-03T03:47:33.039Z","comments":true,"path":"api/articles/zl/2016-01-01-142_Lua_Notes.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>lua脚本语言学习记录      </p>\n<h3 id=\"Vim下Lua的补全（只能实现到支持Lua标准库）\"><a href=\"#Vim下Lua的补全（只能实现到支持Lua标准库）\" class=\"headerlink\" title=\"Vim下Lua的补全（只能实现到支持Lua标准库）\"></a>Vim下Lua的补全（只能实现到支持Lua标准库）</h3><p>使用Vundle + vim-lua-ftplugin + vim-misc<br/>1、安装Vundle<br/>2、在命令行输入vim ~/.vimrc对.vimrc文件进行修改<br/>3、在My Bundles here：下加入，并保存退出：<br/>    Bundle ‘xolox/vim-lua-ftplugin’<br/>    Bundle ‘xolox/vim-misc’<br/>4、开启vim，输入:BundleInstall，安装vim-lua-ftplugin和vim-misc插件，重启vim即可使用补全  </p>\n<h3 id=\"C-C-中嵌入Lua脚本\"><a href=\"#C-C-中嵌入Lua脚本\" class=\"headerlink\" title=\"C/C++中嵌入Lua脚本\"></a>C/C++中嵌入Lua脚本</h3><p>Lua文件：  </p>\n<pre><code>function test_print()\n    print(&#34;test!&#34;)\nend\n</code></pre><p>CPP文件：    </p>\n<pre><code>#include&lt;iostream&gt;\n<p>extern &quot;C&quot;&#123;<br />\n#include&lt;lua.h&gt;<br />\n#include&lt;lualib.h&gt;<br />\n#include&lt;lauxlib.h&gt;<br />\n&#125;<br />\nusing namespace std;</p>\n<p>int main()<br />\n&#123;<br />\nlua_State *L = luaL_newstate();</p>\n<pre><code>luaL_openlibs(L);//加载lua通用扩展库\n\nif(L == NULL)\n    cout &amp;lt;&amp;lt; &amp;#34;Lua Error&amp;#34; &amp;lt;&amp;lt; endl;\n\nif(luaL_loadfile(L, &amp;#34;test.lua&amp;#34;) != LUA_OK)//载入lua脚本\n    cout &amp;lt;&amp;lt; &amp;#34;Load File Error!&amp;#34; &amp;lt;&amp;lt; endl;\n\nif(lua_pcall(L, 0, 0, 0))//加载完lua文件后需要先运行一遍文件，此后才可以对文件内容操作\n    cout &amp;lt;&amp;lt; &amp;#34;Load lua field error!&amp;#34; &amp;lt;&amp;lt; endl;\n\nlua_getglobal(L, &amp;#34;test_print&amp;#34;);//将函数压入栈中\n\nif(lua_pcall(L, 0, 0, 0))//执行函数\n&#123;\n    cout &amp;lt;&amp;lt; &amp;#34;Run lua Function Error!&amp;#34; &amp;lt;&amp;lt; endl;\n    const char *tempstr = lua_tostring(L, -1);\n    cout &amp;lt;&amp;lt; tempstr &amp;lt;&amp;lt; endl;\n\n&#125;\nlua_close(L);\n</code></pre>\n<p>}<br />\n</code></pre><p>编译链接：g++ main.cpp -llua -ldl  </p></p>\n<h3 id=\"Lua中使用C-C-模块\"><a href=\"#Lua中使用C-C-模块\" class=\"headerlink\" title=\"Lua中使用C/C++模块\"></a>Lua中使用C/C++模块</h3><p>一般采用动态链接库的方式载入模块，所以首先要先编译C/C++文件，生成动态链接库  </p>\n<p>头文件：  </p>\n<pre><code>#ifndef _CPPLUALIB_H\n#define _CPPLUALIB_H\n<p>#ifdef __cplusplus<br />\n//以下内容按C的规则进行编译<br />\nextern &quot;C&quot;&#123;<br />\n#endif</p>\n<p>/<em>必须在h文件中加入这几个头文件，否则认不到LUA_API</em>/<br />\n/<em>防止重复定义，可以自己宏定义个flag</em>/<br />\n#include&quot;lua.h&quot;<br />\n#include&quot;lualib.h&quot;<br />\n#include &quot;lauxlib.h&quot;</p>\n<p>LUA_API int luaopen_my_lib(lua_State *L);</p>\n<p>#ifdef __cplusplus<br />\n&#125;<br />\n#endif</p>\n<p>#endif<br />\n</code></pre><p>C++文件：    </p></p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;stdio.h&gt;\n#include&lt;string&gt;\n#include &#34;cpplualib.h&#34;\nusing namespace std;\n\nstatic int SayHello(lua_State *L)\n&#123;\n    cout &lt;&lt; &#34;Hello World!&#34; &lt;&lt; endl;\n    int num = lua_gettop(L);\n    cout &lt;&lt; num &lt;&lt; endl;\n   // cout &lt;&lt; temstr &lt;&lt; endl;//所有参数都被放入L栈中\n\n    //lua_pushstring(L, &#34;LZ&#34;);\n    return num;//返回所有压栈数量\n&#125;\n\nstatic const struct luaL_Reg my_lib[] = \n&#123;\n    &#123;&#34;SayHello&#34;, SayHello&#125;,\n    &#123;NULL, NULL&#125;\n&#125;;\n\nint luaopen_my_lib(lua_State *L) //必须和上面的数组同名，并且生成的动态链接库也必须命名为my_lib.so\n&#123;\n    luaL_newlib(L, my_lib);\n    return 1;\n&#125;\n</code></pre><p>Lua文件：    </p>\n<pre><code>local mylib = require &#34;my_lib&#34;//导入模块\nprint (mylib.SayHello(&#34;mytest&#34;, 1,2,3))  \n</code></pre><p>生成动态链接库：g++ -fPIC -shared -o my_lib.so xxx.cpp    </p>\n<p>执行Lua脚本：lua xxx.lua即可看到打印输出    </p>\n<h3 id=\"语法糖\"><a href=\"#语法糖\" class=\"headerlink\" title=\"语法糖\"></a>语法糖</h3><pre><code>1、\nt_table = &#123;&#125;\nt_table[&#34;li&#34;] = &#34;lizhong&#34; --等价于t_table.li = &#34;lizhong&#34;\n<p>2、<br />\nt_table = &#123;'a', 'b', 'c', key1 = 'cc', 'bb'&#125;<br />\nfor i = 1, #t_table do --#t获取table中key为数字的个数，key为nil的元素则不统计。table.maxn则以最大数字下角标为准，统计nil<br />\nprint(t_table[i]) --输出a, b, c, bb<br />\nend</p>\n<p>3、<br />\n</code></pre><h3 id=\"必用脚本语法\"><a href=\"#必用脚本语法\" class=\"headerlink\" title=\"必用脚本语法\"></a>必用脚本语法</h3><p>1、脚本开头可加#！/usr/local/bin/lua用于指定解释器路径，可不用显式使用lua。（实际测试结果：还是需要显式使用lua xxx.lua才能执行）<br/>2、单行注释：– //两个减号<br/>多行注释：–[[xxxxxxxxx –]]<br/>3、标识符（变量名）：不要使用下划线加大写字母的标识符，因为lua中的保留字一般这样写。约定下划线开头连接一串大写字母的名字（_VERSION）被保留用于lua内部全局变量。lua区分大小写<br/>4、全局变量：默认情况下，变量总是全局的，给一个变量赋值后即创建了这个全局变量，访问一个没初始化的全局变量会返回nil，若希望删除一个全局变量，只需要将变量赋值为nil（也就是说，当且仅当一个变量不等于nil时，这个变量即存在）  </p></p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>脚本语言无需定义变量类型，只需要对变量进行赋值<br/>nil：表示一个无效值（具有删除作用，给一个）<br/>boolean：false和true<br/>number：表示双精度类型的实浮点数（可以看出lua中的数值都按此类表示）<br/>string：字符串由一对双引号或单引号来表示     </p>\n<pre><code>string1 = &#39;hello&#39;  \nstring2 = &#34;hello&#34;  \nstring3 = [[123,  \n456   \n78965413  \n]] --[[]]可表示一块字符串  \nprint(&#39;2&#39;+6) --return 8.0,lua会自动将数字字符串转换为一个10进制数字，直接丢弃其引号\nprint(#&#39;132123&#39;) --用#计算字符串长度\n</code></pre><p>function：由C或lua编写的函数  </p>\n<pre><code>function test(n)\n    print(n)\ntest1 = test\ntest1(10) --lua中函数可以直接赋值给变量，通过变量调用此函数\n<p>function printf(n,fun)<br />\nfun(n)<br />\nprintf(1, function(m)<br />\nprint(m)<br />\nend) --function定义一个匿名函数<br />\n</code></pre><p>userdata：表示任意存储在变量中的C数据结构，可以将C/C++中的任意数据类型（通常是struct和指针）存储到lua变量中调用<br/>thread：表示执行的独立线路，用于执行协同程序<br/>table：一个关联数组，用{}来创建。（可以看出table类似于Python中的字典，只不过此处更适合看做是变量和其值的集合）  </p></p>\n<pre><code>key的几种类型：\ndir0 = &#123;[&#34;key1&#34;] = 1, key2 = 2&#125; --等价，key定义时若为数字或字符串则需加[]\n\ndir1 = &#123;key1 = &#39;value1&#39;, key2 = &#39;value2&#39;&#125; --需要使用dir1[&#34;key1&#34;]进行索引\n\ndir2 = &#123;&#39;value1&#39;, &#39;value2&#39;&#125; --一维数组 --等价于：dir2 = &#123;[1] = &#39;value1&#39;, [2] = &#39;value2&#39;&#125;\n\n-需要使用dir2[1]和dir[2]进行索引，注意lua中下标是从1开始计数的，而非0\n\ndir3 = &#123;i = &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ii = &#39;d&#39;, &#39;e&#39;&#125; -- dir3[3]返回e\n</code></pre><p>可以使用type函数查询类型：<br/>print(type(“123”))    –&gt;string<br/>print(type(123))    –&gt;number    </p>\n<p>do end –相当于C++中的{}名称空间  </p>\n<h3 id=\"lua变量\"><a href=\"#lua变量\" class=\"headerlink\" title=\"lua变量\"></a>lua变量</h3><p>局部变量的作用域仅限于声明他们的那个块。块可以是一个控制结构的执行体、一个函数的执行体或者是一个程序块（do end中间的部分）<br/>（所声明的局部变量的作用域从声明语句开始，直至所在块的结尾）</p>\n<pre><code>x = 10 --没有local就默认为全局变量，在函数中也是如此\nlocal i = 1 --程序块中的局部变量\n<p>while i &lt;= x do<br />\nlocal x = i * 2 --while循环体中的局部变量<br />\nprint(x) --while循环体中的局部变量，输出2,4,6,8…<br />\ni = i +1<br />\nend</p>\n<p>if i &gt; 20 then<br />\nlocal x --then中的局部变量<br />\nx = 20 --then中的局部变量<br />\nprint(x + 2) --then中的局部变量，输出22<br />\nelse<br />\nprint(x) --开头定义的全局变量x,输出10<br />\nend<br />\nprint(x) --开头定义的全局变量x，输出10<br />\n</code></pre><p>注意：交互模式下每输入一行语句都会成为一个程序块，所以想在交互模式下正确指定作用域，就需要显示的用do end来指定块</p></p>\n<h3 id=\"关系操作符\"><a href=\"#关系操作符\" class=\"headerlink\" title=\"关系操作符\"></a>关系操作符</h3><p>只能对两个数字或两个字符串做大小比较，不同类的会返回false。字符串的比较是按照字母次序例如：  </p>\n<pre><code>&#34;bc&#34; &lt; &#34;ace&#34; --&gt;返回false  \n&#34;2&#34; &lt; &#34;15&#34; --&gt;返回false\n&#34;a&#34; &gt; &#34;9&#34; --&gt;返回true，说明字母字符串总大于数字字符串\n</code></pre><p>nil只与其自身相等   </p>\n<p>~= –不等<br/>= –赋值，注意table的赋值是引用（不同于深浅拷贝）</p>\n<pre><code>a = &#123;&#39;a&#39;, &#39;b&#39;&#125;\nc = a\nc[1] = &#39;z&#39;\nprint(a[1]) --&gt;返回z，说明是引用\n<p>c = &#123;'v', 'r'&#125;<br />\nprint(a[1]) –&gt;返回z，说明c已经变为了另一个table的引用<br />\n</code></pre><h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><p>not 数字 –&gt;输出都为false<br/>not nil –&gt;输出true<br/>not false –&gt;输出true<br/>(a &gt; b) and a or b –&gt;a若大于b则括号内成立，则true and a or b,根据短路法则直接返回true and a。（and对应&amp;&amp;，or对应||）,有nil参与的逻辑运算可将nil视为0  </p></p>\n<h3 id=\"字符串连接符\"><a href=\"#字符串连接符\" class=\"headerlink\" title=\"字符串连接符\"></a>字符串连接符</h3><p>..（两个点），如果任意一边是数字则会将数字直接转换为字符串（直接加引号）再进行连接输出。  </p>\n<h3 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h3><p>由高到低（高优先级先执行）：  </p>\n<pre><code>^（右结合:x^y^z &lt;--&gt; x^(y^z)）  \nnot # -  \n* / %  \n+ -  \n..（右结合）  \n&lt; &gt; &lt;= &gt;= -= ==  \nand  \nor  \n</code></pre><h3 id=\"多重赋值\"><a href=\"#多重赋值\" class=\"headerlink\" title=\"多重赋值\"></a>多重赋值</h3><p>交换：x, y = y, x –x与y互换<br/>右边值多于左边变量，值会被丢弃。右边值少于左边变量，多出的变量被置为nil  </p>\n<h3 id=\"控制结构\"><a href=\"#控制结构\" class=\"headerlink\" title=\"控制结构\"></a>控制结构</h3><p>注意：在控制结构中所有不是false和nil的值都会被视为真（数字0也是真）</p>\n<pre><code>if ... then\n    ...\nelse\n    ...\nend\n<p>if … then<br />\n…<br />\nelseif … then<br />\n…<br />\nelse<br />\n…<br />\nend</p>\n<p>whie … do<br />\n…<br />\nend</p>\n<p>repeat --重复执行循环体，直到条件为真<br />\n…<br />\nuntil …（条件）</p>\n<p>–数值for循环<br />\n–var从exp1变化到exp2，每次变化以exp3为步长递增，并执行一次循环体，若不存在exp3，则默认步长为1。for的三个表达式在循环开始前进行一次性求值，之后不再求值<br />\nfor var = exp1, exp2, exp3 do<br />\n&lt;执行体&gt;<br />\nend</p>\n<p>–泛型for循环（注意pairs是无序的，ipairs是有序的）<br />\ndir3 = &#123;i = 'a', 'b', 'c', ii = 'd', 'e'&#125;<br />\n–pairs(dir3)方法可以用于遍历table,可以遍历表中所有的key。<br />\n–ipairs(dir3)只能遍历到表中出现第一个不是整数的key。也就是说ipairs(dir3)只可以遍历出b,c,e</p>\n<p>dir3 = &#123;[2] = 'b', 'c', 'e'&#125;–这样ipairs将遍历出c,e。因为[2]的值再e定义时被改写了<br />\ndir3 = &#123;key1 = 'a', key2 = 'b'&#125;–这样ipairs将无法遍历，直接跳出循环，因为dir3[1]=nil</p>\n<p>–pairs和ipairs只能遍历一维数据，多维数据还是要依赖for循环<br />\n</code></pre><h3 id=\"多重返回函数\"><a href=\"#多重返回函数\" class=\"headerlink\" title=\"多重返回函数\"></a>多重返回函数</h3><pre><code>function foo()<br />\nreturn 'a', 'b'<br />\nend</p>\n<p>function goo(i, j, k)<br />\nreturn i, j, k<br />\nend<br />\n–若foo()被调用，并且不是一系列表达式的最后一个元素，那么Lua会将其返回值数量调整为1<br />\nx, y = foo(), 10 --x = 'a', y = 10<br />\nprint(foo(), 2) --输出a, 2<br />\ngoo(foo()) --输出a, b, nil<br />\ngoo(foo(), 1) --foo将只返回一个值,输出a, 1, nil<br />\ngoo((foo())) --foo()放入括号内将迫使它只返回一个值a, nil, nil</p>\n<p>–泛型调用，unpack(),接受一个数组table作为参数，并从下标1开始返回该数组的所有元素,与ipairs相似，只不过这个可以直接返回值<br />\nlist1 = &#123;'a', 'b', 'c'&#125;<br />\nprint(table.unpack(list1))</p>\n<p>–变长参数<br />\nfunction add(…)<br />\nlocal s = 0<br />\nfor i, v in ipairs(…) do<br />\ns = s + v<br />\nend<br />\nreturn s<br />\nend<br />\nprint(add(&#123;10, 20, 30, 40&#125;)) --返回100,注意…处需要传入的是一个table</p>\n<p>function foo(…)<br />\nlocal a, b, c, e, f =…<br />\nend</p>\n<p>function goo(a, …) – 在变长参数…前可以加入固定参数<br />\nprint(a, …) --注意…处需要传入table，零散的参数不可以<br />\nend<br />\n</code></pre></p>\n","text":"lua脚本语言学习记录 Vim下Lua的补全（只能实现到支持Lua标准库）使用Vundle + vim-lua-ftplugin + vim-misc1、安装Vundle2、在命令行输入vim ~/.vimrc对.vimrc文件进行修改3、在My Bundles here：下加入...","link":"","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Vim%E4%B8%8BLua%E7%9A%84%E8%A1%A5%E5%85%A8%EF%BC%88%E5%8F%AA%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%88%B0%E6%94%AF%E6%8C%81Lua%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%89\"><span class=\"toc-text\">Vim下Lua的补全（只能实现到支持Lua标准库）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#C-C-%E4%B8%AD%E5%B5%8C%E5%85%A5Lua%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">C&#x2F;C++中嵌入Lua脚本</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Lua%E4%B8%AD%E4%BD%BF%E7%94%A8C-C-%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">Lua中使用C&#x2F;C++模块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95%E7%B3%96\"><span class=\"toc-text\">语法糖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BF%85%E7%94%A8%E8%84%9A%E6%9C%AC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">必用脚本语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">数据类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#lua%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">lua变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">关系操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">逻辑运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E7%AC%A6\"><span class=\"toc-text\">字符串连接符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">运算符优先级</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">多重赋值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">控制结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%87%8D%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">多重返回函数</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"LUA5.1调用C函数","uid":"c16303c759dd88967615455485b434a3","slug":"zl/2016-01-01-141_LUA5.1调用C函数","date":"2024-04-03T03:47:33.038Z","updated":"2024-04-03T03:47:33.038Z","comments":true,"path":"api/articles/zl/2016-01-01-141_LUA5.1调用C函数.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua利用一个虚拟的栈(stack)来给C传递值或从C获取值。每当Lua调用C函数，都会获得一个新的栈，该栈初始包含所有的调用C函数所需要的参数值（Lua传给C函数的调用实参），并且C函数执行完毕后，会把返回值压入这个栈（Lua从中拿到C函数调用结果）本文展示了如何在lua中调用...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua闭包","uid":"8af19d7fe0a420298158116e9697e3f4","slug":"zl/2016-01-01-138_Lua闭包","date":"2024-04-03T03:47:33.037Z","updated":"2024-04-03T03:47:33.037Z","comments":true,"path":"api/articles/zl/2016-01-01-138_Lua闭包.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua中的闭包 闭包，又称词法闭包或函数闭包，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}