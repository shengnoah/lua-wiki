{"title":"xLua热更新3之生成代码","uid":"dd376855338d26226b310de8b083f6d2","slug":"zl/2016-01-01-957_xLua热更新3之生成代码","date":"2024-04-03T03:47:36.227Z","updated":"2024-04-03T03:47:36.228Z","comments":true,"path":"api/articles/zl/2016-01-01-957_xLua热更新3之生成代码.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>思考并回答以下问题：<br/>1.如何创建一个空表？</p>\n<p>之前提到了生成代码的问题，是不是对这个概念很陌生？生成代码从广义上来说就是通过程序来生成代码。在xLua中也是如此，下面来看看在xLua中具体是什么。</p>\n<h2 id=\"什么是生成代码？\"><a href=\"#什么是生成代码？\" class=\"headerlink\" title=\"什么是生成代码？\"></a><span style=\"color:#EF7060;\">什么是生成代码？</span></h2><p>生成代码是xLua支持的lua和C#间交互技术之一，这种技术通过生成两者间的适配代码来实现交互，性能较好，是<span style=\"color:red\"> 推荐的方式</span>。xLua可以自动生成配置好的代码，后面会有介绍。</p>\n<p>另一种交互技术是反射，这种方式对安装包的影响更少，可以在性能要求不高或者对安装包大小很敏感的场景下使用。</p>\n<h2 id=\"应该什么时候生成代码？\"><a href=\"#应该什么时候生成代码？\" class=\"headerlink\" title=\"应该什么时候生成代码？\"></a><span style=\"color:#EF7060;\">应该什么时候生成代码？</span></h2><p>开发期不建议生成代码，可以避免很多由于不一致导致的编译失败，以及生成代码本身的编译等待。</p>\n<p>发布手机版本前必须执行生成代码，建议做成自动化的流程。</p>\n<p>做性能调优，性能测试前必须执行生成代码，因为生成和不生成性能的区别还是很大的。</p>\n<h2 id=\"如何生成代码？\"><a href=\"#如何生成代码？\" class=\"headerlink\" title=\"如何生成代码？\"></a><span style=\"color:#EF7060;\">如何生成代码？</span></h2><p>生成代码的过程是自动化的，xLua提供了相关的脚本进行生成。</p>\n<p>入口是下图的菜单栏：</p>\n<img src=\"https://chebincarl.github.io//2019/06/24/xLua热更新3之生成代码/1.png\"/>\n<p>但是xLua需要首先知道生成哪些代码，这就涉及到xLua的配置了。</p>\n<h2 id=\"xLua的配置\"><a href=\"#xLua的配置\" class=\"headerlink\" title=\"xLua的配置\"></a><span style=\"color:#EF7060;\">xLua的配置</span></h2><p>xLua所有的配置都支持三种方式：打标签；静态列表；动态列表。</p>\n<p>配置有两必须两建议：</p>\n<ul>\n<li>列表方式均必须是static的字段/属性</li>\n<li>列表方式均必须放到一个static类</li>\n<li>建议不用标签方式</li>\n<li>建议列表方式配置放Editor目录（如果是Hotfix配置【后面会讲】，而且类位于Assembly-CSharp.dll之外的其它dll，必须放Editor目录）</li>\n</ul>\n<p><strong> 打标签 </strong></p>\n<p>xLua用白名单来指明生成哪些代码，而白名单通过attribute来配置，比如你想从lua调用c#的某个类，希望生成适配代码，你可以为这个类型打一个LuaCallCSharp标签：<br/></p><figure class=\"highlight cs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">[]</span><br/><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> </span><br/><span class=\"line\">{</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p><span style=\"color:red\">该方式方便，但在il2cpp下会增加不少的代码量，不建议使用。</span></p>\n<p><strong> 静态列表 </strong></p>\n<p>有时我们无法直接给一个类型打标签，比如系统API，没源码的库，或者实例化的泛化类型，这时你可以在一个静态类里声明一个静态字段，该字段的类型除BlackList和AdditionalProperties之外只要实现了IEnumerable就可以了（这两个例外后面具体会说），然后为这字段加上标签：<br/></p><figure class=\"highlight cs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">[]</span><br/><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Type&gt; mymodule_lua_call_cs_list = <span class=\"keyword\">new</span> List&lt;Type&gt;()</span><br/><span class=\"line\">{</span><br/><span class=\"line\">    <span class=\"keyword\">typeof</span>(GameObject),</span><br/><span class=\"line\">    <span class=\"keyword\">typeof</span>(Dictionary&lt;<span class=\"keyword\">string</span>, <span class=\"keyword\">int</span>&gt;),</span><br/><span class=\"line\">};</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>这个字段需要放到一个<span style=\"color:red\">静态类</span>里头，建议放到<span style=\"color:red\">Editor</span>目录 。</p>\n<p><strong> 动态列表 </strong></p>\n<p>声明一个静态属性，打上相应的[Hotfix]标签即可。<br/></p><figure class=\"highlight cs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">Hotfix</span>]</span><br/><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Type&gt; by_property</span><br/><span class=\"line\">{</span><br/><span class=\"line\">    <span class=\"keyword\">get</span></span><br/><span class=\"line\">    {</span><br/><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">from</span> type <span class=\"keyword\">in</span> Assembly.Load(<span class=\"string\">&#34;Assembly-CSharp&#34;</span>).GetTypes()</span><br/><span class=\"line\">                <span class=\"keyword\">where</span> type.Namespace == <span class=\"string\">&#34;XXXX&#34;</span></span><br/><span class=\"line\">                <span class=\"keyword\">select</span> type).ToList();</span><br/><span class=\"line\">    }</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>Getter是代码，你可以实现很多效果，比如按名字空间配置，按程序集配置等等。</p>\n<p>这个属性需要放到一个<span style=\"color:red\">静态类</span>里头，建议放到<span style=\"color:red\">Editor</span>目录 。</p>\n<h2 id=\"配置Attribute\"><a href=\"#配置Attribute\" class=\"headerlink\" title=\"配置Attribute\"></a><span style=\"color:#EF7060;\">配置Attribute</span></h2><p><strong> XLua.LuaCallCSharp </strong><br/></p><figure class=\"highlight cs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">[]</span><br/><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> </span><br/><span class=\"line\">{</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>一个C#类型加了这个配置，xLua会生成这个类型的适配代码（包括构造该类型实例，访问其成员属性、方法，静态属性、方法），否则将会尝试用性能较低的反射方式来访问。</p>\n<p>一个类型的扩展方法（Extension Methods）加了这配置，也会生成适配代码并追加到被扩展类型的成员方法上。</p>\n<p>xLua只会生成加了该配置的类型，不会自动生成其父类的适配代码，当访问子类对象的父类方法，如果该父类加了LuaCallCSharp配置，则执行父类的适配代码，否则会尝试用反射来访问。</p>\n<p>反射访问除了性能不佳之外，在il2cpp下还有可能因为代码剪裁而导致无法访问，后者可以通过下面介绍的ReflectionUse标签来避免。</p>\n<h2 id=\"XLua-ReflectionUse\"><a href=\"#XLua-ReflectionUse\" class=\"headerlink\" title=\"XLua.ReflectionUse\"></a><span style=\"color:#EF7060;\">XLua.ReflectionUse</span></h2><figure class=\"highlight cs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">ReflectionUse</span>]</span><br/><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> </span><br/><span class=\"line\">{</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure>\n<p>一个C#类型类型加了这个配置，xLua会生成link.xml阻止il2cpp的代码剪裁。</p>\n<p>对于扩展方法，必须加上LuaCallCSharp或者ReflectionUse才可以被访问到。</p>\n<p>建议所有要在Lua访问的类型，要么加LuaCallCSharp，要么加上ReflectionUse，这才能够保证在各平台都能正常运行。</p>\n<h2 id=\"XLua-BlackList\"><a href=\"#XLua-BlackList\" class=\"headerlink\" title=\"XLua.BlackList\"></a><span style=\"color:#EF7060;\">XLua.BlackList</span></h2><p>如果你不要生成一个类型的一些成员的适配代码，你可以通过这个配置来实现。</p>\n<p>标签方式比较简单，对应的成员上加就可以了。</p>\n<p>由于考虑到有可能需要把重载函数的其中一个重载列入黑名单，配置方式比较复杂，类型是List<list>，对于每个成员，在第一层List有一个条目，第二层List是个string的列表，第一个string是类型的全路径名，第二个string是成员名，如果成员是一个方法，还需要从第三个string开始，把其参数的类型全路径全列出来。</list></p>\n<p>例如下面是对GameObject的一个属性以及FileInfo的一个方法列入黑名单：<br/></p><figure class=\"highlight cs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">BlackList</span>]</span><br/><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;<span class=\"keyword\">string</span>&gt;&gt; BlackList = <span class=\"keyword\">new</span> List&lt;List&lt;<span class=\"keyword\">string</span>&gt;&gt;()  {</span><br/><span class=\"line\">    <span class=\"keyword\">new</span> List&lt;<span class=\"keyword\">string</span>&gt;(){<span class=\"string\">&#34;UnityEngine.GameObject&#34;</span>, <span class=\"string\">&#34;networkView&#34;</span>},</span><br/><span class=\"line\">    <span class=\"keyword\">new</span> List&lt;<span class=\"keyword\">string</span>&gt;(){<span class=\"string\">&#34;System.IO.FileInfo&#34;</span>, <span class=\"string\">&#34;GetAccessControl&#34;</span>, <span class=\"string\">&#34;System.Security.AccessControl.AccessControlSections&#34;</span>},</span><br/><span class=\"line\">};</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<h2 id=\"XLua-DoNotGen\"><a href=\"#XLua-DoNotGen\" class=\"headerlink\" title=\"XLua.DoNotGen\"></a><span style=\"color:#EF7060;\">XLua.DoNotGen</span></h2><p>指明一个类里的部分函数、字段、属性不生成代码，通过反射访问。</p>\n<p>只能标注Dictionary<type, list=\"\">的field或者property。key指明的是生效的类，value是一个列表，配置的是不生成代码的函数、字段、属性的名字。</type,></p>\n<p>和ReflectionUse的区别是：</p>\n<ul>\n<li>ReflectionUse指明的是整个类；</li>\n<li>当第一次访问一个函数（字段、属性）时，ReflectionUse会把整个类都wrap，而DoNotGen只wrap该函数（字段、属性），换句话DoNotGen更lazy一些；</li>\n</ul>\n<p>和BlackList的区别是：</p>\n<ul>\n<li>BlackList配了里面指定的类型就不能在lua中用了；</li>\n<li>BlackList能指明某重载函数，DoNotGen不能。</li>\n</ul>\n<h2 id=\"XLua-CSharpCallLua\"><a href=\"#XLua-CSharpCallLua\" class=\"headerlink\" title=\"XLua.CSharpCallLua\"></a><span style=\"color:#EF7060;\">XLua.CSharpCallLua</span></h2><p>如果希望把一个lua函数适配到一个C# delegate（一类是C#侧各种回调：UI事件，delegate参数，比如List:ForEach；另外一类场景是通过LuaTable的Get函数指明一个lua函数绑定到一个delegate）。或者把一个lua table适配到一个C# interface，该delegate或者interface需要加上该配置。</p>\n<h2 id=\"XLua-GCOptimize\"><a href=\"#XLua-GCOptimize\" class=\"headerlink\" title=\"XLua.GCOptimize\"></a><span style=\"color:#EF7060;\">XLua.GCOptimize</span></h2><p>一个C#纯值类型（注：指的是一个只包含值类型的struct，可以嵌套其它只包含值类型的struct）或者C#枚举值加上了这个配置。xLua会为该类型生成gc优化代码，效果是该值类型在lua和c#间传递不产生（C#）gc alloc，该类型的数组访问也不产生gc。</p>\n<p>除枚举之外，包含无参构造函数的复杂类型，都会生成lua table到该类型，以及改类型的一维数组的转换代码，这将会优化这个转换的性能，包括更少的gc alloc。</p>\n<h2 id=\"XLua-AdditionalProperties\"><a href=\"#XLua-AdditionalProperties\" class=\"headerlink\" title=\"XLua.AdditionalProperties\"></a><span style=\"color:#EF7060;\">XLua.AdditionalProperties</span></h2><p>这个是GCOptimize的扩展配置，有的时候，一些struct喜欢把field写成私有的，通过property来访问field，这时就需要用到该配置（默认情况下GCOptimize只对public的field打解包）。</p>\n<p>标签方式比较简单，配置方式复杂一点，要求是Dictionary<type, list=\"\">类型，Dictionary的Key是要生效的类型，Value是属性名列表。</type,></p>\n<h2 id=\"下面是生成期配置，必须放到Editor目录下\"><a href=\"#下面是生成期配置，必须放到Editor目录下\" class=\"headerlink\" title=\"下面是生成期配置，必须放到Editor目录下\"></a><span style=\"color:#EF7060;\">下面是生成期配置，必须放到Editor目录下</span></h2><p><strong> CSObjectWrapEditor.GenPath </strong></p>\n<figure class=\"highlight cs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">CSObjectWrapEditor.GenPath</span>]</span><br/><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">string</span> Path = Application.streamingAssetsPath;</span><br/></pre></td></tr></tbody></table></figure>\n<p>配置生成代码的放置路径，类型是string。如果不配置默认生成在”Assets/XLua/Gen/“下。</p>\n<p><strong> CSObjectWrapEditor.GenCodeMenu </strong></p>\n<figure class=\"highlight cs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">CSObjectWrapEditor.GenCodeMenu</span>]</span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Method</span>(<span class=\"params\"></span>)</span>{</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure>\n<p>该配置用于生成引擎的二次开发，一个无参数函数加了这个标签，在执行”XLua/Generate Code”菜单时会触发这个函数的调用。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>xLua也给出了一份常用的xLua的配置，可以在这个基础上根据自己的项目做修改。地址是：<a href=\"https://github.com/Tencent/xLua/blob/master/Assets/XLua/Editor/ExampleConfig.cs\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Tencent/xLua/blob/master/Assets/XLua/Editor/ExampleConfig.cs</a></p>","text":"思考并回答以下问题：1.如何创建一个空表？ 之前提到了生成代码的问题，是不是对这个概念很陌生？生成代码从广义上来说就是通过程序来生成代码。在xLua中也是如此，下面来看看在xLua中具体是什么。 什么是生成代码？生成代码是xLua支持的lua和C#间交互技术之一，这种技术通过生成...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%EF%BC%9F\"><span class=\"toc-text\">什么是生成代码？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%94%E8%AF%A5%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%EF%BC%9F\"><span class=\"toc-text\">应该什么时候生成代码？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%EF%BC%9F\"><span class=\"toc-text\">如何生成代码？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#xLua%E7%9A%84%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">xLua的配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AEAttribute\"><span class=\"toc-text\">配置Attribute</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XLua-ReflectionUse\"><span class=\"toc-text\">XLua.ReflectionUse</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XLua-BlackList\"><span class=\"toc-text\">XLua.BlackList</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XLua-DoNotGen\"><span class=\"toc-text\">XLua.DoNotGen</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XLua-CSharpCallLua\"><span class=\"toc-text\">XLua.CSharpCallLua</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XLua-GCOptimize\"><span class=\"toc-text\">XLua.GCOptimize</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XLua-AdditionalProperties\"><span class=\"toc-text\">XLua.AdditionalProperties</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8B%E9%9D%A2%E6%98%AF%E7%94%9F%E6%88%90%E6%9C%9F%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%BF%85%E9%A1%BB%E6%94%BE%E5%88%B0Editor%E7%9B%AE%E5%BD%95%E4%B8%8B\"><span class=\"toc-text\">下面是生成期配置，必须放到Editor目录下</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"tolua实现分析","uid":"badacccfdd679d5ed5e22c4988c3b87d","slug":"zl/2016-01-01-955_tolua实现分析","date":"2024-04-03T03:47:36.227Z","updated":"2024-04-03T03:47:36.227Z","comments":true,"path":"api/articles/zl/2016-01-01-955_tolua实现分析.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"tolua++如何将c++对象导入到lua里tolua++为每一个传入lua的对象建立一个userdata，userdata的值，是c++对象的地址。userdata的metatable，是一个tolua++建立的，记录了userdata对应c++类型信息的表格，包括导出的成员变...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua","uid":"15b0cdc6d03f6c3f6bf8d3a7ff197317","slug":"zl/2016-01-01-952_Lua","date":"2024-04-03T03:47:36.226Z","updated":"2024-04-03T03:47:36.226Z","comments":true,"path":"api/articles/zl/2016-01-01-952_Lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 我们要明确一个前提：Lua是动态型语言，变量是不需要类型定义，只需要为变量赋值。值可以存储在变量中，最为参数传递或结果返回。一 基本类型 Lua有8个基本类型：nil、boolean、number、string、userdata、function、thread、table 1 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}