{"title":"Lua数据类型","uid":"fbf063cfd1e14012521ff08e60dd9b1f","slug":"zl/2016-01-01-936_Lua数据类型","date":"2024-04-03T03:47:36.207Z","updated":"2024-04-03T03:47:36.207Z","comments":true,"path":"api/articles/zl/2016-01-01-936_Lua数据类型.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"前言\">前言</h2>\n<p>接触lua近4年了，一直断断续续读相关源码，这次计划把lua源码整体分析一遍，基于最新版本(<em>Lua 5.3.5</em>), 完成如下文章（顺序可能不一致）：</p>\n<ul>\n  <li>基本数据类型</li>\n  <li>string/table 剖析</li>\n  <li>luavm 分析</li>\n  <li>lexer/ast/gencode 词法分析/语法树/生成字节码</li>\n  <li>lua周边支持：debug/continue等</li>\n</ul>\n<h3 id=\"lua源码简介\">lua源码简介</h3>\n<ul>\n  <li>可以从lua官方网站下载最新源码：<a href=\"https://www.lua.org/\">源码下载</a></li>\n  <li>推荐直接用 vscode+wsl 阅读代码，<a href=\"https://code.visualstudio.com/docs/cpp/config-wsl\">方案参考</a>，然后可以配置Task/Debug， 很方便地即可实现断点，code定位等常用功能， 注意修改一下gcc编译优化等级即可</li>\n</ul>\n<h3 id=\"lua数据类型概括\">Lua数据类型概括</h3>\n<p>lua数据类型定义在 <b>lobject.h</b> 中, 暴露出来的类型一共有9中：nil/bool/lightud/number/string/table/func/ud/thread, 定义：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#define LUA_TNIL\t\t0\n#define LUA_TBOOLEAN\t\t1\n#define LUA_TLIGHTUSERDATA\t2\n#define LUA_TNUMBER\t\t3\n#define LUA_TSTRING\t\t4\n#define LUA_TTABLE\t\t5\n#define LUA_TFUNCTION\t\t6\n#define LUA_TUSERDATA\t\t7\n#define LUA_TTHREAD\t\t8\n</code></pre></div></div>\n<p>如此看，似乎4个bit就能完全满足类型定义了，但是lua在一些数据类型实现上还有进一步细分，如</p>\n<ul>\n  <li><em>LUA_TNUMBER</em> 细分：<em>LUA_TNUMFLT/LUA_TNUMINT</em> (float64/int64)</li>\n  <li><em>LUA_TSTRING</em> 细分：<em>LUA_TSHRSTR/LUA_TLNGSTR</em></li>\n  <li><em>LUA_TFUNCTION</em> 细分：<em>LUA_TLCL/LUA_TLCF/LUA_TCCL</em></li>\n</ul>\n<p>lua从设计上只想暴露出9中数据类型，但是实现上必须更加精巧地去考虑，那么如何用一个字节去定义9种基础类型以及部分细分类型：</p>\n<ul>\n  <li>0 - 3bit：定义9种基础数据类型，一共可以定义15种目前用了9种</li>\n  <li>4 - 6bit: 定义细分类型</li>\n</ul>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#define LUA_TLCL\t(LUA_TFUNCTION | (0 &lt;&lt; 4))  /* Lua closure */\n#define LUA_TLCF\t(LUA_TFUNCTION | (1 &lt;&lt; 4))  /* light C function */\n#define LUA_TCCL\t(LUA_TFUNCTION | (2 &lt;&lt; 4))  /* C closure */\n<p>/* Variant tags for strings <em>/<br />\n#define LUA_TSHRSTR\t(LUA_TSTRING | (0 &lt;&lt; 4))  /</em> short strings <em>/<br />\n#define LUA_TLNGSTR\t(LUA_TSTRING | (1 &lt;&lt; 4))  /</em> long strings */</p>\n<p>/* Variant tags for numbers <em>/<br />\n#define LUA_TNUMFLT\t(LUA_TNUMBER | (0 &lt;&lt; 4))  /</em> float numbers <em>/<br />\n#define LUA_TNUMINT\t(LUA_TNUMBER | (1 &lt;&lt; 4))  /</em> integer numbers */<br />\n</code></pre></div></div></p>\n<p>那么为什么不能这么定义呢</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#define LUA_TNUMFLT\t\t9\n#define LUA_TNUMINT     10\n....\n</code></pre></div></div>\n<p>如果真的这样定义也不是一定就不行，但是会有一个小问题，当我们判断某个数据类型是不是 <em>LUA_TNUMBER</em> 时就变得有点麻烦，可能就需要<code class=\"language-plaintext highlighter-rouge\">if type == LUA_TNUMFLT or type == LUA_TNUMINT &#123;do something&#125;</code>, 但是用bit去定义就可以 <code class=\"language-plaintext highlighter-rouge\">if type &amp; LUA_TNUMBER &#123; do something&#125;</code></p>\n<h3 id=\"lua数据类型结构体定义\">Lua数据类型结构体定义</h3>\n<ul>\n  <li>\n    <p>lua 是一种弱类型脚本语言，所以在实现时期望用一个统一的结构对象去实现所有类型，类比到高级语言种如：C# 可以用object对象去实现，golang可以用interface{}，java可以用Object等等，不考虑值类型装箱问题的话，的确可以这么做的。 但是放到c语言中，假设我们尝试用void*去处理，一则值类型也必须用指针处理，再者此时就失去原类型的定义，如任意 <em>void* ptr</em>并无法知道ptr具体是什么类型</p>\n  </li>\n  <li>可以用 <em>struct</em> 去实现吗？ 自然也不太好，struct会带来内存浪费问题，比如会如下定义 :\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>typedef struct LuaType &#123;\n  int64 num;\n  char* str;\n  Table tbl;\n  char type;\n  ... \n  &#125;  \n</code></pre></div>    </div>\n    <p>那么对于任意 LuaType 对象来说，内存都是 sizeof(LuaType) = sizeof(int64)+sizeof(char*)…., 然后需要的仅仅是某个类型+type的内存</p>\n  </li>\n  <li>Lua用了c中union去实现这种“内存共享”逻辑 <a href=\"https://www.geeksforgeeks.org/union-c/\">union 参考</a></li>\n</ul>\n<p>Lua 数据类型大体上分为：可被<em>GC的对象 / 值类型</em>，<b><em>TValue</em></b> 是lua中所有类型的表示, 定义：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>typedef union Value &#123;\n  GCObject *gc;    /* collectable objects */\n  void *p;         /* light userdata */\n  int b;           /* booleans */\n  lua_CFunction f; /* light C functions */\n  lua_Inteluager i;   /* integer numbers */\n  lua_Number n;    /* float numbers */\n&#125; Value;\n<p>#define TValuefields\tValue value_; int tt_</p>\n<p>typedef struct lua_TValue &#123;<br />\nTValuefields;<br />\n&#125; TValue;</p>\n<p></code></pre></div></div></p>\n<p>其中 <em>Value value_</em> 定义了数据部分，tt_ 定义了数据类型：</p>\n<ul>\n  <li>\n    <p>lua_Number/lua_Inteluager 分别定义为：double/long long，所以lua中number就是8字节，浮点的数的话用double，那么它的精度就是52位 （最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M）， 所以如果是一个超出52位整型转float64时可能会丢失精度</p>\n  </li>\n  <li>\n    <p>所以一个lua 数据对象，在内存中占用最少 12byte = sizeof(long long) + sizeof(int)</p>\n  </li>\n  <li>\n    <p>tt_ 定义了具体数据类型，其中如果是 GCObject* 则tt_第7位会标记出来 <code class=\"language-plaintext highlighter-rouge\">#define BIT_ISCOLLECTABLE\t(1 &lt;&lt; 6);#define ctb(t)\t\t\t((t) | BIT_ISCOLLECTABLE)</code></p>\n  </li>\n</ul>\n<p>GCObject 是所有可GC对象的定义</p>\n<ul>\n  <li>next 字段使得GCObject可以变成一个单项链表，用于GC过程中遍历以及“根对象”管理</li>\n  <li>tt 表示该对象类型类型</li>\n  <li>mark 字段用于GC过程中的 扫描标记中 white/gray/black 标记</li>\n</ul>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/* Common Header for all collectable objects (in macro form, to be included in other objects) */\n#define CommonHeader\tGCObject *next; lu_byte tt; lu_byte marked\n<p>/* Common type has only the common header */<br />\nstruct GCObject &#123;<br />\nCommonHeader;<br />\n&#125;;</p>\n<p></code></pre></div></div></p>\n<h3 id=\"lua-数据结构字段getset-封装\">Lua 数据结构字段get/set 封装</h3>\n<p>为了更加方便地操作TValue字段，Lua定义了各种宏去判断类型/字段访问等，之所以用宏，主要考虑避免method频繁调用带来的上下文切换开销：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#define val_(o)\t\t((o)-&gt;value_)\n<p>/* raw type tag of a TValue */<br />\n#define rttype(o)\t((o)-&gt;tt_)</p>\n<p>/* tag with no variants (bits 0-3) */<br />\n#define novariant(x)\t((x) &amp; 0x0F)</p>\n<p>/* type tag of a TValue (bits 0-3 for tags + variant bits 4-5) */<br />\n#define ttype(o)\t(rttype(o) &amp; 0x3F)</p>\n<p>/* type tag of a TValue with no variants (bits 0-3) */<br />\n#define ttnov(o)\t(novariant(rttype(o)))<br />\n</code></pre></div></div></p>\n<p>值得注意的是 如果是9种基础类型，那么用：<code class=\"language-plaintext highlighter-rouge\">novariant(x)</code> 去处理即可, 细分类型用 <code class=\"language-plaintext highlighter-rouge\">ttype(o)</code>, 正如Lua源码更高级地接口封装：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/* Macros to test type */\n#define checktag(o,t)\t\t(rttype(o) == (t))\n#define checktype(o,t)\t\t(ttnov(o) == (t))\n#define ttisnumber(o)\t\tchecktype((o), LUA_TNUMBER)\n#define ttisfloat(o)\t\tchecktag((o), LUA_TNUMFLT)\n#define ttisinteger(o)\t\tchecktag((o), LUA_TNUMINT)\n...\n</code></pre></div></div>\n<p>对于非GC类型的对象，<em>get/set</em> 不用转型，直接访问即可，如：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#define settt_(o,t)\t((o)-&gt;tt_=(t))\n<p>#define setfltvalue(obj,x)<br />\n&#123; TValue *io=(obj); val_(io).n=(x); settt_(io, LUA_TNUMFLT); &#125;</p>\n<p>#define chgfltvalue(obj,x)<br />\n&#123; TValue *io=(obj); lua_assert(ttisfloat(io)); val_(io).n=(x); &#125;</p>\n<p>#define setivalue(obj,x)<br />\n&#123; TValue *io=(obj); val_(io).i=(x); settt_(io, LUA_TNUMINT); &#125;<br />\n</code></pre></div></div></p>\n<p>但是GC类型需要特殊处理一下， 因为他们本身是一种”继承“的复合类型，如string的定义：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  /*\n** Header for string value; string bytes follow the end of this structure\n** (aligned according to &#39;UTString&#39;; see next).\n*/\ntypedef struct TString &#123;\n  CommonHeader;\n  lu_byte extra;  /* reserved words for short strings; &#34;has hash&#34; for longs */\n  lu_byte shrlen;  /* length for short strings */\n  unsigned int hash;\n  union &#123;\n    size_t lnglen;  /* length for long strings */\n    struct TString *hnext;  /* linked list for hash table */\n  &#125; u;\n&#125; TString;\n<p>/*<br />\n** Ensures that address after this type is always fully aligned.<br />\n<em>/<br />\ntypedef union UTString &#123;<br />\nL_Umaxalign dummy;  /</em> ensures maximum alignment for strings */<br />\nTString tsv;<br />\n&#125; UTString;</p>\n<p></code></pre></div></div></p>\n<p>复杂的GCObject类型数据访问方式需要特使处理，TString 内存结构： TString+rawData, 其中rawData就是真正存数据的内存，所以分配过程：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>static TString *createstrobj (lua_State *L, size_t l, int tag, unsigned int h) {\n  TString *ts;\n  GCObject *o;\n  size_t totalsize;  /* total size of TString object */\n  totalsize = sizelstring(l);\n  o = luaC_newobj(L, tag, totalsize);\n  ts = gco2ts(o);\n  ts-&gt;hash = h;\n  ts-&gt;extra = 0;\n  getstr(ts)[l] = &#39;","text":"前言 接触lua近4年了，一直断断续续读相关源码，这次计划把lua源码整体分析一遍，基于最新版本(Lua 5.3.5), 完成如下文章（顺序可能不一致）： 基本数据类型 string/table 剖析 luavm 分析 lexer/ast/gencode 词法分析/语法树/生成字...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#lua%E6%BA%90%E7%A0%81%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">lua源码简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#lua%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E6%8B%AC\"><span class=\"toc-text\">Lua数据类型概括</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#lua%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">Lua数据类型结构体定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#lua-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%97%E6%AE%B5getset-%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">Lua 数据结构字段get&#x2F;set 封装</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Nginx 使用 lua","uid":"b2a7e9b111087d85b75d3fcb8b23cc07","slug":"zl/2016-01-01-937_Nginx 使用 lua","date":"2024-04-03T03:47:36.207Z","updated":"2024-04-03T03:47:36.208Z","comments":true,"path":"api/articles/zl/2016-01-01-937_Nginx 使用 lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 1. 软件版本 2. 环境准备 3. 软件安装 4. 配置lua脚本 5. 配置php 6. 配置日志，记录post请求的request_body 和response_body 1. 软件版本 系统 centos6.7X86_64 nginx 1.11.5 lua-nginx-...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"LuaTable判空","uid":"32bbc491153d9d789c957531761cb91b","slug":"zl/2016-01-01-933_LuaTable判空","date":"2024-04-03T03:47:36.206Z","updated":"2024-04-03T03:47:36.206Z","comments":true,"path":"api/articles/zl/2016-01-01-933_LuaTable判空.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua判断表为空t = {}的逻辑1if next(a) == nil thennext(table[,index]) 运行程序来遍历表中的所有域。 第一个参数是要遍历的表，第二个参数是表中的某个键。 next 返回该键的下一个键及其关联的值。 如果用 nil 作为第二个参数调用...","link":"","photos":[],"count_time":{"symbolsCount":742,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}