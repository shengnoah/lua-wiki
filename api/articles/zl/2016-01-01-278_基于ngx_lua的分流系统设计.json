{"title":"基于ngx_lua的分流系统设计","uid":"772134e6021c5f0f3a759af6775d6b20","slug":"zl/2016-01-01-278_基于ngx_lua的分流系统设计","date":"2024-04-03T03:47:33.138Z","updated":"2024-04-03T03:47:33.138Z","comments":true,"path":"api/articles/zl/2016-01-01-278_基于ngx_lua的分流系统设计.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>    &lt;h3 id=&quot;导言&quot;&gt;&lt;a href=&quot;https://fankeke.github.io/#%E5%AF%BC%E8%A8%80&quot; class=&quot;headerlink&quot; title=&quot;导言&quot;&gt;&lt;/a&gt;导言&lt;/h3&gt;&lt;p&gt;为了在接入层面做到对请求精细化的控制和导流，需要在nginx上做分流的工作，解决包括但不限于几种需求，如版本上线，灰度发布、特殊用户，特殊版本等。其工作流程如下：&lt;/p&gt;\n</code></pre>\n<p><img src=\"https://fankeke.github.io/img/%E5%9F%BA%E4%BA%8Engx_lua%E7%9A%84%E5%88%86%E6%B5%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1.png\" alt=\"\"></p>\n<p>在业务侧，可以根据需求将其业务节点划分为组，可以按照自己定制的策略来反馈给nginx，根据需求来导流相应分组。</p>\n<h3 id=\"NGINX＋Lua实现\"><a href=\"https://fankeke.github.io/#NGINX%EF%BC%8BLua%E5%AE%9E%E7%8E%B0\" class=\"headerlink\" title=\"NGINX＋Lua实现\"></a>NGINX＋Lua实现</h3><h4 id=\"方案预期\"><a href=\"https://fankeke.github.io/#%E6%96%B9%E6%A1%88%E9%A2%84%E6%9C%9F\" class=\"headerlink\" title=\"方案预期\"></a>方案预期</h4><p>在到达分流目的同时，需要有到达其它几个目的：<br>1 配置方便，兼容其它功能<br>如果某个服务需要接入分流系统，SRE可以清晰清楚且便捷的配置即可，不会影响其它的功能，不需要有其它冗余的操作或交流。</p>\n<p>2 提供降级开关<br>响应业务需求，SRE或者业务需求发能够方便地选择开启或者关闭某个分流需求，甚至不需要对nginx做重启操作</p>\n<p>3 即配即走，不重启NGINX<br>我们希望能够到达即配即走的效果，不重启NGINX。（当然接入分流系统时配置文档的变更，SRE需要重启）<br>（事实上如果业务接入了其它lua的功能，那么连配置都不用更改，直接走新的Lua框架即可生效）</p>\n<p>4 系统轻巧，耦合度低<br>希望将系统做的足够轻巧，能够掌握整改分流过程和生效过程，方便及时排查问题，不影响其它业务。</p>\n<p>5 高容错性<br>系统不应该对请求有伤害，包括系统不可用时、分流集群不合法时等意外情况下，都要保重请求的正常。</p>\n<p>6 流量统计<br>能够从对分流情况有明确的感知和了解，包括每个分流集群的qps、响应时间等。</p>\n<h3 id=\"方案设计\"><a href=\"https://fankeke.github.io/#%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1\" class=\"headerlink\" title=\"方案设计\"></a>方案设计</h3><h4 id=\"方案架构\"><a href=\"https://fankeke.github.io/#%E6%96%B9%E6%A1%88%E6%9E%B6%E6%9E%84\" class=\"headerlink\" title=\"方案架构\"></a>方案架构</h4><p>为了达到上面几个目的，构件了一套轻巧的系统。核心思想为表驱动的方式：以业务的appkey为索引，通过查表找出该业务需要分流的策略，将具体分流策略下放，加载策略进行分流。</p>\n<p><img src=\"https://fankeke.github.io/img/%E5%9F%BA%E4%BA%8Engx_lua%E7%9A%84%E5%88%86%E6%B5%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/2.png\" alt=\"\"></p>\n<p>在请求来临时，取出appkey，查找分流数据，执行分流策略。每个不同的分流逻辑在不同的分流文档里面完成。<br>该表时刻处于变化中，从第三方存储中定时加载到nginx共享内存。其分流流程如下：</p>\n<p><img src=\"https://fankeke.github.io/img/%E5%9F%BA%E4%BA%8Engx_lua%E7%9A%84%E5%88%86%E6%B5%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/3.png\" alt=\"\"></p>\n<p>分流数据的更新逻辑如下：<br>方案一：<br><img src=\"https://fankeke.github.io/img/%E5%9F%BA%E4%BA%8Engx_lua%E7%9A%84%E5%88%86%E6%B5%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/4.png\" alt=\"\"></p>\n<p>当管理机把更新的表推送到redis后，每个nginx会从redis里面定时拉取该表，缓存入nginx的共享内存。<br>该方案优势：<br>1 每个分流的Nginx都可以自己拉取，只要有定时拉取的逻辑<br>存在的问题：<br>1 单个worker拉取，需要patch tengine源码，担心会造成问题<br>2 每个nginx定时轮询，且定时时间短</p>\n<p>方案二：<br><img src=\"https://fankeke.github.io/img/%E5%9F%BA%E4%BA%8Engx_lua%E7%9A%84%E5%88%86%E6%B5%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/5.png\" alt=\"\"><br>通过http接口，在每次数据真正变更时候走http来更新每个分流nginx的内存，并将最新的一份数据存储在redis里面容灾。<br>优势：<br>1 不用定时器，即不需patch源码<br>2 在数据真正变动时进行更新，没有无谓轮询。</p>","text":" &lt;h3 id=&quot;导言&quot;&gt;&lt;a href=&quot;https://fankeke.github.io/#%E5%AF%BC%E8%A8%80&quot; class=&quot;headerlink&quot; title=&quot;导...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#NGINX%EF%BC%8BLua%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">NGINX＋Lua实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%A1%88%E9%A2%84%E6%9C%9F\"><span class=\"toc-text\">方案预期</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">方案设计</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%A1%88%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">方案架构</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua源码阅读：命令的解析与执行","uid":"9363a15236ec28e0fce435700581c713","slug":"zl/2016-01-01-279_Lua源码阅读：命令的解析与执行","date":"2024-04-03T03:47:33.138Z","updated":"2024-04-03T03:47:33.138Z","comments":true,"path":"api/articles/zl/2016-01-01-279_Lua源码阅读：命令的解析与执行.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;具体分析文档如何被解析、生成对应命令以及到虚拟机执行的流程。&lt;/p&gt; Lua词法：Lua使用一遍扫描代码文档的方式生成字节码，即在第一遍扫描代码的时候就生成字节码了，这么做主要是为了加快解释执行的速度。 赋值类命令：局部变量：lua代码： 1loc...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua编程4之表达式和语句","uid":"673ce118e6bfa2b1bda337e3ee7a4f70","slug":"zl/2016-01-01-275_Lua编程4之表达式和语句","date":"2024-04-03T03:47:33.137Z","updated":"2024-04-03T03:47:33.137Z","comments":true,"path":"api/articles/zl/2016-01-01-275_Lua编程4之表达式和语句.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;思考并回答以下问题：&lt;br&gt;1.如何创建一个空表？&lt;/p&gt; 学习了数据类型和变量之后，就可以开始写代码的表达式，然后进一步写语句了。 算术操作符Lua支持常规算术操作符有：二元的“+”、“-”、“*”、“/”、“^”(指数)、“%”(取...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}