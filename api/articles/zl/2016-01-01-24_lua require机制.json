{"title":"lua require机制","uid":"fc07d610e727a4dac9a13d0c264a8534","slug":"zl/2016-01-01-24_lua require机制","date":"2024-04-03T03:47:33.117Z","updated":"2024-04-03T03:47:33.117Z","comments":true,"path":"api/articles/zl/2016-01-01-24_lua require机制.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>require(modname)</p>\n<p>加载给定的模块.函数首先检查表package.loaded来判定modname是否已经存在.</p>\n<p>如果存在,则require返回package.loaded[modname]所存储的值否则它尝试为模块找到一个加载器(loader).</p>\n<p>要找到一个加载器,require首先查询package.preloaded[modname].如果它有值,该值(应该是一个函数)就是加载器.</p>\n<p>如果没值require使用package.path中存储的路径查找一个Lua的加载器.如果该查找也失败,它使用package.cpath中</p>\n<p>存储的路径查找一个C语言加载器(C loader).如果还是失败,它尝试使用all-in-one加载器(如下)</p>\n<p>当加载一个C库的时候,require首先使用动态链接工具将应用程序与库连接起来.之后它尝试找到一个该库中的C函数,该函数要被当做加载器使用.这个C函数的名称是字符串”luaopen_”连接着复制的模块名(模块名称中的每个点号”.”都被替换为一个下划线).此外,如果模块名称含有连字符”-“,则第一个连字符的前缀(包括连字符)都被移除.比如,如果模块名称是a.v1-b.c,则函数名称将是luaopen_b_c.</p>\n<p>如果require即没有为模块找到一个Lua库也没有为模块找到一个C库,他将调用all-in-one加载器.该加载器为给定模块的根名称查找C路径找到对应库(原文:this loader searches the C path for a library for the root name of the given module).例如,当require a.b.c时,它将为a查找一个库.如果找到,它查询该库内部为子模块找到一个开放函数(open function);在我们这个例子中将会是luaopen_a_b_c.使用这个便利机制(facility),一个包可以将几个子模块打包进单个的库中,同时每个子模块保存着它本来的开放函数.</p>\n<p>一旦找到一个加载器,require使用单个的参数modname调用加载器.如果加载器返回任何值,require将其赋值给package.loaded[modname].</p>\n<p>如果加载器没有返回值且没有给package.loaded[modname]赋与任何值,则require为该条目赋值为true.</p>\n<p>无论如何,require返回package.loaded[modname]的最终值.</p>\n<p>如果加载或者运行模块有任何错误,或者他不能为模块找到一个加载器,则require发出一个错误信号.</p>\n<p>require函数的实现原理如下:</p>\n<ol>\n<li>–require 函数的实现  </li>\n<li>function require(name)  </li>\n<li>​    if not package.loaded[name] then    –是否在package.loaded中存在name</li>\n<li>​        local loader = findloader(name) –不存在则查找加载器 </li>\n<li>​        if loader == nil then  </li>\n<li>​            error(“unable to load module” .. name)  </li>\n<li>​        end  </li>\n<li>​        package.loaded[name] = true     –加载器不存在 设置true</li>\n<li>​        local res = loader(name)        –加载</li>\n<li>​        if res ~= nil then  </li>\n<li>​            package.loaded[name] = res  –加载返回的值给你 package.loaded</li>\n<li>​        end  </li>\n<li>​    end  </li>\n<li>​    return package.loaded[name]         –返回 package.loaded[name]</li>\n<li>end  </li>\n</ol>\n<p>package.cpath</p>\n<p>由require使用查找C加载器的路径</p>\n<p>Lua初始化C路径package.cpath的方法与初始化Lua路径package.path的相同,使用LUA_CPATH中的环境变量(另外一个默认的路径在luaconf.h中定义)</p>\n<p>package.loaded</p>\n<p>一个用于控制哪些模块已经加载的表,该表由require使用.当require一个模块名为modname的模块且package.loaded[modname]不为false时,require仅返回package.loaded[modname]存储的值.</p>\n<p>package.loadlib(libname,funcname)</p>\n<p>使用C库libname动态链接到宿主程序.在这个库中,寻找函数funcname并将该函数作为一个C函数返回.(所以,funcname必须遵守协议(参见lua_CFunction)).</p>\n<p>这是一个底层函数.它完全绕过了package和module系统.与require不同,它不执行任何路径查找且不自动添加扩展名.libname必须是C库中完整的文件名,如果必要的话还要包含路径和扩展名.funcname必须是原封不动的C库中导出的名字(这可能取决于使用的C编译器和链接器).</p>\n<p>这个函数不被ANSI C支持.就其本身而言,它只在一些平台上才能使用(Windows,Linux,Mac OS X,Solaris,BSD,加上其他支持dlfcn标准的Unix系统)</p>\n<p>package.path</p>\n<p>require用于查找Lua加载器的路径</p>\n<p>在启动时,Lua使用环境变量LUA_PATH或者如果环境变量未定义就使用luaconf.h中定义的默认值来初始化该值.环境变量中的任何”::”都被替换为默认路径.</p>\n<p>路径是一系列由分号隔开的模板(templates).对于每个模板,require将每个模板中的问号替换为filename,filename是modname中每个点都被替换成”目录分隔符”(比如Unix中的”/“)(这句感觉翻译不准确,原文:For each template,require will change each interrogation mark in the template by filename,which is modname with each dot replaced by a “directory separator”(such as “/“ in Unix));之后他将加载产生的文件名.因此,举个例子,如果Lua路径是”./?.lua;./?.lc;/usr/local/?/init.lua”,为模块foo查找一个Lua加载器将会尝试以如下顺序加载文件./foo.lua,./foo.lc和/usr/local/foo/init.lua</p>\n<p>package.preload</p>\n<p>为特定模块存储加载器的一个表(参见require)</p>\n<p>package.seeall(module)</p>\n<p>为module设置一个元表,module的__index只想全局环境(global environment),以便该module继承全局环境中的值.作为函数module中的一个选项来使用.</p>\n<p>在Programming Lua中是这么讲的:</p>\n<p>默认情况下,module不提供外部访问.必须在调用它之前,为需要访问的外部函数或模块声明适当的局部变量.也可以通过继承来实现外部访问,只需在调用module时附加一个选项package.seeall.这个选项等价于如下代码:</p>\n<ol>\n<li>setmetatable(M,{__index = _G})  </li>\n</ol>\n<p>因而只需这么做:</p>\n<ol>\n<li>module(…,package.seeall)  </li>\n</ol>\n<p>module(name,[,…])</p>\n<p>创建一个模块.如果在package.loaded[name]中有表,该表便是创建的模块.否则,如果有一个全局表t其名称与给定名称相同,则该全局表便是创建的模块.否则创建一个新的表t</p>\n<p>lua中import和require的区别</p>\n<p>载入一个模块</p>\n<p>import() 与 require() 功能相同，但具有一定程度的自动化特性。</p>\n<p>假设有如下的目录结构：</p>\n<p>app/</p>\n<p>app/classes/</p>\n<p>app/classes/MyClass.luaapp/classes/MyClassBase.luaapp/classes/data/Data1.luaapp/classes/data/Data2.lua</p>\n<p>MyClass 中需要载入 MyClassBase 和 MyClassData。如果用 require()，MyClass 内的代码如下：</p>\n<p>local MyClassBase = require(“app.classes.MyClassBase”)</p>\n<p>local MyClass = class(“MyClass”, MyClassBase)</p>\n<p>local Data1 = require(“app.classes.data.Data1”)</p>\n<p>local Data2 = require(“app.classes.data.Data2”)</p>\n<p>假如将 MyClass 及其相关文件换一个目录存放，那么就必须修改 MyClass 中的 require() 命令，否则将找不到模块文件。</p>\n<p>而使用 import()，只需要如下写：</p>\n<p>local MyClassBase = import(“.MyClassBase”)</p>\n<p>local MyClass = class(“MyClass”, MyClassBase)</p>\n<p>local Data1 = import(“.data.Data1”)</p>\n<p>local Data2 = import(“.data.Data2”)</p>\n<p>当在模块名前面有一个”.” 时，import() 会从当前模块所在目录中查找其他模块。因此 MyClass 及其相关文件不管存放到什么目录里，都不再需要修改 MyClass 中的 import() 命令。这在开发一些重复使用的功能组件时，会非常方便。</p>\n<p>可以在模块名前添加多个”.” ，这样 import() 会从更上层的目录开始查找模块。</p>\n<p>不过 import() 只有在模块级别调用（也就是没有将 import() 写在任何函数中）时，才能够自动得到当前模块名。如果需要在函数中调用 import()，那么就需要指定当前模块名：</p>\n<p># MyClass.lua</p>\n<p># 这里的 … 是隐藏参数，包含了当前模块的名字，所以最好将这行代码写在模块的第一行</p>\n<p>local CURRENT_MODULE_NAME = …</p>\n<p>local function testLoad() local MyClassBase = import(“.MyClassBase”, CURRENT_MODULE_NAME)</p>\n<p># 更多代码</p>\n<p>end</p>\n<p>Parameters</p>\n<p>string moduleName 要载入的模块的名字</p>\n<p>[string currentModuleName]</p>\n<p>当前模块名</p>\n<p>Returns</p>\n<p>module</p>","text":"require(modname) 加载给定的模块.函数首先检查表package.loaded来判定modname是否已经存在. 如果存在,则require返回package.loaded[modname]所存储的值否则它尝试为模块找到一个加载器(loader). 要找到一个加载器...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua c api","uid":"a088e52eeedd5a2e08a78395ae73ef54","slug":"zl/2016-01-01-252_lua c api ","date":"2024-04-03T03:47:33.118Z","updated":"2024-04-03T03:47:33.119Z","comments":true,"path":"api/articles/zl/2016-01-01-252_lua c api .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 一 概述 在 C 中使用 API 通过栈操作表或数组类型的数据，本篇使用示例来演示如果通过栈来操作表。 二 渠道秘钥更新 set_channel_key 函数接收一个 table 作为参数，从 table 中获取 channel_name 的值作为 key，之后从动态库的全局渠...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua中的深拷贝与浅拷贝","uid":"08ce81cf0af59271fcc247bbc48f18d2","slug":"zl/2016-01-01-250_Lua中的深拷贝与浅拷贝","date":"2024-04-03T03:47:33.117Z","updated":"2024-04-03T03:47:33.118Z","comments":true,"path":"api/articles/zl/2016-01-01-250_Lua中的深拷贝与浅拷贝.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;有关深拷贝、浅拷贝在Lua中的一系列事情。&lt;/p&gt; 为什么要写深拷贝：在《Lua进程设计（第四版）》第五章开头，作者描述了表的性质： 已经描述的很清楚了，对于表的操作，Lua语言不会进行深拷贝（即Lua语言拷贝的是对象的引用而非整个对象本身。） 先...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}