{"title":"Lua 正确处理可变参数","uid":"9073ce92e645b93c4caec3a7c43f9966","slug":"zl/2016-01-01-260_Lua 正确处理可变参数 ","date":"2024-04-03T03:47:33.122Z","updated":"2024-04-03T03:47:33.123Z","comments":true,"path":"api/articles/zl/2016-01-01-260_Lua 正确处理可变参数 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>\t\t\t&lt;p&gt;为了在 Lua 里处理可变参数，我们可能会写下面这样的代码：&lt;/p&gt;\n</code></pre>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">local</span> <span class=\"k\">function</span> <span class=\"nf\">args</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"nb\">next</span><span class=\"p\">(&#123;</span><span class=\"o\">...</span><span class=\"p\">&#125;)</span> <span class=\"k\">then</span>\n        <span class=\"k\">for</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"k\">in</span> <span class=\"nb\">ipairs</span><span class=\"p\">&#123;</span><span class=\"o\">...</span><span class=\"p\">&#125;</span> <span class=\"k\">do</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">else</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"empty var\"</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n<p><span class=\"n\">args</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">30</span><span class=\"p\">)</span></p>\n<p><span class=\"c1\">– output:</span><br />\n<span class=\"c1\">– 10</span><br />\n<span class=\"c1\">– 20</span><br />\n<span class=\"c1\">– 30</span><br />\n</code></pre></div></div></p>\n<p>咋一看，貌似没什么问题，但是当传入 <code class=\"highlighter-rouge\">args(10, nil, 30)</code> 时，发现并不符合我们的预期：</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">-- output:</span>\n<span class=\"c1\">-- 10</span>\n</code></pre></div></div>\n<p>原因就在于 <code class=\"highlighter-rouge\">ipairs</code> 遍历的 table 必须是一个序列。序列的数字索引必须连续。table 中间包括 <code class=\"highlighter-rouge\">nil</code>，这样的 table 就不是序列，例如：<code class=\"highlighter-rouge\">a=&#123;10, nil, 30&#125;</code> 它不是序列，因为它的数字索引是 1 3 不是连续的, 所以它不是序列。为了处理这个问题，就要引入 <code class=\"highlighter-rouge\">select</code> 了。</p>\n<p>调用 <code class=\"highlighter-rouge\">select</code> 时，需要传入一个 selector 和变长参数。如果 selector 为数字 n, 那么 <code class=\"highlighter-rouge\">select</code> 返回它的第 n 个可变实参，否则只能为字符串 #, 这样 <code class=\"highlighter-rouge\">select</code> 会返回变长参数的总数。</p>\n<p>增强后的函数为：</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">local</span> <span class=\"k\">function</span> <span class=\"nf\">args</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"nb\">next</span><span class=\"p\">(&#123;</span><span class=\"o\">...</span><span class=\"p\">&#125;)</span> <span class=\"k\">then</span>\n        <span class=\"c1\">-- get the count of the params</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">select</span><span class=\"p\">(</span><span class=\"s1\">'#'</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span> <span class=\"k\">do</span>\n            <span class=\"c1\">-- select the param</span>\n            <span class=\"kd\">local</span> <span class=\"n\">param</span> <span class=\"o\">=</span> <span class=\"nb\">select</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">param</span><span class=\"p\">)</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">else</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"empty var\"</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n<p><span class=\"n\">args</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"kc\">nil</span><span class=\"p\">,</span> <span class=\"mi\">30</span><span class=\"p\">)</span></p>\n<p><span class=\"c1\">– output:</span><br />\n<span class=\"c1\">– 10</span><br />\n<span class=\"c1\">– nil</span><br />\n<span class=\"c1\">– 30</span><br />\n</code></pre></div></div></p>\n<p><strong>我个人认为 <code class=\"highlighter-rouge\">pairs</code> 对 <code class=\"highlighter-rouge\">nil</code> 的表达能力是极其有限的</strong>，比如这个用例：</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">local</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"p\">&#123;</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"kc\">nil</span><span class=\"p\">,</span> <span class=\"mi\">30</span><span class=\"p\">&#125;</span>\n<p><span class=\"k\">for</span> <span class=\"n\">k</span><span class=\"p\">,</span><span class=\"n\">v</span> <span class=\"k\">in</span> <span class=\"nb\">pairs</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"k\">do</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">“in”</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span><span class=\"n\">v</span><span class=\"p\">)</span><br />\n<span class=\"k\">end</span></p>\n<p><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">“=============”</span><span class=\"p\">)</span></p>\n<p><span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">select</span><span class=\"p\">(</span><span class=\"s1\">‘#’</span><span class=\"p\">,</span> <span class=\"n\">unpack</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">))</span> <span class=\"k\">do</span><br />\n<span class=\"kd\">local</span> <span class=\"n\">param</span> <span class=\"o\">=</span> <span class=\"nb\">select</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">unpack</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">))</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">param</span><span class=\"p\">)</span><br />\n<span class=\"k\">end</span></p>\n<p><span class=\"c1\">– output:</span><br />\n<span class=\"c1\">– in\t1\t10</span><br />\n<span class=\"c1\">– in\t3\t30</span><br />\n<span class=\"c1\">– =============</span><br />\n<span class=\"c1\">– 10</span><br />\n<span class=\"c1\">– nil</span><br />\n<span class=\"c1\">– 30</span><br />\n</code></pre></div></div></p>\n<p>可以看到 <code class=\"highlighter-rouge\">pairs</code> 只遍历了两次，1 =&gt; 10、3 =&gt; 20 其并没有表现出 2 =&gt; nil ，虽然我们可以从结果来推断出这个结论，但是显然，在某些场景下我们更需要的是直接还原出这个结果来。这其实和 cjson 的稀松数组类似。</p>\n<p>而使用 <code class=\"highlighter-rouge\">select</code> 后，我们就可以直接看到期待的效果了。</p>\n<pre><code>            &lt;hr style=&quot;visibility: hidden;&quot;&gt;\n</code></pre>\n","text":" &lt;p&gt;为了在 Lua 里处理可变参数，我们可能会写下面这样的代码：&lt;/p&gt; local function args(...) if next(&#123;...&#125;) then for _, v in ipairs&#123;...&#125; ...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 面向对象","uid":"556bb9604a5d13d5fc4856d4cf15bf71","slug":"zl/2016-01-01-25_Lua 面向对象","date":"2024-04-03T03:47:33.122Z","updated":"2024-04-03T03:47:33.122Z","comments":true,"path":"api/articles/zl/2016-01-01-25_Lua 面向对象.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 隐藏 self 参数 用 lua 进行面向对象的编程 声明方法和调用方法统一用 &#34;:&#34; 属性的定义和调用全部用 &#34;.&#34; 定义的时候冒号默认接收 self 参数，调用的时候默认传递调用者自身作为参数，而点号要显式传递或接收 self 参数。 一个简...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua","uid":"df60e476b394b1dd4755ec96c53302ff","slug":"zl/2016-01-01-258_lua","date":"2024-04-03T03:47:33.121Z","updated":"2024-04-03T03:47:33.121Z","comments":true,"path":"api/articles/zl/2016-01-01-258_lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;Lua支持两种形式的函数调用，一种对调用过程的堆栈进行保护，即使中间过程出错，也不至于让进程退出，也就是pcall，一般在使用C调用Lua写的脚本函数时，都采用pcall方式。&lt;/p&gt; 对比起一般的函数调用方式，pcall多做了这些事情： 对函数调...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}