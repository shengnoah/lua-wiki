{"title":"Lua_Trace 1. Lua数据结构","uid":"2255485e32f4f4f9bb0be992fedc2297","slug":"zl/2016-01-01-4_[Lua_Trace] 1. Lua数据结构 ","date":"2024-04-03T03:47:35.779Z","updated":"2024-04-03T03:47:35.779Z","comments":true,"path":"api/articles/zl/2016-01-01-4_[Lua_Trace] 1. Lua数据结构 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>                    &lt;p&gt;摘要:[Lua_Trace] 1. Lua数据结构 - TValue&lt;/p&gt;\n                &lt;br /&gt;\n                &lt;p&gt;\n欲深入了解Lua，我认为先从数据结构开始是必要的，&lt;/p&gt;\n</code></pre>\n<p>\n\t本文将由Lua基础数据结构(TValue)讲起, 进而衍生至TString, Table ⋯ 等。</p>\n<p>\n\t此源码分析的版本为 : <strong>Lua 5.3.1</strong></p>\n<p>\n</p>\n<p>\n\t<strong>1. TValue : 基础数据</strong></p>\n<p>\n\tLua中所有的数据结构都由TValue衍伸，以OO的概念来看它就有点像是基底类(abstract)般的存在着，因此采C语言来模拟,就是定义出一个通用的结构体作为”父类”,然后子类的结构体中以这个父类作为结构体的第一个成员变量。</p>\n<pre><code>\n//lobject.h\n<p>typedef struct lua_TValue TValue;</p>\n<p>struct lua_TValue &#123;<br />\nTValuefields;<br />\n&#125;;</p>\n<p>/*<br />\nTagged Values. This is the basic representation of values in Lua,<br />\nan actual value plus a tag with its type.<br />\n*/<br />\n#define TValuefields\tValue value_; int tt_</code></pre></p>\n<p>\n\ttt_可再区分为 tt (low byte) &amp; marked (hight byte)，前者表示数据的类型(详细可见下表)，后者则是GC回收用途的标记(marked)。</p>\n<p>\n <img border=\"0\" src=\"https://az787680.vo.msecnd.net/user/iounegpf/1507/20157316011406.png\"></p>\n<p>\n\tvalue_则是存放各种数据，事实上Lua将数据区分为两大类：</p>\n<p>\n\t1. 原始类型 : 透过C语言表示的对应类型，例：void *p表示 light userdata、int 表示 boolean、double 表示 lua_Number‧‧‧等。</p>\n<p>\n                     因此如为原始类型的数据，则根据其tt_类型将数据对应的置于Value union中的 p (void *), b (int), f(lua_CFunction), i (lua_Integer), n(lua_Number)中。\n<p>\n\t2. 可被GC回收类型 : 统一使用GCObject的指针表示。</p>\n<pre><code>\n//lobject.h\n<p>union Value &#123;<br />\nGCObject <em>gc;    /</em> collectable objects */<br />\nvoid <em>p;         /</em> light userdata <em>/<br />\nint b;           /</em> booleans <em>/<br />\nlua_CFunction f; /</em> light C functions <em>/<br />\nlua_Integer i;   /</em> integer numbers <em>/<br />\nlua_Number n;    /</em> float numbers */<br />\n&#125;;</p>\n<p></code></pre></p>\n<p>\n\tGCObject的成员由 GCObject指针*next, 数据类型tt与回收标签marked组成， 其中tt与marked两者同TValue中的tt_定义，也是为了识别该数据的类型。</p>\n<p>\n\t可被GC回收的数据类型都有个共同点就是其结构的第一个成员皆是CommonHeader，此手法同前面提到OO概念，在Lua源码中算是蛮常见的，因此CommonHeader可算是所有GC回收类型的父类。</p>\n<pre><code>\n/*\n Common type has only the common header\n*/\nstruct GCObject &#123;\n  CommonHeader;\n&#125;;\n<p>/*<br />\nCommon Header for all collectable objects (in macro form, to be<br />\nincluded in other objects)<br />\n*/<br />\n#define CommonHeader\tGCObject *next; lu_byte tt; lu_byte marked</code></pre></p>\n<p>\n</p>\n<p>\n\t<strong>GCUnion : 专针对GC类型进行转型的数据结构</strong></p>\n<pre><code>\n//lstate.h\n<p>/*<br />\nUnion of all collectable objects (only for conversions)<br />\n<em>/<br />\nunion GCUnion &#123;<br />\nGCObject gc;  /</em> common header <em>/<br />\nstruct TString ts;<br />\nstruct Udata u;<br />\nunion Closure cl;<br />\nstruct Table h;<br />\nstruct Proto p;<br />\nstruct lua_State th;  /</em> thread */<br />\n&#125;;</code></pre></p>\n<p>\n\t一些会被GC回收的类型都集合在GCUnion中  (ex : TString, Udata, Closure, Table, Proto, lua_State)</p>\n<p>\n\t相对的，GC回收的数据类型中它的第一项元素往往是CommonHeader (GCObject的共有定义，前面也才刚提到)</p>\n<p>\n\t事实上GCUnion的主用功能是拿来转型之用，由于在Lua栈上的数据都视为TValue</p>\n<p>\n\t故Lua运用一些定义(define)协助转型(ex : hvalue)，而这过程中常透过GCUnion来取回数据的真实类型。</p>\n<p>\n\t例如 :  Table -> TValue -> GCUnion - > Table</p>\n<p>\n\t上述原Table类型的变量可能因为被存入栈中后被统一视为TValue，</p>\n<p>\n\t因此如果需要正确的将TValue转型为Table则可透过 hvalue (如下程序) 协助，仔细追朔其中不难发现它最后都会透过GCUnion来达到正确的类型。</p>\n<pre><code>\n//lvm.c\n<p>Table *h = hvalue(t);</p>\n<p><a href=\"//lobject.h\">//lobject.h</a></p>\n<p>#define hvalue(o)\tcheck_exp(ttistable(o), gco2t(val_(o).gc))</p>\n<p>#define val_(o)\t\t((o)-&gt;value_)</p>\n<p><a href=\"//lstate.h\">//lstate.h</a></p>\n<p>#define gco2t(o)  check_exp((o)-&gt;tt == LUA_TTABLE, &amp;((cast_u(o))-&gt;h))</p>\n<p>#define cast_u(o)\tcast(union GCUnion *, (o))</p>\n<p></code></pre></p>\n<p>\n\t有任何错误请指正，后续我将尽可能的再补充详细</p>","text":" &lt;p&gt;摘要:[Lua_Trace] 1. Lua数据结构 - TValue&lt;/p&gt; &lt;br /&gt; &lt;p&gt; 欲深入了解Lua，我认为先从数据结构开始是必要的，&lt;/p&gt; 本文将由Lua基础数据结构(TValue)讲起, 进...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"OpenResty Lua Stream实现分析","uid":"a59ecef36dd992daa5cb5fac1da10766","slug":"zl/2016-01-01-501_OpenResty Lua Stream实现分析","date":"2024-04-03T03:47:35.781Z","updated":"2024-04-03T03:47:35.782Z","comments":true,"path":"api/articles/zl/2016-01-01-501_OpenResty Lua Stream实现分析.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"OpenResty（以下简称OR）是Lua应用的典范，其最大的亮点在于，使用Lua协程搭配上异步非阻塞的IO，这样开发者可以使用同步方式来编写代码，而底层IO调度、唤醒等操作留给C编写的引擎层。 实际上，使用类协程的技术，让异步操作同步化，已经有很多相关的技术了，比如腾讯的lib...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"tolua++安装","uid":"0f6d71b477132b063b4c2ff5fbac2c35","slug":"zl/2016-01-01-49_tolua++安装","date":"2024-04-03T03:47:35.778Z","updated":"2024-04-03T03:47:35.778Z","comments":true,"path":"api/articles/zl/2016-01-01-49_tolua++安装.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;a href=&quot;/2015/11/11/lua_cpp_bind/&quot; rel=&quot;next&quot; title=&quot;C++与Lua本质原始交互API&quot;&gt; &lt;i class=&quot;fa fa-chevro...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}