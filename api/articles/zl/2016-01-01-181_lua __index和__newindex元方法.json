{"title":"lua __index和__newindex元方法","uid":"2de21734b2aaee59ca84e1dec23909a3","slug":"zl/2016-01-01-181_lua __index和__newindex元方法","date":"2024-04-03T03:47:33.069Z","updated":"2024-04-03T03:47:33.069Z","comments":true,"path":"api/articles/zl/2016-01-01-181_lua __index和__newindex元方法.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>          &lt;h1 id=&quot;__index&quot;&gt;__index&lt;/h1&gt;\n</code></pre>\n<ul>\n  <li>当访问一个table的字段时，如果存在这个字段，则返回这个字段的值</li>\n  <li>如果没有这个字段，则会让解释器去查找<strong>__index</strong>元方法，如果存在此元方法，则会调用它，返回结果</li>\n  <li>如果没有这个元方法，返回nil</li>\n  <li>\n<strong>__index</strong>元方法可以是table，也可以是函数，是table的话就从table里面去找值</li>\n  <li>注意，是table中没有这个字段才会触发此元方法</li>\n</ul>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">local</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"p\">&#123;</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">&#125;</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">c</span><span class=\"p\">)</span>  <span class=\"c1\">--nil</span>\n<p><span class=\"c1\">–setmetatable(t, &#123;&#125;)</span><br />\n<span class=\"c1\">–print(t.c)  --nil</span></p>\n<p><span class=\"cm\">–[[<br />\nlocal tt = &#123;c=3&#125;<br />\n–__index元方法是一个table<br />\nsetmetatable(t, &#123;__index = tt&#125;)<br />\nprint(t.c) – 3<br />\ntt.c = 4<br />\nprint(t.c) – 4<br />\n]]</span></p>\n<p><span class=\"cm\">–[[<br />\nsetmetatable(t, &#123;__index = function ( tbl, key )<br />\nprint(&quot;t __index &quot;, key)<br />\nreturn 6<br />\nend&#125;)<br />\nprint(t.c)</p>\n<p>–输出<br />\n– t __index       c<br />\n– 6<br />\n]]</span></p>\n<p><span class=\"cm\">–[[<br />\nlocal tt = &#123;&#125;<br />\nsetmetatable(tt, &#123;__index = function ( tbl, key )<br />\nprint(&quot;tt __index &quot;, key)<br />\nend&#125;)</p>\n<p>setmetatable(t, &#123;__index = tt&#125;)</p>\n<p>print(t.c)<br />\nprint(t.a)<br />\n–输出<br />\n– tt __index      c<br />\n– nil<br />\n– 1<br />\n– 会调用到 tt 的__index元方法，在 t 中没有 c 的字段，所以找到 __index元方法，指向 tt 这个table，就从tt里面去找，tt也没有 c 这个字段，就触发了 __index 元方法<br />\n]]</span></p>\n<p></code></pre></div></div></p>\n<h1 id=\"__newindex\">__newindex</h1>\n<ul>\n  <li>\n<strong>__newindex</strong>用于更新table中的数据，当对table中不存在的字段赋值时，lua按照一下步骤进行</li>\n  <li>lua解释器先判断这个table有无元表</li>\n  <li>如果有元表，就查找元表中是否有<strong>__newindex</strong>元方法；如果没有元表，就直接添加这个字段，然后赋值</li>\n  <li>如果有这个<strong>__newindex</strong>元方法，就执行它，而不是执行赋值</li>\n  <li>如果<strong>__newindex</strong>对应的不是一个函数，而是一个table时，就在这个table中赋值，而不是对原来的table</li>\n</ul>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">local</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span>\n<span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"mi\">4</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">c</span><span class=\"p\">)</span>  <span class=\"c1\">-- 4</span>\n<p><span class=\"nb\">setmetatable</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"p\">&#123;</span><br />\n<span class=\"n\">__newindex</span> <span class=\"o\">=</span> <span class=\"k\">function</span> <span class=\"p\">(</span> <span class=\"n\">tbl</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"p\">)</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;t __newindex &quot;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span><br />\n<span class=\"nb\">rawset</span><span class=\"p\">(</span><span class=\"n\">tbl</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span><br />\n<span class=\"c1\">–执行原来的赋值操作</span><br />\n<span class=\"c1\">–这里不能用 tbl[key] = value，这样会触发__newindex元方法，进入死循环</span><br />\n<span class=\"k\">end</span><br />\n<span class=\"p\">&#125;)</span><br />\n<span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"mi\">6</span><br />\n<span class=\"c1\">–输出 t __newindex    d       6</span></p>\n<p><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><br />\n<span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><br />\n<span class=\"c1\">–只输出 t __newindex    a       1</span><br />\n<span class=\"c1\">–由此可见，给不存在的字段赋值时才会触发__newindex</span></p>\n<p><span class=\"kd\">local</span> <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span><br />\n<span class=\"nb\">setmetatable</span><span class=\"p\">(</span><span class=\"n\">t2</span><span class=\"p\">,</span> <span class=\"p\">&#123;</span><br />\n<span class=\"n\">__newindex</span> <span class=\"o\">=</span> <span class=\"n\">t</span><br />\n<span class=\"p\">&#125;)</span><br />\n<span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><br />\n<span class=\"n\">t2</span><span class=\"p\">.</span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">t2</span><span class=\"p\">.</span><span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">t2</span><span class=\"p\">.</span><span class=\"n\">b</span><span class=\"p\">)</span><br />\n<span class=\"c1\">–输出</span><br />\n<span class=\"c1\">– t __newindex    e       2</span><br />\n<span class=\"c1\">– t __newindex    b       1</span><br />\n<span class=\"c1\">– 2       1       nil     nil</span><br />\n<span class=\"c1\">– 可以看出，给 t、t2 赋值其实都是给 t 赋值</span><br />\n<span class=\"c1\">–这里会调用到 t 的__newindex元方法，如果__newindex对应的是一个table，就会对这个table赋值，也就是对 t 赋值，而 t 中没有 b 字段，所以会触发 t 的__newindex</span></p>\n<p></code></pre></div></div></p>\n<h3 id=\"补充\">补充</h3>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">local</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"p\">&#123;</span>\n\t<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n\t<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"p\">&#125;</span>\n<span class=\"kd\">local</span> <span class=\"n\">tt</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span>\n<span class=\"nb\">setmetatable</span><span class=\"p\">(</span><span class=\"n\">tt</span><span class=\"p\">,</span> <span class=\"p\">&#123;</span>\n\t<span class=\"n\">__index</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"p\">,</span>\n\t<span class=\"n\">__newindex</span> <span class=\"o\">=</span> <span class=\"k\">function</span> <span class=\"p\">(</span> <span class=\"n\">tbl</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"p\">)</span>\n\t\t<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"__newindex here \"</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n\t<span class=\"k\">end</span>\n<span class=\"p\">&#125;)</span>\n<p><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">tt</span><span class=\"p\">.</span><span class=\"n\">a</span><span class=\"p\">)</span>\t<span class=\"c1\">– 1</span><br />\n<span class=\"n\">tt</span><span class=\"p\">.</span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\t<span class=\"c1\">– __newindex here         b       2</span><br />\n<span class=\"c1\">–tt里没有b这个字段，给这个字段赋值触发了__newindex，而不是给 t 里面的 b 赋值，赋值不会触发__index</span><br />\n</code></pre></div></div></p>\n<h1 id=\"rawget-和-rawset\">rawget 和 rawset</h1>\n<p><strong>rawget(table, index)</strong> 在不触发任何元方法的情况下获取table[index]的值。table必须是一张表，index可以是任何值。</p>\n<p><strong>rawset(table, index, value)</strong> 在不触发任何元方法的情况下将 table[index] 设为value。table必须是一张表，index可以是 nil 之外的任何值。value可以是任何lua值。这个函数返回table。</p>","text":" &lt;h1 id=&quot;__index&quot;&gt;__index&lt;/h1&gt; 当访问一个table的字段时，如果存在这个字段，则返回这个字段的值 如果没有这个字段，则会让解释器去查找__index元方法，如果存在此元方法，则会调用它，返回结果 如果没有...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#__newindex\"><span class=\"toc-text\">__newindex</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">补充</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#rawget-%E5%92%8C-rawset\"><span class=\"toc-text\">rawget 和 rawset</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"The Environment Model of Evaluation","uid":"7fba90ed15811944e899f4562a8fb009","slug":"zl/2016-01-01-183_The Environment Model of Evaluation","date":"2024-04-03T03:47:33.071Z","updated":"2024-04-03T03:47:33.071Z","comments":true,"path":"api/articles/zl/2016-01-01-183_The Environment Model of Evaluation.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"&lt;p&gt;这是 sicp 第三章中的 The Environment Model of Evaluation 的总结和一道习题的回顾。&lt;/p&gt; 因为 procedure 在调用过程中会有参数的引入，嵌套的调用，define 变量的定义和作用域等。 如何安排这些...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua运行时更新代码","uid":"4f6e2483e44ae389e49ffa9a5cd91ffd","slug":"zl/2016-01-01-182_Lua运行时更新代码 ","date":"2024-04-03T03:47:33.069Z","updated":"2024-04-03T03:47:33.070Z","comments":true,"path":"api/articles/zl/2016-01-01-182_Lua运行时更新代码 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt; 最近沉迷lua脚本热更，想说这个可以提高多少菜鸡的调试效率，找了网上好多文章，但是都不行，尝试了很久，并且自己测试和学习，写了一遍，勉强能热更了（还是有个问题，要按2次才能输出正确热更的值，一直找不到，有人找到麻烦告诉我一下308164213）。下面记录一下...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}