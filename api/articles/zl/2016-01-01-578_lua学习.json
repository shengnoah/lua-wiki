{"title":"lua学习","uid":"95b16d2adc3f9ac3d9071f8d9e44b9d7","slug":"zl/2016-01-01-578_lua学习","date":"2024-04-03T03:47:35.828Z","updated":"2024-04-03T03:47:35.828Z","comments":true,"path":"api/articles/zl/2016-01-01-578_lua学习.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"一、注释\">一、注释</h2><p>单行注释：两个破折号<br/>多行注释：[[ … ]]</p>\n<h2 id=\"二、变量和流程控制\">二、变量和流程控制</h2><p>所有的数字类型都是double</p>\n<pre><code>num=<span class=\"number\">42</span>\n</code></pre><p>字符串是Immutable的，和python一样</p>\n<pre><code>s = <span class=\"string\">&#39;walternate&#39;</span>\nt = <span class=\"string\">&#34;double-quotes are also fine&#34;</span>\nu = <span class=\"string\">[[ Double brackets\n          start and end\n          multi-line strings.]]</span>\n</code></pre><p>lua有垃圾回收机制，t是undefined</p>\n<pre><code><span class=\"literal\">t</span> = <span class=\"literal\">nil</span>\n</code></pre><p>语句块用关键字do/end标示</p>\n<pre><code><span class=\"keyword\">while</span> <span class=\"built_in\">num</span> &lt; <span class=\"number\">50</span> <span class=\"built_in\">do</span>\n    <span class=\"built_in\">num</span> = <span class=\"built_in\">num</span> + <span class=\"number\">1</span>       \n<span class=\"function\"><span class=\"keyword\">end</span>\n<p>语句:</span><br />\n<span class=\"keyword\">if</span> <span class=\"built_in\">num</span> &gt; <span class=\"number\">40</span> <span class=\"keyword\">then</span><br />\nprint(<span class=\"string\">'over 40'</span>)<br />\nelseif s ~= <span class=\"string\">'walternate'</span> <span class=\"keyword\">then</span>  <span class=\"comment\">– ~= 是不等号.</span><br />\n<span class=\"comment\">– 等号是== 对字符串也适用.</span><br />\nio.<span class=\"built_in\">write</span>(<span class=\"string\">'not over 40n'</span>)  <span class=\"comment\">– 默认输出到stdout.</span><br />\n<span class=\"keyword\">else</span><br />\n<span class=\"comment\">– 变量默认是全局的.</span><br />\nthisIsGlobal = <span class=\"number\">5</span>  <span class=\"comment\">– 常用Camel样式.</span></p>\n<p><span class=\"comment\">– 局部变量如下定义:</span><br />\n<span class=\"built_in\">local</span> <span class=\"built_in\">line</span> = io.<span class=\"built_in\">read</span>()  <span class=\"comment\">– 读取下一个stdin 行.</span></p>\n<p><span class=\"comment\">– 字符串连接使用 … 操作符:</span><br />\nprint(<span class=\"string\">'Winter is coming, '</span> … <span class=\"built_in\">line</span>)<br />\n<span class=\"function\"><span class=\"keyword\">end</span></p>\n<p>未定义的变量返回<span class=\"title\">nil</span></span><br />\nfoo = anUnknownVariable  <span class=\"comment\">– Now foo = nil.</span><br />\naBoolValue = <span class=\"constant\">false</span><br />\n<span class=\"comment\">– 只有nil 和 false 是 falsy; 0 和 '' 是 true!</span><br />\n<span class=\"keyword\">if</span> <span class=\"operator\">not</span> aBoolValue <span class=\"keyword\">then</span> print(<span class=\"string\">'twas false'</span>) <span class=\"function\"><span class=\"keyword\">end</span><br />\n– '<span class=\"title\">or</span>' <span class=\"title\">and</span> '<span class=\"title\">and</span>' 是短路的.</span><br />\n<span class=\"comment\">– 这和 C/js中的 a?b:c 相似:</span><br />\nans = aBoolValue <span class=\"operator\">and</span> <span class=\"string\">'yes'</span> <span class=\"operator\">or</span> <span class=\"string\">'no'</span>  <span class=\"comment\">–&gt; 'no'</span></p>\n<pre><code>karlSum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;\n&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;do&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;-- 范围是闭区间.&lt;/span&gt;\n   karlSum = karlSum + i\n&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;\n</code></pre>\n<p>– 用 &quot;<span class=\"title\">100</span>, <span class=\"title\">1</span>, -<span class=\"title\">1</span>&quot; 作为区间来递减:</span><br />\nfredSum = <span class=\"number\">0</span><br />\n<span class=\"keyword\">for</span> j = <span class=\"number\">100</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span> <span class=\"built_in\">do</span> fredSum = fredSum + j <span class=\"function\"><span class=\"keyword\">end</span></p>\n<p>– 总体上, 区间是 <span class=\"title\">begin</span>, <span class=\"title\">end</span>[, <span class=\"title\">step</span>].</span></p>\n<p><span class=\"comment\">– 另一种循环结构:</span><br />\n<span class=\"keyword\">repeat</span><br />\nprint(<span class=\"string\">'the way of the future'</span>)<br />\n<span class=\"built_in\">num</span> = <span class=\"built_in\">num</span> - <span class=\"number\">1</span><br />\n<span class=\"keyword\">until</span> <span class=\"built_in\">num</span> == <span class=\"number\">0</span><br />\n</code></pre><h2 id=\"三、函数\">三、函数</h2><pre><code><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fib</span><span class=\"params\">(n)</span></span><br />\n<span class=\"keyword\">if</span> n &lt; <span class=\"number\">2</span> <span class=\"keyword\">then</span> <span class=\"keyword\">return</span> <span class=\"number\">1</span> <span class=\"keyword\">end</span><br />\n<span class=\"keyword\">return</span> fib(n - <span class=\"number\">2</span>) + fib(n - <span class=\"number\">1</span>)<br />\n<span class=\"keyword\">end</span></p>\n<p><span class=\"comment\">– 也可返回闭包和匿名函数:</span><br />\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">adder</span><span class=\"params\">(x)</span></span><br />\n<span class=\"comment\">– 当adder被调用时，返回函数就被创建，并且保存有x的值：</span><br />\n<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(y)</span></span> <span class=\"keyword\">return</span> x + y <span class=\"keyword\">end</span><br />\n<span class=\"keyword\">end</span><br />\na1 = adder(<span class=\"number\">9</span>)<br />\na2 = adder(<span class=\"number\">36</span>)<br />\n<span class=\"built_in\">print</span>(a1(<span class=\"number\">16</span>))  <span class=\"comment\">–&gt; 25</span><br />\n<span class=\"built_in\">print</span>(a2(<span class=\"number\">64</span>))  <span class=\"comment\">–&gt; 100</span></p>\n<p>x, y, z = <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span><br />\n<span class=\"comment\">– 赋值后 x = 1, y = 2, z = 3, 但 4 被丢弃了.</span></p>\n<p><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span><span class=\"params\">(a, b, c)</span></span><br />\n<span class=\"built_in\">print</span>(a, b, c)<br />\n<span class=\"keyword\">return</span> <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">23</span>, <span class=\"number\">42</span><br />\n<span class=\"keyword\">end</span></p>\n<p>x, y = bar(<span class=\"string\">'zaphod'</span>)  <span class=\"comment\">–&gt; prints &quot;zaphod  nil nil&quot;</span><br />\n<span class=\"comment\">– 现在 x = 4, y = 8, 值 15…42 被丢弃了.</span></p>\n<p><span class=\"comment\">– 函数是一等公民, 可以是 local/global.</span><br />\n<span class=\"comment\">– 下面是等价的:</span><br />\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(x)</span></span> <span class=\"keyword\">return</span> x * x <span class=\"keyword\">end</span><br />\nf = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(x)</span></span> <span class=\"keyword\">return</span> x * x <span class=\"keyword\">end</span></p>\n<p><span class=\"comment\">– 下面也是等价的:</span><br />\n<span class=\"keyword\">local</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span><span class=\"params\">(x)</span></span> <span class=\"keyword\">return</span> <span class=\"built_in\">math</span>.sin(x) <span class=\"keyword\">end</span><br />\n<span class=\"keyword\">local</span> g; g  = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(x)</span></span> <span class=\"keyword\">return</span> <span class=\"built_in\">math</span>.sin(x) <span class=\"keyword\">end</span></p>\n<p><span class=\"comment\">– 调用只有一个字符串的参数，不需要括号:</span><br />\n<span class=\"built_in\">print</span> <span class=\"string\">'hello'</span>  <span class=\"comment\">– Works fine.</span><br />\n</code></pre><h2 id=\"四、表\">四、表</h2><p>Tables ： 哈希查找的关联数组，和dictionaries、map类似，是lua仅有的复合数据结构。</p></p>\n<pre><code>Dict的的键默认是字符串的\nt = &#123;key1 = <span class=\"string\">&#39;value1&#39;</span>, key2 = <span class=\"keyword\">false</span>&#125;\n<span class=\"built_in\">print</span>(t.key1)  <span class=\"comment\">-- 输出 &#39;value1&#39;.</span>\nt.newKey = &#123;&#125;  <span class=\"comment\">-- 添加一个新的 key/value 对.</span>\nt.key2 = <span class=\"keyword\">nil</span>   <span class=\"comment\">-- 从table中移除 key2.</span>\n\n表常用的的键一般是数字或者字符串\nu = &#123;[<span class=\"string\">&#39;@!#&#39;</span>] = <span class=\"string\">&#39;qbert&#39;</span>, [&#123;&#125;] = <span class=\"number\">1729</span>, [<span class=\"number\">6.28</span>] = <span class=\"string\">&#39;tau&#39;</span>&#125;\n<span class=\"built_in\">print</span>(u[<span class=\"number\">6.28</span>])  <span class=\"comment\">-- 输出&#34;tau&#34;</span>\na = u[<span class=\"string\">&#39;@!#&#39;</span>]    <span class=\"comment\">-- a = &#39;qbert&#39;.</span>\nb = u[&#123;&#125;]     <span class=\"comment\">-- 误认为是1729, 其实是 nil。</span>\n\n<span class=\"keyword\">for</span> key, val <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(u) <span class=\"keyword\">do</span>  <span class=\"comment\">-- 表迭代.</span>\n  <span class=\"built_in\">print</span>(key, val)\n<span class=\"keyword\">end</span>\n\n<span class=\"comment\">-- 调用一个 one-table-param 的函数不需要括号</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">h</span><span class=\"params\">(x)</span></span> <span class=\"built_in\">print</span>(x.key1) <span class=\"keyword\">end</span>\nh&#123;key1 = <span class=\"string\">&#39;Sonmi~451&#39;</span>&#125;  <span class=\"comment\">-- Prints &#39;Sonmi~451&#39;.</span>\n\n<span class=\"comment\">-- _G 是一个全局的特殊表.</span>\n<span class=\"built_in\">print</span>(<span class=\"built_in\">_G</span>[<span class=\"string\">&#39;_G&#39;</span>] == <span class=\"built_in\">_G</span>)  <span class=\"comment\">-- 输出 &#39;true&#39;.</span>\n\n<span class=\"comment\">-- 把 tables 用作 lists / arrays:</span>\n\n<span class=\"comment\">-- List 的键默认是整数，键是连续的整数，其实还是table:</span>\nv = &#123;<span class=\"string\">&#39;value1&#39;</span>, <span class=\"string\">&#39;value2&#39;</span>, <span class=\"number\">1.21</span>, <span class=\"string\">&#39;gigawatts&#39;</span>&#125;\n<span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, #v <span class=\"keyword\">do</span>  <span class=\"comment\">-- #v 是列表v的长度.</span>\n  <span class=\"built_in\">print</span>(v[i])     <span class=\"comment\">-- 第一个索引是1</span>\n<span class=\"keyword\">end</span>\n</code></pre><p>4.1. 元表和元方法.</p>\n<p>–元表给予表操作符重载的特性，类似js的prototype的特性。</p>\n<pre><code>f1 = &#123;<span class=\"operator\">a</span> = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>&#125;  <span class=\"comment\">-- 表示分数 a/b.</span>\nf2 = &#123;<span class=\"operator\">a</span> = <span class=\"number\">2</span>, b = <span class=\"number\">3</span>&#125;\n<p><span class=\"comment\">– 但是下面这样会报错:</span><br />\n<span class=\"comment\">– s = f1 + f2</span></p>\n<p>metafraction = &#123;&#125;<br />\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">metafraction</span>.<span class=\"title\">__add</span>(<span class=\"title\">f1</span>, <span class=\"title\">f2</span>)</span><br />\n<span class=\"built_in\">sum</span> = &#123;&#125;<br />\n<span class=\"built_in\">sum</span>.b = f1.b * f2.b<br />\n<span class=\"built_in\">sum</span>.<span class=\"operator\">a</span> = f1.<span class=\"operator\">a</span> * f2.b + f2.<span class=\"operator\">a</span> * f1.b<br />\n<span class=\"constant\">return</span> <span class=\"built_in\">sum</span><br />\n<span class=\"function\"><span class=\"keyword\">end</span></p>\n<p><span class=\"title\">setmetatable</span>(<span class=\"title\">f1</span>, <span class=\"title\">metafraction</span>)</span><br />\nsetmetatable(f2, metafraction)</p>\n<p>s = f1 + f2</p>\n<p><span class=\"comment\">– 元表上的 __index 重载 . 查找:</span><br />\ndefaultFavs = &#123;animal = <span class=\"string\">'gru'</span>, food = <span class=\"string\">'donuts'</span>&#125;<br />\nmyFavs = &#123;food = <span class=\"string\">'pizza'</span>&#125;<br />\nsetmetatable(myFavs, &#123;__index = defaultFavs&#125;)<br />\neatenBy = myFavs.animal  <span class=\"comment\">– 可行! thanks, metatable</span></p>\n<p>一个__index值也可以是个函数(tbl, key)，有利于个性化查找。<br />\n像__index,<span class=\"built_in\">add</span>, … 都是元方法，下面是一个全表，这里 <span class=\"operator\">a</span>是一个有metamethod的表</p>\n<p><span class=\"comment\">– __add(a, b)                     for a + b</span><br />\n<span class=\"comment\">– __sub(a, b)                     for a - b</span><br />\n<span class=\"comment\">– __mul(a, b)                     for a * b</span><br />\n<span class=\"comment\">– __div(a, b)                     for a / b</span><br />\n<span class=\"comment\">– __mod(a, b)                     for a % b</span><br />\n<span class=\"comment\">– __pow(a, b)                     for a ^ b</span><br />\n<span class=\"comment\">– __unm(a)                        for -a</span><br />\n<span class=\"comment\">– __concat(a, b)                  for a … b</span><br />\n<span class=\"comment\">– __len(a)                        for #a</span><br />\n<span class=\"comment\">– __eq(a, b)                      for a == b</span><br />\n<span class=\"comment\">– __lt(a, b)                      for a &lt; b</span><br />\n<span class=\"comment\">– __le(a, b)                      for a &lt;= b</span><br />\n<span class=\"comment\">– __index(a, b)  &lt;fn or a table&gt;  for a.b</span><br />\n<span class=\"comment\">– __newindex(a, b, c)             for a.b = c</span><br />\n<span class=\"comment\">– __call(a, …)                  for a(…)</span><br />\n</code></pre><p>4.2. 类风格的表与继承 </p></p>\n<p>类不是内置的，有多种可以使用tables和metatables的方法</p>\n<pre><code>Dog = &#123;&#125;                                   <span class=\"comment\">-- 1.</span>\n<p><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog:new</span><span class=\"params\">()</span></span>                         <span class=\"comment\">– 2.</span><br />\nnewObj = &#123;sound = <span class=\"string\">'woof'</span>&#125;                <span class=\"comment\">– 3.</span><br />\nself.__index = self                      <span class=\"comment\">– 4.</span><br />\n<span class=\"keyword\">return</span> <span class=\"built_in\">setmetatable</span>(newObj, self)        <span class=\"comment\">– 5.</span><br />\n<span class=\"keyword\">end</span></p>\n<p><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog:makeSound</span><span class=\"params\">()</span></span>                   <span class=\"comment\">– 6.</span><br />\n<span class=\"built_in\">print</span>(<span class=\"string\">'I say '</span> … self.sound)<br />\n<span class=\"keyword\">end</span></p>\n<p>mrDog = Dog:new()                          <span class=\"comment\">– 7.</span><br />\nmrDog:makeSound()  <span class=\"comment\">– 'I say woof'         – 8.</span><br />\n</code></pre><p>–1. Dog 像是一个class，它实际是一个表。</p></p>\n<p>–2. 函数 tablename：fn(…) 和函数tablename.fn(self,…)一样，： 仅仅添加第一个名为self的参数。</p>\n<p>–3. newObj是类Dog的实例。</p>\n<p>–4. self就是被继承的类，但是继承可以改变self的值，这里是Dog，当我们设置newObj’s metatable 和 self’s __index to self时，newObj 才能使用self’s 函数。</p>\n<p>–5. setmetatable 返回它的第一个参数</p>\n<p>–6. 这时，self是一个实例而不是一个类。</p>\n<p>–7. 和Dog.new(Dog)一样。</p>\n<p>–8. 和mrDog.makeSound(mrDog)一样; 此时 self = mrDog.</p>\n<p>继承的例子：</p>\n<pre><code>LoudDog = Dog:new()                           <span class=\"comment\">-- 1.    </span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LoudDog:makeSound</span><span class=\"params\">()</span></span>\n  s = self.sound .. <span class=\"string\">&#39; &#39;</span>                       <span class=\"comment\">-- 2.</span>\n  <span class=\"built_in\">print</span>(s .. s .. s)\n<span class=\"keyword\">end</span>    \nseymour = LoudDog:new()                       <span class=\"comment\">-- 3.</span>\nseymour:makeSound()  <span class=\"comment\">-- &#39;woof woof woof&#39;      -- 4.</span>\n</code></pre><p>– 1. LoudDog 继承了 Dog’s 的方法和变量。</p>\n<p>– 2. self 有一个来自于new()的 ‘sound’键。</p>\n<p>– 3. 和LoudDog.new(LoudDog)一样, 由于LoudDog没有‘new’键，将被转换为 Dog.new(LoudDog),但是它的 metatable 拥有 <strong>index = Dog。<br/>结论：seymour的 metatable是LoudDog，LoudDog.</strong>index = LoudDog. 所以 seymour.key = seymour.key, LoudDog.key, Dog.key, 任何第一个含有给定键的表。</p>\n<p>– 4. ‘makeSound’ key 包含在LoudDog;这和LoudDog.makeSound(seymour)一样.</p>\n<p>– 如果有需要, 一个子类的 new() 可以和基类的一样:</p>\n<pre><code><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LoudDog</span>:</span><span class=\"keyword\">new</span>()\n  newObj = &#123;&#125;\n  -- set up newObj\n  <span class=\"variable\">self</span>.__index = <span class=\"variable\">self</span>\n  <span class=\"keyword\">return</span> setmetatable(newObj, <span class=\"variable\">self</span>)\n<span class=\"keyword\">end</span>\n</code></pre><h1 id=\"五、模块\">五、模块</h1><p>– 假设文件mod.lua 像如下所示:</p>\n<pre><code><span class=\"keyword\">local</span> M = &#123;&#125;\n<span class=\"keyword\">local</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayMyName</span><span class=\"params\">()</span></span>\n  <span class=\"built_in\">print</span>(<span class=\"string\">&#39;Hrunkner&#39;</span>)\n<span class=\"keyword\">end</span>\n<p><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">M.sayHello</span><span class=\"params\">()</span></span><br />\n<span class=\"built_in\">print</span>(<span class=\"string\">'Why hello there'</span>)<br />\nsayMyName()<br />\n<span class=\"keyword\">end</span></p>\n<p><span class=\"keyword\">return</span> M</p>\n<p><span class=\"comment\">– 另一个文件可以使用mod.lua's 的函数:</span><br />\n<span class=\"keyword\">local</span> mod = <span class=\"built_in\">require</span>(<span class=\"string\">'mod'</span>)  <span class=\"comment\">– 运行文件 mod.lua.</span></p>\n<p><span class=\"comment\">– require 是 引用和包含 modules 的标准方法.</span><br />\n<span class=\"comment\">– require 其实像下面这样工作:  （没有缓存的）   </span><br />\n<span class=\"keyword\">local</span> mod = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span><br />\n&lt;contents of mod.lua&gt;<br />\n<span class=\"keyword\">end</span>)()<br />\n<span class=\"comment\">– mod.lua 像是一个函数体,所以 mod.lua内的局部变量对外不可见</span></p>\n<p><span class=\"comment\">– 因为在mod.lua里面，这里的mod = M :</span><br />\nmod.sayHello()   <span class=\"comment\">– Says hello to Hrunkner.</span></p>\n<p><span class=\"comment\">– 错误; sayMyName 只存在于 mod.lua:</span><br />\nmod.sayMyName()  <span class=\"comment\">– error</span></p>\n<p><span class=\"comment\">– require 的返回值是经过缓存的，所以一个文件最多运行一次，无论require多少次。</span><br />\n<span class=\"comment\">– 假设 mod2.lua 包含 &quot;print('Hi!')&quot;.</span><br />\n<span class=\"keyword\">local</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'mod2'</span>)  <span class=\"comment\">– 输出 Hi!</span><br />\n<span class=\"keyword\">local</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'mod2'</span>)  <span class=\"comment\">– 无输出; a=b.</span></p>\n<p><span class=\"comment\">– dofile 就像无缓存的 require:</span><br />\n<span class=\"built_in\">dofile</span>(<span class=\"string\">'mod2.lua'</span>)  <span class=\"comment\">–&gt; Hi!</span><br />\n<span class=\"built_in\">dofile</span>(<span class=\"string\">'mod2.lua'</span>)  <span class=\"comment\">–&gt; Hi! (runs it again)</span></p>\n<p><span class=\"comment\">– loadfile 装载一个lua 文件，但并不立即运行。</span><br />\nf = <span class=\"built_in\">loadfile</span>(<span class=\"string\">'mod2.lua'</span>)  <span class=\"comment\">– 调用 f() 来运行.</span></p>\n<p><span class=\"comment\">– loadstring 相当于strings版的loadfile.</span><br />\ng = <span class=\"built_in\">loadstring</span>(<span class=\"string\">'print(343)'</span>)  <span class=\"comment\">– 返回一个函数.</span><br />\ng()                            <span class=\"comment\">– 输出343; 此前无输出.</span><br />\n</code></pre><h1 id=\"参考：\">参考：</h1><p><a href=\"http://tylerneylon.com/a/learn-lua/\" target=\"_blank\" rel=\"external noopener noreferrer\">15分钟学会lua</a></p></p>\n<p><a href=\"http://nova-fusion.com/2012/08/27/lua-for-programmers-part-1/\" target=\"_blank\" rel=\"external noopener noreferrer\">Lua编程(Part 1)：基本语法</a></p>\n<p><a href=\"http://nova-fusion.com/2012/08/27/lua-for-programmers-part-2/\" target=\"_blank\" rel=\"external noopener noreferrer\">Lua编程(Part 2)：数据和标准库</a></p>\n<p><a href=\"http://nova-fusion.com/2012/09/07/lua-for-programmers-part-3/\" target=\"_blank\" rel=\"external noopener noreferrer\">Lua编程(Part 3)：高级概念</a></p>\n<p><a href=\"http://nova-fusion.com/2012/09/09/lua-for-programmers-part-4/\" target=\"_blank\" rel=\"external noopener noreferrer\">Lua编程(Part 4)：技巧</a></p>\n<p><a href=\"http://love2d.org/\" target=\"_blank\" rel=\"external noopener noreferrer\">love 2D游戏引擎</a></p>\n<p><a href=\"http://www.lua.org/pil/contents.html\" target=\"_blank\" rel=\"external noopener noreferrer\">lua官方学习文档</a></p>\n<p><a href=\"https://apaszke.github.io/torch-internals.html\" target=\"_blank\" rel=\"external noopener noreferrer\">A quick tour of Torch internals</a></p>\n<p><a href=\"http://apaszke.github.io/lstm-explained.html\" target=\"_blank\" rel=\"external noopener noreferrer\">基于Torch的LSTM实现</a></p>","text":"一、注释单行注释：两个破折号多行注释：[[ … ]] 二、变量和流程控制所有的数字类型都是double num=42 字符串是Immutable的，和python一样 s = &#39;walternate&#39; t = &#34;double-quotes are also...","link":"","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">一、注释</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">二、变量和流程控制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">三、函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E8%A1%A8\"><span class=\"toc-text\">四、表</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">五、模块</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%EF%BC%9A\"><span class=\"toc-text\">参考：</span></a>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 学习 chapter25","uid":"750a10f53a4ef67c79f4f67a9f9da4d0","slug":"zl/2016-01-01-579_Lua 学习 chapter25 ","date":"2024-04-03T03:47:35.828Z","updated":"2024-04-03T03:47:35.828Z","comments":true,"path":"api/articles/zl/2016-01-01-579_Lua 学习 chapter25 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"目录 自省机制 访问变量 钩子 沙盒 只有疯狂过，你才知道自己究竟能不能成功。 自省机制 通过debug.getinfo(foo)，函数就会返回一个包含该函数有关的一些数据的表。 访问变量 通过debug.getlocal来检查任意活跃函数的局部变量。还可以通过函数getupva...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"3 Model Evaluation","uid":"d4560d3f1f9925741d7de629bfb8f0ef","slug":"zl/2016-01-01-57_3 Model Evaluation","date":"2024-04-03T03:47:35.828Z","updated":"2024-04-03T03:47:35.829Z","comments":true,"path":"api/articles/zl/2016-01-01-57_3 Model Evaluation.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"模型评估 经验误差与拟合问题 在分类问题中，将分类错误的样本占样本总数的比例称为错误率。如果在$m$个样本中有$a$个样本分类错误，则错误率为$E=frac{a}{m}$，与之相对的精度为$Accu=1-E$。或者，我们将学习算法的实际预测输出与样本的真实输出之间的差异称为误差。...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}