{"title":"tolua之wrap文件的原理与使用","uid":"99d79527b247d67792c14ab4db2f8700","slug":"zl/2016-01-01-566_tolua之wrap文件的原理与使用","date":"2024-04-03T03:47:35.822Z","updated":"2024-04-03T03:47:35.823Z","comments":true,"path":"api/articles/zl/2016-01-01-566_tolua之wrap文件的原理与使用.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>每个wrap文件都是对一个c#类的包装，在lua中，通过对wrap类中的函数调用，间接的对c#实例进行操作。<br/></p>\n<h1 id=\"wrap类文件生成和使用的总体流程\"><a href=\"#wrap类文件生成和使用的总体流程\" class=\"headerlink\" title=\"wrap类文件生成和使用的总体流程\"></a>wrap类文件生成和使用的总体流程</h1><p><img src=\"http://arrayindex.me//2018/09/19/tolua之wrap文件的原理与使用/MainProcess.svg\" alt=\"\"/>  </p>\n<h1 id=\"生成一个wrap文件的流程\"><a href=\"#生成一个wrap文件的流程\" class=\"headerlink\" title=\"生成一个wrap文件的流程\"></a>生成一个wrap文件的流程</h1><p><img src=\"http://arrayindex.me//2018/09/19/tolua之wrap文件的原理与使用/GenerateClassWraps.svg\" alt=\"\"/><br/>这部分主要通过分析类的反射信息完成。</p>\n<h1 id=\"wrap文件内容解析\"><a href=\"#wrap文件内容解析\" class=\"headerlink\" title=\"wrap文件内容解析\"></a>wrap文件内容解析</h1><p>使用UnityEngine_GameObjectWrap.cs进行举例。</p>\n<h2 id=\"注册部分\"><a href=\"#注册部分\" class=\"headerlink\" title=\"注册部分\"></a>注册部分</h2><figure class=\"highlight cs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/><span class=\"line\">26</span><br/><span class=\"line\">27</span><br/><span class=\"line\">28</span><br/><span class=\"line\">29</span><br/><span class=\"line\">30</span><br/><span class=\"line\">31</span><br/><span class=\"line\">32</span><br/><span class=\"line\">33</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> (<span class=\"params\">LuaState L</span>)</span></span><br/><span class=\"line\"><span class=\"function\"></span>{</span><br/><span class=\"line\">    L.BeginClass(<span class=\"keyword\">typeof</span>(UnityEngine.GameObject), <span class=\"keyword\">typeof</span>(UnityEngine.Object));</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;CreatePrimitive&#34;</span>, CreatePrimitive);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;GetComponent&#34;</span>, GetComponent);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;GetComponentInChildren&#34;</span>, GetComponentInChildren);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;GetComponentInParent&#34;</span>, GetComponentInParent);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;GetComponents&#34;</span>, GetComponents);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;GetComponentsInChildren&#34;</span>, GetComponentsInChildren);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;GetComponentsInParent&#34;</span>, GetComponentsInParent);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;SetActive&#34;</span>, SetActive);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;CompareTag&#34;</span>, CompareTag);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;FindGameObjectWithTag&#34;</span>, FindGameObjectWithTag);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;FindWithTag&#34;</span>, FindWithTag);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;FindGameObjectsWithTag&#34;</span>, FindGameObjectsWithTag);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;Find&#34;</span>, Find);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;AddComponent&#34;</span>, AddComponent);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;BroadcastMessage&#34;</span>, BroadcastMessage);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;SendMessageUpwards&#34;</span>, SendMessageUpwards);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;SendMessage&#34;</span>, SendMessage);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;New&#34;</span>, _CreateUnityEngine_GameObject);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;__eq&#34;</span>, op_Equality);</span><br/><span class=\"line\">    L.RegFunction(<span class=\"string\">&#34;__tostring&#34;</span>, ToLua.op_ToString);</span><br/><span class=\"line\">    L.RegVar(<span class=\"string\">&#34;transform&#34;</span>, get_transform, <span class=\"literal\">null</span>);</span><br/><span class=\"line\">    L.RegVar(<span class=\"string\">&#34;layer&#34;</span>, get_layer, set_layer);</span><br/><span class=\"line\">    L.RegVar(<span class=\"string\">&#34;activeSelf&#34;</span>, get_activeSelf, <span class=\"literal\">null</span>);</span><br/><span class=\"line\">    L.RegVar(<span class=\"string\">&#34;activeInHierarchy&#34;</span>, get_activeInHierarchy, <span class=\"literal\">null</span>);</span><br/><span class=\"line\">    L.RegVar(<span class=\"string\">&#34;isStatic&#34;</span>, get_isStatic, set_isStatic);</span><br/><span class=\"line\">    L.RegVar(<span class=\"string\">&#34;tag&#34;</span>, get_tag, set_tag);</span><br/><span class=\"line\">    L.RegVar(<span class=\"string\">&#34;scene&#34;</span>, get_scene, <span class=\"literal\">null</span>);</span><br/><span class=\"line\">    L.RegVar(<span class=\"string\">&#34;gameObject&#34;</span>, get_gameObject, <span class=\"literal\">null</span>);</span><br/><span class=\"line\">    L.EndClass();</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure>\n<p>这部分代码由GenRegisterFunction()生成，可以看到，这些代码分为了4部分：<br/>1.BeginClass部分，负责类在lua中的初始化部分<br/>2.RegFunction部分，负责将函数注册到lua中<br/>3.RegVar部分，负责将变量和属性注册到lua中<br/>4.EndClass部分，负责类结束注册的收尾工作  </p>\n<h3 id=\"BeginClass部分\"><a href=\"#BeginClass部分\" class=\"headerlink\" title=\"BeginClass部分\"></a>BeginClass部分</h3><p>①用于创建类和类的元表,如果类的元表的元表（类的元表是承载每个类方法和属性的实体，类的元表的元表就是类的父类）<br/>②将类添加到loaded表中。<br/>③设置每个类的元表的通用的元方法和属性，<strong>gc,name,ref,</strong>cal,<strong>index,</strong>newindex。  </p>\n<h3 id=\"RegFunction部分\"><a href=\"#RegFunction部分\" class=\"headerlink\" title=\"RegFunction部分\"></a>RegFunction部分</h3><p>每一个RefFunction做的事都很简单，将每个函数转化为一个指针，然后添加到类的元表中去，与将一个c函数注册到lua中是一样的。  </p>\n<h3 id=\"RegVar部分\"><a href=\"#RegVar部分\" class=\"headerlink\" title=\"RegVar部分\"></a>RegVar部分</h3><p>每一个变量或属性或被包装成get_xxx,set_xxx函数注册添加到类的元表的gettag，settag表中去，用于调用和获取。  </p>\n<h3 id=\"EndClass部分\"><a href=\"#EndClass部分\" class=\"headerlink\" title=\"EndClass部分\"></a>EndClass部分</h3><p>做了两件事：<br/>①设置类的元表<br/>②把该类加到所在模块代表的表中（如将GameObject加入到UnityEngine表中）  </p>\n<h2 id=\"每个函数的实体部分\"><a href=\"#每个函数的实体部分\" class=\"headerlink\" title=\"每个函数的实体部分\"></a>每个函数的实体部分</h2><p>由于构造函数，this[]，get_xxx，set_xxx的原理都差不多，都是通过反射的信息生成的，所以放在一起用一个实例讲一下（使用GameObject的GetComponent函数进行说明）。<br/></p><figure class=\"highlight cs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/><span class=\"line\">26</span><br/><span class=\"line\">27</span><br/><span class=\"line\">28</span><br/><span class=\"line\">29</span><br/><span class=\"line\">30</span><br/><span class=\"line\">31</span><br/><span class=\"line\">32</span><br/><span class=\"line\">33</span><br/><span class=\"line\">34</span><br/><span class=\"line\">35</span><br/><span class=\"line\">36</span><br/><span class=\"line\">37</span><br/><span class=\"line\">38</span><br/><span class=\"line\">39</span><br/><span class=\"line\">40</span><br/><span class=\"line\">41</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">[]</span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">GetComponent</span>(<span class=\"params\">IntPtr L</span>)</span></span><br/><span class=\"line\"><span class=\"function\"></span>{</span><br/><span class=\"line\">    <span class=\"keyword\">try</span></span><br/><span class=\"line\">    {</span><br/><span class=\"line\">        </span><br/><span class=\"line\">        <span class=\"keyword\">int</span> count = LuaDLL.lua_gettop(L);</span><br/><span class=\"line\">        <span class=\"comment\">//根据栈中元素的个数和元素的类型判断该使用那一个重载</span></span><br/><span class=\"line\">        <span class=\"keyword\">if</span> (count == <span class=\"number\">2</span> &amp;&amp; TypeChecker.CheckTypes&lt;<span class=\"keyword\">string</span>&gt;(L, <span class=\"number\">2</span>))</span><br/><span class=\"line\">        {</span><br/><span class=\"line\">            <span class=\"comment\">//将栈底的元素取出来，这个obj在栈中是一个fulluserdata，需要先将这个fulluserdata转化成对应的c#实例，也就是调用这个GetComponent函数的GameObject实例</span></span><br/><span class=\"line\">            UnityEngine.GameObject obj = (UnityEngine.GameObject)ToLua.CheckObject(L, <span class=\"number\">1</span>, <span class=\"keyword\">typeof</span>(UnityEngine.GameObject));</span><br/><span class=\"line\">            <span class=\"comment\">//将栈底的上一个元素取出来，也就是GetComponent(string type)的参数</span></span><br/><span class=\"line\">            <span class=\"keyword\">string</span> arg0 = ToLua.ToString(L, <span class=\"number\">2</span>);</span><br/><span class=\"line\">            <span class=\"comment\">//通过obj，arg0直接第调用GetCompent(string type)函数</span></span><br/><span class=\"line\">            UnityEngine.Component o = obj.GetComponent(arg0);</span><br/><span class=\"line\">            <span class=\"comment\">//将调用结果压栈</span></span><br/><span class=\"line\">            ToLua.Push(L, o);</span><br/><span class=\"line\">            <span class=\"comment\">//返回参数的个数</span></span><br/><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br/><span class=\"line\">        }</span><br/><span class=\"line\">        <span class=\"comment\">//另一个GetComponent的重载，跟上一个差不多，就不详细说明了</span></span><br/><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count == <span class=\"number\">2</span> &amp;&amp; TypeChecker.CheckTypes&lt;System.Type&gt;(L, <span class=\"number\">2</span>))</span><br/><span class=\"line\">        {</span><br/><span class=\"line\">            UnityEngine.GameObject obj = (UnityEngine.GameObject)ToLua.CheckObject(L, <span class=\"number\">1</span>, <span class=\"keyword\">typeof</span>(UnityEngine.GameObject));</span><br/><span class=\"line\">            System.Type arg0 = (System.Type)ToLua.ToObject(L, <span class=\"number\">2</span>);</span><br/><span class=\"line\">            UnityEngine.Component o = obj.GetComponent(arg0);</span><br/><span class=\"line\">            ToLua.Push(L, o);</span><br/><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br/><span class=\"line\">        }</span><br/><span class=\"line\">        <span class=\"comment\">//参数数量或类型不对，没有找到对应的重载，抛出错误</span></span><br/><span class=\"line\">        <span class=\"keyword\">else</span></span><br/><span class=\"line\">        {</span><br/><span class=\"line\">            <span class=\"keyword\">return</span> LuaDLL.luaL_throw(L, <span class=\"string\">&#34;invalid arguments to method: UnityEngine.GameObject.GetComponent&#34;</span>);</span><br/><span class=\"line\">        }</span><br/><span class=\"line\">    }</span><br/><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception e)</span><br/><span class=\"line\">    {</span><br/><span class=\"line\">        <span class=\"keyword\">return</span> LuaDLL.toluaL_exception(L, e);</span><br/><span class=\"line\">    }</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>可以看到，GetComponent函数的内容，其实就是通过反射分析GetComponent的重载个数，每个重载的参数个数，类型生成的。具体内容和lua调用c函数差不多。 </p>\n<h2 id=\"每个函数实际的调用过程\"><a href=\"#每个函数实际的调用过程\" class=\"headerlink\" title=\"每个函数实际的调用过程\"></a>每个函数实际的调用过程</h2><p><strong>假如说在lua中有这么一个调用：</strong><br/></p><figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> tempGameObject = UnityEngine.GameObject(<span class=\"string\">&#34;temp&#34;</span>)</span><br/><span class=\"line\"><span class=\"keyword\">local</span> transform = tempGameObject.GetComponent(<span class=\"string\">&#34;Transform&#34;</span>)</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p><strong>第二行代码对应的实际调用过程是：</strong><br/>1.先去tempGameObject的元表GameObject元表中尝试去取GetComponent函数，取到了。<br/>2.调用取到的GetComponent函数，调用时会将tempGameObject,”Transform”作为参数先压栈，然后调用GetComponent函数。<br/>3.接下来就进入GetComponent函数内部进行操作，因为生成了新的ci，所以此时栈中只有tempGameOjbect,”Transfrom”两个元素。<br/>4.根据参数的数量和类型判断需要使用的重载。<br/>5.通过tempGameObject代表的c#实例的索引，在objects表中找到对应的实例。同时取出”Transform”这个参数，准备进行真正的函数调用。<br/>6.执行obj.GetComponent(arg0)，将结果包装成一个fulluserdata后压栈，结束调用。<br/>7.lua中的transfrom变量赋值为这个压栈的fulluserdata。<br/>8.结束。<br/>其中3-7的操作都在c#中进行，也就是wrap文件中的GetComponent函数。 </p>\n<h1 id=\"一个类通过wrap文件注册进lua虚拟机后是什么样子的\"><a href=\"#一个类通过wrap文件注册进lua虚拟机后是什么样子的\" class=\"headerlink\" title=\"一个类通过wrap文件注册进lua虚拟机后是什么样子的\"></a>一个类通过wrap文件注册进lua虚拟机后是什么样子的</h1><p>使用GameObjectWrap进行举例<br/><img src=\"http://arrayindex.me//2018/09/19/tolua之wrap文件的原理与使用/GameObjectClass.svg\" alt=\"\"/><br/>可以看到GameObject的所有功能都是通过一个元表实现的，通过这个元表可以调用GameObjectWrap文件中的各个函数来实现对GameObject实例的操作，这个元表对使用者来说是不可见的，因为我们平时只会在代码中调用GameObject类，GameObject实例，并不会直接引用到这个元表,接下来来分析一下GameObject类，GameObject实例与这个元表的关系：<br/>①GameObject类：其实只是一个放在_G表中供人调用的一个充当索引的表，我们通过它来触发GameObject元表的各种元方法，实现对c#类的使用。<br/>②GameObject的实例：是一个fulluserdata,内容为一个整数，这个整数代表了这个实例在objects表中的索引（objects是一个用list实现的回收链表，lua中调用的c#类实例都存在这个里面，后面会讲这个objects表），每次在lua中调用一个c#实例的方法时，都会通过这个索引找到这个索引在c#中对应的实例，然后进行操作，最后将操作结果转化为一个fulluserdata（或lua的内建类型，如bool等）压栈，结束调用。  </p>\n<h1 id=\"在lua中调用一个c-实例中的函数或变量的过程\"><a href=\"#在lua中调用一个c-实例中的函数或变量的过程\" class=\"headerlink\" title=\"在lua中调用一个c#实例中的函数或变量的过程\"></a>在lua中调用一个c#实例中的函数或变量的过程</h1><figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> tempGameObject = UnityEngine.GameObject(<span class=\"string\">&#34;temp&#34;</span>)</span><br/><span class=\"line\"><span class=\"keyword\">local</span> instanceID = tempGameObject.GetInstanceID()</span><br/></pre></td></tr></tbody></table></figure>\n<p><img src=\"http://arrayindex.me//2018/09/19/tolua之wrap文件的原理与使用/GameObjectDamo.svg\" alt=\"\"/><br/>在了解了GameObject元表后，这些只是一些基础的元表操作，就不多做解释。  </p>\n<h1 id=\"lua中c-实例的真正存储位置\"><a href=\"#lua中c-实例的真正存储位置\" class=\"headerlink\" title=\"lua中c#实例的真正存储位置\"></a>lua中c#实例的真正存储位置</h1><p>前面说了每一个c#实例在lua中是一个内容为整数索引的fulluserdata，在进行函数调用时，通过这个整数索引查找和调用这个索引代表的实例的函数和变量。<br/>生成或使用一个代表c#实例的lua变量的过程大概是这样的。<br/>还用这个例子来说明：<br/></p><figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> tempGameObject = UnityEngine.GameObject(<span class=\"string\">&#34;temp&#34;</span>)</span><br/><span class=\"line\"><span class=\"keyword\">local</span> transform = tempGameObject.GetComponent(<span class=\"string\">&#34;Transform&#34;</span>)</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p><img src=\"http://arrayindex.me//2018/09/19/tolua之wrap文件的原理与使用/ObjectsDamo.svg\" alt=\"\"/><br/>所以说lua中调用和创建的c#实例实际都是存在c#中的objects表中，lua中的变量只是一个持有该c#实例索引位置的fulluserdata，并没有直接对c#实例进行引用。<br/>对c#实例进行函数的调用和变量的修改都是通过元表调用操作wrap文件中的函数进行的。</p>\n<p>以上就是c#类如何通过wrap类在lua中进行使用的原理。</p>","text":"每个wrap文件都是对一个c#类的包装，在lua中，通过对wrap类中的函数调用，间接的对c#实例进行操作。 wrap类文件生成和使用的总体流程 生成一个wrap文件的流程这部分主要通过分析类的反射信息完成。 wrap文件内容解析使用UnityEngine_GameObjectW...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#wrap%E7%B1%BB%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E5%92%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">wrap类文件生成和使用的总体流程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AAwrap%E6%96%87%E4%BB%B6%E7%9A%84%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">生成一个wrap文件的流程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#wrap%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">wrap文件内容解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%86%8C%E9%83%A8%E5%88%86\"><span class=\"toc-text\">注册部分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BeginClass%E9%83%A8%E5%88%86\"><span class=\"toc-text\">BeginClass部分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RegFunction%E9%83%A8%E5%88%86\"><span class=\"toc-text\">RegFunction部分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RegVar%E9%83%A8%E5%88%86\"><span class=\"toc-text\">RegVar部分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#EndClass%E9%83%A8%E5%88%86\"><span class=\"toc-text\">EndClass部分</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%8F%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E4%BD%93%E9%83%A8%E5%88%86\"><span class=\"toc-text\">每个函数的实体部分</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%8F%E4%B8%AA%E5%87%BD%E6%95%B0%E5%AE%9E%E9%99%85%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">每个函数实际的调用过程</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E7%B1%BB%E9%80%9A%E8%BF%87wrap%E6%96%87%E4%BB%B6%E6%B3%A8%E5%86%8C%E8%BF%9Blua%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%8E%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84\"><span class=\"toc-text\">一个类通过wrap文件注册进lua虚拟机后是什么样子的</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9C%A8lua%E4%B8%AD%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AAc-%E5%AE%9E%E4%BE%8B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%88%96%E5%8F%98%E9%87%8F%E7%9A%84%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">在lua中调用一个c#实例中的函数或变量的过程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#lua%E4%B8%ADc-%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">lua中c#实例的真正存储位置</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua远程调用的实现方法","uid":"76e52e8255c32e959dab4087b6cfa1a6","slug":"zl/2016-01-01-564_Lua远程调用的实现方法","date":"2024-04-03T03:47:35.822Z","updated":"2024-04-03T03:47:35.822Z","comments":true,"path":"api/articles/zl/2016-01-01-564_Lua远程调用的实现方法.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"游戏开发中，客户端、服务端之间的交互是很频繁的，尤其是逻辑玩法的实现，需要大量的交互。 如果所有的交互都按功能构建出不同的协议，这样即繁琐又不方便修改。 通过Lua，使用远程调用可以极大的方便客户端、服务器的通信。 在Lua中，通过C++告诉对方，我要调用哪个函数、传递哪些参数，...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua封装 [ 奔跑的蜗牛 ]","uid":"3978f4e0c59724fc4edb93b95117c340","slug":"zl/2016-01-01-563_Lua封装 [ 奔跑的蜗牛 ]","date":"2024-04-03T03:47:35.821Z","updated":"2024-04-03T03:47:35.821Z","comments":true,"path":"api/articles/zl/2016-01-01-563_Lua封装 [ 奔跑的蜗牛 ].json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 撰写于 2018-05-25 &lt;span id=&quot;post-title-updated&quot;&gt;修改于 2018-05-25&lt;/span&gt; &lt;span id=&quot;post-title-categories&quot;&gt;分...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}