{"title":"lua","uid":"df60e476b394b1dd4755ec96c53302ff","slug":"zl/2016-01-01-924_lua","date":"2024-04-03T03:47:36.198Z","updated":"2024-04-03T03:47:36.198Z","comments":true,"path":"api/articles/zl/2016-01-01-924_lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h3 id=\"函数\">函数</h3>\n<hr/>\n<h5 id=\"函数定义\">函数定义</h5>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tbody><tr><td class=\"lntd\">\n<pre class=\"chroma\"><span class=\"lnt\">1\n</span><span class=\"lnt\">2\n</span><span class=\"lnt\">3\n</span></pre></td>\n<td class=\"lntd\">\n<pre class=\"chroma\">function function_name (arc)  -- arc 表示参数列表，函数的参数列表可以为空\n   -- body\nend</pre></td></tr></tbody></table>\n</div>\n</div><div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tbody><tr><td class=\"lntd\">\n<pre class=\"chroma\"><span class=\"lnt\">1\n</span><span class=\"lnt\">2\n</span><span class=\"lnt\">3\n</span></pre></td>\n<td class=\"lntd\">\n<pre class=\"chroma\">local function function_name (arc)\n  -- body\nend</pre></td></tr></tbody></table>\n</div>\n</div>\n<p><code>由于全局变量一般会污染全局名字空间，同时也有性能损耗（即查询全局环境表的开销），因此我们应当尽量使用“局部函数”，其记法是类似的，只是开头加上 local 修饰符</code></p>\n<h5 id=\"函数的参数\">函数的参数</h5>\n<ol>\n<li>按值传递（<code>在调用函数的时候，若形参个数和实参个数不同时，Lua 会自动调整实参个数。调整规则：若实参个数大于形参个数，从左向右，多余的实参被忽略；若实参个数小于形参个数，从左向右，没有被实参初始化的形参会被初始化为 nil。</code>）</li>\n<li><p>按引用传递(<code>在常用基本类型中，除了 table 是按址传递类型外，其它的都是按值传递参数</code>)</p>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tbody><tr><td class=\"lntd\">\n<pre class=\"chroma\"><span class=\"lnt\"> 1\n</span><span class=\"lnt\"> 2\n</span><span class=\"lnt\"> 3\n</span><span class=\"lnt\"> 4\n</span><span class=\"lnt\"> 5\n</span><span class=\"lnt\"> 6\n</span><span class=\"lnt\"> 7\n</span><span class=\"lnt\"> 8\n</span><span class=\"lnt\"> 9\n</span><span class=\"lnt\">10\n</span></pre></td>\n<td class=\"lntd\">\n<pre class=\"chroma\">local function func( ... )                -- 形参为 ... ,表示函数采用变长参数\n<p>local temp = {…}                     – 访问的时候也要使用 …<br />\nlocal ans = table.concat(temp, &quot; &quot;)    – 使用 table.concat 库函数对数<br />\n– 组内容使用 &quot; &quot; 拼接成字符串。<br />\nprint(ans)<br />\nend</p>\n<p>func(1, 2)        – 传递了两个参数<br />\nfunc(1, 2, 3, 4)  – 传递了四个参数</pre></td></tr></tbody></table></p>\n</div>\n</div></li>\n</ol>\n<p><code>变长参数 LuaJIT 2 尚不能 JIT 编译这种变长参数的用法，只能解释执行。所以对性能敏感的代码，应当避免使用此种形式</code></p>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tbody><tr><td class=\"lntd\">\n<pre class=\"chroma\"><span class=\"lnt\"> 1\n</span><span class=\"lnt\"> 2\n</span><span class=\"lnt\"> 3\n</span><span class=\"lnt\"> 4\n</span><span class=\"lnt\"> 5\n</span><span class=\"lnt\"> 6\n</span><span class=\"lnt\"> 7\n</span><span class=\"lnt\"> 8\n</span><span class=\"lnt\"> 9\n</span><span class=\"lnt\">10\n</span><span class=\"lnt\">11\n</span><span class=\"lnt\">12\n</span></pre></td>\n<td class=\"lntd\">\n<pre class=\"chroma\">local function change(arg) -- change 函数，改变长方形的长和宽，使其各增长一倍\n  arg.width = arg.width * 2\n  arg.height = arg.height * 2\n  return arg\nend\n<p>local rectangle = { width = 20, height = 15 }<br />\nprint(&quot;before change:&quot;, &quot;width  =&quot;, rectangle.width,<br />\n&quot;height =&quot;, rectangle.height)<br />\nrectangle = change(rectangle)<br />\nprint(&quot;after  change:&quot;, &quot;width  =&quot;, rectangle.width,<br />\n&quot;height =&quot;, rectangle.height)</pre></td></tr></tbody></table></p>\n</div>\n</div>\n<p><code>具名参数(所有的实参组织到一个 table 中，并将这个 table 作为唯一的实参传给函数)</code></p>\n<h5 id=\"函数返回值\">函数返回值</h5>\n<ol>\n<li>允许多个返回值</li>\n<li><p>当函数返回值的个数和接收返回值的变量的个数不一致时，Lua 也会自动调整参数个数( <code>调整规则： 若返回值个数大于接收变量的个数，多余的返回值会被忽略掉； 若返回值个数小于参数个数，从左向右，没有被返回值初始化的变量会被初始化为 nil。</code>)</p>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tbody><tr><td class=\"lntd\">\n<pre class=\"chroma\"><span class=\"lnt\">1\n</span><span class=\"lnt\">2\n</span><span class=\"lnt\">3\n</span><span class=\"lnt\">4\n</span><span class=\"lnt\">5\n</span><span class=\"lnt\">6\n</span><span class=\"lnt\">7\n</span><span class=\"lnt\">8\n</span><span class=\"lnt\">9\n</span></pre></td>\n<td class=\"lntd\">\n<pre class=\"chroma\">local function init()       -- init 函数 返回两个值 1 和 &#34;lua&#34;\nreturn 1, &#34;lua&#34;\nend\n<p>local x, y, z = init(), 2   – init 函数的位置不在最后，此时只返回 1<br />\nprint(x, y, z)              –&gt;output  1  2  nil</p>\n<p>local a, b, c = 2, init()   – init 函数的位置在最后，此时返回 1 和 &quot;lua&quot;<br />\nprint(a, b, c)              –&gt;output  2  1  lua</pre></td></tr></tbody></table></p>\n</div>\n</div></li>\n</ol>\n<p><code>当一个函数有一个以上返回值，且函数调用不是一个列表表达式的最后一个元素，那么函数调用只会产生一个返回值, 也就是第一个返回值。</code></p>\n<p><code>如果实参列表中某个函数会返回多个值，同时调用者又没有显式地使用括号运算符来筛选和过滤，则这样的表达式是不能被 LuaJIT 2 所 JIT 编译的，而只能被解释执行。</code></p>\n<h5 id=\"全动态函数调用\">全动态函数调用</h5>\n<ol>\n<li><p>使用场景</p>\n<ul>\n<li>你要调用的函数参数是未知的；</li>\n<li><p>函数的实际参数的类型和数目也都是未知的</p>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tbody><tr><td class=\"lntd\">\n<pre class=\"chroma\"><span class=\"lnt\"> 1\n</span><span class=\"lnt\"> 2\n</span><span class=\"lnt\"> 3\n</span><span class=\"lnt\"> 4\n</span><span class=\"lnt\"> 5\n</span><span class=\"lnt\"> 6\n</span><span class=\"lnt\"> 7\n</span><span class=\"lnt\"> 8\n</span><span class=\"lnt\"> 9\n</span><span class=\"lnt\">10\n</span><span class=\"lnt\">11\n</span><span class=\"lnt\">12\n</span><span class=\"lnt\">13\n</span><span class=\"lnt\">14\n</span><span class=\"lnt\">15\n</span></pre></td>\n<td class=\"lntd\">\n<pre class=\"chroma\">local function run(x, y)\nprint(&#39;run&#39;, x, y)\nend\n<p>local function attack(targetId)<br />\nprint('targetId', targetId)<br />\nend</p>\n<p>local function do_action(method, …)<br />\nlocal args = {…} or {}<br />\nmethod(unpack(args, 1, table.maxn(args)))<br />\nend</p>\n<p>do_action(run, 1, 2)         – output: run 1 2<br />\ndo_action(attack, 1111)      – output: targetId    1111</pre></td></tr></tbody></table></p>\n</div>\n</div></li>\n</ul></li>\n</ol>\n<p><code>unpack 内建函数还不能为 LuaJIT 所 JIT 编译，因此这种用法总是会被解释执行。对性能敏感的代码路径应避免这种用法。</code></p>\n<h3 id=\"模块\">模块</h3>\n<hr/>\n<h5 id=\"用法\">用法</h5>\n<p>my.lua</p>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tbody><tr><td class=\"lntd\">\n<pre class=\"chroma\"><span class=\"lnt\"> 1\n</span><span class=\"lnt\"> 2\n</span><span class=\"lnt\"> 3\n</span><span class=\"lnt\"> 4\n</span><span class=\"lnt\"> 5\n</span><span class=\"lnt\"> 6\n</span><span class=\"lnt\"> 7\n</span><span class=\"lnt\"> 8\n</span><span class=\"lnt\"> 9\n</span><span class=\"lnt\">10\n</span><span class=\"lnt\">11\n</span></pre></td>\n<td class=\"lntd\">\n<pre class=\"chroma\">local foo={}\n<p>local function getname()<br />\nreturn &quot;Lucy&quot;<br />\nend</p>\n<p>function foo.greeting()<br />\nprint(&quot;hello &quot; … getname())<br />\nend</p>\n<p>return foo</pre></td></tr></tbody></table></p>\n</div>\n</div>\n<p>main.lua</p>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tbody><tr><td class=\"lntd\">\n<pre class=\"chroma\"><span class=\"lnt\">1\n</span><span class=\"lnt\">2\n</span></pre></td>\n<td class=\"lntd\">\n<pre class=\"chroma\">local fp = require(&#34;my&#34;)\nfp.greeting()     --&gt;output: hello Lucy</pre></td></tr></tbody></table>\n</div>\n</div>\n<h3 id=\"string库\">string库</h3>\n<hr/>\n<h5 id=\"了解哈即可\">了解哈即可</h5>\n<h3 id=\"table-库\">table 库</h3>\n<h5 id=\"了解即可\">了解即可</h5>\n<h5 id=\"注意数组获取长度\">注意数组获取长度</h5>\n<ol>\n<li>对于常规的数组，里面从 1 到 n 放着一些非空的值的时候，它的长度就精确的为 n，即最后一个值的下标。如果数组有一个“空洞”（就是说，nil 值被夹在非空值之间），那么 #t 可能是指向任何一个是 nil 值的前一个位置的下标（就是说，任何一个 nil 值都有可能被当成数组的结束）。这也就说明对于有“空洞”的情况，table 的长度存在一定的 不可确定性。</li>\n</ol>\n<h3 id=\"时间库尽量用ngx-lua模块提供的\">时间库尽量用ngx_lua模块提供的</h3>","text":"函数 函数定义 1 2 3 function function_name (arc) -- arc 表示参数列表，函数的参数列表可以为空 -- body end 1 2 3 local function function_name (arc) -- body end 由于全局变量...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">函数定义</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">函数的参数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">函数返回值</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">全动态函数调用</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">模块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">用法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#string%E5%BA%93\"><span class=\"toc-text\">string库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%86%E8%A7%A3%E5%93%88%E5%8D%B3%E5%8F%AF\"><span class=\"toc-text\">了解哈即可</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#table-%E5%BA%93\"><span class=\"toc-text\">table 库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF\"><span class=\"toc-text\">了解即可</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E6%95%B0%E7%BB%84%E8%8E%B7%E5%8F%96%E9%95%BF%E5%BA%A6\"><span class=\"toc-text\">注意数组获取长度</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E5%BA%93%E5%B0%BD%E9%87%8F%E7%94%A8ngx-lua%E6%A8%A1%E5%9D%97%E6%8F%90%E4%BE%9B%E7%9A%84\"><span class=\"toc-text\">时间库尽量用ngx_lua模块提供的</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"LuaFramework","uid":"db140fe46b6f34be23d26c4682528f9b","slug":"zl/2016-01-01-928_LuaFramework","date":"2024-04-03T03:47:36.199Z","updated":"2024-04-03T03:47:36.199Z","comments":true,"path":"api/articles/zl/2016-01-01-928_LuaFramework.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"思考并回答以下问题： 用Lua写逻辑时，可以先用C#实现，再转换成Lua语言。这样好吗？ Lua的几个变种：XLua、ToLua（原uLua）和Slua都可以做Unity热更，而ToLua更是提供了一个简易的热更框架--LuaFramework_UGUI，使得上手变得容易，因此选...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"采访 Lua 发明人","uid":"516513f72d81df95c47f0577f2b63e14","slug":"zl/2016-01-01-925_采访 Lua 发明人","date":"2024-04-03T03:47:36.198Z","updated":"2024-04-03T03:47:36.198Z","comments":true,"path":"api/articles/zl/2016-01-01-925_采访 Lua 发明人.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;div class=&quot;entry&quot;&gt; &lt;p id=&quot;fortitle&quot;&gt; 2012-12-03 转载云风的一篇文章 采访 Lua 发明人的一篇文章 《Masterminds of Programming: Con...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}