{"title":"lua沙盒","uid":"e0634f6e1ca64b0c82fd90868116d14e","slug":"zl/2016-01-01-464_lua沙盒","date":"2024-04-03T03:47:35.743Z","updated":"2024-04-03T03:47:35.747Z","comments":true,"path":"api/articles/zl/2016-01-01-464_lua沙盒.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h3 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><p>Lua 给我的感觉是：各种内置函数和标准库的存在感都是比较强的。如果执行这句：   </p>\n<p><code>for name in pairs(_G) do print(_G) end</code><br/>就会把各种环境中已存在名称的打印出来：    </p>\n<p>全局变量：比如字符串 _VERSION。<br/>内置函数：比如 print、tonumber、dofile 之类。<br/>模块名称：比如 string、io、coroutine 之类。<br/>这里的全局变量 _G 就是存放环境的表（于是会有 _G 中存在着 _G._G 的递归）。   </p>\n<p>于是，平时对于全局变量的访问就可以等同于对 _G 表进行索引：   </p>\n<p>value = _G[varname]  –&gt; value = varname<br/>_G[varname] = value  –&gt; varname = value  </p>\n<h3 id=\"改变函数的环境\"><a href=\"#改变函数的环境\" class=\"headerlink\" title=\"改变函数的环境\"></a>改变函数的环境</h3><p>函数的上下文环境可以通过 setfenv(f, table) 函数改变，其中 table 是新的环境表，f 表示需要被改变环境的函数。如果 f 是数字，则将其视为堆栈层级（Stack   Level），从而指明函数（1 为当前函数，2 为上一级函数）：           </p>\n<pre><code>a = 3          -- 全局变量 a\nsetfenv(1, &#123;&#125;) -- 将当前函数的环境表改为空表\nprint(a)       -- 出错，因为当前环境表中 print 已经不存在了\n没错，不仅是 a 不存在，连 print 都一块儿不存在了。如果需要引用以前的 print 则需要在新的环境表中放入线索：\n<p>a = 3<br />\nsetfenv(1, &#123; g = _G &#125;)<br />\ng.print(a)             – 输出 nil<br />\ng.print(g.a)           – 输出 3<br />\n</code></pre><h3 id=\"沙盒\"><a href=\"#沙盒\" class=\"headerlink\" title=\"沙盒\"></a>沙盒</h3><p>于是，出于安全或者改变一些内置函数行为的目的，需要在执行 Lua   代码时改变其环境时便可以使用 setfenv   函数。仅将你认为安全的函数或者新的实现加入新环境表中：  </p></p>\n<pre><code>local env = &#123;&#125;  -- 沙盒环境表，按需要添入允许的函数  \n\nfunction run_sandbox(code)\n  local func, message = loadstring(code)\n  if not func then return nil, message end  -- 传入代码本身错误\n  setfenv(func, env)\n  return pcall(func)\nend\n</code></pre><p>Lua 5.2 的 _ENV 变量<br/>Lua 5.2 中所有对全局变量 var 的访问都会在语法上翻译为 _ENV.var。而 _ENV 本身被认为是处于当前块外的一个局部变量。（于是只要你自己定义一个名为 _ENV 的变量，就自动成为了其后代码所处的「环境」（enviroment）。另有一个「全局环境」（global enviroment）的概念，指初始的 _G 表。）</p>\n<p>Lua 的作者之一 Roberto Ierusalimschy 同志在介绍 Lua 5.2 时说：</p>\n<p>the new scheme, with _ENV, allows the main benefit of setfenv with a little more than syntactic sugar.</p>\n<p>就我的理解来说，优点就是原先虚无缥缈只能通过 setfenv、getfenv 访问的所谓「环境」终于实体化为一个始终存在的变量 _ENV 了。</p>\n<p>于是以下两个函数内容大致是一样的：</p>\n<pre><code>-- Lua 5.1\nfunction foobar()\n  setfenv(1, &#123;&#125;)\n  -- code here\nend\n<p>– Lua 5.2<br />\nfunction foobar()<br />\nlocal _ENV = &#123;&#125;<br />\n– code here<br />\nend<br />\n</code></pre><p>而更进一步的是，5.2 中对 load 函数作出了修改。（包括但不限于 😃）合并了 loadstring 功能，并可以在参数中指定所使用的环境表：</p></p>\n<p><code>local func, message = load(code, nil, &#34;t&#34;, env)</code></p>\n<h3 id=\"setfenv\"><a href=\"#setfenv\" class=\"headerlink\" title=\"setfenv\"></a>setfenv</h3><p>当我们在全局环境中定义变量时经常会有命名冲突，尤其是在使用一些库的时候，变量声明可能会发生覆盖，这时候就需要一个非全局的环境来解决这问题。setfenv函数可以满足我们的需求。     </p>\n<p>　　setfenv(f, table)：设置一个函数的环境     </p>\n<p>　　（1）当第一个参数为一个函数时，表示设置该函数的环境    </p>\n<p>　　（2）当第一个参数为一个数字时，为1代表当前函数，2代表调用自己的函数，3代表调用自己的函数的函数，以此类推   </p>\n<p>　　所谓函数的环境，其实一个环境就是一个表，该函数被限定为只能访问该表中的域，或在函数体内自己定义的变量。下面这个例子，设定当前函数的环境为一个空表，那么在设定执行以后，来自全局的print函数将不可见，所以调用会失败。   </p>\n<p>– 一个环境就是一个表，该表记录了新环境能够访问的全部域<br/>newfenv = {}<br/>setfenv(1, newfenv)<br/>print(1)        – attempt to call global `print’ (a nil value)<br/>　　我们可以这样继承已有的域：  </p>\n<pre><code>a = 10\nnewfenv = &#123;_G = _G&#125;\nsetfenv(1, newfenv)\n_G.print(1)        -- 1\n_G.print(_G.a)        -- 10\n_G.print(a)        -- nil 注意此处是nil，新环境没有a域，但可以通过_G.a访问_G的a域\n　　可以看到，新环境中可以访问_G，但有一点就是_G中的所有函数必须手动调用，这样其实很不方便。我们可以使用metatable来对上述代码进行改进：\n<p>– 任何赋值操作都对新表进行，不用担心误操作修改了全局变量表。另外，你仍然可以通过_G修改全局变量：<br />\nnewfenv = &#123;&#125;<br />\nsetmetatable(newfenv, &#123;__index = _G&#125;)<br />\nsetfenv(1, newfenv)<br />\nprint(1)        – 1 新环境直接继承了全局环境的所有域，好处：可以不需要通过_G来手动调用<br />\n</code></pre><p>　　这样，当访问到函数中不存在的变量时，会自动在_G中查找。对于当前函数和_G都存在的变量，可以通过是否用_G显示调用来区分，比如如果有两个a，那么_G.a表示继承来的，a就是当前函数环境的。    </p></p>\n<p>　　另外，可以通过getfenv(f)函数查看函数所处的环境，默认会返回全局环境_G。   </p>","text":"背景知识Lua 给我的感觉是：各种内置函数和标准库的存在感都是比较强的。如果执行这句： for name in pairs(_G) do print(_G) end就会把各种环境中已存在名称的打印出来： 全局变量：比如字符串 _VERSION。内置函数：比如 print、tonu...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">背景知识</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%94%B9%E5%8F%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">改变函数的环境</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B2%99%E7%9B%92\"><span class=\"toc-text\">沙盒</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#setfenv\"><span class=\"toc-text\">setfenv</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua","uid":"15b0cdc6d03f6c3f6bf8d3a7ff197317","slug":"zl/2016-01-01-462_Lua","date":"2024-04-03T03:47:35.743Z","updated":"2024-04-03T03:47:35.743Z","comments":true,"path":"api/articles/zl/2016-01-01-462_Lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"简单模式和完全模式 简单模式（simple model）拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。 完全模式（complete model） 使用外部的文件句柄来实现。它以一种面对对象的形式，将所有的文件操作定义为文件句柄的方法。 打开文件1file...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua元表详解","uid":"4a5da11af780eab3d33a48b37cf44e2e","slug":"zl/2016-01-01-460_lua元表详解","date":"2024-04-03T03:47:35.742Z","updated":"2024-04-03T03:47:35.742Z","comments":true,"path":"api/articles/zl/2016-01-01-460_lua元表详解.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"元表的作用元表是用来定义对table或userdata操作方式的表 举个例子123local t1 = {1}local t2 = {2}local t3 = t1 + t2 我们直接对两个table执行＋运算，会报错 1lua: /usercode/file.lua:3: at...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}