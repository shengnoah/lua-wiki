{"title":"Lua学习笔记(4)面向对象实现","uid":"9e83c6c60823836655cba905e4082c95","slug":"zl/2016-01-01-72_Lua学习笔记(4)面向对象实现","date":"2024-04-03T03:47:35.972Z","updated":"2024-04-03T03:47:35.974Z","comments":true,"path":"api/articles/zl/2016-01-01-72_Lua学习笔记(4)面向对象实现.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>百度搜索一下，给出出的解决方案和学习帖子很多，可是我还是有很多的问题！</p>\n<ul>\n  <li>\n    <p>什么是面向对象？</p>\n  </li>\n  <li>\n    <p>lua中怎么实现面向对象？</p>\n  </li>\n  <li>\n    <p>什么样的实现既简单又能完成我的功能？</p>\n  </li>\n  <li>\n    <p>一定要按照c++的方式实现类的继承吗？</p>\n  </li>\n</ul>\n<p>在学习lua面向对象的过程中我比较喜欢下面两种实现方式：</p>\n<h1 id=\"简单粗暴的实现\">简单粗暴的实现</h1>\n<blockquote>\n  <p>参考[1]：参考同事的方法，如果借鉴、转载请注明</p>\n</blockquote>\n<p>在lua中，我们知道table是万能的一个类型，当我们用table实现一个基类和子类的时候，他们都是确确实实存在的一个个table，都是有地址的。不会说像c++一样，类定义是类定义，只有new出来才是真正可以使用的，而lua却不是这样。所以，最简单的一种方法就是，每次继承基类的时候，直接copy基类的所有内容，函数除外，其他的成员都重新复制一遍，如果是table的话重新构建一个，并且把内容拷贝过来。代码如下：</p>\n<p>参考代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>--lua面向对象：简单粗暴的实现function copytable(tbArg)\n    local tbCollsion = &#123;&#125;\n<pre><code>--local的作用域问题local copy    \ncopy = function (obj)\n    if type(obj) ~= &amp;#34;table&amp;#34; thenreturn obj;\n    end--检查是否有嵌套循环的tableif tbCollsion[obj] thenreturn tbCollsion[obj];\n    endlocal tbNew = &#123;&#125;\n    tbCollsion[obj] = tbNew;\n    --递归复制for k, v in pairs(obj) do\n        tbNew[k] = copy(v);\n    end--复制完之后，元表关系也要保留下来return setmetatable(tbNew, getmetatable(obj))\nendreturn copy(tbArg);\n</code></pre>\n<p>endfunction inherit(tbBase, tbClass)<br />\n–复制基类local tbNew = copytable(tbBase)</p>\n<pre><code>local tm = &#123;&#125;\ntm.__index = tbClass;\nsetmetatable(tbNew, tm)\n\n--修改tbBase为tbClass中的成员或者新增加tbClass中的成员if tbClass thenfor k, v in pairs(tbClass) do\n        tbNew[k] = v\n    endendreturn tbNew;\n</code></pre>\n<p>end–使用local tbObject = {}<br />\nlocal tbFruit = inherit(tbObject)<br />\nlocal tbApple = inherit(tbFruit)<br />\nlocal tbBanana = inherit(tbFruit)<br />\nlocal tbBanana1 = inherit(tbFruit)<br />\nlocal tbBanana2 = inherit(tbFruit, tbBanana1)<br />\n</code></pre></div></div></p>\n<p>优点：</p>\n<ul>\n  <li>\n    <p>好理解</p>\n  </li>\n  <li>\n    <p>好用，不会出现共用一个table引用，导致其中一个修改影响了另外一个</p>\n  </li>\n  <li>\n    <p>共享函数引用</p>\n  </li>\n</ul>\n<p>缺点：</p>\n<ul>\n  <li>\n    <p>真正意义上的面向对象，继承等概念不清晰</p>\n  </li>\n  <li>\n    <p>一个子类new多个对象的概念是没有的，和继承已经混在了一起，所以如果要实现new多个对象的话，有代码冗余</p>\n  </li>\n</ul>\n<h1 id=\"概念意义上的实现\">概念意义上的实现</h1>\n<blockquote>\n  <p>参考[2]：云风的blog，如果借鉴、转载请注明</p>\n</blockquote>\n<p>这种从概念上实现面向对象的方法做到以下几点：</p>\n<ul>\n  <li>\n    <p>有类定义和对象的概念，类定义通过new来创建对象，并且同时调用自己的构造函数</p>\n  </li>\n  <li>\n    <p>子类可以访问基类的成员函数</p>\n  </li>\n  <li>\n    <p>类定义不能够调用函数（除了new之外），只有对象才能调用函数</p>\n  </li>\n  <li>\n    <p>构造函数调用有和c++一样的层级关系，先调用父类的构造函数，再调用子类的构造函</p>\n  </li>\n</ul>\n<p>参考代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>--lua面向对象：概念意义上的实现local _class=&#123;&#125;\n<p>function class(super)<br />\nlocal class_type=&#123;&#125;<br />\n–注意：因为重载了__newindex函数, 所以ctor不要定义为nil<br />\nclass_type.ctor=false<br />\nclass_type.super=super<br />\nclass_type.new=function(…)<br />\nlocal obj=&#123;&#125;<br />\n–下面的块只做了一件事：依次从父类到当前子类调用构造函数ctordolocal create<br />\ncreate = function(c,…)<br />\nif c.super then<br />\ncreate(c.super,…)<br />\nendif c.ctor then<br />\nc.ctor(obj,…)<br />\nendend</p>\n<pre><code>            create(class_type,...)\n        endsetmetatable(obj,&#123; __index=_class[class_type] &#125;)\n        return obj\n    end--新加成员：防止定义类调用函数local vtbl=&#123;&#125;\n_class[class_type]=vtbl\n\nsetmetatable(class_type,&#123;__newindex=\n    function(t,k,v)\n        vtbl[k]=v\n    end\n&#125;)\n\n--只有定义类修改了__newindex--vbtl只属于定义类--new出来的对象共享所有定义类的引用，但独享自己新增加的成员变量if super thensetmetatable(vtbl,&#123;__index=\n        function(t,k)\n            local ret=_class[super][k]\n            vtbl[k]=ret\n            return ret\n        end\n    &#125;)\nendreturn class_type\n</code></pre>\n<p>end<br />\n</code></pre></div></div></p>\n<p>说明几点：</p>\n<ul>\n  <li>只有定义类修改了__newindex</li>\n  <li>vbtl只属于定义类</li>\n  <li>new出来的对象共享所有定义类的引用，但独享自己新增加的成员变量</li>\n</ul>\n<p>优点：</p>\n<ul>\n  <li>\n    <p>概念上更加清晰，熟悉c++面向对象的很容易了解这个继承的关系</p>\n  </li>\n  <li>\n    <p>写法上感觉很牛逼，做到了定义不能调用函数这一点</p>\n  </li>\n  <li>\n    <p>共享函数引用</p>\n  </li>\n</ul>\n<p>缺点：</p>\n<ul>\n  <li>\n    <p>概念上清晰的成本是要更多的时间去理解</p>\n  </li>\n  <li>\n    <p>虽然做到了c++类定义和对象上的概念区别，但是还是有多东西没有实现</p>\n  </li>\n  <li>\n    <p>对象也可以定义自己的函数，这一点就直接打破了区分定义和对象的本源，但是价值还是有的</p>\n  </li>\n  <li>\n    <p>所有new出来对象共享类定义的引用对象，包括不需要复用的函数和table。由此多个对象共享一个定义的table很是个问题！</p>\n  </li>\n</ul>\n<blockquote>\n  <p>针对最后一条，可以通过实现定义的init函数，在init函数给不同的对象初始化不同的数据，即使是table！</p>\n</blockquote>\n<h1 id=\"总结\">总结</h1>\n<ul>\n  <li>\n    <p>面向对象</p>\n  </li>\n  <li>\n    <p>lua中的实现最主要就是使用talbe的元表和元方法</p>\n  </li>\n  <li>\n    <p>lua本身是用c实现的，可以做到很复杂的事情，但是做到满足自己的需求即可，没有必要搞得很复杂；如果非要苛求的话，往往会适得其反，不仅复杂难理解，性能上也会有影响</p>\n  </li>\n</ul>\n<h1 id=\"参考\">参考</h1>\n<p>[1]同事</p>\n<p>[2]<a href=\"http://blog.codingnow.com/cloud/LuaOO\">云风blog</a></p>","text":"百度搜索一下，给出出的解决方案和学习帖子很多，可是我还是有很多的问题！ 什么是面向对象？ lua中怎么实现面向对象？ 什么样的实现既简单又能完成我的功能？ 一定要按照c++的方式实现类的继承吗？ 在学习lua面向对象的过程中我比较喜欢下面两种实现方式： 简单粗暴的实现 参考[1]...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">简单粗暴的实现</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A6%82%E5%BF%B5%E6%84%8F%E4%B9%89%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">概念意义上的实现</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua模块与包 · 花生肉泥","uid":"fa26efea87641e4d0b61bbcc2aa1b1af","slug":"zl/2016-01-01-730_Lua模块与包 · 花生肉泥","date":"2024-04-03T03:47:35.974Z","updated":"2024-04-03T03:47:35.975Z","comments":true,"path":"api/articles/zl/2016-01-01-730_Lua模块与包 · 花生肉泥.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"lua的模块是由变量，函数等已知元素组成的table，因此创建一个模块很简单，就是创建一个table，然后把需要导出的常量，函数放入其中，最后返回这个table就行。 例：123456789101112131415161718192021-- 定义一个名为module的模块mod...","link":"","photos":[],"count_time":{"symbolsCount":881,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"nginx编译安装lua模块","uid":"eb06e9f2ad672616c91271c05869f3c6","slug":"zl/2016-01-01-729_nginx编译安装lua模块","date":"2024-04-03T03:47:35.971Z","updated":"2024-04-03T03:47:35.972Z","comments":true,"path":"api/articles/zl/2016-01-01-729_nginx编译安装lua模块.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"1. 获取nginx源代码1git clone https://github.com/nginx/nginx.git nginx-release 2. 下载安装LuaJIT1234git clone https://github.com/LuaJIT/LuaJIT.gitcd L...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}