{"title":"Lua源码笔记","uid":"89642c5c32e3c5c206257f92bd57a70c","slug":"zl/2016-01-01-840_Lua源码笔记","date":"2024-04-03T03:47:36.092Z","updated":"2024-04-03T03:47:36.093Z","comments":true,"path":"api/articles/zl/2016-01-01-840_Lua源码笔记.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>用Lua开发游戏已经有一段时间了，但是对Lua的理解还一直停留在浅层。最近想深入研究下，于是着手开始看Lua源码，并在本文记录知识点。</p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><h3 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h3><h4 id=\"1-基本数据结构\"><a href=\"#1-基本数据结构\" class=\"headerlink\" title=\"1.基本数据结构\"></a>1.基本数据结构</h4><p>Lua的基本数据结构是一个类型union+type。相关的核心代码如下：</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/><span class=\"line\">26</span><br/><span class=\"line\">27</span><br/><span class=\"line\">28</span><br/><span class=\"line\">29</span><br/><span class=\"line\">30</span><br/><span class=\"line\">31</span><br/><span class=\"line\">32</span><br/><span class=\"line\">33</span><br/><span class=\"line\">34</span><br/><span class=\"line\">35</span><br/><span class=\"line\">36</span><br/><span class=\"line\">37</span><br/><span class=\"line\">38</span><br/><span class=\"line\">39</span><br/><span class=\"line\">40</span><br/><span class=\"line\">41</span><br/><span class=\"line\">42</span><br/><span class=\"line\">43</span><br/><span class=\"line\">44</span><br/><span class=\"line\">45</span><br/><span class=\"line\">46</span><br/><span class=\"line\">47</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br/><span class=\"line\"><span class=\"comment\">** Common type for all collectable objects</span></span><br/><span class=\"line\"><span class=\"comment\">*/</span></span><br/><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>  ;</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"comment\">** Common Header for all collectable objects (in macro form, to be</span></span><br/><span class=\"line\"><span class=\"comment\">** included in other objects)</span></span><br/><span class=\"line\"><span class=\"comment\">*/</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">\tGCObject *next;  </span><br/><span class=\"line\">\tlu_byte tt;      </span><br/><span class=\"line\">\tlu_byte marked</span><br/><span class=\"line\"></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"comment\">** Common type has only the common header</span></span><br/><span class=\"line\"><span class=\"comment\">*/</span></span><br/><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> </span></span><br/><span class=\"line\"><span class=\"class\">{</span></span><br/><span class=\"line\">\tCommonHeader;</span><br/><span class=\"line\">};</span><br/><span class=\"line\"></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"comment\">** Tagged Values. This is the basic representation of values in Lua,</span></span><br/><span class=\"line\"><span class=\"comment\">** an actual value plus a tag with its type.</span></span><br/><span class=\"line\"><span class=\"comment\">*/</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"comment\">** Union of all Lua values</span></span><br/><span class=\"line\"><span class=\"comment\">*/</span></span><br/><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> Value {</span><br/><span class=\"line\">\tGCObject *gc;\t<span class=\"comment\">/* collectable objects */</span></span><br/><span class=\"line\">\t<span class=\"keyword\">void</span> *p;\t\t <span class=\"comment\">/* light userdata */</span></span><br/><span class=\"line\">\t<span class=\"keyword\">int</span> b;\t\t\t <span class=\"comment\">/* booleans */</span></span><br/><span class=\"line\">\tlua_CFunction f; <span class=\"comment\">/* light C functions */</span></span><br/><span class=\"line\">\tlua_Integer i;   <span class=\"comment\">/* integer numbers */</span></span><br/><span class=\"line\">\tlua_Number n;\t<span class=\"comment\">/* float numbers */</span></span><br/><span class=\"line\">} Value;</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TValuefields </span></span><br/><span class=\"line\">\tValue value_;    </span><br/><span class=\"line\">\t<span class=\"keyword\">int</span> tt_</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lua_TValue</span></span></span><br/><span class=\"line\"><span class=\"class\">{</span></span><br/><span class=\"line\">\tTValuefields;</span><br/><span class=\"line\">} TValue;</span><br/></pre></td></tr></tbody></table></figure>\n<h4 id=\"2-GC算法和流程\"><a href=\"#2-GC算法和流程\" class=\"headerlink\" title=\"2.GC算法和流程\"></a>2.GC算法和流程</h4><ol>\n<li><p>双色标记清除算法</p>\n<p>在Lua5.0中的GC，是一次性不可被打断的操作，执行的算法是Mark-and-sweep算法，在执行GC操作的时候，会设置2种颜色，黑色和白色，然后执行GC的流程，大体的伪代码流程如下:</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">每个新创建的对象为白色</span><br/><span class=\"line\"></span><br/><span class=\"line\">//初始化阶段</span><br/><span class=\"line\">遍历root链表中的对象，并将其加入到对象链表中    </span><br/><span class=\"line\"></span><br/><span class=\"line\">//标记阶段   </span><br/><span class=\"line\">当前对象链表中还有未被扫描的元素:    </span><br/><span class=\"line\">    从中取出对象并将其标记为黑色   </span><br/><span class=\"line\">    遍历这个对象关联的其他所有对象: </span><br/><span class=\"line\">        标记为黑色</span><br/><span class=\"line\">        </span><br/><span class=\"line\">//回收阶段</span><br/><span class=\"line\">遍历所有对象:   </span><br/><span class=\"line\">    如果为白色:   </span><br/><span class=\"line\">        这些对象没有被引用，则执行回收</span><br/><span class=\"line\">    否则: </span><br/><span class=\"line\">        这些对象仍然被引用，需要保留</span><br/></pre></td></tr></tbody></table></figure>\n<p>整个过程是不能被打断的，这是为了避免一种情况：<br/>如果可以被打断，在GC的过程中新创建一个对象<br/>那么如果标记为白色，此时处于回收阶段，那么这个对象没有被扫描就会被回收；<br/>如果标记为黑色，此时处于回收阶段，那么这个对象没有被扫描就会被保留<br/>两种情况都不适合，所以只有让整个过程不可被打断，带来的问题就是造成gc的时候卡顿</p>\n</li>\n<li><p>三色标记清除算法</p>\n<p>虽然是三色，本质是四色，颜色分为三种:</p>\n<p><strong>白色:</strong> 当前对象为待访问状态，表示对象还未被gc标记过，也就是对象创建的初始状态； 同理，如果在gc完成后，仍然为白色，则说明当前对象没有被引用，则可以被清除回收</p>\n<p><strong>灰色:</strong> 当前对象为待扫描状态，当前对象已经被扫描过，但是其引用的其他对象没有被扫描</p>\n<p><strong>黑色:</strong> 当前对象已经扫描过，并且其引用的其他对象也被扫描过</p>\n<p>其流程伪代码:</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">每个新创建的对象为白色</span><br/><span class=\"line\"></span><br/><span class=\"line\">//初始化阶段   </span><br/><span class=\"line\">遍历root阶段中引用的对象，从白色设置为灰色，并放入到灰色节点列表中   </span><br/><span class=\"line\"></span><br/><span class=\"line\">//标记阶段    </span><br/><span class=\"line\">当灰色链表中还有未被扫描的元素:    </span><br/><span class=\"line\">    从中去除一个对象并将其标记为黑色   </span><br/><span class=\"line\">    遍历这个对象关联的其他所有对象:   </span><br/><span class=\"line\">        如果是白色:</span><br/><span class=\"line\">            标记为灰色，并加入灰色链表中   </span><br/><span class=\"line\">            </span><br/><span class=\"line\">//回收阶段  </span><br/><span class=\"line\">遍历所有对象:   </span><br/><span class=\"line\">    如果为白色: </span><br/><span class=\"line\">        这些对象没有被引用，需要被回收</span><br/><span class=\"line\">    否则:</span><br/><span class=\"line\">        重新加入对象链表中等待下次gc</span><br/></pre></td></tr></tbody></table></figure>\n<p>整个标记过程是可以被打断的，被打断后回来只需要接着执行标记过程即可，回收阶段是不可被打断的。</p>\n<p>如何解决在标记阶段之后创建的对象为白色的问题?<br/>分裂白色为两种白色，一种为当前白色 currentwhite， 一种为非当前白色 otherwhite，新创建的对象都为otherwhite，则在执行回收的时候，如果为otherwhite则不执行回收操作，等待下次gc的时候，会执行白色的轮换，则新创建的对象会进入下一轮GC。</p>\n</li>\n</ol>","text":"用Lua开发游戏已经有一段时间了，但是对Lua的理解还一直停留在浅层。最近想深入研究下，于是着手开始看Lua源码，并在本文记录知识点。 模块GC1.基本数据结构Lua的基本数据结构是一个类型union+type。相关的核心代码如下： 12345678910111213141516...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">模块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GC\"><span class=\"toc-text\">GC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.基本数据结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-GC%E7%AE%97%E6%B3%95%E5%92%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">2.GC算法和流程</span></a></li></ol></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"nginx与lua的执行顺序和步骤说明","uid":"36864ebe1c02cd87187d51d88aaf35e2","slug":"zl/2016-01-01-83_nginx与lua的执行顺序和步骤说明 ","date":"2024-04-03T03:47:36.092Z","updated":"2024-04-03T03:47:36.092Z","comments":true,"path":"api/articles/zl/2016-01-01-83_nginx与lua的执行顺序和步骤说明 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"一. nginx执行步骤 nginx在处理每一个用户请求时，都是按照若干个不同的阶段依次处理的，与配置文件上的顺序没有关系，详细内容可以阅读《深入理解nginx:模块开发与架构解析》这本书，这里只做简单介绍； 1. post-read 读取请求内容阶段，nginx读取并解析完请求...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua特别之处笔记","uid":"1a1cf82db3f5dba4b69966eabcf53cea","slug":"zl/2016-01-01-839_Lua特别之处笔记","date":"2024-04-03T03:47:36.091Z","updated":"2024-04-03T03:47:36.092Z","comments":true,"path":"api/articles/zl/2016-01-01-839_Lua特别之处笔记.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;a href=&quot;/2015/02/02/gdb_tutorial/&quot; rel=&quot;next&quot; title=&quot;GDB基础教程&quot;&gt; &lt;i class=&quot;fa fa-chevron-left&qu...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}