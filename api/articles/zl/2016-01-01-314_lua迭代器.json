{"title":"lua迭代器","uid":"ecfc0e46121faea05c667f5289652c9b","slug":"zl/2016-01-01-314_lua迭代器","date":"2024-04-03T03:47:35.595Z","updated":"2024-04-03T03:47:35.595Z","comments":true,"path":"api/articles/zl/2016-01-01-314_lua迭代器.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>迭代器就是一种可以遍历一种集合中所有元素的机制，在Lua中，通常将迭代器表示为函数。每调用一次函数，就返回集合中的“下一个”元素。每个迭代器都需要在每次成功调用之后保存一些状态，这样才能知道它所在的位置及如何走到下一个位置，通过之前博文的总结，闭包对于这样的任务提供了极佳的支持。现在我们就用代码来实现一个简单的迭代器。</p>\n<pre><code>function values(tb)\n     local i = 0\n     return function ()\n          i = i + 1\n          return tb[i]\n     end\nend\n<p>local testTb = &#123;10, 20, 30&#125;<br />\nfor value in values(testTb) do<br />\nprint(value)<br />\nend<br />\n</code></pre><p>这就是一个最简单的迭代器，使用闭包来完成整个任务；这只是一个简单的例子，接下来，再看看泛型for的语义。</p></p>\n<h4 id=\"泛型for的语义\"><a href=\"#泛型for的语义\" class=\"headerlink\" title=\"泛型for的语义\"></a>泛型for的语义</h4><p>泛型for比较复杂，它在循环过程内保存了迭代器函数。它实际上保存着3个值：一个迭代器函数、一个恒定状态和一个控制变量。接下来，分别进行总结。<br/>泛型for的语法如下：</p>\n<pre><code>for &lt;var-list&gt; in &lt;exp-list&gt; do\n     &lt;body&gt;\nend\n</code></pre><p>其中，<var-list>是一个或多个变量名的列表，以逗号分隔；<exp-list>是一个或多个表达式的列表，同样以逗号分隔。通常表达式列表只有一个元素，即一句对迭代器函数的调用。例如：</exp-list></var-list></p>\n<p>for k, v in pairs(t) do print(k, v) end<br/>for做的第一件事就是对in后面的表达式求值，这些表达式应该返回3个值供for保存：迭代器函数、恒定状态和控制变量的初值。这里和多重赋值是一样的，只有最后一个表达式才会产生多个结果，并且只会保留前3个值，多余的值会被丢弃；而不够的话，就以nil补足。</p>\n<p>在初始化完成以后，for会以恒定状态和控制变量来调用迭代器函数。然后for将迭代器函数的返回值赋予变量列表中的变量。如果第一个返回值为nil，那么循环就终止，否则，for执行它的循环体，随后再次调用迭代器函数，并重复这个过程。在前言部分的代码中，只是返回了迭代器函数，并没有返回恒定状态和控制变量。下面通过代码来说明这个问题，比如：</p>\n<pre><code>for var_1, ..., var_n in &lt;explist&gt; do &lt;block&gt; end -- 就等价于以下代码：\ndo\n     local _f, _s, _var = &lt;explist&gt;    -- 返回迭代器函数、恒定状态和控制变量的初值\n     while true do\n          local var_1, ..., var_n = _f(_s, _var)\n          _var = var_1\n          if _var == nil then break end\n          &lt;block&gt;\n          end\n     end\nend\n</code></pre><h4 id=\"无状态的迭代器\"><a href=\"#无状态的迭代器\" class=\"headerlink\" title=\"无状态的迭代器\"></a>无状态的迭代器</h4><p>所谓“无状态的迭代器”，就是一种自身不保存任何状态的迭代器。因此，我们可以在多个循环中使用同一个无状态的迭代器，避免创建新的闭包的开销。</p>\n<p>在每次迭代中，for循环都会用恒定状态和控制变量来调用迭代器函数。一个无状态的迭代器可以根据这两个值来为下次迭代生成下一个元素。这类迭代器的代表就是ipairs。它可以用来迭代一个数组的所有元素。如下述演示代码：</p>\n<pre><code>local aTb = &#123;&#34;One&#34;, &#34;Two&#34;, &#34;Three&#34;&#125;\nfor i, v in ipairs(aTb) do\n     print(i, v)\nend\n</code></pre><p>在这里，迭代器状态就是需要遍历的table（一个恒定状态，它不会在循环中改变）及当前的索引值（控制变量）。我们可以使用Lua代码来实现ipairs，大概就如下代码：</p>\n<pre><code>local function iter(a, i)\n     i = i + 1\n     local v = a[i]\n     if v then\n          return i, v\n     end\nend\n<p>function ipairs(a)<br />\nreturn iter, a, 0<br />\nend<br />\n</code></pre><p>函数pairs与ipairs类似，也是用于遍历一个table中的所有元素。不同的是，它的迭代器函数是Lua中的一个基本函next。</p></p>\n<pre><code>function pairs(a)\n     return next, t, nil\nend\n</code></pre><p>在调用next(t, k)时，k是table t的一个key。此调用会以table中的任意次序返回一组值：此table的下一个key，及这个key所对应的值。而调用next(t, nil)时，返回table的第一组值。若没有下一组值时，next返回nil。所以，我们也可以使用next来判断一个table是否为空。</p>\n<p>对于大家经常迷惑的ipairs和pairs的区别，在这里就能看的一清二楚了，ipairs只能用于遍历index是整型的table，同时，由于ipairs返回的控制变量初值为0，这就决定了，ipairs只能访问index从1开始的key和value；ipairs不能返回nil，当key对应的值为nil时，就直接终止遍历；而pairs则没有要求。关于ipairs和pairs的具体差异，请参考这篇博文：点这里。</p>\n<p>当然了，有了无状态的迭代器，就有了有状态的迭代器了，有状态的迭代器就是专门用一个table来保存状态；在无状态的迭代器中，我们每一次都是迭代一个table，这个table就是一个无状态的table，它不会再遍历的过程中发生变化，而有状态的迭代器，则会在遍历的过程中对迭代的table进行变更，迭代的table的状态也随之发生了变化。这里不做详细的总结。</p>","text":"前言迭代器就是一种可以遍历一种集合中所有元素的机制，在Lua中，通常将迭代器表示为函数。每调用一次函数，就返回集合中的“下一个”元素。每个迭代器都需要在每次成功调用之后保存一些状态，这样才能知道它所在的位置及如何走到下一个位置，通过之前博文的总结，闭包对于这样的任务提供了极佳的支...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8Bfor%E7%9A%84%E8%AF%AD%E4%B9%89\"><span class=\"toc-text\">泛型for的语义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">无状态的迭代器</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"每周一论文：An Empirical Evaluation of In","uid":"0b77060d08022f719138953da135e44a","slug":"zl/2016-01-01-313_每周一论文：An Empirical Evaluation of In","date":"2024-04-03T03:47:35.595Z","updated":"2024-04-03T03:47:35.595Z","comments":true,"path":"api/articles/zl/2016-01-01-313_每周一论文：An Empirical Evaluation of In.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"论文概要多版本并发控制(Multi-Version Concurrency Control，以下简称MVCC) 是当今数据库领域最流行的并发控制实现，MVCC 在最大化并发度的情况下尽可能保证事务的正确性，其好处有： 写不会阻塞读 只读事务无需数据库锁就能支持可重复读 可以很好地...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"热更新之xLua","uid":"7b924de70ea203910be828eb8399f249","slug":"zl/2016-01-01-312_热更新之xLua","date":"2024-04-03T03:47:35.594Z","updated":"2024-04-03T03:47:35.594Z","comments":true,"path":"api/articles/zl/2016-01-01-312_热更新之xLua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"思考并回答以下问题：1.Lua有哪两种作用？2.如何安装xLua？ Unity热更新有两大流派，C#派和lua派，那lua派是啥样的呢？ lua是一门历史悠久的脚本语言，从端游那个年代就被广泛应用在游戏开发中，所以到了现在的手游时代，有很多团队也让lua技术再次发展了起来。 Lu...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}