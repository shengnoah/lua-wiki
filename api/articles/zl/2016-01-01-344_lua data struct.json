{"title":"lua data struct","uid":"be3005dc20f946c578282785ec07b2f0","slug":"zl/2016-01-01-344_lua data struct","date":"2024-04-03T03:47:35.623Z","updated":"2024-04-03T03:47:35.623Z","comments":true,"path":"api/articles/zl/2016-01-01-344_lua data struct.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>TValue是lua中的通用数据结构，lua中的所有数据都可以使用这个结构表示。下面看一下与TValue定义相关的数据结构：</p>\n<pre><code>/*\n** &#123;======================================================\n** types and prototypes\n** =======================================================\n*/\nunion Value &#123;\n  \t\tGCObject *gc;    /* collectable objects */\n  \t\tvoid *p;         /* light userdata */\n  \t\tint b;           /* booleans */\n  \t\tlua_CFunction f; /* light C functions */\n  \t\tlua_Integer i;   /* integer numbers */\n  \t\tlua_Number n;    /* float numbers */\n&#125;;\n\n/*\n** Union of all Lua values\n*/\ntypedef union Value Value;\n\n/*\n** Tagged Values. This is the basic representation of values in Lua,\n** an actual value plus a tag with its type.\n*/\n#define TValuefields\tValue value_; int tt_\n\nstruct lua_TValue &#123;\n  \t\tTValuefields;\n&#125;;\n\ntypedef struct lua_TValue TValue;\n\n/*\n** Common type for all collectable objects\n*/\ntypedef struct GCObject GCObject;\n\n\n/*\n** Common Header for all collectable objects (in macro form, to be\n** included in other objects)\n*/\n#define CommonHeader\tGCObject *next; lu_byte tt; lu_byte marked\n\n\n/*\n** Common type has only the common header\n*/\nstruct GCObject &#123;\n \t\tCommonHeader;\n&#125;;\n</code></pre>\n<p>下面把TValue结构中相关的宏展开：</p>\n<pre><code>typedef struct lua_TValue &#123;\n\tunion &#123;\n\t\tstruct GCObject &#123;\n\t\t\tGCObject *next;\n\t\t\tlu_byte tt;\n\t\t\tlu_byte marked;\n\t\t&#125; *gc;\n\t\tvoid *p;\n\t\tint b;\n\t\tlua_CFunction f;\n\t\tlua_Integer i;\n\t\tlua_Number n;\n\t&#125; value_;\n\tint tt_;\n&#125; TValue;\n</code></pre>\n<p>这个结构可以分为两部分：一部分tt_用来标识数据类型，而另一部分value_用来存放相关的数据。联合体gc部分用来存放可gc对象的gc相关的信息：next指针将可gc对象连成链表，tt表示数据类型，marked表示gc处理时的颜色值。从源码时可以看出各种可gc的对象的结构都会包含CommonHeader这个头信息来处理gc相关的信息。</p>\n<p>lua中stack相关的信息被表示为TValue的指针，如果：</p>\n<pre><code>typedef TValue *StkId;  /* index to stack elements */\n</code></pre>\n<p>下面是字符串结构：</p>\n<pre><code>/*\n** Header for string value; string bytes follow the end of this structure\n** (aligned according to &#39;UTString&#39;; see next).\n*/\ntypedef struct TString &#123;\n  \t\tCommonHeader;\n  \t\tlu_byte extra;  /* reserved words for short strings; &#34;has hash&#34; for longs */\n  \t\tlu_byte shrlen;  /* length for short strings */\n  \t\tunsigned int hash;\n  \t\tunion &#123;\n\t\tsize_t lnglen;  /* length for long strings */\n\t\tstruct TString *hnext;  /* linked list for hash table */\n  \t\t&#125; u;\n&#125; TString;\n\n/*\n** Ensures that address after this type is always fully aligned.\n*/\ntypedef union UTString &#123;\n  \t\tL_Umaxalign dummy;  /* ensures maximum alignment for strings */\n  \t\tTString tsv;\n&#125; UTString;\n</code></pre>\n<p>字符串一旦创建，则不可被改写。lua的值对象若这字符串类型，则以引用方式存在。属于被gc管理的对象。当一个字符串没有任何地方引用就可以回收它。\n除了用于gc的CommonHeader外，还有extra shrlen hash和u域。extra对于短字符串来说用于记录这个字符串是否为保留字，这个标识用于词法分析器对保留字的快速判断，对于长字符串存hash值。\nhash记录字符串的hash值用来加快字符串的相关操作。shrlen用于记录短字符串的长度。u为联合体其中lnglen记录长字符串的长度，hnext为链表指针。\n字符串的实际值并没有分配独立的内在来保存，而是直接加在UTString后面。用下面的宏就可以取到实际的C字符串指针：</p>\n<pre><code>/*\n** Get the actual string (array of bytes) from a &#39;TString&#39;.\n** (Access to &#39;extra&#39; ensures that value is really a &#39;TString&#39;.)\n*/\n#define getaddrstr(ts)\t(cast(char *, (ts)) + sizeof(UTString))\n#define getstr(ts)  \n  \t\tcheck_exp(sizeof((ts)-&gt;extra), cast(const char*, getaddrstr(ts)))\n</code></pre>\n<p>所有的短字符串被存放在全局状态机(global_State)的strt域中，strt的数据类型如下：</p>\n<pre><code>typedef struct stringtable &#123;\n  \t\tTString **hash;\n  \t\tint nuse;  /* number of elements */\n  \t\tint size;\n&#125; stringtable;\n</code></pre>\n<p>相同的短字符串在同一个lua state中存在唯一一份，这样不仅能减小内在而且还提高了比较相关的操作的效率。\n长字符串则独立存在，从外部压入一个长字符串时，简单的复制一遍字符串。但不立即计算其hash值，推迟到对字符串作匹配时。</p>\n<p>Userdata在lua中并没有特别之处，在储存形式上和字符串相同。可以看成是拥有独立的元表，不被内部化处理，也不需要追加","text":"TValue是lua中的通用数据结构，lua中的所有数据都可以使用这个结构表示。下面看一下与TValue定义相关的数据结构： /* ** &#123;====================================================== ** types a...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"redis编写lua脚本","uid":"a628b5f8d3069a00eec61e6c67b75d18","slug":"zl/2016-01-01-347_redis编写lua脚本","date":"2024-04-03T03:47:35.624Z","updated":"2024-04-03T03:47:35.624Z","comments":true,"path":"api/articles/zl/2016-01-01-347_redis编写lua脚本.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"由于redis并没有类似mysql或者mongo的乐观锁机制，并发控制成了一个棘手的问题这块是可以用redis的watch来做，但是如果能实现乐观锁，那就非常方便了 redis使用lua的基础语法12345&gt; eval &#34;return {KEYS[1],KEYS[2...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua学习笔记（二）","uid":"e07778deeaf81d4e352e39b31a6e0149","slug":"zl/2016-01-01-345_lua学习笔记（二）","date":"2024-04-03T03:47:35.623Z","updated":"2024-04-03T03:47:35.624Z","comments":true,"path":"api/articles/zl/2016-01-01-345_lua学习笔记（二）.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua变量12345678910111213141516171819202122232425Lua变量三种类型：全局变量（储存在名称为_G的table中）、局部变量、table中的域Lua中的变量全都是全局变量，即使在语句块或函数里，除非用local显式声明为局部变量局部变量作用...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}