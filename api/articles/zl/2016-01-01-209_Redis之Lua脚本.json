{"title":"Redis之Lua脚本","uid":"f5df4819644a6a6a65feb7630929c7d1","slug":"zl/2016-01-01-209_Redis之Lua脚本","date":"2024-04-03T03:47:33.089Z","updated":"2024-04-03T03:47:33.089Z","comments":true,"path":"api/articles/zl/2016-01-01-209_Redis之Lua脚本.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>    &lt;p&gt;Redis中内嵌了对Lua环境的支持，允许开发者使用Lua语言编写脚本传到Redis中执行，直接在服务端原子的执行多个Redis命令。&lt;/p&gt;\n</code></pre>\n<p>使用Lua脚本的好处：</p>\n<ol>\n<li>减少网络开销，在Lua脚本中可以把多个命令放在同一个脚本中运行</li>\n<li>原子操作，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入</li>\n<li>复用性，客户端发送的脚本会永远存储在redis中，其他客户端可以复用这一脚本来完成同样的逻辑</li>\n</ol>\n<h1 id=\"Lua脚本使用\"><a href=\"https://cpp288.github.io/#Lua%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8\" class=\"headerlink\" title=\"Lua脚本使用\"></a>Lua脚本使用</h1><h2 id=\"在Lua脚本中调用Redis命令\"><a href=\"https://cpp288.github.io/#%E5%9C%A8Lua%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%B0%83%E7%94%A8Redis%E5%91%BD%E4%BB%A4\" class=\"headerlink\" title=\"在Lua脚本中调用Redis命令\"></a>在Lua脚本中调用Redis命令</h2><p>在Lua脚本中调用Redis命令，可以使用<code>redis.call</code>函数调用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis.call('set', 'hello', 'world')</span><br><span class=\"line\">local value = redis.call('get', 'hello')</span><br></pre></td></tr></table></figure></p>\n<p><code>redis.call</code>函数的返回值就是redis命令的执行结果，<code>redis.call</code>函数会将redis的数据类型返回值转换对应的Lua的数据类型，在脚本中可以使用return语句将值返回给redis客户端，如果没有执行return，默认返回为nil</p>\n<h2 id=\"EVAL命令\"><a href=\"https://cpp288.github.io/#EVAL%E5%91%BD%E4%BB%A4\" class=\"headerlink\" title=\"EVAL命令\"></a>EVAL命令</h2><p>格式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[EVAL][脚本内容][key参数的数量][key...][arg...]</span><br></pre></td></tr></table></figure></p>\n<p>可以通过key和arg这两个参数向脚本中传递数据，他们的值可以在脚本中分别使用KEYS和ARGV这两个类型的全局变量访问，比如：</p>\n<p>Lua脚本：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return redis.call('set',KEYS[1],ARGV[1]) // KEYS和ARGV必须大写</span><br></pre></td></tr></table></figure></p>\n<p>EVAL命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval \"return redis.call('set',KEYS[1],ARGV[1])\" 1 lua1 hello</span><br></pre></td></tr></table></figure></p>\n<p>注意：EVAL命令是根据key参数的数量，也就是上面例子中的1来将后面所有参数分别存入脚本中KEYS和ARGV两个表类型的全局变量。当脚本不需要任何参数时也不能省略这个参数，如果没有则设置为0：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval \"return redis.call('get','lua1')\" 0</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"EVALSHA命令\"><a href=\"https://cpp288.github.io/#EVALSHA%E5%91%BD%E4%BB%A4\" class=\"headerlink\" title=\"EVALSHA命令\"></a>EVALSHA命令</h2><p>考虑到通过eval执行lua脚本，脚本比较长的情况下，每次调用脚本都需要把整个脚本传给redis，比较占用带宽。为了解决这个问题，redis提供了EVALSHA命令，允许通过脚本内容的SHA1摘要来执行脚本。</p>\n<p>该命令用法和EVAL一样，只不过是将脚本内容替换成脚本内容的SHA1摘要：</p>\n<ol>\n<li>Redis在执行EVAL命令时会计算脚本的SHA1摘要并记录在脚本缓存中</li>\n<li>执行EVALSHA命令时Redis会根据提供的摘要从脚本缓存中查找对应的脚本内容，如果找到了就执行，否则返回“NOSCRIPT No matching script, Please use EVAL”</li>\n</ol>\n<p>将脚本加入缓存并生成sha1摘要：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script load \"return redis.call('get',\"lua1\")\"</span><br></pre></td></tr></table></figure></p>\n<p>使用EVALSHA执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evalsha \"a5a402e90df3hkfakyi32970058233hjfd574\" 0</span><br></pre></td></tr></table></figure></p>\n<p>我们在调用eval命令之前，先执行evalsha命令，如果提示脚本不存在，则再调用eval命令</p>","text":" &lt;p&gt;Redis中内嵌了对Lua环境的支持，允许开发者使用Lua语言编写脚本传到Redis中执行，直接在服务端原子的执行多个Redis命令。&lt;/p&gt; 使用Lua脚本的好处： 减少网络开销，在Lua脚本中可以把多个命令放在同一个脚本中运行 原子操作，red...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Lua%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">Lua脚本使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8Lua%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%B0%83%E7%94%A8Redis%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">在Lua脚本中调用Redis命令</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EVAL%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">EVAL命令</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EVALSHA%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">EVALSHA命令</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lazy Evaluation 的原理与实现","uid":"d7bcce7d3fdaca51ca7bf745ecf3d47b","slug":"zl/2016-01-01-212_Lazy Evaluation 的原理与实现","date":"2024-04-03T03:47:33.090Z","updated":"2024-04-03T03:47:33.091Z","comments":true,"path":"api/articles/zl/2016-01-01-212_Lazy Evaluation 的原理与实现.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"&lt;p&gt;Lazy Evaluation 是Haskell进程的求值方式。当把一个表达式与一个变量绑定时，这个表达式并没有被立即求值，而是当它的结果需要被其他的计算用到时才会求值。因此，在调用函数时，参数也不会在调用前求值， 而是当它的值被用到是才会求值。Technica...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"深入Lua","uid":"b53ad1c28b606c3d0d932548066c6b45","slug":"zl/2016-01-01-207_深入Lua ","date":"2024-04-03T03:47:33.085Z","updated":"2024-04-03T03:47:33.085Z","comments":true,"path":"api/articles/zl/2016-01-01-207_深入Lua .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"该篇文章将从Lua string的底层代码去分析字符串是如何创建、缓存、以及扩容的，深入分析了Lua字符串的整个工作原理。 字符串结构定义Lua中字符串结构体定义: 1234567891011121314151617181920212223242526272829/*** Hea...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}