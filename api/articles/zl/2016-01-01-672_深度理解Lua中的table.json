{"title":"深度理解Lua中的table","uid":"abe49e98abae713bee593ac15ed4e6fc","slug":"zl/2016-01-01-672_深度理解Lua中的table","date":"2024-04-03T03:47:35.898Z","updated":"2024-04-03T03:47:35.899Z","comments":true,"path":"api/articles/zl/2016-01-01-672_深度理解Lua中的table.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>Lua的table是个很有意思的东西。有些内容平时写代码的时候很少接触到，但是了解一下还是很有意思的。</p>\n<p>这篇blog参考<a href=\"http://lua-users.org/wiki/MetatableEvents\">MetatableEvents</a>，一个一个边写测试边细说。</p>\n<h2 id=\"__newindex\">__newindex</h2>\n<p>原文翻译：</p>\n<p><code class=\"highlighter-rouge\">__newindex</code>用于分配属性，当调用 <code class=\"highlighter-rouge\">myTable[key]=value</code>时，如果元表中有<code class=\"highlighter-rouge\">__newindex</code>并且指向一个function，就会调用这个function，传入的参数为table, key 和 value</p>\n<ul>\n  <li>用 <code class=\"highlighter-rouge\">rawset(myTable, key, value)</code>可以跳过这个元方法直接给myTable的key属性赋值为value。</li>\n  <li>如果<code class=\"highlighter-rouge\">__newindex</code>指向的方法中，没有调用<code class=\"highlighter-rouge\">rawset</code>方法，传入的键值对（key/value）就不会添加到myTable中。</li>\n</ul>\n<p>测试代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local meta = &#123;\n    __newindex = function(t, key, value)\n        print(&#34;call __newindex&#34;,t, key, value)\n    end\n&#125;\n<p>local test = &#123;&#125;<br />\nsetmetatable(test, meta)</p>\n<p>print(&quot;test&quot;, test)<br />\nprint(&quot;meta&quot;, meta)</p>\n<p><a href=\"http://test.name\">test.name</a> = &quot;t1&quot;<br />\n<a href=\"http://test.name\">test.name</a> = &quot;t2&quot;<br />\nprint(&quot;test.name&quot;, <a href=\"http://test.name\">test.name</a>)</p>\n<p>---- result output ----<br />\ntest\ttable: 0x7f9c13406f00<br />\nmeta\ttable: 0x7f9c13407240<br />\ncall __newindex\ttable: 0x7f9c13406f00\tname\tt1<br />\ncall __newindex\ttable: 0x7f9c13406f00\tname\tt2<br />\n<a href=\"http://test.name\">test.name</a>\tnil<br />\n</code></pre></div></div></p>\n<p>测试代码中，当给t的name的赋值时，就会触发元表中的__newindex指向的function，打印的信息可以看到key和value的值。</p>\n<p><code class=\"highlighter-rouge\">__newindex</code>方法中传进来的参数<code class=\"highlighter-rouge\">t</code>的指针和<code class=\"highlighter-rouge\">test</code>的指针指向同一个地址，说明<code class=\"highlighter-rouge\">__newindex</code>中的参数<code class=\"highlighter-rouge\">t</code>，并不是元表。</p>\n<p>测试代码中对t.name连续赋值时，<code class=\"highlighter-rouge\">__newindex</code>会连续调用，需要留意一下这里，后面的测试会跟这里做一个对比。</p>\n<p>赋值之后打印 t.name 的值是空的。原因是<code class=\"highlighter-rouge\">__newindex</code>并没有给t.name赋值，我们用一个错误的方式给t.name赋值，来加深<code class=\"highlighter-rouge\">__newindex</code>的理解。修改一下测试代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local meta = &#123;\n    __newindex = function(t, key, value)\n        print(&#34;call __newindex&#34;,t, key, value)\n        t[key] = value\n    end\n&#125;\n<p>local test = &#123;&#125;<br />\nsetmetatable(test, meta)</p>\n<p>print(&quot;test&quot;, test)<br />\nprint(&quot;meta&quot;, meta)</p>\n<p><a href=\"http://test.name\">test.name</a> = &quot;t1&quot;<br />\n<a href=\"http://test.name\">test.name</a> = &quot;t2&quot;<br />\nprint(<a href=\"http://test.name\">test.name</a>)</p>\n<p>---- result output ----<br />\n…<br />\nlua: C stack overflow<br />\n…<br />\n</code></pre></div></div></p>\n<p>报错信息，栈溢出。因为<code class=\"highlighter-rouge\">t[key] = value</code>这段代码会调用t元表中的<code class=\"highlighter-rouge\">__newindex</code>的方法，<code class=\"highlighter-rouge\">__newindex</code>的方法又会调用<code class=\"highlighter-rouge\">t[key] = value</code>，这样就进入了死循环，导致栈溢出。这时就需要用到方法<code class=\"highlighter-rouge\">rawset</code>。</p>\n<p>修改测试代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local meta = &#123;\n    __newindex = function(t, key, value)\n        print(&#34;call __newindex&#34;,t, key, value)\n        rawset(t, key, value)\n    end\n&#125;\n<p>local test = &#123;&#125;<br />\nsetmetatable(test, meta)</p>\n<p><a href=\"http://test.name\">test.name</a> = &quot;t1&quot;<br />\n<a href=\"http://test.name\">test.name</a> = &quot;t2&quot;<br />\nprint(&quot;test.name&quot;, <a href=\"http://test.name\">test.name</a>)</p>\n<p>---- result output ----<br />\ncall __newindex\ttable: 0x7fdade404e20\tname\tt1<br />\n<a href=\"http://test.name\">test.name</a>\tt2<br />\n</code></pre></div></div></p>\n<p>这段代码中信息比较多</p>\n<p>在<code class=\"highlighter-rouge\">__newindex</code>中使用了<code class=\"highlighter-rouge\">rawset</code>方法，可以看到，没有栈溢出的错误了，说明用<code class=\"highlighter-rouge\">rawset</code>给table赋值，不会进入<code class=\"highlighter-rouge\">__newindex</code>\n的方法。</p>\n<p>给t.name连续赋值，会发现只进入<code class=\"highlighter-rouge\">__newindex</code>一次，跟之前不同的是，我们在<code class=\"highlighter-rouge\">__newindex</code>给t.name赋了值。如果t中没有这个key时，才会进入<code class=\"highlighter-rouge\">__newindex</code>方法。否则不会进入。</p>\n<p><code class=\"highlighter-rouge\">__newindex</code>的默认值就是上面<code class=\"highlighter-rouge\">meta.__newindex</code>的代码。如果不需要额外处理，完全可以不写。如下：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local meta = &#123;&#125;\nlocal test = &#123;&#125;\nsetmetatable(test, meta)\n<p><a href=\"http://test.name\">test.name</a> = &quot;t1&quot;<br />\nprint(&quot;test.name&quot;, <a href=\"http://test.name\">test.name</a>)</p>\n<p>---- result output ----<br />\n<a href=\"http://test.name\">test.name</a>\tt1</p>\n<p></code></pre></div></div></p>\n<h2 id=\"__index\">__index</h2>\n<p>翻译原文</p>\n<p><code class=\"highlighter-rouge\">__index</code>用于控制属性（prototype）的继承，当访问 myTable[key] 时，如果myTable中不存在这个key，但是如果元表（metatable）中有 <code class=\"highlighter-rouge\">__index</code>时：</p>\n<ul>\n  <li>如果<code class=\"highlighter-rouge\">__index</code>是一个<code class=\"highlighter-rouge\">function</code>，传递的参数是<code class=\"highlighter-rouge\">table</code>和<code class=\"highlighter-rouge\">key</code>,<code class=\"highlighter-rouge\">function</code>的返回值作为结果返回。</li>\n  <li>如果<code class=\"highlighter-rouge\">__index</code>是一个<code class=\"highlighter-rouge\">table</code>，就返回这个表中key对应的值。\n    <ul>\n      <li>如果这个<code class=\"highlighter-rouge\">table</code>不存在该<code class=\"highlighter-rouge\">key</code>，但是这个<code class=\"highlighter-rouge\">table</code>有元表，会继续寻找元表中的<code class=\"highlighter-rouge\">__index</code>属性，以此类推。都没有就返回<code class=\"highlighter-rouge\">nil</code></li>\n    </ul>\n  </li>\n  <li>使用 “rawget(myTable,key)” 可以跳过这个元方法（__index）.</li>\n</ul>\n<p>写点测试：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local test = &#123;&#125;\n<p>local meta = &#123;<br />\n__index = function(t, k)<br />\nprint(&quot;__index&quot;, k)<br />\nif rawget(t, k) == nil then<br />\nprint(&quot;Can't find &quot;… k)<br />\nend</p>\n<pre><code>    return rawget(t, k)\nend,\n</code></pre>\n<p>}</p>\n<p>setmetatable(test, meta)</p>\n<p>print(&quot;test.name1&quot;, <a href=\"http://test.name\">test.name</a>)<br />\n<a href=\"http://test.name\">test.name</a> = &quot;hello&quot;<br />\nprint(&quot;test.name2&quot;, <a href=\"http://test.name\">test.name</a>)</p>\n<p>---- result output ----</p>\n<p>__index\tname<br />\nCan't find name<br />\ntest.name1\tnil<br />\ntest.name2\thello<br />\n</code></pre></div></div></p>\n<p><code class=\"highlighter-rouge\">__newindex</code>和<code class=\"highlighter-rouge\">__index</code>其实可以类比成setter和getter，这么类比会比较容易理解，但是实际上还是有比较大的区别。</p>\n<p>上面的测试中<code class=\"highlighter-rouge\">__index</code>是个function。当执行test.name时，如果test.name是nil，会调用<code class=\"highlighter-rouge\">__index</code>的function，并返回function的返回值。否则，直接返回test[key]，不会进入<code class=\"highlighter-rouge\">__index</code>。</p>\n<p>再做一个测试，这次<code class=\"highlighter-rouge\">__index</code>是个table</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local test = &#123;&#125;\n<p>local meta = &#123;<br />\n__index = &#123;name=&quot;meta&quot;&#125;,<br />\n&#125;</p>\n<p>setmetatable(test, meta)</p>\n<p>print(&quot;test.name1&quot;, <a href=\"http://test.name\">test.name</a>)<br />\n<a href=\"http://test.name\">test.name</a> = &quot;hello&quot;<br />\nprint(&quot;test.name2&quot;, <a href=\"http://test.name\">test.name</a>)</p>\n<p>---- result output ----</p>\n<p>test.name1\tmeta<br />\ntest.name2\thello<br />\n</code></pre></div></div></p>\n<p>这个测试可以看到，访问顺序是先访问test的name，如果没有值，再访问test元表中<code class=\"highlighter-rouge\">__index</code>的table。如果test的元表还有元表，会继续向上访问，Lua继承的实现就是利用这个特性。</p>\n<p>掌握<code class=\"highlighter-rouge\">__newindex</code>和<code class=\"highlighter-rouge\">__index</code>这两个元方法，可以把这两个元方法看做两个事件，那要就要清楚两个方法的触发条件和特性。才能融会贯通。</p>\n<p>举个例子：</p>\n<p>禁用全局变量</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local meta = &#123;\n    __newindex = function(t, k, v)\n        print(&#34;Error! Can&#39;t set globle variable&#34;, k)\n    end,\n<pre><code>-- 默认实现\n-- __index = function(t, k)\n--     return rawget(t, k)\n-- end\n</code></pre>\n<p>}</p>\n<p>setmetatable(_G, meta)</p>\n<p>test = &quot;test&quot;<br />\nprint(test)</p>\n<p>---- result output ----</p>\n<p>Error! Can't set globle variable\ttest<br />\nnil<br />\n</code></pre></div></div></p>\n<h2 id=\"__mode\">__mode</h2>\n<p>原文翻译:</p>\n<p>控制弱引用，用字符<code class=\"highlighter-rouge\">k</code>和<code class=\"highlighter-rouge\">v</code>来代表table的<code class=\"highlighter-rouge\">键</code>和<code class=\"highlighter-rouge\">值</code>是否是弱引用。这个感觉没什么好说的，只写个测试就好了。</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local meta = &#123;__mode = &#34;k&#34;&#125;\nlocal test = &#123;&#125;\nsetmetatable(test, meta)\nkey = &#123;&#125;\ntest[key] = 1\nkey = &#123;&#125;\ntest[key] = 2\nfor k,v in pairs(test) do\n    print(v)\nend\n<p>collectgarbage()<br />\nprint(&quot;collectgarbage&quot;)</p>\n<p>for k,v in pairs(test) do<br />\nprint(v)<br />\nend</p>\n<p>---- result output ----</p>\n<p>1<br />\n2<br />\ncollectgarbage<br />\n2<br />\n</code></pre></div></div></p>\n<p>例子中当调用collectgarbage()进行回收后，test表中只剩下一个值。弱引用的key被清理了。我们也可以在__mode中设置<code class=\"highlighter-rouge\">v</code>,<code class=\"highlighter-rouge\">kv</code>来表示<code class=\"highlighter-rouge\">值</code> <code class=\"highlighter-rouge\">键和值</code>都是弱引用。</p>\n<h2 id=\"__call\">__call</h2>\n<p>原文翻译:</p>\n<p>把table当做一个function使用，当table后跟一个圆括号时，而且table的元表中的__call指向一个function，就会调用这个function，table自己做为第一个参数，后面可接任意数量的参数，返回值就是function的返回值。</p>\n<p>测试代码来模拟实现一个构造方法。</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local meta = &#123;\n    __call = function(t, ...)\n<pre><code>    local instance = &#123;&#125;\n    for k, v in pairs(t) do\n        instance[k] = v\n    end\n    return instance\nend\n</code></pre>\n<p>}</p>\n<p>local A = setmetatable({}, meta)</p>\n<p>function A:info()<br />\nprint(&quot;info&quot;,self)<br />\nend</p>\n<p>local a = A()<br />\nlocal b = A()</p>\n<p>a:info()<br />\nb:info()</p>\n<p>---- result output ----<br />\ninfo\ttable: 0x7f8771e05030<br />\ninfo\ttable: 0x7f8771e050a0<br />\n</code></pre></div></div></p>\n<h2 id=\"__metatable\">__metatable</h2>\n<p>原文翻译：</p>\n<p>隐藏真正的元表，当调用<code class=\"highlighter-rouge\">getmetatable</code>时，而且table的元表有<code class=\"highlighter-rouge\">__metatable</code>字段，则返回<code class=\"highlighter-rouge\">__metatable</code>字段中的值。</p>\n<p>测试代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local meta = &#123;\n    name = &#34;meta&#34;\n&#125;\n<p>local test = setmetatable(&#123;&#125;, meta)<br />\nprint(getmetatable(test).name)</p>\n<p>local meta = &#123;<br />\n__metatable = &#123;name = &quot;__metatable&quot;&#125;,<br />\nname = &quot;meta&quot;<br />\n&#125;</p>\n<p>local test = setmetatable(&#123;&#125;, meta)<br />\nprint(getmetatable(test).name)</p>\n<p>---- result output ----<br />\nmeta<br />\n__metatable<br />\n</code></pre></div></div></p>\n<p>结果很直观不解释了，我另外还做了个的测试，让<code class=\"highlighter-rouge\">__metatable</code>指向了一个function，调用<code class=\"highlighter-rouge\">getmetatable</code>时也会返回这个function。很有意思，但是暂时没想到有什么应用场景。</p>\n<h2 id=\"__tostring\">__tostring</h2>\n<p>原文翻译：</p>\n<p>控制字符串的表现，当调用<code class=\"highlighter-rouge\">tostring(myTable)</code>时，且myTable的元表中有<code class=\"highlighter-rouge\">__tostring</code>字段时，就会调用这个方法。返回值是方法的返回值。</p>\n<p>测试代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local meta = &#123;\n    __tostring = function(t)\n        return string.format(&#34;My name is %s&#34;, t.name)\n    end\n&#125;\n<p>local test = setmetatable(&#123;&#125;, meta)<br />\n<a href=\"http://test.name\">test.name</a> = &quot;test&quot;<br />\nprint(test)<br />\nprint(tostring(test))</p>\n<p>---- result output ----<br />\nMy name is test<br />\nMy name is test<br />\n</code></pre></div></div></p>\n<p>这个也不做过多说明了，很容易理解。有一点提一下就是print方法会自动调用tostring(test)</p>\n<h2 id=\"__len\">__len</h2>\n<p>原文翻译：</p>\n<p>控制table的长度。当用<code class=\"highlighter-rouge\">#</code>操作符请求长度时，且table的元表有<code class=\"highlighter-rouge\">__len</code>字段指向一个function，就会调用这个function，参数是table自己，返回值是function的返回值。</p>\n<p>写个测试代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local meta = &#123;\n    __len = function(t)\n        local result = 0\n        for k, v in pairs(t) do\n            result = result + 1\n        end\n        return result\n    end\n&#125;\n<p>local test = &#123;<br />\n[1] = &quot;A&quot;,<br />\n[2] = &quot;B&quot;,<br />\n[3] = &quot;C&quot;,<br />\n[5] = &quot;D&quot;,<br />\n[6] = &quot;E&quot;,<br />\n[8] = &quot;F&quot;,<br />\n&#125;<br />\nprint(#test)</p>\n<p>setmetatable(test, meta)<br />\nprint(#test)</p>\n<p>---- result output ----<br />\n3<br />\n6<br />\n</code></pre></div></div></p>\n<p>Lua中使用<code class=\"highlighter-rouge\">#</code>获取长度有个特性，就是如果某个key对应的值是nil就结束，上面例子中，test第4个值是nil，那返回的长度为3。我们重新定义了<code class=\"highlighter-rouge\">__len</code>后返回了，用遍历的方式计算长度，返回table内元素的数量为6。</p>\n<h2 id=\"__gc\">__gc</h2>\n<p>原文翻译：</p>\n<p>简单说就是数据被垃圾回收的时候会首先触发<code class=\"highlighter-rouge\">__gc</code>。</p>\n<p>测试代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local meta = &#123;\n<pre><code>__gc = function(t)\n    print(&amp;#34;gc&amp;#34;)\nend\n</code></pre>\n<p>}</p>\n<p>local function test()<br />\nlocal test = {}<br />\nsetmetatable(test, meta)<br />\nend</p>\n<p>test()</p>\n<p>---- result output ----<br />\ngc<br />\n</code></pre></div></div></p>\n<p>Lua table中所有的元方法就分析完了，还有一些操作符重载的，之后再写。</p>","text":"Lua的table是个很有意思的东西。有些内容平时写代码的时候很少接触到，但是了解一下还是很有意思的。 这篇blog参考MetatableEvents，一个一个边写测试边细说。 __newindex 原文翻译： __newindex用于分配属性，当调用 myTable[key]=...","link":"","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#__newindex\"><span class=\"toc-text\">__newindex</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#__index\"><span class=\"toc-text\">__index</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#__mode\"><span class=\"toc-text\">__mode</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#__call\"><span class=\"toc-text\">__call</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#__metatable\"><span class=\"toc-text\">__metatable</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#__tostring\"><span class=\"toc-text\">__tostring</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#__len\"><span class=\"toc-text\">__len</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#__gc\"><span class=\"toc-text\">__gc</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua入门教程：垃圾回收","uid":"4b20aa269e6f3afa1a8fc742335197dc","slug":"zl/2016-01-01-671_Lua入门教程：垃圾回收","date":"2024-04-03T03:47:35.898Z","updated":"2024-04-03T03:47:35.898Z","comments":true,"path":"api/articles/zl/2016-01-01-671_Lua入门教程：垃圾回收.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua 使用的是自动内存管理，所以我们不需要自己手动取删除创建后的对象，Lua 通过垃圾回收（garbage collection）的方式自动删除成为来及的对象，从而将程序员从内存管理的负担中解放出来。 虽然在理想的环境中，垃圾回收对我们来说是不可见的，但其却不是万能的，比如某些...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua语言进阶","uid":"dc394ec5eb5b7d637233ad2b80dc6e95","slug":"zl/2016-01-01-670_Lua语言进阶","date":"2024-04-03T03:47:35.897Z","updated":"2024-04-03T03:47:35.898Z","comments":true,"path":"api/articles/zl/2016-01-01-670_Lua语言进阶.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 0x01 Lua中什么值为假？12nilfalse 0x02 语法举例 当在一个数字后面写 .. 时，必须加上空格以防止被解释出错。 lua会自动在string 和numbers之间自动运行类型转换，当一个字符串使用算术操作符时，string就会被转化成数字。 123456pr...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}