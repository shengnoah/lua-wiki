{"title":"Lazy Evaluation 的原理与实现","uid":"d7bcce7d3fdaca51ca7bf745ecf3d47b","slug":"zl/2016-01-01-212_Lazy Evaluation 的原理与实现","date":"2024-04-03T03:47:33.090Z","updated":"2024-04-03T03:47:33.091Z","comments":true,"path":"api/articles/zl/2016-01-01-212_Lazy Evaluation 的原理与实现.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>&lt;p&gt;Lazy Evaluation 是Haskell进程的求值方式。当把一个表达式与一个变量绑定时，这个表达式并没有被立即求值，而是当它的结果需要被其他的计算用到时才会求值。因此，在调用函数时，参数也不会在调用前求值，\n</code></pre>\n<p>而是当它的值被用到是才会求值。<strong>Technically, lazy evaluation means call-by-name plus Sharing.</strong></p></p>\n<h2 id=\"lazy-的实现\">Lazy 的实现</h2>\n<blockquote>\n  <p>Thunks are primarily used to represent an additional calculation that a subroutine needs to execute, or to call a routine that does not support the usual calling mechanism.</p>\n</blockquote>\n<p>Haksell 的惰性求值正是通过将表达式包装成一个<strong>thunk</strong>实现的。例如计算 <code class=\"highlighter-rouge\">f (g x)</code>，实际上给f传递的参数就是一个类似于包装成 <code class=\"highlighter-rouge\">(_ &gt; (g x))</code> 的一个 <a href=\"https://en.wikipedia.org/wiki/Thunk\">thunk</a> 然后在真正需要计算 <code class=\"highlighter-rouge\">g x</code>\n的时候才会调用这个thunk。这个thunk里面还包含一个boolean表示该thunk是否已经被计算过（若已经被计算过，则还包含一个返回值），用来防止重复计算。</p>\n<p>接下来，我们使用Haskell的 <a href=\"http://hackage.haskell.org/package/ghc-heap-view\">ghc-heap-view</a> 工具来举例说明 Haskell 的惰性求值是如何运作的。</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Prelude&gt; let x = map show [(0::Int) ..]\nPrelude&gt; :printHeap x\nlet f1 = _fun\nin (_bco (_bco (D:Enum _fun _fun f1 f1 _fun _fun _fun _fun) _fun)\n(_bco (D:Show _fun _fun _fun) _fun) _fun)()\n</code></pre></div></div>\n<p>惰性求值，_bco 指的是 bytecode object。这里</p>\n<ul>\n  <li><code class=\"highlighter-rouge\">(_bco (D:Enum _fun _fun f1 f1 _fun _fun _fun _fun) _fun)</code> 是<code class=\"highlighter-rouge\">class Enum</code>中的<code class=\"highlighter-rouge\">enumFrom</code></li>\n  <li><code class=\"highlighter-rouge\">(_bco (D:Show _fun _fun _fun) _fun)</code> 是<code class=\"highlighter-rouge\">class Show</code>中的<code class=\"highlighter-rouge\">show</code></li>\n</ul>\n<p>由此例子，可以看出GHC在实现中其实是将instance作为一个record of functions的隐含参数的。</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Prelude&gt; head x\n\"0\"\nPrelude&gt; :printHeap x\n_bh (\"0\" : _thunk _fun (_thunk _fun&#123;9223372036854775807&#125; 9223372036854775807 0))\n</code></pre></div></div>\n<p><code class=\"highlighter-rouge\">_bh</code> 指的是BLACKHOLE。这里</p>\n<ul>\n  <li><code class=\"highlighter-rouge\">(_bh _fun)</code> 应该是<code class=\"highlighter-rouge\">instace Show Int</code>中的<code class=\"highlighter-rouge\">show</code></li>\n  <li><code class=\"highlighter-rouge\">(_thunk _fun&#123;9223372036854775807&#125; 9223372036854775807 0)</code> 本应该是<code class=\"highlighter-rouge\">instance Enum Int</code>中的<code class=\"highlighter-rouge\">enumFrom</code>，不过从这个数值 9223372036854775807 可以猜测到 <code class=\"highlighter-rouge\">enumFrom n = enumFromTo n maxBound</code></li>\n</ul>\n<p>这时x已经被求值到了，而<code class=\"highlighter-rouge\">show</code>和<code class=\"highlighter-rouge\">enumFrom</code>本身也被求值了。</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Prelude&gt; x !! 3\n\"3\"\nPrelude&gt; :printHeap x\nlet x1 = []\n    f1 = _fun\nin _bh ((C# '0' : x1) : _bh (_thunk f1 (I# 1) : _thunk f1 (I# 2) : (C# '3' : x1)\n : _thunk f1 (_thunk _fun&#123;9223372036854775807&#125; 9223372036854775807 3)))\n</code></pre></div></div>\n<p>这里<code class=\"highlighter-rouge\">f1</code>就是<code class=\"highlighter-rouge\">show</code>。虽然<code class=\"highlighter-rouge\">List</code>前4项被展开了，但<code class=\"highlighter-rouge\">show 1</code>和<code class=\"highlighter-rouge\">show 2</code>本身并没有被求值！</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Prelude&gt; System.Mem.performGC\nPrelude&gt; :printHeap x\nlet x1 = []\n    f1 = _fun\nin (C# '0' : x1) : _thunk f1 (I# 1) : _thunk f1 (I# 2) : (C# '3' : x1) : _thunk\nf1 (_thunk _fun&#123;9223372036854775807&#125; 9223372036854775807 3)\nPrelude&gt;\n</code></pre></div></div>\n<p><code class=\"highlighter-rouge\">performGC</code>消灭BLACKHOLE。BLACKHOLE是为了兼顾多线程和效率而存在。Black Hole 的详细定义和解释:</p>\n<blockquote>\n  <p>The concurrent runtime system uses black holes as synchronisation points for subexpressions which are shared among multiple threads. In “sequential Haskell”, a black hole indicates a cyclic data dependency, which is a fatal error. However, in concurrent execution, a black hole may simply indicate that the desired expression is being evaluated by another thread. Therefore, when a thread encounters a black hole, it simply blocks and waits for the black hole to be updated.</p>\n</blockquote>\n<h2 id=\"lazy-graph-reduction\">lazy graph reduction</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Graph_reduction\">Graph reduction</a>, 是惰性求值的实现方式，Spineless Tarless G-Machine 和 G-Machine 之类的抽象机器可以专门用于实现惰性求值语言中的 Graph reduction。</p>\n<p>关于 Lazy Evaluation 的时间和空间消耗，<strong>惰性求值不会需要比贪婪求值更多的求值步骤</strong>，因此，二者的时间复杂度不会有本质上的差异，Haskell 中，用于判断一个 object 的值是否已经求出的重复的检查，但是，Lazy Evaluation 的空间消耗值得关注。</p>\n<p>例如这段代码的求值过程：</p>\n<div class=\"language-haskell highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">foldl</span> <span class=\"p\">(</span><span class=\"o\">+</span><span class=\"p\">)</span> <span class=\"mi\">0</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"mi\">100</span><span class=\"p\">]</span>\n<span class=\"o\">=&gt;</span> <span class=\"n\">foldl</span> <span class=\"p\">(</span><span class=\"o\">+</span><span class=\"p\">)</span> <span class=\"mi\">0</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"o\">..</span><span class=\"mi\">100</span><span class=\"p\">])</span>\n<span class=\"o\">=&gt;</span> <span class=\"n\">foldl</span> <span class=\"p\">(</span><span class=\"o\">+</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"mi\">0</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"o\">..</span><span class=\"mi\">100</span><span class=\"p\">]</span>\n<span class=\"o\">=&gt;</span> <span class=\"n\">foldl</span> <span class=\"p\">(</span><span class=\"o\">+</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"mi\">0</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"o\">..</span><span class=\"mi\">100</span><span class=\"p\">])</span>\n<span class=\"o\">=&gt;</span> <span class=\"n\">foldl</span> <span class=\"p\">(</span><span class=\"o\">+</span><span class=\"p\">)</span> <span class=\"p\">((</span><span class=\"mi\">0</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"o\">..</span><span class=\"mi\">100</span><span class=\"p\">]</span>\n<span class=\"o\">=&gt;</span> <span class=\"n\">foldl</span> <span class=\"p\">(</span><span class=\"o\">+</span><span class=\"p\">)</span> <span class=\"p\">((</span><span class=\"mi\">0</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"o\">..</span><span class=\"mi\">100</span><span class=\"p\">])</span>\n<span class=\"o\">=&gt;</span> <span class=\"n\">foldl</span> <span class=\"p\">(</span><span class=\"o\">+</span><span class=\"p\">)</span> <span class=\"p\">(((</span><span class=\"mi\">0</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"o\">..</span><span class=\"mi\">100</span><span class=\"p\">]</span>\n<span class=\"o\">=&gt;</span> <span class=\"o\">...</span>\n</code></pre></div></div>\n<p>在求值的过程中，累积参数占用的空间会越来越大，这个问题称为 <strong>space leak</strong>, space leak 会增加GC的负担，而不是重复检查。</p>\n<h2 id=\"strictness\">Strictness</h2>\n<p>Haskell求值顺序的不确定性确实又会给编译器的优化带来不小的挑战。所以Haskell有时候确实要放弃一些lazyness，引入一些strictness，例如:</p>\n<ul>\n  <li>seq：是对RealWorld做的妥协</li>\n  <li>BangPatterns：其实就是更优雅的写seq，这样就引入的顺序，使得编译器能做更多的推断。在函数内也就不再需要检查这些参数了</li>\n  <li>strict fields和UNPACK：datatype里的BangPatterns</li>\n  <li>使用带有strictness的函数，比如foldl’</li>\n  <li>使用Unboxed的容器，比如Data.Array.Unboxed、Data.Vector.Unboxed</li>\n  <li>使用自带strictness的module，比如Data.Map.Strict，Data.HashMap.Strict</li>\n  <li>Control.DeepSeq</li>\n  <li>unsafe[Dupable]PerformIO</li>\n</ul>\n<p>使用GHC来编译Haskell代码时，打开某些编译选项也可以是的使用lazy evaluation的代码采用某些strict的数据类型，以提升进程的运行效率。</p>\n<h2 id=\"lazy-实现示例\">Lazy 实现示例</h2>\n<p>了解了 thunk 的原理，我们可以使用既非函数式的、不支持 first-class function 的编程语言来实现 Lazy Evaluation。</p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cp\">#include &lt;stdlib.h&gt;\n</span>\n<span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"p\">&#123;</span>\n    <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">val</span><span class=\"p\">;</span> <span class=\"c1\">// store result when evaluated.\n</span>    <span class=\"kt\">int</span> <span class=\"n\">evaluated</span><span class=\"p\">;</span>\n    <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">thunk</span><span class=\"p\">)(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"p\">);</span> <span class=\"c1\">// deferred computation.\n</span>    <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">;</span> <span class=\"c1\">// args to pass to deferred computation.\n</span><span class=\"p\">&#125;</span> <span class=\"n\">lazy</span><span class=\"p\">;</span>\n<p><span class=\"c1\">// create lazy evaluated thunk.<br />\n</span><span class=\"n\">lazy</span> <span class=\"o\"><em></span><span class=\"nf\">make_lazy</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\"></em></span><span class=\"p\">(</span><span class=\"o\"><em></span><span class=\"n\">thunk</span><span class=\"p\">)(</span><span class=\"kt\">void</span> <span class=\"o\"></em></span><span class=\"p\">),</span> <span class=\"kt\">void</span> <span class=\"o\"><em></span><span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"n\">lazy</span> <span class=\"o\"></em></span><span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">malloc</span><span class=\"p\">(</span><span class=\"n\">sizoof</span><span class=\"p\">(</span><span class=\"n\">lazy</span><span class=\"p\">));</span><br />\n<span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span><br />\n<span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">evaluated</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span><br />\n<span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">thunk</span> <span class=\"o\">=</span> <span class=\"n\">thunk</span><span class=\"p\">;</span><br />\n<span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"n\">args</span><span class=\"p\">;</span><br />\n<span class=\"k\">return</span> <span class=\"n\">l</span><span class=\"p\">;</span><br />\n<span class=\"p\">&#125;</span></p>\n<p><span class=\"c1\">// force evaluation of the thunk.<br />\n</span><span class=\"kt\">void</span> <span class=\"o\"><em></span><span class=\"nf\">force</span><span class=\"p\">(</span><span class=\"n\">lazy</span> <span class=\"o\"></em></span><span class=\"n\">l</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">evaluated</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">thunk</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">args</span><span class=\"p\">)</span><br />\n<span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">evaluated</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span><br />\n<span class=\"p\">&#125;</span><br />\n<span class=\"k\">return</span> <span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">val</span><span class=\"p\">;</span><br />\n<span class=\"p\">&#125;</span><br />\n</code></pre></div></div></p>\n<h2 id=\"参考\">参考</h2>\n<ol>\n  <li><a href=\"https://downloads.haskell.org/~ghc/0.29/docs/users_guide/user_86.html\">Potential problems with Concurrent Haskell</a></li>\n  <li><a href=\"https://hackhands.com/lazy-evaluation-works-haskell/\">How Lazy Evaluation Works in Haskell</a></li>\n</ol>","text":"&lt;p&gt;Lazy Evaluation 是Haskell进程的求值方式。当把一个表达式与一个变量绑定时，这个表达式并没有被立即求值，而是当它的结果需要被其他的计算用到时才会求值。因此，在调用函数时，参数也不会在调用前求值， 而是当它的值被用到是才会求值。Technica...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lazy-%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">Lazy 的实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lazy-graph-reduction\"><span class=\"toc-text\">lazy graph reduction</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#strictness\"><span class=\"toc-text\">Strictness</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lazy-%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">Lazy 实现示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 学习 chapter17","uid":"71d4be5e48e9da5655b092bfb309953f","slug":"zl/2016-01-01-211_Lua 学习 chapter17 ","date":"2024-04-03T03:47:33.090Z","updated":"2024-04-03T03:47:33.090Z","comments":true,"path":"api/articles/zl/2016-01-01-211_Lua 学习 chapter17 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt; require函数 模块 require函数 ruquire函数可以加载任意模块，然后创建和返回一个表. 1 2 3 4 5 6 7 8 9 local mod = require \"mod\" ...","link":"","photos":[],"count_time":{"symbolsCount":739,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Redis之Lua脚本","uid":"f5df4819644a6a6a65feb7630929c7d1","slug":"zl/2016-01-01-209_Redis之Lua脚本","date":"2024-04-03T03:47:33.089Z","updated":"2024-04-03T03:47:33.089Z","comments":true,"path":"api/articles/zl/2016-01-01-209_Redis之Lua脚本.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;Redis中内嵌了对Lua环境的支持，允许开发者使用Lua语言编写脚本传到Redis中执行，直接在服务端原子的执行多个Redis命令。&lt;/p&gt; 使用Lua脚本的好处： 减少网络开销，在Lua脚本中可以把多个命令放在同一个脚本中运行 原子操作，red...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}