{"title":"cocos2dx lua 热更新原理与实战","uid":"f3d67063cbdd4d9c236062995f15586f","slug":"zl/2016-01-01-56_cocos2dx lua 热更新原理与实战","date":"2024-04-03T03:47:35.824Z","updated":"2024-04-03T03:47:35.824Z","comments":true,"path":"api/articles/zl/2016-01-01-56_cocos2dx lua 热更新原理与实战.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>首先，如果有过cocos2dx lua开发经验的朋友都知道，为什么使用Lua而不是C++,最重要的原因就是因为下面这三个原因</p>\n<ul>\n<li>热更新(在线更新代码和资源)</li>\n<li>比C++简单很多,入门和实战</li>\n<li>轻量级，最小最轻的脚本语言</li>\n</ul>\n<p>今天就从Lua热更新，捣鼓一下其中的原理，并具体实战一下！</p>\n<h3 id=\"什么是热更新？\"><a href=\"#什么是热更新？\" class=\"headerlink\" title=\"什么是热更新？\"></a>什么是热更新？</h3><p>热更新也叫不停机更新，是在游戏服务器运行期间对游戏进行更新。实现不停机修正bug、修改游戏数据等操作。也可以这样讲：一辆车以时速150km跑着，突然爆胎了，然后司机告诉你，我不停车，你去把轮胎换了，小心点。</p>\n<h3 id=\"热更新的作用\"><a href=\"#热更新的作用\" class=\"headerlink\" title=\"热更新的作用\"></a>热更新的作用</h3><p>Lua模块热更新原理，能很好的支持代码热更新机制，是大部分选择要嵌入脚本语言的原因之一。好处很简单，脚本代码可以热更新的话，调试和线上解决问题都可以不用重启程序了，对开发效率有很大的帮助。</p>\n<h3 id=\"热更新原理\"><a href=\"#热更新原理\" class=\"headerlink\" title=\"热更新原理\"></a>热更新原理</h3><p>Lua内部提供了一个require函数，来实现模块的加载，它做的事情主要是以下几个：</p>\n<blockquote>\n<p>在registry[“_LOADED”]表中判断该模块是否已经加载过了，如果是则返回，避免重复加载某个模块代码。</p>\n</blockquote>\n<p>依次调用注册的loader来加载模块,将加载过的模块赋值给registry[“_LOADED”]表。</p>\n<p>而如果要实现Lua的代码热更新，其实也就是需要重新加载某个模块，因此就要想办法让Lua认为它之前没有加载过。查看Lua代码发现，registry[“_LOADED”]表，实际上对应的是package.loaded表，这在以下函数中有体现：</p>\n<pre><code>(loadlib.c)\n627 LUALIB_API int luaopen_package (lua_State *L) &#123;\n<p>655   /* set field `loaded' */<br />\n656   luaL_findtable(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;, 2);<br />\n657   lua_setfield(L, -2, &quot;loaded&quot;);<br />\n</code></pre><p>因此事情就很简单了，需要提供一个require_ex函数，可以理解为require的增强版，使用这个函数可以动态更新某个模块的代码:</p></p>\n<pre><code>function require_ex( _mname )\nprint( string.format(&#34;require_ex = %s&#34;, _mname) )\nif package.loaded[_mname] then\nprint( string.format(&#34;require_ex module[%s] reload&#34;, _mname))\nend\npackage.loaded[_mname] = nil\nrequire( _mname )\nend\n</code></pre><p>这个函数做的事情一目了然。首先判断是否曾经加载过这个模块，如果有则打印一条日志表示需要重新加载某个模块，然后将该模块原来在表中注册的值赋空，然后再次调用require进行模块的加载和注册。</p>\n<h3 id=\"热更新实现细节\"><a href=\"#热更新实现细节\" class=\"headerlink\" title=\"热更新实现细节\"></a>热更新实现细节</h3><p>以上了解了Lua代码热更新的原理，但是还有一些细节需要提醒一下。</p>\n<ul>\n<li><p>如何组织你的项目中的Lua代码？</p>\n<ul>\n<li>我在qnode中使用的方式是，单独使用一个叫main.lua的文件调用require_ex函数来加载需要用到的lua模块，而Lua虚拟机创建之后执行的是这个文件，这样的话，当你需要热更新项目中的Lua代码时，只需要重新执行这个main.lua就行了。</li>\n</ul>\n</li>\n<li><p>如何通知热更新代码呢？</p>\n<ul>\n<li>我在qnode中使用的信号机制，当服务器收到USR1信号时，通知所有工作进程，由工作进程来重新对main.lua进行重新加载，这样就完成了lua代码的热更新，为此我写了一个简单的脚本reload.sh，就是根据当前qnode的服务器进程ID来对其发送USR1信号量的。</li>\n</ul>\n</li>\n<li><p>一般热更新的都是函数的实现，所以需要对全局变量做一些保护。</p>\n<ul>\n<li>比如当前某全局变量为100，表示某个操作已经进行了100次，它不能因为热更新重新置0，所以要对这些不能改变的全局变量做一个保护，最简单的方式就是这样:</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">a = a or 0</span><br/></pre></td></tr></tbody></table></figure>\n<p>很简单的原理，只有当前a这个变量没有初始值的时候才会赋值为0，而后面不管这个Lua文件被加载多少次，a都不会因为重新加载了Lua代码发生改变了。</p>\n<h3 id=\"热更新实战\"><a href=\"#热更新实战\" class=\"headerlink\" title=\"热更新实战\"></a>热更新实战</h3><p>其实我们平时开发中，可以用简单易懂的方式来理解热更新</p>\n<ul>\n<li><ol>\n<li>客户端向服务器发送请求，服务器告诉客户端，没更新，你是最新的啦，那就直接跳过喽</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>如果是告诉你有更新，那就要告诉我哪些需要更新对吧，你可能需要更新的东西，放在一个文件里，一并发送给客户端</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>客户端拿到这个文件，就一个一个去向服务器要，最后把要更新的内容都下载到本地了</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>cocos2dx-lua中有assetmanagerex的c++实现类，也有绑定到lua。</p>\n<blockquote>\n<p>3.10之前有缺陷，问题是当有文件下载失败时会陷入死循环，导致业务链断裂。不过网上有解决办法，可简单修改源码解决。<br/>建议把高于3.10版本以后的assetmanagerex代码移植到旧的3.x版本，也可以选择新项目使用3.10以后版本。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"网上有提到两种热更新的方法\"><a href=\"#网上有提到两种热更新的方法\" class=\"headerlink\" title=\"网上有提到两种热更新的方法\"></a>网上有提到两种热更新的方法</h4><ul>\n<li><p>1.只存在一套资源，用一个文件记录所有文件的信息（文件名，路径，大小，MD5）。游戏启动时下载这个文件与本地文件MD5进行对比，不同的和新增的下载下来，没有的删掉。（最好再做个简要信息文件，因为资源多了记录文件信息的文件会有上百KB大小）</p>\n</li>\n<li><p>2.第二种存在多套资源，客户端每更新一个版本都会有一个内部版本号。更新服务端会有多套压缩包，如1.0-1.5， 1.1-1.5 ，1.2-1.5 ，1.3-1.5，1.4-1.5。此方法需要保留每个版本的文件资源，依次生成每一个版本到最新版本的增量压缩包（依据是文件名和MD5）</p>\n</li>\n</ul>\n<p>但是结合实战第一种和优点是方便管理，从始到终只有一套资源。缺点是玩家下载时流量多一点，因为没有压缩。第二种优点是玩家下载流量小，但每次升级需要保留历史版本为升级依据，版本越多越不好管理。</p>\n<h5 id=\"具体代码实战\"><a href=\"#具体代码实战\" class=\"headerlink\" title=\"具体代码实战\"></a>具体代码实战</h5><pre><code>local AutoUpdateScene = class(&#34;AutoUpdateScene&#34;, cc.load(&#34;mvc&#34;).ViewBase)\n<p>local manifestPath = &quot;project.manifest&quot;<br />\nlocal storagePath = &quot;update&quot;</p>\n<p>function AutoUpdateScene:onCreate()</p>\n<p>self._update_failed_count = 0</p>\n<p>local layer  = cc.Layer:create()</p>\n<p>local am = nil</p>\n<p>local function onEnter()</p>\n<p>local ttfConfig = &#123;&#125;<br />\nttfConfig.fontFilePath = &quot;fonts/arial.ttf&quot;<br />\nttfConfig.fontSize = 80</p>\n<p>local  progress = cc.Label:createWithTTF(ttfConfig, &quot;0%&quot;, cc.VERTICAL_TEXT_ALIGNMENT_CENTER)<br />\nprogress:setPosition(cc.p(display.center.x, display.center.y + 50))<br />\nlayer:addChild(progress)</p>\n<p>am = cc.AssetsManagerEx:create(manifestPath, cc.FileUtils:getInstance():getWritablePath() … storagePath)<br />\nam:retain()</p>\n<p>if not am:getLocalManifest():isLoaded() then<br />\nprint(&quot;Fail to update assets, step skipped.&quot;)<br />\nself:onFail(&quot;本地资源错误，请重新下载游戏。&quot;)<br />\nelse<br />\nlocal function onUpdateEvent(event)<br />\nlocal eventCode = event:getEventCode()<br />\nprint(&quot;====== assetsmanagerex error code:&quot;, eventCode)<br />\n–[[ cc.EventAssetsManagerEx.EventCode = &#123;<br />\nERROR_NO_LOCAL_MANIFEST = 0,<br />\nERROR_DOWNLOAD_MANIFEST = 1,<br />\nERROR_PARSE_MANIFEST = 2,<br />\nNEW_VERSION_FOUND = 3,<br />\nALREADY_UP_TO_DATE = 4,<br />\nUPDATE_PROGRESSION = 5,<br />\nASSET_UPDATED = 6,<br />\nERROR_UPDATING = 7,<br />\nUPDATE_FINISHED = 8,<br />\nUPDATE_FAILED = 9,<br />\nERROR_DECOMPRESS = 10<br />\n&#125; ]]<br />\nif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_NO_LOCAL_MANIFEST then<br />\nprint(&quot;No local manifest file found, skip assets update.&quot;)<br />\nself:onFail(string.format(&quot;本地资源错误，请重新下载游戏。(错误码:%d)&quot;, eventCode))<br />\nelseif eventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_PROGRESSION then<br />\nlocal assetId = event:getAssetId()<br />\nlocal percent = event:getPercent()<br />\nlocal strInfo = &quot;&quot;<br />\nif assetId == cc.AssetsManagerExStatic.VERSION_ID then<br />\nstrInfo = string.format(&quot;Version file: %d%%&quot;, percent)<br />\nelseif assetId == cc.AssetsManagerExStatic.MANIFEST_ID then<br />\nstrInfo = string.format(&quot;Manifest file: %d%%&quot;, percent)<br />\nelse<br />\nstrInfo = string.format(&quot;%d%%&quot;, percent)<br />\nend<br />\nprogress:setString(strInfo)<br />\nself:setLoadingProgress(event:getPercentByFile())<br />\nelseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_DOWNLOAD_MANIFEST or<br />\neventCode == cc.EventAssetsManagerEx.EventCode.ERROR_PARSE_MANIFEST then<br />\nprint(&quot;Fail to download manifest file, update skipped.&quot;)<br />\nself:onFail(string.format(&quot;更新失败，请检查网络配置。(错误码:%d)&quot;, eventCode))<br />\nelseif eventCode == cc.EventAssetsManagerEx.EventCode.ALREADY_UP_TO_DATE or<br />\neventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_FINISHED then<br />\nprint(&quot;Update finished.&quot;)<br />\nself:onSuccess()<br />\nelseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_UPDATING then<br />\nprint(&quot;Asset &quot;, event:getAssetId(), &quot;, &quot;, event:getMessage())<br />\n– self:onFail(string.format(&quot;更新资源失败，请检查网络后重试。(%d)&quot;, eventCode))<br />\nelseif eventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_FAILED then<br />\nprint(&quot;Fail to download resource files.&quot;)<br />\nself._update_failed_count = self._update_failed_count + 1<br />\nif self._update_failed_count &lt;= 3 then<br />\nprint(&quot;try again&quot;)<br />\nam:downloadFailedAssets()<br />\nelse<br />\nself:onFail(string.format(&quot;更新失败，请检查网络配置。(错误码:%d)&quot;, eventCode))<br />\nend<br />\nelseif eventCode == cc.EventAssetsManagerEx.EventCode.NEW_VERSION_FOUND then<br />\nprint(&quot;new version found.&quot;)<br />\n–am:update()<br />\nelseif eventCode == cc.EventAssetsManagerEx.EventCode.ASSET_UPDATED then<br />\nprint(&quot;assets updated.&quot;)<br />\nelseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_DECOMPRESS then<br />\nprint(&quot;decompress error.&quot;)<br />\nend<br />\nend<br />\nlocal listener = cc.EventListenerAssetsManagerEx:create(am, onUpdateEvent)<br />\ncc.Director:getInstance():getEventDispatcher():addEventListenerWithFixedPriority(listener, 1)</p>\n<p>am:update()<br />\n–am:checkUpdate()<br />\nend<br />\nend</p>\n<p>local function onExit()<br />\nam:release()<br />\nend</p>\n<p>local function onNodeEvent(event)<br />\nif &quot;enter&quot; == event then<br />\nonEnter()<br />\nelseif &quot;exit&quot; == event then<br />\nonExit()<br />\nend<br />\nend<br />\nlayer:registerScriptHandler(onNodeEvent)</p>\n<p>self:addChild(layer)<br />\nend</p>\n<p>function AutoUpdateScene:onFail(msg)<br />\nprint(&quot;====== update fail ======&quot;, msg)</p>\n<p>– 热更新失败处理<br />\nend</p>\n<p>function AutoUpdateScene:onSuccess()<br />\nprint(&quot;====== update success ======&quot;)</p>\n<p>local writablePath = cc.FileUtils:getInstance():getWritablePath()<br />\npackage.path = writablePath … &quot;update/src/?.lua;./?.lua;&quot;</p>\n<p>– 启动热更新后的场景<br />\nend</p>\n<p>return AutoUpdateScene<br />\n</code></pre><ul></p>\n<li>推荐<ul>\n<li><a href=\"https://blog.csdn.net/weixin_37730482/article/details/73299286\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/weixin_37730482/article/details/73299286</a></li>\n<li><a href=\"https://blog.csdn.net/qq_32319583/article/details/53223452\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/qq_32319583/article/details/53223452</a></li>\n<li><a href=\"https://blog.csdn.net/q277055799/article/details/8463835?utm_source=blogxgwz3****\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/q277055799/article/details/8463835?utm_source=blogxgwz3<em>**</em></a></li>\n</ul>\n</li>\n</ul>","text":"首先，如果有过cocos2dx lua开发经验的朋友都知道，为什么使用Lua而不是C++,最重要的原因就是因为下面这三个原因 热更新(在线更新代码和资源) 比C++简单很多,入门和实战 轻量级，最小最轻的脚本语言 今天就从Lua热更新，捣鼓一下其中的原理，并具体实战一下！ 什么是...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%9F\"><span class=\"toc-text\">什么是热更新？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">热更新的作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">热更新原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">热更新实现细节</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E6%88%98\"><span class=\"toc-text\">热更新实战</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BD%91%E4%B8%8A%E6%9C%89%E6%8F%90%E5%88%B0%E4%B8%A4%E7%A7%8D%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">网上有提到两种热更新的方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98\"><span class=\"toc-text\">具体代码实战</span></a></li></ol></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Redis慢查询、Pipeline、事务与Lua、Bitmaps、发布订阅","uid":"2eceeeadcd601ca2a9fee495ed73c176","slug":"zl/2016-01-01-572_Redis慢查询、Pipeline、事务与Lua、Bitmaps、发布订阅","date":"2024-04-03T03:47:35.825Z","updated":"2024-04-03T03:47:35.825Z","comments":true,"path":"api/articles/zl/2016-01-01-572_Redis慢查询、Pipeline、事务与Lua、Bitmaps、发布订阅.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" Redis提供的5种数据结构已经足够强大，但除此之外，Redis还提供了诸如慢查询分析、功能强大的Redis Shell、Pipeline、事务与Lua脚本、Bitmaps、HyperLogLog、发布订阅、GEO等附加功能，这些功能可以在某些场景发挥重要的作用。 慢查询分析许...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"ulua的简单解析，cs和Lua的相互调用","uid":"793661612b73172fb8f974a4ce18be1f","slug":"zl/2016-01-01-570_ulua的简单解析，cs和Lua的相互调用","date":"2024-04-03T03:47:35.824Z","updated":"2024-04-03T03:47:35.825Z","comments":true,"path":"api/articles/zl/2016-01-01-570_ulua的简单解析，cs和Lua的相互调用.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"热更新是unity一个长久的话题，热更新主要有两部分，一部分就是资源，这个靠u3d的assetbundle就可以做，另一部分就是逻辑了。游戏更新难免会遇到一些流程或者UI的逻辑变动。在PC和Android上可以使用C#的反射来动态的生成代码，而IOS的Full AOT（完全 预先...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}