{"title":"cocos2dx lua (伪)面向对象理解与实战应用","uid":"9031c35a0fe6df7d970064b52b48b4cb","slug":"zl/2016-01-01-473_cocos2dx lua (伪)面向对象理解与实战应用","date":"2024-04-03T03:47:35.755Z","updated":"2024-04-03T03:47:35.755Z","comments":true,"path":"api/articles/zl/2016-01-01-473_cocos2dx lua (伪)面向对象理解与实战应用.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<blockquote>\n<p>面向对象    </p>\n</blockquote>\n<pre><code>&gt;&gt; 把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class）\n&gt;&gt; 通过类的封装（encapsulation）隐藏内部细节\n&gt;&gt; 通过继承（inheritance）实现类的特化（specialization）／泛化（generalization）\n&gt;&gt; 通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch）\n</code></pre>\n<h3 id=\"1-lua中的类\"><a href=\"#1-lua中的类\" class=\"headerlink\" title=\"1.lua中的类\"></a>1.lua中的类</h3><p>lua中其实是没有类的，有的只是表(table)，而类之间的继承也就是将父类的表连到了一起，派生类中没有找到的属性和方法就通过元表查找父类</p>\n<h3 id=\"2-lua中类的属性\"><a href=\"#2-lua中类的属性\" class=\"headerlink\" title=\"2.lua中类的属性\"></a>2.lua中类的属性</h3><pre><code>classA = &#123;width =10, height=10&#125;\n<p>classA=&#123;&#125;</p>\n<p>classA.width=10</p>\n<p>classA.height=10<br />\n</code></pre><p>两种方法都可以，通过点self.width统一调用</p></p>\n<h3 id=\"3-类方法\"><a href=\"#3-类方法\" class=\"headerlink\" title=\"3.类方法\"></a>3.类方法</h3><pre><code>[cpp] view plaincopy\n<p>function Box:collsion()<br />\n– 默认第一个参数隐藏传递self，<a href=\"http://xn--self-955fz0ybn7i7sa.xxx\">可以通过self.xxx</a> 调用属性和方法<br />\nend</p>\n<p>function Box.create(self)<br />\n–必须手动传递参数self,否则无法用self.xxx调用属性和方法<br />\nend<br />\n</code></pre><h3 id=\"4-类与元表的用法\"><a href=\"#4-类与元表的用法\" class=\"headerlink\" title=\"4.类与元表的用法\"></a>4.类与元表的用法</h3><ul></p>\n<li>lua查找一个表元素时的规则，其实就是如下3个步骤:<ul>\n<li>4.1.在表中查找，如果找到，返回该元素，找不到则继续</li>\n<li>4.2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续</li>\n<li>4.3.判断元表有没有<strong>index方法，如果</strong>index方法为nil，则返回nil；如果<strong>index方法是一个表，则重复1、2、3；如果</strong>index方法是一个函数，则返回该函数的返回值</li>\n</ul>\n</li>\n</ul>\n<p>在Lua中，函数的声明和调用可以用”:”和”.”，属性调用全部用点”.”</p>\n<blockquote>\n<p>我们知道，对象由属性和方法组成。LUA中最基本的结构是table，所以需要用table来描述对象的属性。</p>\n</blockquote>\n<p>lua中的function可以用来表示方法。那么LUA中的类可以通过table + function模拟出来。</p>\n<p>至于继承，可以通过metetable模拟出来（不推荐用，只模拟最基本的对象大部分时间够用了）。</p>\n<blockquote>\n<p>Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。</p>\n</blockquote>\n<h5 id=\"1-初步面向对象\"><a href=\"#1-初步面向对象\" class=\"headerlink\" title=\"1. 初步面向对象\"></a>1. 初步面向对象</h5><pre><code>ObjectData = &#123;balance = 0&#125;\n<p>function ObjectData.count( v )<br />\n– body<br />\nprint(&quot;value is :&quot;, v)<br />\nend</p>\n<p>a = ObjectData<br />\na.count(&quot;iCocos&quot;)<br />\n– value is :    iCocos<br />\n</code></pre><h5 id=\"2-面向对象模拟\"><a href=\"#2-面向对象模拟\" class=\"headerlink\" title=\"2. 面向对象模拟\"></a>2. 面向对象模拟</h5><pre><code>ObjectData = &#123;balance = 100&#125;</p>\n<p>function ObjectData.count( self, v )<br />\nself.balance = self.balance + v<br />\nprint(&quot;value is :&quot;, v, self.balance)<br />\nend</p>\n<p>a = ObjectData<br />\na.count(a, 99) – 传递self<br />\n– value is :    99    199</p>\n<p>a:count(99) – 不传self，直接把a作为self传递进入，<br />\n– value is :    99    298<br />\n</code></pre><h3 id=\"Lua中的继承\"><a href=\"#Lua中的继承\" class=\"headerlink\" title=\"Lua中的继承\"></a>Lua中的继承</h3><h5 id=\"先来定义一个基类，\"><a href=\"#先来定义一个基类，\" class=\"headerlink\" title=\"先来定义一个基类，\"></a>先来定义一个基类，</h5><p>使用前面讲的setmetatable来实现基本的元表</p></p>\n<pre><code>local _M = &#123;&#125;\n\nfunction _M:new(name)\nreturn setmetatable(&#123; name = name&#125;, &#123; __index = _M &#125;)\nend\n\nfunction _M:show()\nprint(self.name .. &#34;: show in parent:&#34;)\nend\n\nfunction _M:hello(arg)\nprint(self.name .. &#34;: hello in parent:&#34; .. tostring(arg))\nend\n\nreturn  _M\n</code></pre><h5 id=\"子类的实现\"><a href=\"#子类的实现\" class=\"headerlink\" title=\"子类的实现\"></a>子类的实现</h5><pre><code>local parent = require(&#34;parent&#34;)\n<p>local _M = &#123;&#125;</p>\n<p>function _M:new()<br />\nlocal obj = parent:new(&quot;the child&quot;)<br />\nlocal super_mt = getmetatable(obj)<br />\n– 当方法在子类中查询不到时，再去父类中去查找。<br />\nsetmetatable(_M, super_mt)<br />\n– 这样设置后，可以通过self.super.method(self, …) 调用父类的已被覆盖的方法。<br />\nobj.super = setmetatable(&#123;&#125;, super_mt)<br />\nreturn setmetatable(obj, &#123; __index = _M &#125;)<br />\nend</p>\n<p>– 覆盖父类的方法。<br />\nfunction _M:hello()<br />\n– 只能使用这种方法调用基类的方法。<br />\nself.super.hello(self, &quot;call from child&quot;)<br />\nprint(tostring(<a href=\"http://self.name\">self.name</a>) … &quot;: hello in child&quot;)<br />\nend</p>\n<p>return _M</p>\n<p>test.lua (使用)</p>\n<p>– local parent = require(&quot;parent&quot;)<br />\nlocal child = require(&quot;child&quot;)</p>\n<p>local c = child:new()<br />\n– 从parent继承的show方法<br />\nc:show()<br />\n– child自己的方法。<br />\nc:hello()<br />\n</code></pre><p>执行lua test.lua 后 输出：</p></p>\n<pre><code>the child: show in parent:\nthe child: hello in parent:call from child\nthe child: hello in child\n</code></pre><ul>\n<li>可以看到：<ul>\n<li>show是继承了父类的方法。</li>\n<li>hello是由子类覆盖了，并且在hello中调用了父类的hello方法。</li>\n</ul>\n</li>\n</ul>","text":" 面向对象 &gt;&gt; 把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class） &gt;&gt; 通过类的封装（encapsulation）隐藏内部细节 &gt;&gt; 通过继承（inheritance）实现类的特化（special...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-lua%E4%B8%AD%E7%9A%84%E7%B1%BB\"><span class=\"toc-text\">1.lua中的类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-lua%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">2.lua中类的属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%B1%BB%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3.类方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%B1%BB%E4%B8%8E%E5%85%83%E8%A1%A8%E7%9A%84%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">4.类与元表的用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%88%9D%E6%AD%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">1. 初步面向对象</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E6%8B%9F\"><span class=\"toc-text\">2. 面向对象模拟</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Lua%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">Lua中的继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%85%88%E6%9D%A5%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%B1%BB%EF%BC%8C\"><span class=\"toc-text\">先来定义一个基类，</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AD%90%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">子类的实现</span></a></li></ol></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua类的实现思路","uid":"4e4ebc3eda806dabbf19b5aaecfdc728","slug":"zl/2016-01-01-472_Lua类的实现思路","date":"2024-04-03T03:47:35.755Z","updated":"2024-04-03T03:47:35.755Z","comments":true,"path":"api/articles/zl/2016-01-01-472_Lua类的实现思路.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"复习下lua的元表元方法，浅尝辄止。 目标是用lua实现以下C++例子的功能。123456789101112131415161718192021222324252627class {public: std::string mName; Anima(){} Anima(const ...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"溪流 WarKey 3.0 论坛预览版 发布，支持Lua脚本","uid":"10b11cff4c48bcbd38346c27bd294825","slug":"zl/2016-01-01-470_溪流 WarKey 3.0 论坛预览版 发布，支持Lua脚本","date":"2024-04-03T03:47:35.751Z","updated":"2024-04-03T03:47:35.751Z","comments":true,"path":"api/articles/zl/2016-01-01-470_溪流 WarKey 3.0 论坛预览版 发布，支持Lua脚本.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"昨晚搞到近 2 点，终于把相关部分搞完了，放出个预览版玩玩。这一版本将支持组合键，比如，可以分别改Q、Ctrl+Q、Alt+Q 等，也将支持所有鼠标操作。此外，增加了一个脚本系统，允许用户进行更大程度上的自定义。 猛击这里下载 脚本使用 lua 语言，格式大致为（正式版出来之前可...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}