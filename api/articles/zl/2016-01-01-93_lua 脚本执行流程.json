{"title":"lua 脚本执行流程","uid":"226f84d76102a9677ebecddad91f60db","slug":"zl/2016-01-01-93_lua 脚本执行流程","date":"2024-04-03T03:47:36.211Z","updated":"2024-04-03T03:47:36.211Z","comments":true,"path":"api/articles/zl/2016-01-01-93_lua 脚本执行流程.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<ul id=\"markdown-toc\">\n  <li><a href=\"#简介\" id=\"markdown-toc-简介\">简介</a></li>\n  <li><a href=\"#luastate\" id=\"markdown-toc-luastate\">LuaState</a></li>\n  <li><a href=\"#执行流程\" id=\"markdown-toc-执行流程\">执行流程</a>    <ul>\n      <li><a href=\"#编译\" id=\"markdown-toc-编译\">编译</a></li>\n      <li><a href=\"#执行\" id=\"markdown-toc-执行\">执行</a></li>\n    </ul>\n  </li>\n  <li><a href=\"#参考资料\" id=\"markdown-toc-参考资料\">参考资料</a></li>\n</ul>\n<h2 id=\"简介\">简介</h2>\n<p>之所以写这篇文章，因为在看lua源码时候，感觉对lua脚本执行流程有一个全局认识对\n研究lua源码本身起着重要作用，故此在这里简单介绍一下lua脚本是何时被加载、又是\n何时执行的。</p>\n<h2 id=\"luastate\">LuaState</h2>\n<p>想要更好的理解脚本执行流程，就必须先了解LuaState相关初始化，源码里简称L，lua\n状态机是lua框架的核心，无论是lua的编译和lua的执行都离不开这个lua状态机，这里\n使用UniLua作为源码参考，方便大家理解，初始化lua状态的方式很简单：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ILuaState Lua = LuaAPI.NewState();\nLua.L_OpenLibs();\n</code></pre></div></div>\n<p>需要注意的是在初始化完lua状态机后，需要初始化lua标准库，也就是上面的第二行代码\n否则lua标准库的函数是无法调用的。</p>\n<h2 id=\"执行流程\">执行流程</h2>\n<p>lua脚本执行流程是在LuaState初始化完成的基础上进行的，核心可以分为两部分，即lua\n的编译和lua的执行。</p>\n<h3 id=\"编译\">编译</h3>\n<p>编译lua源码主要调用这些函数进行源码编译，可以跟踪源码这些方法进行查看：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ThreadStatus L_DoFile(string filename);\npublic ThreadStatus L_LoadFileX(string filename, string mode);\nThreadStatus Load(ILoadInfo loadinfo, string name, string mode);\nprivate ThreadStatus D_PCall&lt;T&gt;(PFuncDelegate&lt;T&gt; func, ref T ud, int oldTopIndex, int errFunc);\nprivate ThreadStatus D_RawRunProtected&lt;T&gt;(PFuncDelegate&lt;T&gt; func, ref T ud);\nprivate static void F_Load(ref LoadParameter param);\n</code></pre></div></div>\n<p>上面函数除了最后一个是进入实际编译解析阶段，其他函数都是初始化数据阶段，这里关心\nF_Load函数的实现是什么？</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>private static void F_Load(ref LoadParameter param) &#123;\n\tvar L = param.L;\n\tLuaProto proto;\n\tvar c = param.LoadInfo.PeekByte();\n\tif(c == LuaConf.LUA_SIGNATURE[0])&#123;\n\t\tL.CheckMode( param.Mode, &#34;binary&#34; );\n\t\tproto = Undump.LoadBinary(L, param.LoadInfo, param.Name);\n\t&#125; else &#123;\n\t\tL.CheckMode( param.Mode, &#34;text&#34; );\n\t\tproto = Parser.Parse(L, param.LoadInfo, param.Name);\n\t&#125;\n\tvar cl = new LuaLClosureValue( proto );\n\tUtl.Assert(cl.Upvals.Length == cl.Proto.Upvalues.Count);\n\tL.Top.V.SetClLValue(cl);\n\tL.IncrTop();\n&#125;\n</code></pre></div></div>\n<p>该函数关键是调用Parser.Parse函数进入编译，具体代码实现可以去Parser的内部实现，\n函数返回LuaProto，然后生成一个LuaLClosureValue对象cl，最终的结果是将函数编译\n后的cl类型Push到栈顶（L.Top.V.SetClLValue(cl)），lua脚本的编译阶段到此全部结\n束。</p>\n<h3 id=\"执行\">执行</h3>\n<p>lua执行是以lua脚本编译后的输出作为输入交给虚拟机进行运行的过程，执行主要涉及\n下面这些脚本。</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ThreadStatus PCall(int numArgs, int numResults, int errFunc);\nprivate ThreadStatus D_PCall&lt;T&gt;(PFuncDelegate&lt;T&gt; func, ref T ud, int oldTopIndex, int errFunc);\nprivate void D_Call(StkId func, int nResults, bool allowYield);\nprivate void V_Execute();\n</code></pre></div></div>\n<p>上面函数只有最后一个是进入执行虚拟机指令阶段，虚拟机执行字节码指令的过程是很简单\n的，这里简单给出函数原型：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>private void V_Execute() &#123;\n\twhile(true)&#123;\n\t\tInstruction i\n\t\tswitch(i)&#123;\n\t\t\tcase OpCpde.OP_MOVE:\n\t\t\t//....\n\t\t\tcase OpCpde.OP_LOADK:\n\t\t\t//....\n\t\t\tdefault:\n\t\t\tbreak\n\t\t&#125;\n\t&#125;\n&#125;\n</code></pre></div></div>\n<p>可以看出该函数使用一个无限循环加switch方式执行字节码，知道字节码执行完毕，lua脚本执行\n也结束了。</p>\n<h2 id=\"参考资料\">参考资料</h2>\n<p><a href=\"https://github.com/xebecnan/UniLua\">UniLua源码</a></p>\n<p><a href=\"https://github.com/lua/lua\">lua源码</a></p>","text":" 简介 LuaState 执行流程 编译 执行 参考资料 简介 之所以写这篇文章，因为在看lua源码时候，感觉对lua脚本执行流程有一个全局认识对 研究lua源码本身起着重要作用，故此在这里简单介绍一下lua脚本是何时被加载、又是 何时执行的。 LuaState 想要更好的理解脚...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#luastate\"><span class=\"toc-text\">LuaState</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">执行流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">编译</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">执行</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\"><span class=\"toc-text\">参考资料</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"tolua++安装","uid":"0f6d71b477132b063b4c2ff5fbac2c35","slug":"zl/2016-01-01-942_tolua++安装","date":"2024-04-03T03:47:36.215Z","updated":"2024-04-03T03:47:36.216Z","comments":true,"path":"api/articles/zl/2016-01-01-942_tolua++安装.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;a href=&quot;/2015/11/11/lua_cpp_bind/&quot; rel=&quot;next&quot; title=&quot;C++与Lua本质原始交互API&quot;&gt; &lt;i class=&quot;fa fa-chevro...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"xLua游戏中的热更新","uid":"c1518e67a55845d9c4088afb6d356e68","slug":"zl/2016-01-01-940_xLua游戏中的热更新","date":"2024-04-03T03:47:36.211Z","updated":"2024-04-03T03:47:36.212Z","comments":true,"path":"api/articles/zl/2016-01-01-940_xLua游戏中的热更新.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"思考并回答以下问题： 目前Unity下的Lua热更新方案大多都是要求要热更新的部分一开始就要用Lua语言实现，不足之处在于： 1、接入成本高，有的项目已经用C#写完了，这时要接入需要把需要热更的地方用Lua重新实现； 2、即使一开始就接入了，也存在同时用两种语言开发难度较大的问题...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}