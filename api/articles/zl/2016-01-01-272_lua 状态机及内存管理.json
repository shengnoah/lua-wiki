{"title":"lua 状态机及内存管理","uid":"e0d30b8cee8a55cef375bf322cac449f","slug":"zl/2016-01-01-272_lua 状态机及内存管理","date":"2024-04-03T03:47:33.132Z","updated":"2024-04-03T03:47:33.135Z","comments":true,"path":"api/articles/zl/2016-01-01-272_lua 状态机及内存管理.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>&lt;p&gt;Lua虚拟机之间的工作是线程安装的，因为一切和虚拟机相关的内存都被关联到虚拟机对象中，没有任何共享变量。Lua允许用户自定义内存管理器，在虚拟机创建时传入，使得使用者对整个运行状态可控。虚拟机的核心部分没有任何的System call。&lt;/p&gt;\n</code></pre>\n<h2 id=\"section\">1. 内存管理</h2>\n<p>一般我们直接使用：</p>\n<pre><code>lua_State *(luaL_newstate) (void);\n</code></pre>\n<p>来直接创建一个虚拟机。其实这样创建虚拟机，传入虚拟机的内存管理函数是C标准库的内存管理函数，具体如下：</p>\n<pre><code>lua_State *luaL_newstate (void) &#123;\n  \tlua_State *L = lua_newstate(l_alloc, NULL);\n  \tif (L) lua_atpanic(L, &amp;panic);\n  \treturn L;\n&#125;\n</code></pre>\n<p>luaL_newstate其实是利用lua_newstate实现的，传给lua_newstate的内存管理器这l_alloc，而l_alloc的实现如果：</p>\n<pre><code>static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) &#123;\n  \t(void)ud; (void)osize;  /* not used */\n  \tif (nsize == 0) &#123;\n\tfree(ptr);\n\treturn NULL;\n  \t&#125;\n  \telse\nreturn realloc(ptr, nsize);\n&#125;\n</code></pre>\n<p>l_alloc是利用C标准库的realloc和free来实现的内存管理器。在这里，用户可以用自己的管理器来代替默认的内存管理器。l_alloc功能上类似于C标准库的realloc，但是当时nsize为0时，提供释放内存的功能。这个内存管理接口接受额外的一个指针ud，这可以让内存管理模块工作在不同的堆上。</p>\n<p>lua使用一组宏来管理单个对象、数组、可变长数组等不同类别的内存。定义在lmem.h中：</p>\n<pre><code>#define luaM_reallocv(L,b,on,n,e) \n  \t\t(((sizeof(n) &gt;= sizeof(size_t) &amp;&amp; cast(size_t, (n)) + 1 &gt; MAX_SIZET/(e)) \n  \t? luaM_toobig(L) : cast_void(0)) , \n   \t\tluaM_realloc_(L, (b), (on)*(e), (n)*(e)))\n</code></pre>\n<pre><code>/*\n</code></pre>\n<pre><code>** Arrays of chars do not need any test\n*/\n#define luaM_reallocvchar(L,b,on,n)  \n\tcast(char *, luaM_realloc_(L, (b), (on)*sizeof(char), (n)*sizeof(char)))\n\n#define luaM_freemem(L, b, s)\tluaM_realloc_(L, (b), (s), 0)\n#define luaM_free(L, b)\t\tluaM_realloc_(L, (b), sizeof(*(b)), 0)\n#define luaM_freearray(L, b, n)   luaM_realloc_(L, (b), (n)*sizeof(*(b)), 0)\n\n#define luaM_malloc(L,s)\tluaM_realloc_(L, NULL, 0, (s))\n#define luaM_new(L,t)\t\tcast(t *, luaM_malloc(L, sizeof(t)))\n#define luaM_newvector(L,n,t) \n\tcast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))\n\n#define luaM_newobject(L,tag,s)\tluaM_realloc_(L, NULL, tag, (s))\n\n#define luaM_growvector(L,v,nelems,size,t,limit,e) \n     if ((nelems)+1 &gt; (size)) \n    ((v)=cast(t *, luaM_growaux_(L,v,&amp;(size),sizeof(t),limit,e)))\n\n#define luaM_reallocvector(L, v,oldn,n,t) \n   \t\t((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))\n</code></pre>\n<p>这组宏实际调用luaM_realloc_和luaM_growaux_这两个内部API，它们不会被直接调用。实现如下：</p>\n<pre><code>void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) &#123;\n  \t\tvoid *newblock;\n  \t\tglobal_State *g = G(L);\n  \t\tsize_t realosize = (block) ? osize : 0;\n  \t\tlua_assert((realosize == 0) == (block == NULL));\n#if defined(HARDMEMTESTS)\n  \t\tif (nsize &gt; realosize &amp;&amp; g-&gt;gcrunning)\n\t\tluaC_fullgc(L, 1);  /* force a GC whenever possible */\n#endif\n  \t\tnewblock = (*g-&gt;frealloc)(g-&gt;ud, block, osize, nsize);\n  \t\tif (newblock == NULL &amp;&amp; nsize &gt; 0) &#123;\n\t\tlua_assert(nsize &gt; realosize);  /* cannot fail when shrinking a block */\n\t\tif (g-&gt;version) &#123;  /* is state fully built? */\n  \t\tluaC_fullgc(L, 1);  /* try to free some memory... */\n  \t\tnewblock = (*g-&gt;frealloc)(g-&gt;ud, block, osize, nsize);  /* try again */\n\t\t&#125;\n\t\tif (newblock == NULL)\n  \t\t\tluaD_throw(L, LUA_ERRMEM);\n  \t\t&#125;\n  \t\tlua_assert((nsize == 0) == (newblock == NULL));\n  \t\tg-&gt;GCdebt = (g-&gt;GCdebt + nsize) - realosize;\n  \t\treturn newblock;\n&#125;\n</code></pre>\n<p>luaM_realloc_调用保存在global_State中的内存管理器来管理内存。主要工作包括分配新的内存、释放不用的内存、扩展不够用的内存，还有通过realloc试图释放掉申请过大的内存的后半部分（取决于用户提供的内存管理器能不能缩小内存块）。</p>\n<pre><code>void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems, int limit, const char *what) &#123;\n  \tvoid *newblock;\n  \tint newsize;\n  \tif (*size &gt;= limit/2) &#123;  /* cannot double it? */\n\tif (*size &gt;= limit)  /* cannot grow even a little? */\n  \t\tluaG_runerror(L, \"too many %s (limit is %d)\", what, limit);\n\tnewsize = limit;  /* still have at least one free place */\n  \t&#125;\n  \telse &#123;\n\tnewsize = (*size)*2;\n\tif (newsize &lt; MINSIZEARRAY)\n  \tnewsize = MINSIZEARRAY;  /* minimum size */\n  \t&#125;\n  \tnewblock = luaM_reallocv(L, block, *size, newsize, size_elems);\n  \t*size = newsize;  /* update only when everything else is OK */\n  \treturn newblock;\n&#125;\n</code></pre>\n<p>luaM_growaux_是用来管理可变长数组的。其主要策略是当数组空间不够时，扩大为原来的两倍。</p>\n<h2 id=\"section-1\">2. 全局状态机</h2>\n<p>global_State对于lua使用者是不可见的，无法用公开的API取到它的指针，也不需要引用它。global_State里面有对主线程的引用，有注册表管理所有全局数据，有全局字符串表，有内存管理函数，GC相关的信息以及一切lua工作时需要的工作内存。</p>\n<p>创建一个新的lua虚拟机时，第一块申请的内存将用来保存主线程和这个全局状态机。利用一个LG结构，把主线程lua_Statet和global_State分配在一起。具体如下：</p>\n<pre><code>/*\n** thread state + extra space\n*/\ntypedef struct LX &#123;\n  \tlu_byte extra_[LUA_EXTRASPACE];\n  \tlua_State l;\n&#125; LX;\n\n\n/*\n** Main thread combines a thread state and the global state\n*/\ntypedef struct LG &#123;\n  \tLX l;\n  \tglobal_State g;\n&#125; LG;\n</code></pre>\n<p>lua_newstate初始化所有global_State中将引用的数据。lua_newstate()利用用户传进来的内存分配器分配主线程和global_State的内存，然后把内存分配器赋给global_State的frealloc来管理虚拟机内在的所有内存。把主线程和global_State关联上以及处理GC等相关的初始化。下面看一下它的具体实现：</p>\n<pre><code>lua_State *lua_newstate (lua_Alloc f, void *ud) &#123;\n  \tint i;\n  \tlua_State *L;\n  \tglobal_State *g;\n  \tLG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));\n  \tif (l == NULL) return NULL;\n  \tL = &amp;l-&gt;l.l;\n  \tg = &amp;l-&gt;g;\n  \tL-&gt;next = NULL;\n \tL-&gt;tt = LUA_TTHREAD;\n  \tg-&gt;currentwhite = bitmask(WHITE0BIT);\n  \tL-&gt;marked = luaC_white(g);\n  \tpreinit_thread(L, g);\n  \tg-&gt;frealloc = f;\n  \tg-&gt;ud = ud;\n  \tg-&gt;mainthread = L;\n  \tg-&gt;seed = makeseed(L);\n  \tg-&gt;gcrunning = 0;  /* no GC while building state */\n  \tg-&gt;GCestimate = 0;\n  \tg-&gt;strt.size = g-&gt;strt.nuse = 0;\n  \tg-&gt;strt.hash = NULL;\n  \tsetnilvalue(&amp;g-&gt;l_registry);\n  \tluaZ_initbuffer(L, &amp;g-&gt;buff);\n  \tg-&gt;panic = NULL;\n  \tg-&gt;version = NULL;\n  \tg-&gt;gcstate = GCSpause;\n  \tg-&gt;gckind = KGC_NORMAL;\n  \tg-&gt;allgc = g-&gt;finobj = g-&gt;tobefnz = g-&gt;fixedgc = NULL;\n  \tg-&gt;sweepgc = NULL;\n  \tg-&gt;gray = g-&gt;grayagain = NULL;\n  \tg-&gt;weak = g-&gt;ephemeron = g-&gt;allweak = NULL;\n  \tg-&gt;twups = NULL;\n  \tg-&gt;totalbytes = sizeof(LG);\n  \tg-&gt;GCdebt = 0;\n  \tg-&gt;gcfinnum = 0;\n  \tg-&gt;gcpause = LUAI_GCPAUSE;\n  \tg-&gt;gcstepmul = LUAI_GCMUL;\n  \tfor (i=0; i &lt; LUA_NUMTAGS; i++) g-&gt;mt[i] = NULL;\n  \tif (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) &#123;\n\t/* memory allocation error: free partial state */\n\tclose_state(L);\n\tL = NULL;\n  \t&#125;\n  \treturn L;\n&#125;\n</code></pre>\n<p>下面主要看f_luaopen()，此函数主要初始化了主线程的数据栈、初始化注册表、初始化字符串表和字符串cache、初始化元表用的字符串、初始化词法分析用的token串等等。由于初始化中会分配内存，有可能会引起内存错误。在lua_newstate中把g-&gt;version = NULL，在f_luaopen()中把所有的初始化完成后，如果没有错误才给版本号赋值g-&gt;version = lua_version(NULL)。我们通过’g-&gt;version’ != NULL来检测虚拟机是否正确建立起来。</p>\n<pre><code>/*\n** open parts of the state that may cause memory-allocation errors.\n** ('g-&gt;version' != NULL flags that the state was completely build)\n*/\nstatic void f_luaopen (lua_State *L, void *ud) &#123;\nglobal_State *g = G(L);\nUNUSED(ud);\n  \tstack_init(L, L);  /* init stack */\n  \tinit_registry(L, g);\n  \tluaS_init(L);\n  \tluaT_init(L);\n  \tluaX_init(L);\n  \tg-&gt;gcrunning = 1;  /* allow gc */\n  \tg-&gt;version = lua_version(NULL);\n  \tluai_userstateopen(L);\n&#125;\n</code></pre>","text":"&lt;p&gt;Lua虚拟机之间的工作是线程安装的，因为一切和虚拟机相关的内存都被关联到虚拟机对象中，没有任何共享变量。Lua允许用户自定义内存管理器，在虚拟机创建时传入，使得使用者对整个运行状态可控。虚拟机的核心部分没有任何的System call。&lt;/p&gt; 1....","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#section\"><span class=\"toc-text\">1. 内存管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#section-1\"><span class=\"toc-text\">2. 全局状态机</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua 元表学习","uid":"1281a2f200121e56ea61eb4caa5ec15c","slug":"zl/2016-01-01-274_lua 元表学习","date":"2024-04-03T03:47:33.136Z","updated":"2024-04-03T03:47:33.137Z","comments":true,"path":"api/articles/zl/2016-01-01-274_lua 元表学习.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua 中的每个值都有一个元表。table 和 userdata 可以有各自独立的原表，其他类型的值则共享其类型所属的单一元素。Lua 在创建新的 table 的时候不会创建元表。 12t = {}print(getmetatable(t)) 可以使用 setmetatable ...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua 在 Android 中应用上,如何引入 Lua","uid":"bb9230b411dc55a2fbf212ffc7592664","slug":"zl/2016-01-01-271_Lua 在 Android 中应用上,如何引入 Lua","date":"2024-04-03T03:47:33.131Z","updated":"2024-04-03T03:47:33.131Z","comments":true,"path":"api/articles/zl/2016-01-01-271_Lua 在 Android 中应用上,如何引入 Lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;转载请附原文链接：&lt;a href=&quot;http://yongyu.itscoder.com/2018/04/16/yongyu_20180416_lua_android_one/&quot; target=&quot;_blank&quot; r...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}