{"title":"Lua 学习 chapter6","uid":"af33457a1ca8da53e4dd258f4137d455","slug":"zl/2016-01-01-191_Lua 学习 chapter6 ","date":"2024-04-03T03:47:33.075Z","updated":"2024-04-03T03:47:33.075Z","comments":true,"path":"api/articles/zl/2016-01-01-191_Lua 学习 chapter6 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>\t\t\t&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;\n</code></pre>\n<ol>\n  <li>函数</li>\n  <li>多个返回值</li>\n  <li>可变长函数参数</li>\n  <li>\n  </li>\n</ol>\n<h2 id=\"函数\">函数</h2>\n<p>在lua中，函数是对语句和表达式抽象的主要方式。函数的调用需要一对空括号，里面放着参数。唯一的例外就是当参数只有一个且该参数是字符串或表构造器。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n</pre></td><td class=\"rouge-code\"><pre><span class=\"nb\">print</span> <span class=\"s\">[[a multi-line\nmessage]]</span>   \n<span class=\"cm\">--[[&gt;print([[a multi-line\n              message]])]]</span>\n<p><span class=\"n\">f</span><span class=\"p\">&#123;</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">&#125;</span> <span class=\"c1\">–&gt;f(&#123;x=10,y=3&#125;)</span><br />\n</pre></td></tr></tbody></table></code></pre></div></div></p>\n<p>lua函数是存在语法糖的，即使用冒号来调用函数会把第一个参数默认认为是调用对象本身</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n</pre></td><td class=\"rouge-code\"><pre><span class=\"n\">o</span><span class=\"p\">:</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>  <span class=\"c1\">--&gt;其中x就是o对象</span>\n</pre></td></tr></tbody></table></code></pre></div></div>\n<p>在lua进程中调用Lua语言编写的函数和用c编写的函数方式是一样的，没有任何区别。</p>\n<p>在lua中，调用函数使用的参数个数可以和定义函数使用的参数个数不一致，当传入参数的个数大于定义的时候后面没有用到的参数就会被舍弃，当传入的参数个数少的时候，后面的参数就会被默认为nil。</p>\n<h2 id=\"多个返回值\">多个返回值</h2>\n<p>在lua函数中，它允许一个函数返回多个返回值。\n函数定义返回多个返回值，但是在调用的时候lua会根据被调用情况调整返回值的个数。</p>\n<ol>\n  <li>当函数被作为一条单独语句调用的时候，其所有的返回值都将被舍弃。</li>\n  <li>当函数被作为表达式调用时，将只保留第一个返回值。</li>\n  <li>当函数调用时一系列表达式中的最后一个表达式时，其所有的返回值才能被获取到。</li>\n  <li>当函数调用是另一个函数调用的最后一个表达式时能返回多个值，否则只能返回一个值。</li>\n  <li>将函数调用用一对圆括号括起来可以强制其只返回一个结果。</li>\n</ol>\n<h2 id=\"可变长函数参数\">可变长函数参数</h2>\n<p>lua语言中的函数是可边长函数参数，参数列表中的三个点表示该函数是可变长的。\n当函数访问这个可变长参数的时候可以将其视作一个表达式。它的放回结果就是各个参数，当然要对其访问的时候，也可以通过表构造器来访问。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n</pre></td><td class=\"rouge-code\"><pre><span class=\"k\">function</span> <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n\t<span class=\"kd\">local</span> <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\t<span class=\"k\">for</span> <span class=\"n\">_</span><span class=\"p\">,</span><span class=\"n\">v</span> <span class=\"k\">in</span> <span class=\"nb\">ipairs</span> <span class=\"p\">&#123;</span><span class=\"o\">...</span><span class=\"p\">&#125;</span> <span class=\"k\">do</span>\n\t\t<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"n\">v</span>\n\t<span class=\"k\">end</span>\n\t<span class=\"kd\">local</span> <span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"o\">...</span>\n\t<span class=\"k\">return</span> <span class=\"n\">s</span>\n<span class=\"k\">end</span>\n<p></pre></td></tr></tbody></table></code></pre></div></div></p>\n<p>函数也可以由固定参数加可变参数，但是可变参数一定要在固定参数的后面。</p>\n<p>在上面的例子中，直接使用表构造器还是存在问题的，如果中间存在nil表就不是连续的了，对于这种情况跟lua提供了函数<strong>table.pack</strong>，\n该函数像{…}保存所有的参数，然后将其放在一个表中范慧慧，但是这个表还有一个保存了参数个数的额外字段 <strong>n</strong> 。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n</pre></td><td class=\"rouge-code\"><pre><span class=\"k\">function</span> <span class=\"nf\">nonils</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"kd\">local</span> <span class=\"n\">arg</span> <span class=\"o\">=</span> <span class=\"nb\">table.pack</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">n</span> <span class=\"k\">do</span>\n\t\t<span class=\"k\">if</span> <span class=\"n\">arg</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"kc\">nil</span> <span class=\"k\">then</span> <span class=\"k\">return</span> <span class=\"kc\">false</span>\n\t<span class=\"k\">end</span>\n\t<span class=\"k\">return</span> <span class=\"kc\">true</span>\n<span class=\"k\">end</span>\n<p></pre></td></tr></tbody></table></code></pre></div></div></p>\n<p>可以使用上面的方法来判断参数是否存在空。</p>\n<p>在lua中还有一个函数select，函数select总是存在一个固定参数selector和数量可变的参数，如果selector是数值n，则select函数返回n(包含n)之后的所有参数。否则selector应该是字符串”#”，select返回额外参数的总数。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n</pre></td><td class=\"rouge-code\"><pre><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">select</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"s2\">\"a\"</span><span class=\"p\">,</span><span class=\"s2\">\"b\"</span><span class=\"p\">,</span><span class=\"s2\">\"c\"</span><span class=\"p\">))</span> <span class=\"c1\">--&gt;a b c</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">select</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"s2\">\"a\"</span><span class=\"p\">,</span><span class=\"s2\">\"b\"</span><span class=\"p\">,</span><span class=\"s2\">\"c\"</span><span class=\"p\">))</span> <span class=\"c1\">--&gt;b c</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">select</span><span class=\"p\">(</span><span class=\"s2\">\"#\"</span><span class=\"p\">,</span><span class=\"s2\">\"a\"</span><span class=\"p\">,</span><span class=\"s2\">\"b\"</span><span class=\"p\">,</span><span class=\"s2\">\"c\"</span><span class=\"p\">))</span> <span class=\"c1\">--&gt;3</span>\n</pre></td></tr></tbody></table></code></pre></div></div>\n<p>与pack相对应，table.unpack的参数是一个数组，返回值为数组内的所有元素。\n顾名思义，pack将参数列表转换成一张表，而unpack将表转换成一组返回值。\n如果有需要也可以显示的限制返回值的范围：</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n</pre></td><td class=\"rouge-code\"><pre><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">table.unpack</span><span class=\"p\">(&#123;</span><span class=\"s2\">\"M\"</span><span class=\"p\">,</span><span class=\"s2\">\"T\"</span><span class=\"p\">,</span><span class=\"s2\">\"Tu\"</span><span class=\"p\">,</span><span class=\"s2\">\"W\"</span><span class=\"p\">&#125;,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">))</span> <span class=\"c1\">--&gt; T  Tu</span>\n</pre></td></tr></tbody></table></code></pre></div></div>\n<pre><code>            &lt;hr style=&quot;visibility: hidden;&quot;&gt;\n</code></pre>\n","text":" &lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt; 函数 多个返回值 可变长函数参数 函数 在lua中，函数是对语句和表达式抽象的主要方式。函数的调用需要一对空括号，里面放着参数。唯一的例外就是当参数只有一个且该参数是字符串或表构造器。 1 2 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">多个返回值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">可变长函数参数</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"unity lua －1 最开始调用","uid":"e114d6fc302998111b5c100fb6afbfcb","slug":"zl/2016-01-01-193_unity lua －1 最开始调用","date":"2024-04-03T03:47:33.076Z","updated":"2024-04-03T03:47:33.077Z","comments":true,"path":"api/articles/zl/2016-01-01-193_unity lua －1 最开始调用.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;ul&gt; lua脚本以txt的形式存储在Resources 下面 用LuaSvr svr svr.start调用到脚本 用 svr.luaState.getFunction(“foo”).call 来调用到里面的方法 lua Table – 是一个Key Value...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"基于XLua的Unity脚本框架的设计与实现","uid":"8912b8abe24cb570896b9c689c6c6d40","slug":"zl/2016-01-01-192_基于XLua的Unity脚本框架的设计与实现","date":"2024-04-03T03:47:33.075Z","updated":"2024-04-03T03:47:33.076Z","comments":true,"path":"api/articles/zl/2016-01-01-192_基于XLua的Unity脚本框架的设计与实现.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;摘 要：&lt;br&gt;Unity技术的迅速崛起, 让3D移动游戏逐渐流行。随着游戏系统的不断丰富, 游戏开发迭代速度迅速加快。但Unity的原生C#开发效率较慢, 而且在部分平台上无法进行热更新, 无法满足[…]&lt;/p&gt; 行游戏内容的更新,由...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}