{"title":"一个简单的Lua (Memory) Profiler","uid":"5b690cfc8daed9e0e24f168f448fdb9c","slug":"zl/2016-01-01-409_一个简单的Lua (Memory) Profiler","date":"2024-04-03T03:47:35.699Z","updated":"2024-04-03T03:47:35.699Z","comments":true,"path":"api/articles/zl/2016-01-01-409_一个简单的Lua (Memory) Profiler.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p><code class=\"highlighter-rouge\">Lua</code>没有内置的<code class=\"highlighter-rouge\">Profiler</code>，但是提供了一些相关的接口，可以用来实现一个简单的<a href=\"https://github.com/qq410029478/luaprofiler\">Lua Profiler</a>。</p>\n<p>一个<code class=\"highlighter-rouge\">Profiler</code>至少需要统计以下信息, 用函数名+调用位置(保留一层堆栈信息)作为<code class=\"highlighter-rouge\">key</code>:</p>\n<ul>\n  <li>执行次数</li>\n  <li>总时间</li>\n  <li>单次最大时间</li>\n  <li>尚未gc的内存数量</li>\n  <li>分配内存的最大值</li>\n</ul>\n<h1 id=\"二基础\">二、基础</h1>\n<p>出发点是<a href=\"https://github.com/LuaDist/luaprofiler\">LuaProfiler</a>，结构比较合理，但是有一些小问题：</p>\n<ul>\n  <li>统计数据应该驻留在内存中，不能写<code class=\"highlighter-rouge\">log</code>，太卡。</li>\n  <li><code class=\"highlighter-rouge\">time()</code>的精度太低，换成<code class=\"highlighter-rouge\">PerformanceCounter</code>(windows)。</li>\n  <li><code class=\"highlighter-rouge\">lua5.3</code>和<code class=\"highlighter-rouge\">5.1</code>的<code class=\"highlighter-rouge\">lua_Hook</code>处理<code class=\"highlighter-rouge\">tail call</code>的接口不一样，需要转换一下。</li>\n  <li><code class=\"highlighter-rouge\">coroutine</code>相关的处理。</li>\n</ul>\n<h1 id=\"三memory\">三、Memory</h1>\n<p>通过以下方式可以获取每个函数分配内存的数据：</p>\n<ol>\n  <li>启动<code class=\"highlighter-rouge\">Profiler</code>时执行一次<code class=\"highlighter-rouge\">full gc</code></li>\n  <li>重载<a href=\"http://www.lua.org/manual/5.3/manual.html#lua_Alloc\"><code class=\"highlighter-rouge\">lua_Alloc</code></a>，按下列三种情况统计数据：\n    <ol>\n      <li>分配新的内存：建立内存指针与当前函数数据的对应关系，如果新内存大小为<code class=\"highlighter-rouge\">size</code>, 当前函数的内存数量<code class=\"highlighter-rouge\">+=size</code>，同时检查更新内存最大值。</li>\n      <li>释放内存：获得对应的函数数据，如果释放的内存大小为<code class=\"highlighter-rouge\">size</code>, 当前函数的内存数量<code class=\"highlighter-rouge\">-=size</code></li>\n      <li><code class=\"highlighter-rouge\">realloc</code>: 按照释放旧内存，分配新内存处理，但是这样可能会出现一些问题。如果旧内存是在函数A中分配，新内存在另一个函数B中分配，旧内存对应的数据会被计入B的统计数据中。不过这个问题应该影响不大。</li>\n    </ol>\n  </li>\n  <li>停止<code class=\"highlighter-rouge\">Profiler</code>时执行一次<code class=\"highlighter-rouge\">full gc</code></li>\n</ol>\n<h1 id=\"四应用\">四、应用</h1>\n<p>这个<code class=\"highlighter-rouge\">Profiler</code>统计的数据虽然简单，但是已经足以用来进行一些精细的优化，其中值得一提的有：</p>\n<h2 id=\"41-内存泄漏\">4.1 内存泄漏</h2>\n<p>以下面这段代码为例：</p>\n<figure class=\"highlight\"><pre><code class=\"language-lua\" data-lang=\"lua\"><span class=\"kd\">local</span> <span class=\"k\">function</span> <span class=\"nf\">alloc</span><span class=\"p\">()</span>\n    <span class=\"k\">return</span> <span class=\"p\">&#123;&#125;</span>\n<span class=\"k\">end</span>\n<p><span class=\"c1\">–分配</span><br />\n<span class=\"kd\">local</span> <span class=\"n\">Cache</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span><br />\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">100</span> <span class=\"k\">do</span><br />\n<span class=\"n\">Cache</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">alloc</span><span class=\"p\">()</span><br />\n<span class=\"k\">end</span><br />\n<span class=\"c1\">– 释放</span><br />\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">100</span> <span class=\"k\">do</span><br />\n<span class=\"n\">Cache</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">nil</span><br />\n<span class=\"k\">end</span></code></pre></figure></p>\n<p>下面是函数<code class=\"highlighter-rouge\">alloc</code>在内存方面的数据，可以看到<code class=\"highlighter-rouge\">alloc</code>分配的内存都释放掉了：</p>\n<table>\n  <thead>\n    <tr>\n      <th>尚未gc的内存数量(Byte)</th>\n      <th>分配内存的最大值(Byte)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>5600</td>\n    </tr>\n  </tbody>\n</table>\n<p>把释放内存的代码注释掉，函数<code class=\"highlighter-rouge\">alloc</code>在内存方面的数据变成：</p>\n<table>\n  <thead>\n    <tr>\n      <th>尚未gc的内存数量(Byte)</th>\n      <th>分配内存的最大值(Byte)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>5600</td>\n      <td>5600</td>\n    </tr>\n  </tbody>\n</table>\n<p>如果代码中存在(持续地)内存泄漏，表现在<code class=\"highlighter-rouge\">profile</code>数据中，是相关函数的<code class=\"highlighter-rouge\">尚未gc的内存数量(Byte)</code>项不但不为0，还可能持续的变大。</p>\n<h2 id=\"42-不必要的临时内存\">4.2 不必要的临时内存</h2>\n<p>用<code class=\"highlighter-rouge\">..</code>拼接字符串是最典型的例子，下面的函数<code class=\"highlighter-rouge\">ConcatStrings</code>将<code class=\"highlighter-rouge\">SubStrList</code>中的字符串拼接成一个字符串：</p>\n<figure class=\"highlight\"><pre><code class=\"language-lua\" data-lang=\"lua\"><span class=\"kd\">local</span> <span class=\"n\">SubStrList</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">10000</span> <span class=\"k\">do</span>\n    <span class=\"nb\">table.insert</span><span class=\"p\">(</span><span class=\"n\">SubStrList</span><span class=\"p\">,</span> <span class=\"nb\">tostring</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">))</span>\n<span class=\"k\">end</span>\n<p><span class=\"kd\">local</span> <span class=\"k\">function</span> <span class=\"nf\">ConcatStrings</span><span class=\"p\">(</span><span class=\"n\">SubStrList</span><span class=\"p\">)</span><br />\n<span class=\"kd\">local</span> <span class=\"n\">Result</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;&quot;</span><br />\n<span class=\"k\">for</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">SubStr</span> <span class=\"k\">in</span> <span class=\"nb\">ipairs</span><span class=\"p\">(</span><span class=\"n\">SubStrList</span><span class=\"p\">)</span> <span class=\"k\">do</span><br />\n<span class=\"n\">Result</span> <span class=\"o\">=</span> <span class=\"n\">Result</span> <span class=\"o\">…</span> <span class=\"n\">SubStr</span><br />\n<span class=\"k\">end</span><br />\n<span class=\"k\">return</span> <span class=\"n\">Result</span><br />\n<span class=\"k\">end</span></code></pre></figure></p>\n<p>调用一次<code class=\"highlighter-rouge\">ConcatStrings</code>的<code class=\"highlighter-rouge\">profile</code>数据如下，从中可以看出产生了大量临时的内存，虽然可以<code class=\"highlighter-rouge\">gc</code>掉：</p>\n<table>\n  <thead>\n    <tr>\n      <th>函数名</th>\n      <th>尚未gc的内存数量(Byte)</th>\n      <th>分配内存的最大值(Byte)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>ConcatStrings</td>\n      <td>38919</td>\n      <td>1641422</td>\n    </tr>\n  </tbody>\n</table>\n<p>拼接字符串的正确姿势应该是：</p>\n<figure class=\"highlight\"><pre><code class=\"language-lua\" data-lang=\"lua\"><span class=\"kd\">local</span> <span class=\"k\">function</span> <span class=\"nf\">ConcatStrings</span><span class=\"p\">(</span><span class=\"n\">SubStrList</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"nb\">table.concat</span><span class=\"p\">(</span><span class=\"n\">SubStrList</span><span class=\"p\">)</span>\n<span class=\"k\">end</span></code></pre></figure>\n<p>调用这个版本<code class=\"highlighter-rouge\">ConcatStrings</code>的数据如下：</p>\n<table>\n  <thead>\n    <tr>\n      <th>函数名</th>\n      <th>尚未gc的内存数量(Byte)</th>\n      <th>分配内存的最大值(Byte)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>ConcatStrings</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <td>table.concat</td>\n      <td>39582</td>\n      <td>137942</td>\n    </tr>\n  </tbody>\n</table>\n<p>比较两个版本的数据可以看出，最终拼接好的字符串占用的内存是相似的，但是拼接过程中产生的临时内存差别非常大。</p>","text":"Lua没有内置的Profiler，但是提供了一些相关的接口，可以用来实现一个简单的Lua Profiler。 一个Profiler至少需要统计以下信息, 用函数名+调用位置(保留一层堆栈信息)作为key: 执行次数 总时间 单次最大时间 尚未gc的内存数量 分配内存的最大值 二、...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">二、基础</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89memory\"><span class=\"toc-text\">三、Memory</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">四、应用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#41-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F\"><span class=\"toc-text\">4.1 内存泄漏</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#42-%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E4%B8%B4%E6%97%B6%E5%86%85%E5%AD%98\"><span class=\"toc-text\">4.2 不必要的临时内存</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"cocos2dx lua TableView(ScrollView, ListView)介绍与使用实战","uid":"c693db45be4097337f085e0e5cc0d97d","slug":"zl/2016-01-01-411_cocos2dx lua TableView(ScrollView, ListView)介绍与使用实","date":"2024-04-03T03:47:35.700Z","updated":"2024-04-03T03:47:35.703Z","comments":true,"path":"api/articles/zl/2016-01-01-411_cocos2dx lua TableView(ScrollView, ListView)介绍与使用实.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"在众多移动应用中，能看到各式各样的列表/表格数据 不管是iOS中的UITableView/UICollectionView/UIScrollView,还是Android中的ListView/CircleView，都是实际项目开发中使用最平凡，也是最重要的功能。 为了用户考虑，也为...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Programming in Lua(Thrid Edition)笔记","uid":"a502732b8dc58224e972b6c53538b8c4","slug":"zl/2016-01-01-40_Programming in Lua(Thrid Edition)笔记","date":"2024-04-03T03:47:35.699Z","updated":"2024-04-03T03:47:35.700Z","comments":true,"path":"api/articles/zl/2016-01-01-40_Programming in Lua(Thrid Edition)笔记.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"13 Metatables and Metamethods metatable和metamethod可以允许我们对一个值做未定义的操作，Lua中的每个值都可以有一个metatable，table和userdata有自己的metatable，其他类型的值对于本类型的所有值共享一个m...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}