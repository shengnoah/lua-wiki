{"title":"openresty通过lua增加随机traceid","uid":"1173ab172ce65d0ed152ddc459d93ed4","slug":"zl/2016-01-01-513_openresty通过lua增加随机traceid","date":"2024-04-03T03:47:35.789Z","updated":"2024-04-03T03:47:35.789Z","comments":true,"path":"api/articles/zl/2016-01-01-513_openresty通过lua增加随机traceid.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>在没有引入zipkin（或者阿里的鹰眼，百度的华佗）这种trace系统的时候，排查问题的一般思路都是按照请求链路来寻找问题源。因此如果能在请求链路中有一个唯一的标识就最好了，而在nginx/openresty做接入层的架构中，可以通过lua脚本生成一个随机traceid。</p><p>随机数的生成原理，都是先初始化一个随机数种子，由于伪随机数的特性，种子的随机性就显得格外重要，而一般种子的生成都是通过时间的倒序来选取</p><h4 id=\"lua-随机数生成方法\">lua 随机数生成方法</h4><p>首先我们看下通常lua的随机数生成方法</p><div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">math.randomseed</span><span class=\"p\">(</span><span class=\"nb\">tonumber</span><span class=\"p\">(</span><span class=\"nb\">tostring</span><span class=\"p\">(</span><span class=\"nb\">os.time</span><span class=\"p\">()):</span><span class=\"n\">reverse</span><span class=\"p\">():</span><span class=\"n\">sub</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">)))</span>\n<span class=\"nb\">math.random</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</code></pre></div></div><p>通过时间字符串的逆序初始化随机种子，这里注意到有个<code class=\"highlighter-rouge\">sub</code>函数做了截断，是因为</p><blockquote><p><code class=\"highlighter-rouge\">math.randomseed</code> will call the underlying C function <code class=\"highlighter-rouge\">srand</code> which takes an unsigned integer valueLua will cast the value of the seed to this format. In case of an overflow the seed will actually become a bad seed, without warning</p></blockquote><p>所以需要避免出现高类型向低类型转换的溢出问题</p><h3 id=\"common-方法的问题\">common 方法的问题</h3><p>但上面的方法有个问题，就是<code class=\"highlighter-rouge\">os.time()</code>函数返回的是秒(10位整数), 所以在做web请求的traceid时很容易就出现重复，影响问题追踪的效率，而lua如果要以毫秒为单位的时间来初始化随机种子，需要引入socket等外部模块，对于openresty来说一般都是封装好的，不方便去做这种定制</p><h4 id=\"利用openresty-与lua生成traceid\">利用openresty 与lua生成traceid</h4><p>幸运的是，nginx-lua中有个函数<code class=\"highlighter-rouge\">ngx.now</code>会返回一个浮点数（当然在lua中统一为number类型），3位小数即为毫秒位，所以问题就变得简单了</p><div class=\"language-shell highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>access_by_lua_block <span class=\"o\">&#123;</span>\n    math.randomseed<span class=\"o\">(</span>tonumber<span class=\"o\">(</span>tostring<span class=\"o\">(</span>ngx.now<span class=\"o\">()</span><span class=\"k\">*</span>1000<span class=\"o\">)</span>:reverse<span class=\"o\">()</span>:sub<span class=\"o\">(</span>1,9<span class=\"o\">)))</span>\n    <span class=\"nb\">local </span>randvar <span class=\"o\">=</span> string.format<span class=\"o\">(</span><span class=\"s2\">&#34;%.0f&#34;</span>,math.random<span class=\"o\">(</span>1000000000000000000,9223372036854775807<span class=\"o\">))</span>\n    ngx.req.set_header<span class=\"o\">(</span><span class=\"s2\">&#34;traceid&#34;</span>, randvar<span class=\"o\">)</span>\n<span class=\"o\">&#125;</span>\n</code></pre></div></div><p>通过<code class=\"highlighter-rouge\">ngx.now()*1000</code>拿到毫秒数据转换为字符串取反，这样毫秒数据的变化才能显出效果; unsigned int（64bit机器下为4byte) 最大值为10位数，我们取前9位避免数据溢出带来的转换问题; lua在显示大于64bit的数据时会自动用科学技术法表示，所以我们需要通过string.format函数来将其转换为19位数字，然后通过ngx.req.set_header添加到请求头中去</p><div class=\"post-links\"> <a class=\"link-to-post\" href=\"/ops/OPS-samba%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/\"> <span class=\"link-to-post__next\">⤧  Next post</span> <span class=\"link-to-post__title\">samba安装及配置说明</span> </a> <a class=\"link-to-post\" href=\"/ops/OPS-ssh-%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/\"> <span class=\"link-to-post__prev\">⤧  Previous post</span> <span class=\"link-to-post__title\">[译]ssh免密登录失败问题排查思路</span> </a></div>","text":"在没有引入zipkin（或者阿里的鹰眼，百度的华佗）这种trace系统的时候，排查问题的一般思路都是按照请求链路来寻找问题源。因此如果能在请求链路中有一个唯一的标识就最好了，而在nginx/openresty做接入层的架构中，可以通过lua脚本生成一个随机traceid。随机数的...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#lua-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">lua 随机数生成方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#common-%E6%96%B9%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">common 方法的问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8openresty-%E4%B8%8Elua%E7%94%9F%E6%88%90traceid\"><span class=\"toc-text\">利用openresty 与lua生成traceid</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 排序算法","uid":"18c65ae79c1521b9ec150d64b8237a42","slug":"zl/2016-01-01-512_Lua 排序算法 ","date":"2024-04-03T03:47:35.789Z","updated":"2024-04-03T03:47:35.789Z","comments":true,"path":"api/articles/zl/2016-01-01-512_Lua 排序算法 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序的主要优点与...","link":"","photos":[],"count_time":{"symbolsCount":957,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua语句段 · 花生肉泥","uid":"82d70b1b5facde5290424415786eeaf4","slug":"zl/2016-01-01-514_Lua语句段 · 花生肉泥","date":"2024-04-03T03:47:35.789Z","updated":"2024-04-03T03:47:35.789Z","comments":true,"path":"api/articles/zl/2016-01-01-514_Lua语句段 · 花生肉泥.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"chunk语句组chunk是一系列语句，lua执行的每一块语句，比如一个文件或者交互模式下的每一行都是一个chunk 语句块显式的语句块对于控制变量的作用范围很有用，有时候，显式的语句块被用来在另一个语句块中插入retuen或是break 赋值语句lua允许多重赋值，因此，赋值的...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}