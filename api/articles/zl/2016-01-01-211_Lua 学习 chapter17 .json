{"title":"Lua 学习 chapter17","uid":"71d4be5e48e9da5655b092bfb309953f","slug":"zl/2016-01-01-211_Lua 学习 chapter17 ","date":"2024-04-03T03:47:33.090Z","updated":"2024-04-03T03:47:33.090Z","comments":true,"path":"api/articles/zl/2016-01-01-211_Lua 学习 chapter17 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>\t\t\t&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;\n</code></pre>\n<ol>\n  <li>require函数</li>\n  <li>模块</li>\n</ol>\n<h2 id=\"require函数\">require函数</h2>\n<p>ruquire函数可以加载任意模块，然后创建和返回一个表.</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n</pre></td><td class=\"rouge-code\"><pre><span class=\"kd\">local</span> <span class=\"n\">mod</span> <span class=\"o\">=</span> <span class=\"nb\">require</span> <span class=\"s2\">\"mod\"</span>\n<span class=\"n\">mod</span><span class=\"p\">.</span><span class=\"n\">foo</span><span class=\"p\">()</span>\n<p><span class=\"kd\">local</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"nb\">require</span> <span class=\"s2\">“mod”</span><br />\n<span class=\"kd\">local</span> <span class=\"n\">f1</span> <span class=\"o\">=</span> <span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">foo</span><br />\n<span class=\"n\">f1</span><span class=\"p\">()</span></p>\n<p><span class=\"kd\">local</span> <span class=\"n\">f2</span> <span class=\"o\">=</span> <span class=\"nb\">require</span> <span class=\"s2\">“mod”</span><span class=\"p\">.</span><span class=\"n\">foo</span><br />\n<span class=\"n\">f2</span><span class=\"p\">()</span><br />\n</pre></td></tr></tbody></table></code></pre></div></div></p>\n<p>require 函数在表package.loaded中检查模块是否已经被加载过。如果加载过就返回相应的值，这就避免的重复的加载。没有加载，就会通过loadfile来对其进行加载。如果没有lua文档，就回去加载c标准库，使用底层函数package.loadlib进行加载。</p>\n<p>如果加载函数有返回值，那么函数require会返回合格值，将其保存在packag.loaded中，如果没有返回值，且package.loaded[@rep{moduname}]为空，函数require就假设该模块的返回值是true。如果不存在这种，补偿会造成重复加载。</p>\n<p>要强制加载同一模块两次，可以先将模块从package.loaded中删除：package.loaded.modname = nil.</p>\n<h2 id=\"模块\">模块</h2>\n<p>在lua中，简单的使用模块的方式就是使用表将所有属性放到这个表中（可以封装成类），然后最后返回这个表。\n如果不想返回的话，可以以选择给package.loaded[M] = M。赋值的方法。</p>\n<pre><code>            &lt;hr style=&quot;visibility: hidden;&quot;&gt;\n</code></pre>\n","text":" &lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt; require函数 模块 require函数 ruquire函数可以加载任意模块，然后创建和返回一个表. 1 2 3 4 5 6 7 8 9 local mod = require \"mod\" ...","link":"","photos":[],"count_time":{"symbolsCount":739,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#require%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">require函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">模块</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 排序算法","uid":"18c65ae79c1521b9ec150d64b8237a42","slug":"zl/2016-01-01-210_Lua 排序算法 ","date":"2024-04-03T03:47:33.090Z","updated":"2024-04-03T03:47:33.090Z","comments":true,"path":"api/articles/zl/2016-01-01-210_Lua 排序算法 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&...","link":"","photos":[],"count_time":{"symbolsCount":917,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lazy Evaluation 的原理与实现","uid":"d7bcce7d3fdaca51ca7bf745ecf3d47b","slug":"zl/2016-01-01-212_Lazy Evaluation 的原理与实现","date":"2024-04-03T03:47:33.090Z","updated":"2024-04-03T03:47:33.091Z","comments":true,"path":"api/articles/zl/2016-01-01-212_Lazy Evaluation 的原理与实现.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"&lt;p&gt;Lazy Evaluation 是Haskell进程的求值方式。当把一个表达式与一个变量绑定时，这个表达式并没有被立即求值，而是当它的结果需要被其他的计算用到时才会求值。因此，在调用函数时，参数也不会在调用前求值， 而是当它的值被用到是才会求值。Technica...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}