{"title":"RedisLua脚本","uid":"bab9b8d672285aed4210fd27a4cf2a1c","slug":"zl/2016-01-01-565_RedisLua脚本","date":"2024-04-03T03:47:35.822Z","updated":"2024-04-03T03:47:35.822Z","comments":true,"path":"api/articles/zl/2016-01-01-565_RedisLua脚本.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"Lua脚本\"><a href=\"#Lua脚本\" class=\"headerlink\" title=\"Lua脚本\"></a>Lua脚本</h2><ol>\n<li><p>使用脚本可以直接在服 务器端执行 Redis 命令,一般的数据 处理操作可以直接使用 Lua 语言或者 Lua 解释器提供的函数 库来完成,不必再返回 给客户端进行处理。</p>\n</li>\n<li><p>所有脚本都是以事 务的形式来执行的,脚本在 执行过程中不会被其他工作打断,也不会引起任何 竞争条件,完全可以使用 Lua 脚本来代替事 务和乐观锁。</p>\n</li>\n<li><p>所有脚本都是可重用的,也即是 说,重复执行相同的操作 时,只要调用储存在服务器内部的脚本 缓存就可以了,不用重新 发送整个脚本,从而尽可能地 节约网络资源。</p>\n</li>\n</ol>\n<h2 id=\"执行-Lua-脚本\"><a href=\"#执行-Lua-脚本\" class=\"headerlink\" title=\"执行 Lua 脚本\"></a>执行 Lua 脚本</h2><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">EVAL script numkeys key [key ...] arg [arg ...]</span><br/></pre></td></tr></tbody></table></figure>\n<ul>\n<li>script 参数是要执行的 Lua 脚本。</li>\n<li>numkeys 是脚本要处理的数据库键的数量,之后的 key [key …] 参数指定了脚本要 处理的数据库键,被传入的键可以在脚本里面通 过访问 KEYS 数组来取得,比如 KEYS[1] 就取出第一个 输入的键,KEYS[2] 取出第二个输入的键,诸如此类。</li>\n<li>arg [arg …] 参数指定了脚本要用到的参数,在脚本里面可以通 过访问 ARGV 数组来获取这些参数。显式地指定脚本里面用到的 键是为了配合 Redis 集群对键的检查,如果不这样做的话,在集群里面使用脚本可能会出 错。</li>\n</ul>\n<p>另外,通过显式地指定脚本要用到的数据 库键以及相关参数,而不是将数据 库键和参数硬写在脚本里面,用户可以更方便地重用同一个脚本。<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; EVAL &#34;return redis.call(&#39;PING&#39;)&#34; 0   # 在 Lua 脚本里面执行 PING 命令</span><br/><span class=\"line\">PONG</span><br/><span class=\"line\">redis&gt; EVAL &#34;return redis.call(&#39;DBSIZE&#39;)&#34; 0  # 在 Lua 脚本里面执行 DBSIZE 命令</span><br/><span class=\"line\">(integer) 4</span><br/><span class=\"line\"></span><br/><span class=\"line\"># 在 Lua 脚本里面执行 GET 命令,取出键 msg 的值,并对值进行字符串拼接操作</span><br/><span class=\"line\">redis&gt; SET msg &#34;hello world&#34;</span><br/><span class=\"line\">OK</span><br/><span class=\"line\">redis&gt; EVAL &#34;return &#39;The message is: &#39; .. redis.call(&#39;GET&#39;, KEYS[1]) &#39;&#34; 1 msg</span><br/><span class=\"line\">&#34;The message is: hello world&#34;</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<h2 id=\"redis-call-和-redis-pcall-的区别\"><a href=\"#redis-call-和-redis-pcall-的区别\" class=\"headerlink\" title=\"redis.call() 和 redis.pcall() 的区别\"></a>redis.call() 和 redis.pcall() 的区别</h2><p>redis.call() 和 redis.pcall() 都可以用来执行 Redis 命令,它们的不同之处在于，当被执行的脚本出错时：</p>\n<ul>\n<li>redis.call() 会返回出错脚本的名字以及 EVAL 命令的错误信息</li>\n<li>redis.pcall() 只返回 EVAL 命令的错误信息。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; EVAL &#34;return redis.call(&#39;NotExistsCommand&#39;)&#34; 0</span><br/><span class=\"line\">(error) ERR Error running script (call to f_ddabd662fa0a8e105765181ee7606562c1e6f1ce):</span><br/><span class=\"line\">@user_script:1: @user_script: 1: Unknown Redis command called from Lua script</span><br/><span class=\"line\"></span><br/><span class=\"line\">redis&gt; EVAL &#34;return redis.pcall(&#39;NotExistsCommand&#39;)&#34; 0</span><br/><span class=\"line\">(error) @user_script: 1: Unknown Redis command called from Lua script</span><br/></pre></td></tr></tbody></table></figure>\n<p>换句话来说,在被执行的脚本出错时, redis.call() 可以提供更详细的错误信息,方便进行查错。</p>\n<h2 id=\"使用-EVALSHA-来减少网络资源损耗\"><a href=\"#使用-EVALSHA-来减少网络资源损耗\" class=\"headerlink\" title=\"使用 EVALSHA 来减少网络资源损耗\"></a>使用 EVALSHA 来减少网络资源损耗</h2><p>任何 Lua 脚本,只要被 EVAL 命令执行过一次,就会被 储存到服务器的脚本缓存里面,用户只要通过 EVALSHA 命令,指定被 缓存脚本的 SHA1 值,就可以在不 发送脚本的情况下,再次 执行脚本:<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">EVALSHA sha1 numkeys key [key ...] arg [arg ...]</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>通过 SHA1 值来重用返回 ‘hello world’ 信息的脚本:<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; EVAL &#34;return &#39;hello world&#39;&#34; 0</span><br/><span class=\"line\">&#34;hello world&#34;</span><br/><span class=\"line\">redis&gt; EVALSHA 5332031c6b470dc5a0dd9b4bf2030dea6d65de91 0</span><br/><span class=\"line\">&#34;hello world&#34;</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>通过 SHA1 值来重用之前实现的 ZDECRBY 命令,这样就不用每次都 发送整个脚本了:<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; EVALSHA 918130cae39ff0759b8256948742f77300a91cb2 1 salary 500 peter</span><br/><span class=\"line\">(integer) 0</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<h2 id=\"脚本管理命令\"><a href=\"#脚本管理命令\" class=\"headerlink\" title=\"脚本管理命令\"></a>脚本管理命令</h2><p>检查 sha1 值所代表的脚本是否已经被加入到脚本缓存里面,是的话返回 1 ,不是的话返回 0 。<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">SCRIPT EXISTS sha1 [sha1 ...]</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>将脚本储存到脚本缓存里面,等待将来 EVALSHA 使用。<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">SCRIPT LOAD script</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>清除脚本缓存储存的所有脚本。<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">SCRIPT FLUSH</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>杀死运行超时的脚本。如果脚本已经执行过写入操作,那么还需要使用 SHUTDOWN NOSAVE 命令来强制服务器不保存数据,以免错误的数据被保存到数据库里面。<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">SCRIPT KILL</span><br/></pre></td></tr></tbody></table></figure><p></p>","text":"Lua脚本 使用脚本可以直接在服 务器端执行 Redis 命令,一般的数据 处理操作可以直接使用 Lua 语言或者 Lua 解释器提供的函数 库来完成,不必再返回 给客户端进行处理。 所有脚本都是以事 务的形式来执行的,脚本在 执行过程中不会被其他工作打断,也不会引起任何 竞争条...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lua%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">Lua脚本</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C-Lua-%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">执行 Lua 脚本</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#redis-call-%E5%92%8C-redis-pcall-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">redis.call() 和 redis.pcall() 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-EVALSHA-%E6%9D%A5%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E6%8D%9F%E8%80%97\"><span class=\"toc-text\">使用 EVALSHA 来减少网络资源损耗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%84%9A%E6%9C%AC%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">脚本管理命令</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua标准库阅读总结（官方文档）","uid":"f898ebac0592fd186e2fa96c1cc03552","slug":"zl/2016-01-01-569_Lua标准库阅读总结（官方文档）","date":"2024-04-03T03:47:35.823Z","updated":"2024-04-03T03:47:35.824Z","comments":true,"path":"api/articles/zl/2016-01-01-569_Lua标准库阅读总结（官方文档）.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" Contents &lt;/div&gt; &lt;p&gt;Lua的标准库直接通过C语言的API进行实现的。有一些函数对于这个语言提供的功能是必不可少的（例如getmetatable和type又元表是lua的一个重要语言特性，还会总结哒）其他的提供了一些输出到外部的功能（例如...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua远程调用的实现方法","uid":"76e52e8255c32e959dab4087b6cfa1a6","slug":"zl/2016-01-01-564_Lua远程调用的实现方法","date":"2024-04-03T03:47:35.822Z","updated":"2024-04-03T03:47:35.822Z","comments":true,"path":"api/articles/zl/2016-01-01-564_Lua远程调用的实现方法.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"游戏开发中，客户端、服务端之间的交互是很频繁的，尤其是逻辑玩法的实现，需要大量的交互。 如果所有的交互都按功能构建出不同的协议，这样即繁琐又不方便修改。 通过Lua，使用远程调用可以极大的方便客户端、服务器的通信。 在Lua中，通过C++告诉对方，我要调用哪个函数、传递哪些参数，...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}