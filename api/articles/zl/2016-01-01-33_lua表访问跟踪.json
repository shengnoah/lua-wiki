{"title":"lua表访问跟踪","uid":"e030a4ac09fbb79af10ae1308131b316","slug":"zl/2016-01-01-33_lua表访问跟踪","date":"2024-04-03T03:47:35.616Z","updated":"2024-04-03T03:47:35.616Z","comments":true,"path":"api/articles/zl/2016-01-01-33_lua表访问跟踪.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>当访问一个 table 或者更新 table 中的某个元素时，lua 首先会在 table 查找是否存在该元素，如果没有，就会查找 table 是否存在 <strong>index(访问) 或者 </strong>newindex(更新) 原方法。以访问为例，首先在 table 中查找某个字段，如果不存在，解释器会去查找 <strong>index 这个原方法，如果仍然没有，返回 nil。所以说，</strong>index 和 __newindex 是在 table 中没有所需访问的 index 时才发挥作用的。    </p>\n<p>根据上面这种思路，如果我们想跟踪一个 table 的操作行为，那么<strong>需要一个空表</strong>，每次对这个空表操作的时候，就会使用 <strong>index 或者 </strong>newindex 这些元方法，在元方法中对原始 table 进行访问和操作，并打印跟踪信息。而之前创建的那个空表，就是代理。</p>\n<pre><code>---------------------------------------------\nprint &#34;跟踪单个表&#34;\n<p>local _t = &#123;&#125;</p>\n<p>local mt = &#123;<br />\n__newindex = function(t, name, value)<br />\nprint(&quot;__newindex&quot;, name, value)<br />\n–rawset(_t, name, value) --原始访问 不访问原表<br />\n_t[name] = value<br />\nend,</p>\n<pre><code>__index = function(t, name)\n    print(&amp;#34;__index&amp;#34;, name, value)\n    --return rawget(_t, name) --原始访问 不访问原表\n    return _t[name]\nend\n</code></pre>\n<p>}</p>\n<p>–a.__index = a<br />\nlocal a = {}<br />\nsetmetatable(a, mt)</p>\n<p>a.x = 1<br />\nprint(a.x)</p>\n<hr />\n<p>print &quot;跟踪多个表&quot;</p>\n<p>local index = {}    –  创建私有索引，即原表在代理表中特殊字段</p>\n<p>local mt = {<br />\n__index = function (t, k)<br />\nprint(&quot;__index &quot; … tostring(k))<br />\nreturn t[index][k]<br />\nend,<br />\n__newindex = function (t, k, v)<br />\nprint(&quot;__newindex &quot; … tostring(k) … &quot; to &quot; … tostring(v))<br />\nt[index][k] = v<br />\nend<br />\n}</p>\n<p>function track (t)<br />\nlocal proxy = {}<br />\nproxy[index] = t<br />\nsetmetatable(proxy, mt)<br />\nreturn proxy<br />\nend</p>\n<p>local ori_table = {} --在其他地方创建的原表，对他进行跟踪<br />\nlocal _o = track(ori_table)</p>\n<p>_o[2] = &quot;lua&quot;<br />\nprint(_o[2])<br />\n</code></pre></p>\n","text":"当访问一个 table 或者更新 table 中的某个元素时，lua 首先会在 table 查找是否存在该元素，如果没有，就会查找 table 是否存在 index(访问) 或者 newindex(更新) 原方法。以访问为例，首先在 table 中查找某个字段，如果不存在，解释器...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Nginx+lua组建基础waf防火墙","uid":"ddb5e4c9c3c745d9ecc07c0486b685e8","slug":"zl/2016-01-01-341_Nginx+lua组建基础waf防火墙","date":"2024-04-03T03:47:35.617Z","updated":"2024-04-03T03:47:35.621Z","comments":true,"path":"api/articles/zl/2016-01-01-341_Nginx+lua组建基础waf防火墙.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"一、nginx+Lua环境部署1、系统基础信息123456192.168.83.129# cat /etc/redhat-releaseCentOS release 6.5 (Final)# uname -r2.6.32-431.el6.x86_64 2、安装基础库12yum -...","link":"","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua 中的随机数","uid":"73feeba3e1d1ac59d590841c2286442d","slug":"zl/2016-01-01-340_Lua 中的随机数 ","date":"2024-04-03T03:47:35.616Z","updated":"2024-04-03T03:47:35.617Z","comments":true,"path":"api/articles/zl/2016-01-01-340_Lua 中的随机数 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua 随机数算法用的是 libc 中的 rand, 也就是 LCG。然而这个算法的随机性一般。尤其是在一些平台上，当随机种子变化非常小的时候，产生的随机数变化也非常小。这样再经过 Lua 的精度取舍之后，产生的随机序列仍然很相似（伪随机的结果变成可预知性）。 lua-l 上也讨...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}