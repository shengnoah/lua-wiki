{"title":"Lua源码分析 Gc篇（二）数据结构   副本","uid":"3d666de728e3aa931e9232cbab18385f","slug":"zl/2016-01-01-38_Lua源码分析 Gc篇（二）数据结构   副本","date":"2024-04-03T03:47:35.678Z","updated":"2024-04-03T03:47:35.678Z","comments":true,"path":"api/articles/zl/2016-01-01-38_Lua源码分析 Gc篇（二）数据结构   副本.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>[TOC]</p>\n<p>这是这个gc系列的第二篇，这一篇主要讲GC用到的数据结构，有助于理解gc的，所以放在前面</p>\n<p>栈就是我们平时写代码接触最多的lua_State。在实现上是用一个数组实现的。每个成员类型是TValue，看下文详细介绍。这里不打算详细介绍栈的结构和内容，只会介绍和gc相关的一些内容，主要是帮助我们更好的理解lua的gc。</p>\n<h2 id=\"定义\">定义</h2>\n<p>下面是lua_State的定义，会看到栈的身影，top和base指针。</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>struct lua_State &#123;\n  CommonHeader;\n  lu_byte status;\n  StkId top;  /* first free slot in the stack */\n  StkId base;  /* base of current function */\n  global_State *l_G;\n  CallInfo *ci;  /* call info for current function */\n  const Instruction *savedpc;  /* `savedpc&#39; of current function */\n  StkId stack_last;  /* last free slot in the stack */\n  StkId stack;  /* stack base */\n  CallInfo *end_ci;  /* points after end of ci array*/\n  CallInfo *base_ci;  /* array of CallInfo&#39;s */\n  int stacksize;\n  int size_ci;  /* size of array `base_ci&#39; */\n  unsigned short nCcalls;  /* number of nested C calls */\n  lu_byte hookmask;\n  lu_byte allowhook;\n  int basehookcount;\n  int hookcount;\n  lua_Hook hook;\n  TValue l_gt;  /* table of globals */\n  TValue env;  /* temporary place for environments */\n  GCObject *openupval;  /* list of open upvalues in this stack */\n  GCObject *gclist;\n  struct lua_longjmp *errorJmp;  /* current error recover point */\n  ptrdiff_t errfunc;  /* current error handling function (stack index) */\n&#125;;\n</code></pre></div></div>\n<h2 id=\"简单的图\">简单的图</h2>\n<p></p>\n<p>至于base/top和stack/stack_last、以及base_ci/end_ci之间的关系和区别就不打算详细介绍了。主要是lua的指令操作的实现，以及函数调用的时候也要用到栈，只是他们在这个数组的不同区间。</p>\n<h1 id=\"2栈元素tvalue\">2.栈元素TValue</h1>\n<p>这个类型是给栈用的，前面说过栈其实是一个TValue的数组。</p>\n<h2 id=\"定义-1\">定义</h2>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>typedef union &#123;\n  GCObject *gc;\n  void *p;\n  lua_Number n;\n  int b;\n&#125; Value;\n<p>#define TValuefields    Value value; int tt<br />\ntypedef struct lua_TValue &#123;<br />\nTValuefields;<br />\n&#125; TValue;<br />\n</code></pre></div></div></p>\n<h2 id=\"说明\">说明</h2>\n<ul>\n  <li>TValue，是Value加了一个类型</li>\n</ul>\n<p>类型定义：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/*\n** basic types\n*/\n#define LUA_TNONE        (-1)\n#define LUA_TNIL        0\n#define LUA_TBOOLEAN        1\n#define LUA_TLIGHTUSERDATA    2\n#define LUA_TNUMBER        3\n#define LUA_TSTRING        4\n#define LUA_TTABLE        5\n#define LUA_TFUNCTION        6\n#define LUA_TUSERDATA        7\n#define LUA_TTHREAD        8\n</code></pre></div></div>\n<ul>\n  <li>可以看到存放真正值的是这是一个union结构</li>\n  <li>用过lua的都知道，lua是一种动态类型语言，所有值都是first-class的。所以代码层就是这个Value</li>\n  <li>简单介绍一下union中成员的含义</li>\n</ul>\n<table>\n  <thead>\n    <tr>\n      <th>成员</th>\n      <th>含义</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>GCObject *gc</td>\n      <td>所有的需要gc的对象都是用的这个成员，所以本系列文章只关注这个成员就好了</td>\n    </tr>\n    <tr>\n      <td>void *p</td>\n      <td>存放lightuserdata</td>\n    </tr>\n    <tr>\n      <td>lua_Number n</td>\n      <td>数值类型，这里也可以看出来lua里面用到的整形浮点型都是用这个存储的，就是double类型</td>\n    </tr>\n    <tr>\n      <td>int b</td>\n      <td>bool类型</td>\n    </tr>\n  </tbody>\n</table>\n<p>看代码：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// bool类型的宏\n#define setbvalue(obj,x) \n  &#123; TValue *i_o=(obj); i_o-&gt;value.b=(x); i_o-&gt;tt=LUA_TBOOLEAN; &#125;\n// table类型的宏\n#define sethvalue(L,obj,x) \n  &#123; TValue *i_o=(obj); \n    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TTABLE; \n    checkliveness(G(L),i_o); &#125;\n</code></pre></div></div>\n<h1 id=\"3gc对象\">3.GC对象</h1>\n<p>gc对象就是指lua里面需要被回收的对象，类型是在LUA_TSTRING（4）到LUA_TTHREAD（8）之间（准确来说还有扩展的类型）。开始看的时候，难免会有疑问，lua里面的所有对象不都是放在栈里面的吗？这个gc对象是个什么的存在？</p>\n<h2 id=\"定义-2\">定义</h2>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>union GCObject &#123;\n  GCheader gch;\n  union TString ts;\n  union Udata u;\n  union Closure cl;\n  struct Table h;\n  struct Proto p;\n  struct UpVal uv;\n  struct lua_State th;  /* thread */\n&#125;;\n<p>// head<br />\n#define CommonHeader    GCObject *next; lu_byte tt; lu_byte marked<br />\n</code></pre></div></div></p>\n<h2 id=\"说明-1\">说明</h2>\n<ul>\n  <li>这是一个union结构体</li>\n  <li><strong>这里必须提醒注意下这个GCheader</strong>，可以看到前面一个GCheader gch的定义，是跟类型无关的。后面在解答上面疑问的时候，一并说明一下。这个CommonHeader实现了一个链表结构(next)，也指明了这个对象的类型(tt)，以及颜色(marked)。</li>\n  <li>会看到除了前面的基本类型之外，多了几个可以回收的类型</li>\n</ul>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/*\n** Extra tags for non-values\n*/\n#define LUA_TPROTO    (LAST_TAG+1)\n#define LUA_TUPVAL    (LAST_TAG+2)\n#define LUA_TDEADKEY    (LAST_TAG+3)\n</code></pre></div></div>\n<h1 id=\"4gc链表\">4.gc链表</h1>\n<p>这个链表是记录了lua里面所有的可回收对象，另外注意这是一个单向链表。正因为是单向链表，为了效率，才不会去整个遍历一遍，才会再增加扫描的链表等，这些后面篇章详细介绍。</p>\n<h2 id=\"定义-3\">定义</h2>\n<p>这个链表的指针是放在global_State中<em>rootgc</em>中的。</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/*\n** `global state&#39;, shared by all threads of this state\n*/\ntypedef struct global_State &#123;\n  stringtable strt;  /* hash table for strings */\n  lua_Alloc frealloc;  /* function to reallocate memory */\n  void *ud;         /* auxiliary data to `frealloc&#39; */\n  lu_byte currentwhite;\n  lu_byte gcstate;  /* state of garbage collector */\n  int sweepstrgc;  /* position of sweep in `strt&#39; */\n  GCObject *rootgc;  /* list of all collectable objects */\n  GCObject **sweepgc;  /* position of sweep in `rootgc&#39; */\n  GCObject *gray;  /* list of gray objects */\n  GCObject *grayagain;  /* list of objects to be traversed atomically */\n  GCObject *weak;  /* list of weak tables (to be cleared) */\n  GCObject *tmudata;  /* last element of list of userdata to be GC */\n  Mbuffer buff;  /* temporary buffer for string concatentation */\n  lu_mem GCthreshold;\n  lu_mem totalbytes;  /* number of bytes currently allocated */\n  lu_mem estimate;  /* an estimate of number of bytes actually in use */\n  lu_mem gcdept;  /* how much GC is `behind schedule&#39; */\n  int gcpause;  /* size of pause between successive GCs */\n  int gcstepmul;  /* GC `granularity&#39; */\n  lua_CFunction panic;  /* to be called in unprotected errors */\n  TValue l_registry;\n  struct lua_State *mainthread;\n  UpVal uvhead;  /* head of double-linked list of all open upvalues */\n  struct Table *mt[NUM_TAGS];  /* metatables for basic types */\n  TString *tmname[TM_N];  /* array with tag-method names */\n&#125; global_State;\n</code></pre></div></div>\n<p>这个结构放了所有关于gc的内容(对着后面的注释看一下)：</p>\n<ul>\n  <li>currentwhite：这个就是<a href=\"\">第一篇</a>中提到的gc流程中的当前白色，如果清理阶段某个对象是otherwhite，那么他就会被清理掉</li>\n  <li>gcstate：控制gc流程的，后面流程中说的状态就是记录在这里</li>\n  <li>rootgc：前面刚提到过，所有可回收的gc对象单向链表</li>\n  <li>gray：为了gc的效率增加的一个gc链表</li>\n  <li>grayagain：为了实现增量式gc，过程中处理中断问题的一个链表</li>\n  <li>GCthreshold，totalbytes，estimate，gcdept，gcpause：这几个单次gc相关的控制或者状态量，直接关系到lua提供的接口<em>collectgarbage</em></li>\n  <li>另外一些是全局的一些变量的定义，metatable等。这些跟gc扫描不会遍历整个gc链表有关系。</li>\n</ul>\n<h1 id=\"5栈和gc链表的关系\">5.栈和gc链表的关系</h1>\n<p>栈没有细说，但是他和gc链表的关系必须详细说明一下。如下图所示</p>\n<p></p>\n<h2 id=\"答疑解惑\">答疑解惑</h2>\n<p>就着问题，说一下栈和gc链表之间的关系。</p>\n<ul>\n  <li>1.GCObject的存在</li>\n</ul>\n<p>这里就需要了解gc链表和栈中元素的关系。lua的栈是一个数组，里面真正存放了lua里面的所有对象。gc链表存放了lua所有的可回收对象，而事实上gc链表存放的只是所有可回收对象的指针，真正的对象还是以TValue（GCObject* gc成员）的形式放在lua栈中的。当然，对象真正的内容是在堆上（需要自己回收）。而栈和gc链表中存在的只是真实对象的指针，不同类型的结构不一样，所以以这种方式才能存在一起管理</p>\n<ul>\n  <li>2.怎么做到的？</li>\n</ul>\n<p>前面提到了CommonHead，它在栈和gc链表关系中起了关键的作用。有相同的头部，所以可以通过强制转换在TValue和GCObject直接为了当时需要进行切换.看源码更清晰了，能够转换为GCObject的结构体都是必须包含这个头部的，需要GC的结构都要添加这个头部，如下所所示：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>//\nstruct lua_State &#123;\n  CommonHeader;\n<p>//<br />\ntypedef struct Table &#123;<br />\nCommonHeader;</p>\n<p>//<br />\ntypedef struct UpVal &#123;<br />\nCommonHeader;</p>\n<p>//<br />\ntypedef struct Proto &#123;<br />\nCommonHeader;</p>\n<p>//<br />\ntypedef union Udata &#123;<br />\nL_Umaxalign dummy;  /* ensures maximum alignment for `local' udata */<br />\nstruct &#123;<br />\nCommonHeader;</p>\n<p>typedef union TString &#123;<br />\nL_Umaxalign dummy;  /* ensures maximum alignment for strings */<br />\nstruct &#123;<br />\nCommonHeader;<br />\n</code></pre></div></div></p>\n<h1 id=\"总结\">总结</h1>\n<ul>\n  <li>这里并没有把所有的结构体都解释一遍，userdata，upvalue相关的都是比较细节的东西，可以单独看相关的内容，在全局理解的情况下根据自身特性去看也会很容易明白</li>\n</ul>","text":"[TOC] 这是这个gc系列的第二篇，这一篇主要讲GC用到的数据结构，有助于理解gc的，所以放在前面 栈就是我们平时写代码接触最多的lua_State。在实现上是用一个数组实现的。每个成员类型是TValue，看下文详细介绍。这里不打算详细介绍栈的结构和内容，只会介绍和gc相关的一...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE\"><span class=\"toc-text\">简单的图</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E6%A0%88%E5%85%83%E7%B4%A0tvalue\"><span class=\"toc-text\">2.栈元素TValue</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89-1\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">说明</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3gc%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">3.GC对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89-2\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E-1\"><span class=\"toc-text\">说明</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4gc%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">4.gc链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89-3\"><span class=\"toc-text\">定义</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E6%A0%88%E5%92%8Cgc%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">5.栈和gc链表的关系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AD%94%E7%96%91%E8%A7%A3%E6%83%91\"><span class=\"toc-text\">答疑解惑</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"PIL.9Lua中的闭包","uid":"66065dc59985b4408d9fe81f872d389b","slug":"zl/2016-01-01-390_PIL.9Lua中的闭包","date":"2024-04-03T03:47:35.678Z","updated":"2024-04-03T03:47:35.683Z","comments":true,"path":"api/articles/zl/2016-01-01-390_PIL.9Lua中的闭包.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua中的函数是 第一类的值加上合适的词法域。那么，函数是第一类值意味着什么呢？这是说，在Lua中，一个函数，就是一个和 数字或字符串一样具有某些权限的值。一个程序可以把函数存储在变量中（全局或者局部都可以）和表中，把函数作为参数传递给其他函数，或者以函数作为值返回。 函数具有词...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua学习笔记一","uid":"4ff1e2a53b46dffd40e47f7016f14195","slug":"zl/2016-01-01-388_Lua学习笔记一","date":"2024-04-03T03:47:35.676Z","updated":"2024-04-03T03:47:35.676Z","comments":true,"path":"api/articles/zl/2016-01-01-388_Lua学习笔记一.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"PS:由于公司项目中用到Lua,所以准备学习一下，这里做下学习笔记。 Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。 基本语法交互式编程lua -i 进入交互式编程 脚本式编程新建一...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}