{"title":"nginx + lua 开发中过程中 post body 过大返回 4xx (续)","uid":"e84c7365bb95758060da0a0503a1f038","slug":"zl/2016-01-01-51_nginx + lua 开发中过程中 post body 过大返回 4xx (续)","date":"2024-04-03T03:47:35.795Z","updated":"2024-04-03T03:47:35.795Z","comments":true,"path":"api/articles/zl/2016-01-01-51_nginx + lua 开发中过程中 post body 过大返回 4xx (续).json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>随着业务发展会出现较大的 post body 数据，按照<a href=\"/2019/05/28/nginx-lua-开发中过程中-post-body-过大返回-4xx/\" title=\"nginx + lua 开发中过程中 post body 过大返回 4xx\">nginx + lua 开发中过程中 post body 过大返回 4xx</a>提到的方式修改后，大部分情况下 post body 正常接收并处理落日志。但会偶现空日志的情况。</p>\n<h2 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2><p>经过多轮本地和沙盒压测，复现了问题。由于在出现空日志情况是 error 日志并没留下相关信息，随后做了如下处理：</p>\n<ol>\n<li>把 error 日志级别调到 debug，当问题复现时，error.log 中会有客户端过早断开连接类似的日子打出。</li>\n<li>在 access 日志中添加 request_time, status,等信息，发现出现空日志时，status=408，request_time 都比较长。</li>\n</ol>\n<p>因此，可以明确出现该问题是客户端链接超时造成的。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>为解决该问题，做如下优化：</p>\n<h3 id=\"调整超时时间，和-buffer\"><a href=\"#调整超时时间，和-buffer\" class=\"headerlink\" title=\"调整超时时间，和 buffer\"></a>调整超时时间，和 buffer</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">client_body_timeout 10s;</span><br/><span class=\"line\">client_header_timeout 10s;</span><br/><span class=\"line\">client_body_in_single_buffer on; #这个 directive 让 Nginx 将所有的 request body 存储在一个缓冲当中，它的默认值是 off。启用它可以优化读取 $request_body 变量时的 I/O 性能</span><br/></pre></td></tr></tbody></table></figure>\n<h3 id=\"开启-access-buffer-和-if\"><a href=\"#开启-access-buffer-和-if\" class=\"headerlink\" title=\"开启 access buffer 和 if\"></a>开启 access buffer 和 if</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">log_format  main escape=json &#39;[$log_time] [$logid] [INFO] $click_info&#39;;</span><br/><span class=\"line\">设置变量loggable，默认$loggable=0;当$status==200时，$loggable=1</span><br/><span class=\"line\">map $status $loggable {</span><br/><span class=\"line\">\t200  1;</span><br/><span class=\"line\">    default 0;</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure>\n<p>只有真确处理了请求才会写日志。客户端在收到 408 时，会将 body 拆分重传。</p>","text":"背景随着业务发展会出现较大的 post body 数据，按照nginx + lua 开发中过程中 post body 过大返回 4xx提到的方式修改后，大部分情况下 post body 正常接收并处理落日志。但会偶现空日志的情况。 问题分析经过多轮本地和沙盒压测，复现了问题。由于...","link":"","photos":[],"count_time":{"symbolsCount":805,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90\"><span class=\"toc-text\">问题分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">解决方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E6%95%B4%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%EF%BC%8C%E5%92%8C-buffer\"><span class=\"toc-text\">调整超时时间，和 buffer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%80%E5%90%AF-access-buffer-%E5%92%8C-if\"><span class=\"toc-text\">开启 access buffer 和 if</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua中的封装","uid":"a16ffa25bc913f5c0040828aa3005f3e","slug":"zl/2016-01-01-519_Lua中的封装","date":"2024-04-03T03:47:35.795Z","updated":"2024-04-03T03:47:35.795Z","comments":true,"path":"api/articles/zl/2016-01-01-519_Lua中的封装.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua中没有private，table中的key/value可以随意访问，利用metatable虽然可以施加一些限制，但是实际上有各种方法可以绕过这些限制。 下面介绍一种方法，实现真正的封装。 local LuaClass = require &#34;LuaClass&#34;...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua学习笔记二","uid":"050df29370421b502767448007b1cff3","slug":"zl/2016-01-01-515_Lua学习笔记二","date":"2024-04-03T03:47:35.790Z","updated":"2024-04-03T03:47:35.790Z","comments":true,"path":"api/articles/zl/2016-01-01-515_Lua学习笔记二.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"while1234while(条件)do 循环体end 代码示例及结果： 123456a = 0while(a &lt; 10)do print(a) a = a + 1end 123456789100123456789 for123for var=值1,值2,值2 do 循环体...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}