{"title":"Lua中的表操作","uid":"cc682423b40ae962d737009e42144d09","slug":"zl/2016-01-01-881_Lua中的表操作","date":"2024-04-03T03:47:36.154Z","updated":"2024-04-03T03:47:36.155Z","comments":true,"path":"api/articles/zl/2016-01-01-881_Lua中的表操作.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>「�TODO�」: 表的查找和新增元素</p>\n<h2 id=\"取长度操作\"><a href=\"#取长度操作\" class=\"headerlink\" title=\"取长度操作\"></a>取长度操作</h2><p>Lua中可以用 <code>#</code> 符号对表进行取长度操作. 对Lua中的表进行取长度操作时, 如果没有该表的元方法 <code>__len</code>, 则该取长度操作只对表的数组部分进行. </p>\n<p>取长度的入口函数为 <code>luaH_getn</code>, 该函数的目的是找到表 <code>t</code> 的一个边界值<code>i</code>, 并且<code>t[i]</code>不为<code>nil</code>, <code>t[i+1]</code>为<code>nil</code> (如果<code>t[1]</code>为<code>nil</code>, 则<code>i</code>为<code>0</code>) 它的伪代码如下:</p>\n<pre><code>如果表存在数组部分:\n    在数组部分二分查找返回位置i,其中i足满足条件 t[i] != nil 且 t[i+1] == nil 的最大数据\n否则前面的数组部分查不到满足条件的数据, 进入散列部分查找:\n    在散列桶部分二分查找返回位置i. 其中i是满足条件 t[i] != nil 且 t[i+1] == nil 的最大数据\n</code></pre><h2 id=\"使用表时需要注意的事项\"><a href=\"#使用表时需要注意的事项\" class=\"headerlink\" title=\"使用表时需要注意的事项\"></a>使用表时需要注意的事项</h2><ul>\n<li>尽量不要将一个表混用数组和散列桶部分, 即一个表最好只存放一类数据. Lua 的实现上确实提供了两者统一表示的遍历, 但是这不意味着使用者就应该混用这两种方式. </li>\n<li>尽量避免进行重新散列操作, 因为重新散列操作的代价极大.  通过预分配, 只使用数组部分等策略规避这个Lua解释器背后的动作, 能提升不少效率. </li>\n</ul>\n<h2 id=\"Lua53相关源码\"><a href=\"#Lua53相关源码\" class=\"headerlink\" title=\"Lua53相关源码\"></a>Lua53相关源码</h2><h3 id=\"luaH-getn\"><a href=\"#luaH-getn\" class=\"headerlink\" title=\"luaH_getn\"></a>luaH_getn</h3><pre><code class=\"c\">//ltable.c\n/*\n** Try to find a boundary in table &#39;t&#39;. A &#39;boundary&#39; is an integer index\n** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).\n*/\nlua_Unsigned luaH_getn (Table *t) &#123;\n  unsigned int j = t-&gt;sizearray;\n  if (j &gt; 0 &amp;&amp; ttisnil(&amp;t-&gt;array[j - 1])) &#123;\n    /* there is a boundary in the array part: (binary) search for it */\n    unsigned int i = 0;\n    while (j - i &gt; 1) &#123;\n      unsigned int m = (i+j)/2;\n      if (ttisnil(&amp;t-&gt;array[m - 1])) j = m;\n      else i = m;\n    &#125;\n    return i;\n  &#125;\n  /* else must find a boundary in hash part */\n  else if (isdummy(t))  /* hash part is empty? */\n    return j;  /* that is easy... */\n  else return unbound_search(t, j);\n&#125;\n</code></pre>\n<h3 id=\"unbound-search\"><a href=\"#unbound-search\" class=\"headerlink\" title=\"unbound_search\"></a>unbound_search</h3><pre><code class=\"c\">//ltable.c\nstatic lua_Unsigned unbound_search (Table *t, lua_Unsigned j) &#123;\n  lua_Unsigned i = j;  /* i is zero or a present index */\n  j++;\n  /* find &#39;i&#39; and &#39;j&#39; such that i is present and j is not */\n  while (!ttisnil(luaH_getint(t, j))) &#123;\n    i = j;\n    if (j &gt; l_castS2U(LUA_MAXINTEGER) / 2) &#123;  /* overflow? */\n      /* table was built with bad purposes: resort to linear search */\n      i = 1;\n      while (!ttisnil(luaH_getint(t, i))) i++;\n      return i - 1;\n    &#125;\n    j *= 2;\n  &#125;\n  /* now do a binary search between them */\n  while (j - i &gt; 1) &#123;\n    lua_Unsigned m = (i+j)/2;\n    if (ttisnil(luaH_getint(t, m))) j = m;\n    else i = m;\n  &#125;\n  return i;\n&#125;\n</code></pre>","text":"「�TODO�」: 表的查找和新增元素 取长度操作Lua中可以用 # 符号对表进行取长度操作. 对Lua中的表进行取长度操作时, 如果没有该表的元方法 __len, 则该取长度操作只对表的数组部分进行. 取长度的入口函数为 luaH_getn, 该函数的目的是找到表 t 的一个边...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%96%E9%95%BF%E5%BA%A6%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">取长度操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E8%A1%A8%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">使用表时需要注意的事项</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lua53%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">Lua53相关源码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#luaH-getn\"><span class=\"toc-text\">luaH_getn</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#unbound-search\"><span class=\"toc-text\">unbound_search</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"快速排序算法的lua实现","uid":"137fe148dad69f7b2b98215db0dc44eb","slug":"zl/2016-01-01-883_快速排序算法的lua实现","date":"2024-04-03T03:47:36.155Z","updated":"2024-04-03T03:47:36.156Z","comments":true,"path":"api/articles/zl/2016-01-01-883_快速排序算法的lua实现.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556-- 快速排序算法的实现--[[ 设要排序的数组是A[0]……A[N-1]...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua 数据类型","uid":"6c463eadf15d1d28f8d8924fee10fda2","slug":"zl/2016-01-01-87_Lua 数据类型","date":"2024-04-03T03:47:36.151Z","updated":"2024-04-03T03:47:36.151Z","comments":true,"path":"api/articles/zl/2016-01-01-87_Lua 数据类型.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 数据类型 描述 nil 这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。 boolean 包含两个值：false和true。 number 表示双精度类型的实浮点数 string 字符串由一对双引号或单引号来表示 function 由 C 或...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}