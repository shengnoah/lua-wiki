{"title":"Lua运行时更新代码","uid":"4f6e2483e44ae389e49ffa9a5cd91ffd","slug":"zl/2016-01-01-182_Lua运行时更新代码 ","date":"2024-04-03T03:47:33.069Z","updated":"2024-04-03T03:47:33.070Z","comments":true,"path":"api/articles/zl/2016-01-01-182_Lua运行时更新代码 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>\t\t\t&lt;p&gt;      最近沉迷lua脚本热更，想说这个可以提高多少菜鸡的调试效率，找了网上好多文章，但是都不行，尝试了很久，并且自己测试和学习，写了一遍，勉强能热更了（还是有个问题，要按2次才能输出正确热更的值，一直找不到，有人找到麻烦告诉我一下308164213）。下面记录一下找热更的过程。&lt;/p&gt;\n</code></pre>\n<p>一、用来卸载表格的加载\n–最简单粗暴的热更新就是将package.loaded[modelname]的值置为nil，强制重新加载：\nfunction reload_module_obsolete(module_name)\n    package.loaded[module_name] = nil\n    require(module_name)\nend\n–这样做虽然能完成热更，但问题是已经引用了该模块的地方不会得到更新， 因此我们需要将引用该模块的地方的值也做对应的更新。\nfunction ReloadUtil.Reload_Module(module_name)\n    local old_module = _G[module_name]</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>package.loaded[module_name] = nil\nrequire (module_name)\n<p>local new_module = _G[module_name]<br />\nfor k, v in pairs(new_module) do<br />\nold_module[k] = v<br />\nend</p>\n<p>package.loaded[module_name] = old_module end<br />\n</code></pre></div></div></p>\n<p>二、我认为逻辑最清晰的，但是可能是我不会用吧！\n源链接：https://github.com/tickbh/td_rlua/wiki/Lua-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%B0%8F%E7%BB%93</p>\n<p>–region 利用_ENV环境，在加载的时候把数据加载到_ENV下，然后再通过对比的方式修改_G底下的值，从而实现热更新，函数 – 失败</p>\n<p>function ReloadUtil.hotfix(chunk, check_name)\n    check_name = check_name or ‘hotfix’\n    local env = {}\n    setmetatable(env, { __index = _G })\n    local f, err = load(chunk, check_name,  ‘t’, env)\n    assert(f,err)\n    local ok, err = pcall(f)\n    assert(ok,err)</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local protection = &#123;\n    setmetatable = true,\n    pairs = true,\n    ipairs = true,\n    next = true,\n    require = true,\n    _ENV = true,\n&#125;\n--防止重复的table替换，造成死循环\nlocal visited_sig = &#123;&#125;\n<p>function ReloadUtil.update_table(newTable, oldTable, name, deep)<br />\n–对某些关键函数不进行比对<br />\nif protection[newTable] or protection[oldTable] then return end<br />\n–如果原值与当前值内存一致，值一样不进行对比<br />\nif newTable == oldTable then return end<br />\nlocal signature = tostring(oldTable)…tostring(newTable)<br />\nif visited_sig[signature] then return end<br />\nvisited_sig[signature] = true<br />\n–遍历对比值，如进行遍历env类似的步骤<br />\nfor name, newValue in pairs(newTable) do<br />\nlocal old_value = oldTable[name]<br />\nif type(newValue) == type(old_value) then<br />\nif type(newValue) == ‘function’ then<br />\nReloadUtil.update_func(newValue, old_value, name, deep…’  ‘…name…’  ‘)<br />\noldTable[name] = newValue<br />\nelseif type(newValue) == ‘table’ then<br />\nReloadUtil.update_table(newValue, old_value, name, deep…’  ‘…name…’  ‘)<br />\nend<br />\nelse<br />\noldTable[name] = newValue<br />\nend<br />\nend<br />\n–遍历table的元表，进行对比<br />\nlocal old_meta = debug.getmetatable(oldTable)<br />\nlocal new_meta = debug.getmetatable(newTable)<br />\nif type(old_meta) == ‘table’ and type(new_meta) == ‘table’ then<br />\nReloadUtil.update_table(new_meta, old_meta, name…‘s Meta’, deep…’  ‘…name…‘s Meta’…’  ’ )<br />\nend<br />\nend</p>\n<p>function ReloadUtil.update_func(newFunc, oldFunc, name, deep)<br />\n–取得原值所有的upvalue，保存起来<br />\nlocal old_upvalue_map = &#123;&#125;<br />\nfor i = 1, math.huge do<br />\nlocal name, value = debug.getupvalue(oldFunc, i)<br />\nif not name then break end<br />\nold_upvalue_map[name] = value<br />\nend<br />\n–遍历所有新的upvalue，根据名字和原值对比，如果原值不存在则进行跳过，如果为其它值则进行遍历env类似的步骤<br />\nfor i = 1, math.huge do<br />\nlocal name, value = debug.getupvalue(newFunc, i)<br />\nif not name then break end<br />\nlocal old_value = old_upvalue_map[name]<br />\nif old_value then<br />\nif type(old_value) ~= type(value) then<br />\ndebug.setupvalue(newFunc, i, old_value)<br />\nelseif type(old_value) == ‘function’ then<br />\nReloadUtil.update_func(value, old_value, name, deep…’  ‘…name…’  ‘)<br />\nelseif type(old_value) == ‘table’ then<br />\nReloadUtil.update_table(value, old_value, name, deep…’  ‘…name…’  ')<br />\ndebug.setupvalue(newFunc, i, old_value)<br />\nelse<br />\ndebug.setupvalue(newFunc, i, old_value)<br />\nend<br />\nend<br />\nend<br />\nend</p>\n<p>–原理<br />\n–利用_ENV环境，在加载的时候把数据加载到_ENV下，然后再通过对比的方式修改_G底下的值，从而实现热更新，函数<br />\nfor name,value in pairs(env) do<br />\nlocal g_value = _G[name]<br />\nif type(g_value) ~= type(value) then<br />\n_G[name] = value<br />\nelseif type(value) == ‘function’ then<br />\nReloadUtil.update_func(value, g_value, name, ‘G’…’  ‘)<br />\n_G[name] = value<br />\nelseif type(value) == ‘table’ then<br />\nReloadUtil.update_table(value, g_value, name, ‘G’…’  ')<br />\nend<br />\nend<br />\nreturn 0 end<br />\n</code></pre></div></div></p>\n<p>function ReloadUtil.hotfix_file(debugName)\n    local newCode\n    local fp = io.open(debugName)\n    if fp then\n        newCode = fp:read(‘*all’)\n        io.close(fp)\n    end\n    if not newCode then\n        return -1\n    end\n    return ReloadUtil.hotfix(newCode, debugName)\nend</p>\n<p>–endregion</p>\n<p>三、有点复杂，递归了debug.getregistry()，然后去替换旧的值\n源链接：http://asqbtcupid.github.io/luahotupdate1-require/</p>\n<p>有介绍原理，讲得还蛮细的，学习了蛮多，但是这个递归真的是复杂，我注释掉了一些递归，能满足基本的需求。</p>\n<p>local ReloadUtil = {}</p>\n<p>local tableInsert = table.insert\nlocal tableRemove = table.remove\nlocal tableConcat = table.concat\nlocal ioPopen = io.popen\nlocal ioInput = io.input\nlocal ioRead = io.read\nlocal stringMatch = string.match\nlocal stringFind = string.find\nlocal stringSub = string.sub\nlocal stringGsub = string.gsub\nlocal packageLoaded = package.loaded\nlocal type = type\nlocal getfenv = getfenv\nlocal setfenv = setfenv\nlocal loadstring = loadstring\nlocal mathHuge = math.huge\nlocal debugGetupvalue = debug.getupvalue\nlocal debugSetupvalue = debug.setupvalue\nlocal debugGetmetatable = debug.getmetatable\nlocal debugSetfenv = debug.setfenv</p>\n<p>function ReloadUtil.FailNotify(…)\n    printAError(…)\nend</p>\n<p>function ReloadUtil.DebugNofity(…)\n    print(…)\nend</p>\n<p>function ReloadUtil.ErrorHandle(e)\n    ReloadUtil.FailNotify(“HotUpdate Errorn”..tostring(e))\n    ReloadUtil.ErrorHappen = true\nend</p>\n<p>function ReloadUtil.InitProtection()\n    ReloadUtil.Protection = {}\n    local Protection = ReloadUtil.Protection\n    Protection[setmetatable] = true\n    Protection[pairs] = true\n    Protection[ipairs] = true\n    Protection[next] = true\n    Protection[require] = true\n    Protection[ReloadUtil] = true\n    Protection[ReloadUtil.Meta] = true\n    Protection[math] = true\n    Protection[string] = true\n    Protection[table] = true\nend</p>\n<p>local function Normalize(path)\n    path = path:gsub(“/”,””)</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local pathLen = #path\nif path:sub(pathLen, pathLen) == \"\\\" then\n    path = path:sub(1, pathLen - 1)\nend\n<p>local parts = &#123; &#125;<br />\nfor w in path:gmatch(“[^]+”) do<br />\nif     w == “…” and #parts ~=0 then tableRemove(parts)<br />\nelseif w ~= “.”  then tableInsert(parts, w)<br />\nend<br />\nend<br />\nreturn tableConcat(parts, &quot;&quot;) end<br />\n</code></pre></div></div></p>\n<p>– 根据给的路径，找到路径下所有文档，HU.FileMap[FileName] = {SysPath = line, LuaPath = luapath}\nfunction ReloadUtil.InitFileMap(RootPath)\n    local systemPathList = {}\n    local HotUpdateDic = ReloadUtil.HotUpdateDic\n    local OldCode = ReloadUtil.OldCode\n    RootPath = Normalize(RootPath)\n    –获取一个File对象其下的所有文档和目录的绝对路径: 的所有文档(/S/B)，不包括文档夹（/A:A），ioPopen返回文档句柄file handle\n    –todo 这里有的问题，多次启动后会报bad file decorator ，检查是否是打开文档没有关闭导致\n    local file = ioPopen(“dir /S/B /A:A \"”..RootPath..”\"”)</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for SysPath in ioInput(file):lines() do\n    local FileName = stringMatch(SysPath,\".*\\(.*)%.lua\")\n    --todo meta 优化一下regex\n    local metaFile = stringMatch(SysPath,\".*\\(.*)%.lua.meta\")\n    if FileName ~= nil and metaFile == nil then\n        --todo !!! luaPath在保存的时候是按文档夹路径保存的比如：game.modules.XXX.lua，所以可能要自己搞对这个路径\n<pre><code>    local startIndex = stringFind(SysPath,&quot;game&quot;)\n    local luaPath = stringSub(SysPath, startIndex, #SysPath -4)\n    luaPath = stringGsub(luaPath, &quot;\\&quot;, &quot;.&quot;)\n    HotUpdateDic[luaPath] = SysPath\n    tableInsert(systemPathList,SysPath)\n    -- 初始化旧代码\n    ioInput(SysPath)\n    OldCode[SysPath] = ioRead(&quot;*all&quot;)\n    ioInput():close()\nend\n</code></pre>\n<p>end</p>\n<p>file:close()</p>\n<p>return systemPathList end<br />\n</code></pre></div></div></p>\n<p>function ReloadUtil.InitFakeTable()\n    local meta = {}\n    ReloadUtil.Meta = meta\n    local function FakeT() return setmetatable({}, meta) end\n    local function EmptyFunc() end\n    local function pairs() return EmptyFunc end\n    local function setmetatable(t, metaT)\n        ReloadUtil.MetaMap[t] = metaT\n        return t\n    end\n    local function getmetatable(t, metaT)\n        return setmetatable({}, t)\n    end</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local function require(LuaPath)\n    if not ReloadUtil.RequireMap[LuaPath] then\n        local FakeTable = FakeT()\n        ReloadUtil.RequireMap[LuaPath] = FakeTable\n    end\n    return ReloadUtil.RequireMap[LuaPath]\nend\n<p>function meta.__index(table, key)<br />\nif key == “setmetatable” then<br />\nreturn setmetatable<br />\nelseif key == “pairs” or key == “ipairs” then<br />\nreturn pairs<br />\nelseif key == “next” then<br />\nreturn EmptyFunc<br />\nelseif key == “require” then<br />\nreturn require<br />\nelse<br />\nlocal FakeTable = FakeT()<br />\nrawset(table, key, FakeTable)<br />\nreturn FakeTable<br />\nend<br />\nend<br />\nfunction meta.__newindex(table, key, value) rawset(table, key, value) end<br />\nfunction meta.__call() return FakeT(), FakeT(), FakeT() end<br />\nfunction meta.__add() return meta.__call() end<br />\nfunction meta.__sub() return meta.__call() end<br />\nfunction meta.__mul() return meta.__call() end<br />\nfunction meta.__div() return meta.__call() end<br />\nfunction meta.__mod() return meta.__call() end<br />\nfunction meta.__pow() return meta.__call() end<br />\nfunction meta.__unm() return meta.__call() end<br />\nfunction meta.__concat() return meta.__call() end<br />\nfunction meta.__eq() return meta.__call() end<br />\nfunction meta.__lt() return meta.__call() end<br />\nfunction meta.__le() return meta.__call() end<br />\nfunction meta.__len() return meta.__call() end<br />\nreturn FakeT end<br />\n</code></pre></div></div></p>\n<p>function ReloadUtil.IsNewCode(SysPath)\n    ioInput(SysPath)\n    local newCode = ioRead(“*all”)</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local oldCode = ReloadUtil.OldCode[SysPath]\nif oldCode == newCode then\n    ioInput():close()\n    return false\nend\n<p>ReloadUtil.DebugNofity(SysPath)<br />\nreturn true, newCode end<br />\n</code></pre></div></div></p>\n<p>function ReloadUtil.GetNewObject(newCode, LuaPath, SysPath)\n    –loadstring 一段lua代码以后，会经过语法解析返回一个函数，执行返回的函数时，字符串中的代码就被执行了。\n    local NewFunction = loadstring(newCode)\n    if not NewFunction then\n        ReloadUtil.FailNotify(SysPath..” has syntax error.”)\n        collectgarbage(“collect”)\n    else\n        – 把加载的字符串放置在空环境了，防止报错\n        setfenv(NewFunction, ReloadUtil.FakeENV)\n        local NewObject\n        ReloadUtil.ErrorHappen = false\n        –类似其它语言里的 try-catch, xpcall 类似 pcall xpcall接受两个参数：调用函数、错误处理函数\n        – todo 父类没拿到\n        xpcall(function () NewObject = NewFunction() end, ReloadUtil.ErrorHandle)</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    if not ReloadUtil.ErrorHappen then\n        ReloadUtil.OldCode[SysPath] = newCode\n        return NewObject\n    else\n        collectgarbage(\"collect\")\n    end\nend end\n</code></pre></div></div>\n<p>function ReloadUtil.ResetENV(object, name, From, Deepth)\n    local visited = {}\n    local function f(object, name)\n        if not object or visited[object] then return end\n        visited[object] = true\n        if type(object) == “function” then\n            ReloadUtil.DebugNofity(Deepth..”HU.ResetENV”, name, “  from:”..From)\n            xpcall(function () setfenv(object, ReloadUtil.ENV) end, ReloadUtil.FailNotify)\n        elseif type(object) == “table” then\n            ReloadUtil.DebugNofity(Deepth..”HU.ResetENV”, name, “  from:”..From)\n            for k, v in pairs(object) do\n                f(k, tostring(k)..”__key”, “ HU.ResetENV “, Deepth..”    “ )\n                f(v, tostring(k), “ HU.ResetENV “, Deepth..”    “)\n            end\n        end\n    end\n    f(object, name)\nend</p>\n<p>– 遍历_G这张全局表，替换HU.ChangedFuncList 有改动列表 的函数\nfunction ReloadUtil.Travel_G()\n    local visited = {}\n    local ChangedFuncList = ReloadUtil.ChangedFuncList\n    visited[ReloadUtil] = true</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local function f(table)\n    if (type(table) ~= \"function\" and type(table) ~= \"table\") or visited[table] or ReloadUtil.Protection[table] then return end\n<pre><code>visited[table] = true\n\nif type(table) == &quot;function&quot; then\n    for i = 1, mathHuge do\n        local name, value = debugGetupvalue(table, i)\n        if not name then break end\n\n        if type(value) == &quot;function&quot; then\n            for _, funcs in ipairs(ChangedFuncList) do\n                if value == funcs.OldObject then\n                    debugSetupvalue(table, i, funcs.NewObject)\n                end\n            end\n        end\n        -- todo\n        --f(value)\n    end\nelseif type(table) == &quot;table&quot; then\n    -- 不要漏掉元表和upvalue的表，元表的获参考debug.getmetatable，\n    -- todo 这样对于有metatable这个key的元表，也能正确获取。\n    --f(debugGetmetatable(table))\n\n    local changeIndexList = &#123;&#125;\n    for key, value in pairs(table) do\n        -- todo 还有注意table的key也可以是函数。\n        --f(key)\n        f(value)\n\n        if type(value) == &quot;function&quot; then\n            for _, funcs in ipairs(ChangedFuncList) do\n                if value == funcs.OldObject then\n                    table[key] = funcs.NewObject\n                end\n            end\n        end\n\n        -- 找出改动的index\n        if type(key) == &quot;function&quot; then\n            for index, funcs in ipairs(ChangedFuncList) do\n                if key == funcs.OldObject then\n                    changeIndexList[#changeIndexList + 1] = index\n                end\n            end\n        end\n    end\n\n    -- 修改改动的值\n    for _, index in ipairs(changeIndexList) do\n        local funcs = ChangedFuncList[index]\n        table[funcs.NewObject] = table[funcs.OldObject]\n        table[funcs.OldObject] = nil\n    end\nend\n</code></pre>\n<p>end</p>\n<p>–遍历_G这张全局表，_G在registryTable里<br />\n–f(_G)<br />\n–如果有宿主语言，那么还要遍历一下注册表，用debug.getregistry()获得。<br />\nlocal registryTable = debug.getregistry()<br />\nf(registryTable) end<br />\n</code></pre></div></div></p>\n<p>function ReloadUtil.UpdateTable(OldTable, NewTable, Name, From, Deepth)\n    if ReloadUtil.Protection[OldTable] or ReloadUtil.Protection[NewTable] then return end</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>if OldTable == NewTable then return end\n<p>local signature = tostring(OldTable)…tostring(NewTable)</p>\n<p>if ReloadUtil.VisitedSig[signature] then return end</p>\n<p>ReloadUtil.VisitedSig[signature] = true<br />\nReloadUtil.DebugNofity(Deepth…“HU.UpdateTable “…Name…”  from:”…From)</p>\n<p>for ElementName, newValue in pairs(NewTable) do<br />\nlocal OldElement = OldTable[ElementName]<br />\nif type(newValue) == type(OldElement) then<br />\nif type(newValue) == “function” then<br />\nReloadUtil.UpdateOneFunction(OldElement, newValue, ElementName, OldTable, “HU.UpdateTable”, Deepth…&quot;    “)<br />\nelseif type(newValue) == “table” then<br />\nReloadUtil.UpdateTable(OldElement, newValue, ElementName, “HU.UpdateTable”, Deepth…”    &quot;)<br />\nend<br />\nelseif OldElement == nil and type(newValue) == “function” then<br />\n– 新增的函数，添加到旧环境里<br />\nif pcall(setfenv, newValue, ReloadUtil.ENV) then<br />\nOldTable[ElementName] = newValue<br />\nend<br />\nend<br />\nend</p>\n<p>– todo 更新metatable<br />\n–local OldMeta = debug.getmetatable(OldTable)<br />\n–local NewMeta = ReloadUtil.MetaMap[NewTable]<br />\n–if type(OldMeta) == “table” and type(NewMeta) == “table” then<br />\n–    ReloadUtil.UpdateTable(OldMeta, NewMeta, Name…“'s Meta”, “HU.UpdateTable”, Deepth…&quot;    &quot;)<br />\n–end end<br />\n</code></pre></div></div></p>\n<p>– Upvalue 是指那些函数外被引用到的local变量\nfunction ReloadUtil.UpdateUpvalue(OldFunction, NewFunction, Name, From, Deepth)\n    ReloadUtil.DebugNofity(Deepth..”HU.UpdateUpvalue”, Name, “  from:”..From)\n    local OldUpvalueMap = {}\n    local OldExistName = {}\n    – 记录旧的upvalue表\n    for i = 1, mathHuge do\n        local name, value = debugGetupvalue(OldFunction, i)\n        if not name then break end\n        OldUpvalueMap[name] = value\n        OldExistName[name] = true\n    end</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- 新的upvalue表进行替换\nfor i = 1, mathHuge do\n    local name, value = debugGetupvalue(NewFunction, i)\n    if not name then break end\n    if OldExistName[name] then\n        local OldValue = OldUpvalueMap[name]\n        if type(OldValue) ~= type(value) then\n            -- 新的upvalue类型不一致时，用旧的upvalue\n            debugSetupvalue(NewFunction, i, OldValue)\n        elseif type(OldValue) == \"function\" then\n            -- 替换单个函数\n            ReloadUtil.UpdateOneFunction(OldValue, value, name, nil, \"HU.UpdateUpvalue\", Deepth..\"    \")\n        elseif type(OldValue) == \"table\" then\n            -- 对table里面的函数继续递归替换\n            ReloadUtil.UpdateTable(OldValue, value, name, \"HU.UpdateUpvalue\", Deepth..\"    \")\n            debugSetupvalue(NewFunction, i, OldValue)\n        else\n            -- 其他类型数据有改变，也要用旧的\n            debugSetupvalue(NewFunction, i, OldValue)\n        end\n    else\n        -- 对新添加的upvalue设置正确的环境表\n        ReloadUtil.ResetENV(value, name, \"HU.UpdateUpvalue\", Deepth..\"    \")\n    end\nend end\n</code></pre></div></div>\n<p>function ReloadUtil.UpdateOneFunction(OldObject, NewObject, FuncName, OldTable, From, Deepth)\n    if ReloadUtil.Protection[OldObject] or ReloadUtil.Protection[NewObject] then return end</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>if OldObject == NewObject then return end\n<p>local signature = tostring(OldObject)…tostring(NewObject)</p>\n<p>if ReloadUtil.VisitedSig[signature] then return end<br />\nReloadUtil.DebugNofity(Deepth…“HU.UpdateOneFunction “…FuncName…”  from:”…From)<br />\nReloadUtil.VisitedSig[signature] = true<br />\n–最后注意把热更新的函数的环境表再改回旧函数的环境表即可，方法是setfenv(newfunction, getfenv(oldfunction))。<br />\nif pcall(debugSetfenv, NewObject, getfenv(OldObject)) then<br />\nReloadUtil.UpdateUpvalue(OldObject, NewObject, FuncName, “HU.UpdateOneFunction”, Deepth…&quot;    &quot;)<br />\nReloadUtil.ChangedFuncList[#ReloadUtil.ChangedFuncList + 1] = &#123;OldObject = OldObject,NewObject = NewObject,FuncName = FuncName,OldTable = OldTable&#125;<br />\nend end<br />\n</code></pre></div></div></p>\n<p>function ReloadUtil.ReplaceOld(OldObject, NewObject, LuaPath, From)\n    if type(OldObject) == type(NewObject) then\n        if type(NewObject) == “table” then\n            ReloadUtil.UpdateTable(OldObject, NewObject, LuaPath, From, “”)\n        elseif type(NewObject) == “function” then\n            ReloadUtil.UpdateOneFunction(OldObject, NewObject, LuaPath, nil, From, “”)\n        end\n    end\nend</p>\n<p>function ReloadUtil.HotUpdateCode(LuaPath, SysPath)\n    local OldObject = packageLoaded[LuaPath]\n    if not OldObject then\n        – 没加载的就不热更？？\n        return\n    end</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local isNew,newCode = ReloadUtil.IsNewCode(SysPath)\nif not isNew then\n    return\nend\n<p>local newObject = ReloadUtil.GetNewObject(newCode,SysPath,LuaPath)<br />\n– 更新旧代码<br />\nReloadUtil.ReplaceOld(OldObject, newObject, LuaPath, “Main”)</p>\n<p>–原理<br />\n–利用_ENV环境，在加载的时候把数据加载到_ENV下，然后再通过对比的方式修改_G底下的值，从而实现热更新，函数<br />\n–setmetatable(ReloadUtil.FakeENV, nil)<br />\n–todo ？？<br />\n–ReloadUtil.UpdateTable(ReloadUtil.ENV, ReloadUtil.FakeENV, &quot; ENV &quot;, “Main”, “”)</p>\n<p>– 替换完，上一次的代码就是旧代码<br />\nReloadUtil.OldCode[SysPath] = newCode end<br />\n</code></pre></div></div></p>\n<p>– 外部调用（先Init需要的路径，然后Update是热更时候调用的）</p>\n<p>—@param RootPath 需要被更新的文档夹路径\n—@param UpdateListFile 需要被更新的文档列表,不传为整个文档夹，会卡\nfunction ReloadUtil.Init(RootPath, ENV)\n    ReloadUtil.HotUpdateDic = {}\n    ReloadUtil.FileMap = {}\n    ReloadUtil.OldCode = {}\n    ReloadUtil.ChangedFuncList = {}\n    ReloadUtil.VisitedSig = {}\n    ReloadUtil.FakeENV = ReloadUtil.InitFakeTable()()\n    –当我们加载lua模块的时候，这时候这个模块信息并不像初始化全局代码一样，就算提前设置了package.loaded[“AA”] = nil,\n    –也不会出现在env中同时也不会调用_G的__newindex函数，也就是说env[“AA”]为空，故这种写法无法进行热更新，所以通常模块的写法改成如下\n    –定义模块AA\n    local AA = {}\n    –相当于package.seeall\n    setmetatable(AA, {__index = _G})\n    –环境隔离\n    local _ENV = AA\n    ReloadUtil.NewENV = _ENV\n    ReloadUtil.ENV = ENV or _G\n    ReloadUtil.InitProtection()\n    ReloadUtil.ALL = false\n    return ReloadUtil.InitFileMap(RootPath)\nend</p>\n<p>function ReloadUtil.Update()\n    ReloadUtil.VisitedSig = {}\n    ReloadUtil.ChangedFuncList = {}\n    for LuaPath, SysPath in pairs(ReloadUtil.HotUpdateDic) do\n        ReloadUtil.HotUpdateCode(LuaPath, SysPath)\n    end</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>if #ReloadUtil.ChangedFuncList &gt; 0 then\n    ReloadUtil.Travel_G()\nend\ncollectgarbage(\"collect\") end\n</code></pre></div></div>\n<p>    我跟老大炫耀的时候，老大说，那你懂其中的原理吗，一下问懵我了，老大说，你要学习到其他的原理才能进步啊，不然就只是个会用工具的人。好有道理，搞得我羞愧难当，赶紧好好学习其中原理。零零碎碎学习了好久，感觉智商不大够。</p>\n<p>  upvalue\nUpvalue 是指那些函数外被引用到的local变量,比如：\nlocal a = 1\nfunction foo()</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>print(a)\n</code></pre></div></div>\n<p>end</p>\n<p> 那么a就是这个foo的upvalue。</p>\n<p>getupvalue (f, up)</p>\n<p>此函数返回函数 f 的第 up 个上值的名字和值。 如果该函数没有那个上值，返回 nil 。 \n以 ‘(‘ （开括号）打头的变量名表示没有名字的变量 （去除了调试信息的代码块）。</p>\n<p>setupvalue (f, up, value):</p>\n<p>这个函数将 value 设为函数 f 的第 up 个上值。 如果函数没有那个上值，返回 nil 否则，返回该上值的名字。</p>\n<p>_G和debug.getregistry这2张表\n     学习的时候，我一直以为只有把_G这张全局表的旧值替换掉就好了，然后真正实施的时候，还是会有种种问题，实在是很糟糕，看这段代码的时候一直不是很理解，看了debug.getregistry的定义：</p>\n<p>debug.getregistry（）：返回注册表表，这是一个预定义出来的表， 可以用来保存任何 C 代码想保存的 Lua 值。</p>\n<p>还是半桶水，但是我有注意到_G这种表其实在debug.getregistry返回的这张注册表里有，所以最后就递归这张表其替换里面的旧值就好了。</p>\n<p>getfenv(object):\n返回对象的环境变量。</p>\n<p>setfenv（function,_ENV）\n设置一段代码的运行环境</p>\n<p>最后总结一下流程：</p>\n<p>1. 初始化需要热更的文档路径，用一张哈希表存下来：</p>\n<ol>\n  <li>对了InitFileMap这个函数有个要注意的，luaPath在保存的时候是按文档夹路径保存的比如：game.modules.XXX.lua，所以可能要自己搞对这个路径；</li>\n</ol>\n<p>2. io.popen(“dir /S/B /A:A \"”..RootPath..”\"”)</p>\n<p>获取一个File对象其下的所有文档和目录的绝对路径: 的所有文档(/S/B)，不包括文档夹（/A:A），io.popen返回文档句柄file handle\n2.  然后遍历这些路径，io.read(“*all”)读取所有的代码，判断是否是新代码，新的话记录到ChangedFuncList</p>\n<p>列表里面</p>\n<ol>\n  <li>\n    <p>新代码的话，就把加载的字符串放置在空环境了，防止报错setfenv(NewFunction, ReloadUtil.FakeENV)</p>\n  </li>\n  <li>\n    <p>代替旧代码，拿着ChangedFuncList列表到注册表(debug.getregistry())里面去找旧值，递归注册表的旧值替换成新的值</p>\n  </li>\n</ol>","text":" &lt;p&gt; 最近沉迷lua脚本热更，想说这个可以提高多少菜鸡的调试效率，找了网上好多文章，但是都不行，尝试了很久，并且自己测试和学习，写了一遍，勉强能热更了（还是有个问题，要按2次才能输出正确热更的值，一直找不到，有人找到麻烦告诉我一下308164213）。下面记录一下...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua __index和__newindex元方法","uid":"2de21734b2aaee59ca84e1dec23909a3","slug":"zl/2016-01-01-181_lua __index和__newindex元方法","date":"2024-04-03T03:47:33.069Z","updated":"2024-04-03T03:47:33.069Z","comments":true,"path":"api/articles/zl/2016-01-01-181_lua __index和__newindex元方法.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;h1 id=&quot;__index&quot;&gt;__index&lt;/h1&gt; 当访问一个table的字段时，如果存在这个字段，则返回这个字段的值 如果没有这个字段，则会让解释器去查找__index元方法，如果存在此元方法，则会调用它，返回结果 如果没有...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua string.find 中的 “坑”","uid":"f0b579433247a9da11a0809ef2f14994","slug":"zl/2016-01-01-180_Lua string.find 中的 “坑” ","date":"2024-04-03T03:47:33.066Z","updated":"2024-04-03T03:47:33.069Z","comments":true,"path":"api/articles/zl/2016-01-01-180_Lua string.find 中的 “坑” .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"我们的线上环境，ngx_lua api 都是以模块形式加载到 lua 级别的 vm 中，已达到最大性能。而且我们并没有使用传统的 “包” 的形式来加载(也就是 require &#34;xx.xx.xx&#34; )，而是直接以模块名为加载( require &#34;xx&#3...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}