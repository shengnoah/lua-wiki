{"title":"Mac下编写lua的C模块","uid":"21fd19bd506bc6ef05480df46c54d3fb","slug":"zl/2016-01-01-242_Mac下编写lua的C模块","date":"2024-04-03T03:47:33.110Z","updated":"2024-04-03T03:47:33.110Z","comments":true,"path":"api/articles/zl/2016-01-01-242_Mac下编写lua的C模块.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>&lt;p&gt;最近在研究lua下protobuf的使用，必然就会接触到了云风大侠的pbc，github上下了源码进行编译，发现想要把binding下面的测试代码运行起来，还是有一些坑点的。&lt;/p&gt;\n</code></pre>\n<p>在 <code class=\"highlighter-rouge\">/binding/lua53</code> 目录下有 <code class=\"highlighter-rouge\">Makefile</code> <code class=\"highlighter-rouge\">pbc-lua53.c</code> <code class=\"highlighter-rouge\">protobuf.lua</code> <code class=\"highlighter-rouge\">test.lua</code>几个主要的文档。</p>\n<p>调用的层次大概是：test.lua会 <code class=\"highlighter-rouge\">require</code> <code class=\"highlighter-rouge\">protobuf.lua</code> 文档，它是对 <code class=\"highlighter-rouge\">pbc-lua53.c</code> 导出的C函数库的一个封装，因此 <code class=\"highlighter-rouge\">protobuf.lua</code>是真正 <code class=\"highlighter-rouge\">require</code> C函数库的。<code class=\"highlighter-rouge\">Makefile</code> 复杂将<code class=\"highlighter-rouge\">pbc-lua53.c</code> 编译成动态链接库。</p>\n<p>但是要注意Linux和Mac上编译选项的差异，直接在命令行下 <code class=\"highlighter-rouge\">make</code> 会报错:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Undefined symbols for architecture x86_64:\n  \"_luaL_buffinit\", referenced from:\n      __pattern_pack in pbc-lua53-57d6af.o\n  \"_luaL_checkinteger\", referenced from:\n  ...\n</code></pre></div></div>\n<p>看到<code class=\"highlighter-rouge\">Undefined symbols</code>的第一反应是没有链接lua的静态库嘛，于是顺手就修改<code class=\"highlighter-rouge\">Makefile</code>文档，指定lua库的链接:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$(CC) $(CFLAGS) -shared -o $@ -llua -I../.. -I$(LUADIR) -L../../build $^ -lpbc\n</code></pre></div></div>\n<p><code class=\"highlighter-rouge\">make</code>一下，编译通过，运行<code class=\"highlighter-rouge\">lua test.lua</code>却报错：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>lua: multiple Lua VMs detected\nstack traceback:\n····\n</code></pre></div></div>\n<p>google一下，原因是我们编译protobuf.so动态链接库，静态链接了一次lua库，然后运行test.lua的时候，又动态链接了一次，导致<code class=\"highlighter-rouge\">multiple Lua VMs detected</code> 。</p>\n<p>正确的 <code class=\"highlighter-rouge\">Makefile</code>修改方式，应该是：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>C = gcc\nCFLAGS = -O2 -fPIC -Wall -bundle -undefined dynamic_lookup\nLUADIR = /usr/local/include\nTARGET = protobuf.so\n<p>.PHONY : all clean</p>\n<p>all : $(TARGET)</p>\n<p>(TARGET) : pbc-lua53.c\n»···(CC) $(CFLAGS) -o <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">@</mi><mo>−</mo><mi>I</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo>−</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">@ -I../.. -I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathrm\">@</span><span class=\"mbin\">−</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">/</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">.</span><span class=\"mbin\">−</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span>(LUADIR) -L…/…/build $^ -lpbc</p>\n<p>clean :<br />\n»···rm -f $(TARGET)<br />\n</code></pre></div></div></p>\n<p>通过 <code class=\"highlighter-rouge\">-bundle -undefined dynamic_lookup</code> 指定未找到的符号将在动态链接的时候，进行动态查找。同时删掉<code class=\"highlighter-rouge\">-shared</code> 选项。</p>\n<p><code class=\"highlighter-rouge\">make</code>然后<code class=\"highlighter-rouge\">lua test.lua</code>结果如下：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>test/addressbook.proto\ntutorial\nProfile\n\tnick_name [1] LABEL_OPTIONAL\n\ticon [2] LABEL_OPTIONAL\nPerson\n\tname [1] LABEL_REQUIRED\n\tid [2] LABEL_REQUIRED\n\temail [3] LABEL_OPTIONAL\n\tphone [4] LABEL_REPEATED\n\ttest [5] LABEL_REPEATED\n\tprofile [6] LABEL_OPTIONAL\nExt\nAddressBook\n\tperson [1] LABEL_REPEATED\nAlice\n12345\n\t1301234567\tHOME\n\t87654321\tWORK\nAlice\t123\ttable: 0x7feff8600950\n</code></pre></div></div>\n<p>测试的case正常跑通！</p>","text":"&lt;p&gt;最近在研究lua下protobuf的使用，必然就会接触到了云风大侠的pbc，github上下了源码进行编译，发现想要把binding下面的测试代码运行起来，还是有一些坑点的。&lt;/p&gt; 在 /binding/lua53 目录下有 Makefile pb...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua源码阅读：目录及模块结构","uid":"47140b7b78b8a632f22caf6eca5ca11d","slug":"zl/2016-01-01-245_Lua源码阅读：目录及模块结构","date":"2024-04-03T03:47:33.111Z","updated":"2024-04-03T03:47:33.111Z","comments":true,"path":"api/articles/zl/2016-01-01-245_Lua源码阅读：目录及模块结构.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;Lua源码阅读的第一期，主要内容：系列内容计划以及目录。&lt;/p&gt; Lua源码阅读：本篇转载于LuaSource 目录 第一篇：目录及模块结构 第二篇：基本数据类型 第三篇：实用函数 第四篇：标准库 第五篇：C API lua.c1234567891...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua学习1","uid":"ccf00cc91e42a79529a94664e1522709","slug":"zl/2016-01-01-243_lua学习1","date":"2024-04-03T03:47:33.110Z","updated":"2024-04-03T03:47:33.110Z","comments":true,"path":"api/articles/zl/2016-01-01-243_lua学习1.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"类型与值Lua是一种动态语言，没有定义类型的语法，每个值都携带了自身的类型信息。 Lua中有8种基础类型：nil、boolean、number、string、userdata、function、thread、table。函数type可以返回值的类型。 123456print(ty...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}