{"title":"proxy_cache_fastcgi_cache_lua","uid":"bef0d97634f836c6fcf89761496747d8","slug":"zl/2016-01-01-206_proxy_cache_fastcgi_cache_lua","date":"2024-04-03T03:47:33.084Z","updated":"2024-04-03T03:47:33.084Z","comments":true,"path":"api/articles/zl/2016-01-01-206_proxy_cache_fastcgi_cache_lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>    &lt;p&gt;[区别] 网上照搬&lt;br&gt;proxy_cache  缓存后端服务器的内容，可以是动态或者静态的任何内容&lt;br&gt;fastcg_cache  缓存fastcgi生成的内容，很多情况是php生成的内容&lt;br&gt;proxy_cache 主要用于反向代理时，对后端内容原服务器进行缓存，减少了nginx与后端通信的次数，节省了传输时间和后端带宽&lt;br&gt;fastcgi_cache  主要用于对fastcgi的动态进程进行缓存，减少了nginx和php通信的次数，减轻了php和数据库的压力&lt;br&gt;  先来proxy_cache 针对lua&lt;br&gt;  levels:缓存的级别，哈希  keys_zone:共享内存区    inactive:一个请求60m没有被请求，那么缓存管理会自动删除 (有了这个感觉不用purge了)&lt;br&gt;  proxy_cache_path    /dev/shm/proxy_cache    levels=1:2 keys_zone=one_cache:100m inactive=60m;&lt;br&gt;  fastcgi_cache_path   /dev/shm/fastcgi_cache_$&#123;USER&#125;-$&#123;PRJ_KEY&#125;-$&#123;APP_SYS&#125; levels=1:2 keys_zone=Action_pk_gift-fcgi-cache_$&#123;USER&#125;-$&#123;PRJ_KEY&#125;-$&#123;APP_SYS&#125;:100m inactive=60m;&lt;/p&gt;\n</code></pre>\n<p>  #这个清理模块要写在上面，也是看别人说的，我太懒了 不想实验了<br>  location ~ /purge/ajax_gift_gifts_get{<br>        allow all;</p>\n<pre><code>#deny all;\nproxy_cache_purge one_cache \"$host$arg_roomid$arg_rid$http_origin\";\n</code></pre><p>   }</p>\n<p>  location = /ajax_gift_gifts_get{<br>            add_header X-Cache-Status “$upstream_cache_status - $upstream_response_time”;</p>\n<pre><code>        #根据key生成相应的缓存  可以通过$arg_参数名，来访问到参数，然后可以设置根据参数不同来指定你想要的缓存条件\n        proxy_cache_key \"$host$arg_roomid$arg_rid$http_origin\";\n        #允许哪些方法可以缓存\n        proxy_cache_methods GET HEAD;\n        #缓存存放的缓存快\n        proxy_cache  one_cache;  #这个one_cache 是上面定义proxy_cache_path 时里面定义的共享内存区\n       #对于任何响应都缓存 30s\n        proxy_cache_valid  any 30s;\n        # 请求几次开始缓存\n        proxy_cache_min_uses  1;\n        #客户端主动断掉链接，Nginx会等待后端处理完（或超时），然后记录后端的返回信息\n        proxy_ignore_client_abort on;\n        add_header        Host           $&#123;DOMAIN_GATE&#125;;\n       # 当多个客户端请求一个不存在的缓存时，只有第一个请求被允许发送至服务器\n        proxy_cache_lock on;\n        # 哪些状态要缓存\n        proxy_cache_use_stale error updating timeout http_500 http_503;\n       #proxy_cache 和 proxy_pass  必须一起用才可以了，我是代理到另一个接口了，网上看 有人写127.0.0.1:port 我没成功，这个必须得写可以访问的通的server_name 自己到时候慢慢试吧\n        proxy_pass http://$&#123;DOMAIN_GATE&#125;/ajax_gift_gifts_getinside;\n&#125;\n<p>location  = /ajax_gift_gifts_getinside&#123;<br />\nlimit_conn mall_one_&#123;USER&#125; 1;\n    limit_conn_status 403;\n    limit_req zone=mall_addr_&#123;USER&#125; burst=1 nodelay;<br />\nlimit_req_status 403;<br />\ndefault_type application/json;<br />\ncontent_by_lua_file $&#123;PRJ_ROOT&#125;/src/lua/app/gift.lua;<br />\n&#125;<br />\n</code></pre><p>  来看fastchi_cache 对php  不能照搬这个 ，环境不一样，参数不一样，变量不一样<br>   location /pk_gift {</p></p>\n<pre><code>   #这里重新整理参数\n    set $paramstr $uri?groupid=$arg__groupid;\n    try_files $uri /localcache$paramstr;\n&#125;\n</code></pre><p>   location ~ ^/localcache/(w+) {<br>        internal;</p>\n<pre><code>   #解析action，/xxx =&gt; action=xxx\n   set $action 'index';\n   if ( $request_uri ~ ^/(w+)[^?]* ) &#123;\n       set $action $1;\n   &#125;\n\n   include        fastcgi_params;\n   root           $&#123;PRJ_ROOT&#125;/src/apps/$&#123;APP_SYS&#125; ;\n   fastcgi_pass   $php_sock;\n   fastcgi_param  SCRIPT_FILENAME  $&#123;PRJ_ROOT&#125;/src/apps/$&#123;APP_SYS&#125;/index.php;\n   fastcgi_param  QUERY_STRING     do=$action&amp;$query_string;\n   client_max_body_size       100m;\n   fastcgi_connect_timeout 1000s;\n   fastcgi_send_timeout 1000s;\n   fastcgi_read_timeout 1000s;\n   #看这里  \n   #这个是给response 头加一个变量看看是否缓存的状态 有MISS：没命中 HIT：缓存命中 EXPIRED:缓存已经过期请求被传送到后端 UPDATING：正在更新缓存，将使用旧的应答 STATE:后端将得到过期的应答\n   add_header X-Cache-CFC \"$upstream_cache_status - $upstream_response_time\";\n  #这个也是根据参数生成相应的缓存key,到时候匹配也是按照这个key来匹配 下面$1是上面正则匹配参数的第一个\n   fastcgi_cache_key \"$host$1$query_string$http_origin\";\n  #允许缓存的方法\n   fastcgi_cache_methods GET HEAD;\n   #最上面fastcgi_cache_path 定义的路径里面有\n   fastcgi_cache  Action_pk_gift-fcgi-cache_fangyuanmei-mall-front;\n   #任何状态缓存30s\n   fastcgi_cache_valid   any 30;\n   #请求几次开始缓存\n   fastcgi_cache_min_uses  1;\n   #同proxy_cache\n   fastcgi_cache_lock on;\n   #同proxy_cache\n   fastcgi_cache_use_stale error updating timeout   http_500 http_503;\n   #同proxy_cache\n   fastcgi_ignore_client_abort on;\n&#125;\n\n哎，图片还不出来\n</code></pre><p><img src=\"https://YM-FANG.github.io/2018/12/25/proxy-cache-fastcgi-cache/%60X1@%5D2%~9G_70H(24Z%DV29.png\" alt=\"\"><br><img src=\"https://YM-FANG.github.io/2018/12/25/proxy-cache-fastcgi-cache/2018/12/25/proxy-cache-fastcgi-cache/%60X1@%5D2%~9G_70H(24Z%DV29.png\" title=\"This is an image\"><br><img src=\"https://YM-FANG.github.io/2018/12/25/proxy-cache-fastcgi-cache/%60X1@%5D2%~9G_70H(24Z%DV29.png\" alt=\"fuck\"></p>","text":" &lt;p&gt;[区别] 网上照搬&lt;br&gt;proxy_cache 缓存后端服务器的内容，可以是动态或者静态的任何内容&lt;br&gt;fastcg_cache 缓存fastcgi生成的内容，很多情况是php生成的内容&lt;br&gt;proxy_cache 主...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua","uid":"df60e476b394b1dd4755ec96c53302ff","slug":"zl/2016-01-01-205_lua","date":"2024-04-03T03:47:33.084Z","updated":"2024-04-03T03:47:33.084Z","comments":true,"path":"api/articles/zl/2016-01-01-205_lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"元表（类似操作符重载） OpenResty 最佳实践 Lua 提供的所有操作符都可以被重载： 元方法 含义 “add” + 操作 “sub” - 操作 其行为类似于 “add” 操作 “mul” * 操作 其行为类似于 “add” 操作 “div” / 操作 其行为类似于 “ad...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"StackExchange.Redis加载Lua脚本进行模糊查询的批量删除和修改","uid":"f637a9bed7edc1a303f75d2f48bec364","slug":"zl/2016-01-01-201_StackExchange.Redis加载Lua脚本进行模糊查询的批量删除和修改","date":"2024-04-03T03:47:33.083Z","updated":"2024-04-03T03:47:33.083Z","comments":true,"path":"api/articles/zl/2016-01-01-201_StackExchange.Redis加载Lua脚本进行模糊查询的批量删除和修改.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;ul id=&quot;markdown-toc&quot;&gt; 通过keys进行模糊查询后的批量操作 对Hash集合下的key进行模糊查询后的批量操作 对Set集合下的值进行模糊查询后的批量操作 注意 通过keys进行模糊查询后的批量操作 var redis = ...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}