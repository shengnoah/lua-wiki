{"title":"lua模块注册","uid":"3ee4caaceb3ca178883af56b7f8a31ac","slug":"zl/2016-01-01-307_lua模块注册","date":"2024-04-03T03:47:35.586Z","updated":"2024-04-03T03:47:35.587Z","comments":true,"path":"api/articles/zl/2016-01-01-307_lua模块注册.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>Lua自带的模块并不多,好处就是Lua足够的小,毕竟它的设计目标是定位成一个嵌入式的轻量级语言的.</p>\n<h4 id=\"相关的函数index2adr\"><a href=\"#相关的函数index2adr\" class=\"headerlink\" title=\"相关的函数index2adr\"></a>相关的函数index2adr</h4><pre><code>static TValue *index2adr (lua_State *L, int idx) &#123;\n  if (idx &gt; 0) &#123;\n    TValue *o = L-&gt;base + (idx - 1);\n    api_check(L, idx &lt;= L-&gt;ci-&gt;top - L-&gt;base);\n    if (o &gt;= L-&gt;top) return cast(TValue *, luaO_nilobject);\n    else return o;\n  &#125;\n  else if (idx &gt; LUA_REGISTRYINDEX) &#123;\n    api_check(L, idx != 0 &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base);\n    return L-&gt;top + idx;\n  &#125;\n  else switch (idx) &#123;  /* pseudo-indices */\n    case LUA_REGISTRYINDEX: return registry(L);\n    case LUA_ENVIRONINDEX: &#123;\n      Closure *func = curr_func(L);\n      sethvalue(L, &amp;L-&gt;env, func-&gt;c.env);\n      return &amp;L-&gt;env;\n    &#125;\n    case LUA_GLOBALSINDEX: return gt(L);\n    default: &#123;\n      Closure *func = curr_func(L);\n      idx = LUA_GLOBALSINDEX - idx;\n      return (idx &lt;= func-&gt;c.nupvalues)\n                ? &amp;func-&gt;c.upvalue[idx-1]\n                : cast(TValue *, luaO_nilobject);\n    &#125;\n  &#125;\n&#125;\n</code></pre><p>一个Lua函数栈由两个指针base和top来指定,base指向函数栈底,top则指向栈顶.<br/>回到index2addr函数中,几种情况:</p>\n<ol>\n<li>如果索引为正,则从函数栈底为起始位置向上查找数据</li>\n<li>如果索引为负,则从函数栈顶为起始位置向下查找数据</li>\n<li>紧跟着是几种特殊的索引值,都定义了非常大的数据,由于Lua栈限定了函数的栈尺寸,所以不会有那么大的索引,大可放心使用.</li>\n</ol>\n<p>索引值为LUA_REGISTRYINDEX时,则返回的是全局数据global_state的l_registry表;如果索引值为LUA_GLOBALSINDEX,则返回该Lua_State的l_gt表.</p>\n<h4 id=\"lua模块注册\"><a href=\"#lua模块注册\" class=\"headerlink\" title=\"lua模块注册\"></a>lua模块注册</h4><p>Lua内部所有模块的注册都在linit.c的函数luaL_openlibs中提供.可以看到的是,它依次访问一个数组,数组中定义了每个模块的模块名及相应的模块注册函数,依次调用函数就完成了模块的注册.</p>\n<pre><code>static const luaL_Reg lualibs[] = &#123;\n  &#123;&#34;&#34;, luaopen_base&#125;,\n  &#123;LUA_LOADLIBNAME, luaopen_package&#125;,\n  &#123;LUA_TABLIBNAME, luaopen_table&#125;,\n  &#123;LUA_IOLIBNAME, luaopen_io&#125;,\n  &#123;LUA_OSLIBNAME, luaopen_os&#125;,\n  &#123;LUA_STRLIBNAME, luaopen_string&#125;,\n  &#123;LUA_MATHLIBNAME, luaopen_math&#125;,\n  &#123;LUA_DBLIBNAME, luaopen_debug&#125;,\n  &#123;NULL, NULL&#125;\n&#125;;\n<p>LUALIB_API void luaL_openlibs (lua_State *L) &#123;<br />\nconst luaL_Reg *lib = lualibs;<br />\nfor (; lib-&gt;func; lib++) &#123;<br />\nlua_pushcfunction(L, lib-&gt;func);<br />\nlua_pushstring(L, lib-&gt;name);<br />\nlua_call(L, 1, 0);<br />\n&#125;<br />\n&#125;<br />\n</code></pre><p>我没有详细的查看每个模块的注册函数,不过还是以最简单的例子来讲解,就是最常用的print函数.</p></p>\n<p>由于这个函数没有前缀,因此的它所在的模块是””,也就是一个空字符串,因此它是在base模块中注册的,调用的注册函数是luaopen_base.</p>\n<p>紧跟着继续看luaopen_base内部调用的第一个函数base_open:</p>\n<pre><code>static void base_open (lua_State *L) &#123;\n  /* set global _G */\n  lua_pushvalue(L, LUA_GLOBALSINDEX);\n  lua_setglobal(L, &#34;_G&#34;);\n  /* open lib into global table */\n  luaL_register(L, &#34;_G&#34;, base_funcs);\n<p>// …<br />\n&#125;<br />\n</code></pre><p>首先来看最前面的两句:</p></p>\n<pre><code>  /* set global _G */\n  lua_pushvalue(L, LUA_GLOBALSINDEX);\n  lua_setglobal(L, &#34;_G&#34;);\n</code></pre><p>这两句首先将LUA_GLOBALSINDEX对应的值压入栈中,其次调用”lua_setglobal(L, “_G”);”,这句代码的意思是在Lua_state的l_gt表中,当查找”_G”时,查找到的是索引值为LUA_GLOBALSINDEX的表.如果觉得有点绕,可以简单这个理解,在Lua中的G表,也就是全局表,满足这个等式”_G = _G[“_G”]“,也就是这个叫”_G”的表,内部有一个key为”_G”的表是指向自己的.怀疑这个结论的,可以在Lua命令行中执行print(_G)和print(_G[“_G”])看看输出结果是不是一致的.</p>\n<p>Lua中要这么处理的理由是:为了让G表和处理其它表使用同样的机制.查找一个变量时,最终会一直查到G表中,这是很自然的事情;所以为了也能按照这个机制顺利的查找到自己,于是在G表中有一个同名成员指向自己.</p>\n<p>好了,前面两句的作用已经分析完毕.其结果有两个:</p>\n<ol>\n<li>_G = _G[“_G”]</li>\n<li>_G表的值压入函数栈中方便了下面的调用.</li>\n</ol>\n<p>继续看下面的语句:<br/><strong>luaL_register(L, “_G”, base_funcs);</strong><br/><strong>它最终会将base_funcs中的函数注册到G表中,但是里面还有些细节需要看看的.</strong></p>\n<pre><code>LUALIB_API void luaI_openlib (lua_State *L, const char *libname,\n                              const luaL_Reg *l, int nup) &#123;\n  if (libname) &#123;\n    int size = libsize(l);\n    /* check whether lib already exists */\n    luaL_findtable(L, LUA_REGISTRYINDEX, &#34;_LOADED&#34;, 1);\n    lua_getfield(L, -1, libname);  /* get _LOADED[libname] */\n    if (!lua_istable(L, -1)) &#123;  /* not found? */\n      lua_pop(L, 1);  /* remove previous result */\n      /* try global variable (and create one if it does not exist) */\n      if (luaL_findtable(L, LUA_GLOBALSINDEX, libname, size) != NULL)\n        luaL_error(L, &#34;name conflict for module &#34; LUA_QS, libname);\n      lua_pushvalue(L, -1);\n      lua_setfield(L, -3, libname);  /* _LOADED[libname] = new table */\n    &#125;\n    lua_remove(L, -2);  /* remove _LOADED table */\n    lua_insert(L, -(nup+1));  /* move library table to below upvalues */\n  &#125;\n<p>// …<br />\n&#125;<br />\n</code></pre><p>注册这些函数之前,首先会到l_registry表的成员_LOADED表中查找该库,如果不存在则再在G表中查找这个库,不存在则创建一个表.因此,不管是lua中内部的库或者是外部使用require引用的库,都会走这个流程并最终在G表和l_registry[“_LOADED”]中存放该库的表.最后,再遍历传进来的函数指针数组,完成库函数的注册.</p></p>\n<p>比如,注册os.print时,首先将print函数绑定在一个函数指针上,再去l_registry[“_LOADED”]和G表中查询该名为”os”的库是否存在,不存在则创建一个表,即:<br/>G[“os”] = {}</p>\n<p>紧跟着注册print函数,即: G[“os”][“print”] = 待注册的函数指针.这样,在调用lua代码os.print(1)时,首先根据”os”到G表中查找对应的表,再在这个表中查找”print”成员得到函数指针,最后完成函数的调用.</p>\n<h4 id=\"注册外部模块\"><a href=\"#注册外部模块\" class=\"headerlink\" title=\"注册外部模块\"></a>注册外部模块</h4><p><strong>luaL_newlibtable</strong> 它仅仅是创建了一个table,然后把数组里的函数放进去而已 </p>\n<p><strong>luaL_setfuncs</strong>它把数组l中的所有函数注册入<strong>栈顶</strong>的table，并给所有函数绑上<strong>nup</strong>个<strong>upvalue</strong> </p>\n<p>define luaL_newlibtable(L, l)</p>\n<pre><code>lua_createtble(L, 0, sizeof(l)/sizeof((l)[0]) - 1)\n</code></pre><p>define luaL_newlib(L, l)</p>\n<pre><code>(luaL_newlibtable(L,l), luaL_setfuncs(L,l,0)\n</code></pre><pre><code>LUALIB_API void luaL_setfuncs(lua_State *L, const luaL_Reg *l, int nup)&#123;\n    luaL_checkversion(L);\n    luaL_checkstack(L, nup, &#34;too_many_upvalue&#34;);\n    for(; l-&gt;name != NULL; i++)&#123;/* fill the table with given functions*/\n        int i;\n        for(i = 0; i &lt; nup; i++)/copy upvalues to the top/\n            lua_pushvalue(L, -nup);\n        lua_pushclosure(L, l-&gt;func, nup);/closure with those upvalues/\n        lua_setfield(L, -(nup + 2), l-&gt;name);\n    &#125;\n    lua_pop(L, nup);/remove upvalues/\n&#125;\n<p></code></pre></p>\n","text":"Lua自带的模块并不多,好处就是Lua足够的小,毕竟它的设计目标是定位成一个嵌入式的轻量级语言的. 相关的函数index2adrstatic TValue *index2adr (lua_State *L, int idx) &#123; if (idx &gt; 0) &#12...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0index2adr\"><span class=\"toc-text\">相关的函数index2adr</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#lua%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8C\"><span class=\"toc-text\">lua模块注册</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%86%8C%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">注册外部模块</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"redis集群及ngx_lua接入方案","uid":"89ec4c26705d03b8fb9b9802b1dcecef","slug":"zl/2016-01-01-308_redis集群及ngx_lua接入方案","date":"2024-04-03T03:47:35.587Z","updated":"2024-04-03T03:47:35.588Z","comments":true,"path":"api/articles/zl/2016-01-01-308_redis集群及ngx_lua接入方案.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"背景介绍精细化分流和降级的项目依赖redis存放分流和降级规则，为了保证redis的高可用，需避免其单点故障和数据丢失。整个系统的架构图如下： 在管理端，通过多个管理实例来避免管理端的单点问题，将策略规则写入redis。在业务端，多个Nginx代理从redis中读出策略规则并缓存...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua基本类型及Basic Functions","uid":"832209621f9ee266a7ca0e324979ce03","slug":"zl/2016-01-01-306_Lua基本类型及Basic Functions","date":"2024-04-03T03:47:35.585Z","updated":"2024-04-03T03:47:35.586Z","comments":true,"path":"api/articles/zl/2016-01-01-306_Lua基本类型及Basic Functions.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua基本类型及Basic Functions &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; 概述 Lua的基本类型 基本类型 e.g. function testType() print (string.format(&#...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}