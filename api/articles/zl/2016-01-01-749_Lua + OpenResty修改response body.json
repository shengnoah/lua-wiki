{"title":"Lua + OpenResty修改response body","uid":"dc71cb9137d51b75049c4c21396aceac","slug":"zl/2016-01-01-749_Lua + OpenResty修改response body","date":"2024-04-03T03:47:35.996Z","updated":"2024-04-03T03:47:35.997Z","comments":true,"path":"api/articles/zl/2016-01-01-749_Lua + OpenResty修改response body.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<blockquote>\n<p>最近公司前端框架组提了个需求，希望修改response中的一个css文件，去掉一个样式：max-width:1632px;。于是便想到了利用lua。</p>\n</blockquote>\n<h2 id=\"OpenResty-lua编程相关资料\"><a href=\"#OpenResty-lua编程相关资料\" class=\"headerlink\" title=\"OpenResty lua编程相关资料\"></a>OpenResty lua编程相关资料</h2><ul>\n<li><a href=\"https://github.com/openresty/lua-nginx-module#name\" target=\"_blank\" rel=\"external noopener noreferrer\">OpenResty Readme</a></li>\n<li><a href=\"https://moonbingbing.gitbooks.io/openresty-best-practices/lua/main.html\" target=\"_blank\" rel=\"external noopener noreferrer\">OpenResty最佳实践\n</a></li>\n</ul>\n<p>其中Readme要看完，是github上对OpenResty的lua-nginx-module比较全面的介绍。</p>\n<h2 id=\"Nginx处理的几个阶段\"><a href=\"#Nginx处理的几个阶段\" class=\"headerlink\" title=\"Nginx处理的几个阶段\"></a>Nginx处理的几个阶段</h2><p>此处放上从网上找来的一幅图，<br/><img src=\"https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/24.png\" alt=\"\"/><br/>我这里修改response body显然是需要用到body_filter_by_lua*指令。</p>\n<h2 id=\"修改Response-Body\"><a href=\"#修改Response-Body\" class=\"headerlink\" title=\"修改Response Body\"></a>修改Response Body</h2><p>修改Response Body的方式总体来说有4种，分别是：</p>\n<ul>\n<li>1.使用 body_filter_by_lua<br/>指令来实现：<a href=\"http://wiki.nginx.org/HttpLuaModule#body_filter_by_lua\" target=\"_blank\" rel=\"external noopener noreferrer\">http://wiki.nginx.org/HttpLuaModule#body_filter_by_lua</a> 这个支持流式处理。 </li>\n<li>2.使用 ngx.location.capture 发起子请求，然后对子请求的响应体进行全缓冲式修改</li>\n<li><p>3.可以使用 <a href=\"https://github.com/agentzh/replace-filter-nginx-module\" target=\"_blank\" rel=\"external noopener noreferrer\">ngx_replace_filter 模块</a>来进行流式正则替换<br/>替换成的目标值可以通过 ngx_lua 模块嵌入一小段 Lua 代码来事先计算好，放置在你自己定义的 nginx 变量中，然后在 replace_filter 指令中直接引用之。比如 </p>\n<p>  set_by_lua $my_var ‘… return …’;<br/>  replace_filter ‘folderlist=w+’ ‘folderlist=$my_var’ ‘g’; </p>\n</li>\n<li>4.使用http_sub_module模块</li>\n</ul>\n<p>根据实际的需求，使用第3种，需要先安装sregex library，然后重新编译安装OpenResty，在编译时 ./configure –add-module=/path/to/replace-filter-nginx-module 启用replace-filter-nginx-module模块。<br/>如果使用第4种方式都需要重新编译安装OpenResty，在编译时 –with-http_sub_module 启用http_sub_module模块。<br/>这两种他们都不接受，因为涉及的客户太多。<br/>对于第2种方式，是个比较好的方式，但是使用第二种方式需要增加一个用于子请求的location，相当于大动了配置文件，并且相应的我还得去修改之前写的安装升级脚本，于是最终还是选择了第一种方式。<br/>虽然第2种到第4种的方案不适用于此次的需求，但是我还是尝试了使用下第2种和第4种的方案，并会把相关的脚本和配置贴在下面。</p>\n<h3 id=\"第一种处理办法\"><a href=\"#第一种处理办法\" class=\"headerlink\" title=\"第一种处理办法\"></a>第一种处理办法</h3><p>lua脚本代码如下：<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">-- body_filter_by_lua, body filter模块，ngx.arg[1]代表输入的chunk，ngx.arg[2]代表当前chunk是否为last</div><div class=\"line\">local chunk, eof = ngx.arg[1], ngx.arg[2]</div><div class=\"line\">local buffered = ngx.ctx.buffered</div><div class=\"line\">if not buffered then</div><div class=\"line\">   buffered = {}  -- XXX we can use table.new here </div><div class=\"line\">   ngx.ctx.buffered = buffered</div><div class=\"line\">end</div><div class=\"line\">if chunk ~= &#34;&#34; then</div><div class=\"line\">   buffered[#buffered + 1] = chunk</div><div class=\"line\">   ngx.arg[1] = nil</div><div class=\"line\">end</div><div class=\"line\">if eof then</div><div class=\"line\">   local whole = table.concat(buffered)</div><div class=\"line\">   ngx.ctx.buffered = nil</div><div class=\"line\">   -- try to unzip</div><div class=\"line\">   -- local status, debody = pcall(com.decode, whole) </div><div class=\"line\">   -- if status then whole = debody end</div><div class=\"line\"></div><div class=\"line\">   -- try to add or replace response body</div><div class=\"line\">   -- local js_code = ...</div><div class=\"line\">   -- whole = whole .. js_code</div><div class=\"line\">   whole = string.gsub(whole, &#34;max%-width%:1632px%;&#34;,  &#34;&#34;)</div><div class=\"line\">   ngx.arg[1] = whole</div><div class=\"line\">end</div></pre></td></tr></tbody></table></figure><p></p>\n<p>Nginx相关location配置如下：<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">location  /fe_components/ {</div><div class=\"line\">     location ~ /fe_components/jqwidget/.*/bh-scenes-1.2.min.css {</div><div class=\"line\">            root   /usr/local/nginx/nginx/html/;</div><div class=\"line\">            body_filter_by_lua_file /opt/lua/replace.lua;</div><div class=\"line\">     }</div><div class=\"line\"></div><div class=\"line\">     root   /usr/local/nginx/nginx/html;</div><div class=\"line\">}</div></pre></td></tr></tbody></table></figure><p></p>\n<p>但是重载Nginx后发现，这个css样式的响应时间竟然是1.1min，可怕。。。<br/><img src=\"https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/25.png\" alt=\"\"/><br/><img src=\"https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/26.png\" alt=\"\"/><br/>仔细阅读上面贴出来的<a href=\"https://github.com/openresty/lua-nginx-module#name\" target=\"_blank\" rel=\"external noopener noreferrer\">OpenResty Readme</a>，发现有这么一段话：<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">When the Lua code may change the length of the response body, then it is required to always clear out the Content-Length response header (if any) in a header filter to enforce streaming output, as in</div></pre></td></tr></tbody></table></figure><p></p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">location /foo {</div><div class=\"line\">    # fastcgi_pass/proxy_pass/...</div><div class=\"line\"></div><div class=\"line\">    header_filter_by_lua_block { ngx.header.content_length = nil }</div><div class=\"line\">    body_filter_by_lua &#39;ngx.arg[1] = string.len(ngx.arg[1]) .. &#34;\\n&#34;&#39;;</div><div class=\"line\">}</div></pre></td></tr></tbody></table></figure>\n<p>于是需要修改配置文件，在body_filter_by_lua_file /opt/lua/replace.lua之前就得把header中的 content_length 置为空。<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">location  /fe_components/ {</div><div class=\"line\">     location ~ /fe_components/jqwidget/.*/bh-scenes-1.2.min.css {</div><div class=\"line\">            root   /usr/local/nginx/nginx/html/;</div><div class=\"line\">            header_filter_by_lua &#39;ngx.header.content_length = nil&#39;;</div><div class=\"line\">            body_filter_by_lua_file /opt/lua/replace.lua;</div><div class=\"line\">     }</div><div class=\"line\"></div><div class=\"line\">     root   /usr/local/nginx/nginx/html;</div><div class=\"line\">}</div></pre></td></tr></tbody></table></figure><p></p>\n<p>这样重载Nginx，清除缓存重新访问下，发现加载就正常了。<br/>仔细了解了下原因，当代码运行到 body_filter_by_lua<em> 时，HTTP 报头（header）已经发送出去了。如果在之前设置了跟响应体相关的报头，而又在 body_filter_by_lua</em> 中修改了响应体，会导致响应报头和实际响应的不一致。举个简就是说这个例子里上游的服务器返回了 Content-Length 报头，而 body_filter_by_lua* 又修改了响应体的实际大小（因为我删除了一些字符串）。客户端收到这个报头后，按其中的 Content-Length 去处理，顺着一头栽进坑里。由于Nginx 的流式响应，发出去的报头就像泼出去的水，要想修改只能提前进行。这是流式处理常常面对的悖论：要在流的开始输出长度，但又不能在那个时间事先知道流的长度。<br/>对于处理逻辑简单的场景来说，Lua是十分合适的。 </p>\n<h3 id=\"第二种处理办法\"><a href=\"#第二种处理办法\" class=\"headerlink\" title=\"第二种处理办法\"></a>第二种处理办法</h3><p>lua脚本：<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">ngx.req.read_body()</div><div class=\"line\">local data = ngx.req.get_body_data()</div><div class=\"line\">local args = ngx.req.get_uri_args()</div><div class=\"line\">local res = ngx.location.capture(&#34;/bh-scenes-1.2.min.css&#34;, {method = ngx.HTTP_GET, body=data, args=args})</div><div class=\"line\">res.body = string.gsub(res.body, &#34;max%-width%:1632px%;&#34;, &#34;&#34;)</div><div class=\"line\">ngx.say(res.body)</div></pre></td></tr></tbody></table></figure><p></p>\n<p>Nginx相关配置：<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">location = /bh-scenes-1.2.min.css {</div><div class=\"line\">      root   /usr/local/nginx/nginx/html/fe_components/jqwidget/teal/;</div><div class=\"line\">}</div><div class=\"line\"></div><div class=\"line\">location  /fe_components/ {</div><div class=\"line\">     location ~ /fe_components/jqwidget/.*/bh-scenes-1.2.min.css {</div><div class=\"line\">          content_by_lua_file /opt/lua/replace2.lua;</div><div class=\"line\">     }</div><div class=\"line\"></div><div class=\"line\">     root   /usr/local/nginx/nginx/html;</div><div class=\"line\">}</div></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"第四种处理办法\"><a href=\"#第四种处理办法\" class=\"headerlink\" title=\"第四种处理办法\"></a>第四种处理办法</h3><p>需要重新编译安装OpenResty，编译时加入参数 –with-http_sub_module。<br/>Nginx相关配置如下：<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">location  /fe_components/ {</div><div class=\"line\">        location ~ /jqwidget/teal/bh-scenes-1.2.min.css {</div><div class=\"line\">           #sub_filter_types *;</div><div class=\"line\">           sub_filter_types text/css;</div><div class=\"line\">           sub_filter &#39;max-width:1632px;&#39;  &#39;&#39;;</div><div class=\"line\">           sub_filter_once off;</div><div class=\"line\">           root   /usr/local/nginx/nginx/html/;</div><div class=\"line\">        }</div><div class=\"line\">        root   /usr/local/nginx/nginx/html;</div><div class=\"line\">}</div></pre></td></tr></tbody></table></figure><p></p>","text":" 最近公司前端框架组提了个需求，希望修改response中的一个css文件，去掉一个样式：max-width:1632px;。于是便想到了利用lua。 OpenResty lua编程相关资料 OpenResty Readme OpenResty最佳实践 其中Readme要看完，是...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OpenResty-lua%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99\"><span class=\"toc-text\">OpenResty lua编程相关资料</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Nginx%E5%A4%84%E7%90%86%E7%9A%84%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">Nginx处理的几个阶段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9Response-Body\"><span class=\"toc-text\">修改Response Body</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">第一种处理办法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">第二种处理办法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%9B%9B%E7%A7%8D%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">第四种处理办法</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua GC 参数的含义","uid":"10d7779567e23657008e4474a5f79998","slug":"zl/2016-01-01-74_Lua GC 参数的含义","date":"2024-04-03T03:47:35.997Z","updated":"2024-04-03T03:47:35.998Z","comments":true,"path":"api/articles/zl/2016-01-01-74_Lua GC 参数的含义.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"lua实现了简单的incremental mark-and-sweep collector，有两个参数会影响GC的工作方式：pause和step multiplier。 概念 GC完整地清理一次内存的过程(“full gc”或”cycle”)由”标记内存是否垃圾”(mark)和”...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"(译)tolua参考手册","uid":"09f3fd9a5d5cc23a1aaaef40c13caf2f","slug":"zl/2016-01-01-747_(译)tolua参考手册","date":"2024-04-03T03:47:35.995Z","updated":"2024-04-03T03:47:35.995Z","comments":true,"path":"api/articles/zl/2016-01-01-747_(译)tolua参考手册.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 文章目录 &lt;/div&gt; &lt;p&gt;项目使用Cocos2dx+lua框架做的，用到luabinding实现C++代码绑定到lua层使用，所以学习一下tolua++工具的原理和使用，在这做个记录。&lt;/p&gt; tolua++是tolua的扩展版本，是一款...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}