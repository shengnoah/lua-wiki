{"title":"lua c api","uid":"a088e52eeedd5a2e08a78395ae73ef54","slug":"zl/2016-01-01-252_lua c api ","date":"2024-04-03T03:47:33.118Z","updated":"2024-04-03T03:47:33.119Z","comments":true,"path":"api/articles/zl/2016-01-01-252_lua c api .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"   <h2 id=\"一-概述\">一 概述</h2> <p>在 <code class=\"highlighter-rouge\">C</code> 中使用 <code class=\"highlighter-rouge\">API</code> 通过栈操作表或数组类型的数据，本篇使用示例来演示如果通过栈来操作表。</p> <h2 id=\"二-渠道秘钥更新\">二 渠道秘钥更新</h2> <p><code class=\"highlighter-rouge\">set_channel_key</code> 函数接收一个 <code class=\"highlighter-rouge\">table</code> 作为参数，从 <code class=\"highlighter-rouge\">table</code> 中获取 <code class=\"highlighter-rouge\">channel_name</code> 的值作为 <code class=\"highlighter-rouge\">key</code>，之后从动态库的全局渠道秘钥表中获取相应渠道的秘钥，并在 <code class=\"highlighter-rouge\">table</code> 中添加或更新 <code class=\"highlighter-rouge\">channel_key</code> 条目。</p> <h3 id=\"1-示例代码\">1. 示例代码</h3> <div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// gcc -fPIC -I/usr/local/lua5.1.5/include  -g -c private_cfg.c -Wall\n// gcc -shared -I/usr/local/lua5.1.5/include  -L/usr/local/lua5.1.5/lib -llua -o private_cfg.so private_cfg.o\n</span>\n<span class=\"cp\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n</span>\n<span class=\"cp\">#include \"lua.h\"\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n</span>\n<span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">channel_key_s</span> <span class=\"p\">&#123;</span>\n    <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">channel</span><span class=\"p\">;</span>\n    <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">key</span><span class=\"p\">;</span>\n<span class=\"p\">&#125;</span> <span class=\"n\">channel_key</span><span class=\"p\">;</span>\n<p><span class=\"k\">static</span> <span class=\"n\">channel_key</span><br />\n<span class=\"n\">g_channel_keys</span><span class=\"p\">[]</span> <span class=\"o\">=</span> <span class=\"p\">&#123;</span><br />\n<span class=\"p\">&#123;</span><span class=\"s\">“mobile”</span><span class=\"p\">,</span> <span class=\"s\">“mobile key”</span><span class=\"p\">&#125;,</span><br />\n<span class=\"p\">&#123;</span><span class=\"s\">“pc”</span><span class=\"p\">,</span> <span class=\"s\">“pc key”</span><span class=\"p\">&#125;,</span><br />\n<span class=\"p\">&#123;</span><span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">&#125;,</span><br />\n<span class=\"p\">&#125;;</span></p>\n<p><span class=\"cm\">/*******************************************************************************</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-3\">\n<p>从全局渠道秘钥表获取秘钥<br />\n***************************************************************************<em><em><em>/</span><br />\n<span class=\"k\">static</span> <span class=\"kt\">char</span> <span class=\"o\"></em></span><br />\n<span class=\"nf\">get_key</span><span class=\"p\">(</span><span class=\"kt\">char</span> <span class=\"o\"></em></span><span class=\"n\">channel_name</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"kt\">char</span> <span class=\"o\"></em></span><span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span></p>\n<p><span class=\"n\">channel_key</span> <span class=\"o\">*</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">g_channel_keys</span><span class=\"p\">;</span><br />\n<span class=\"k\">for</span> <span class=\"p\">(;</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">channel</span><span class=\"p\">;</span><span class=\"n\">p</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">strcmp</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">channel_name</span><span class=\"p\">))</span> <span class=\"p\">&#123;</span><br />\n<span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">key</span><span class=\"p\">;</span><br />\n<span class=\"k\">break</span><span class=\"p\">;</span><br />\n<span class=\"p\">&#125;</span><br />\n<span class=\"p\">&#125;</span></p>\n<p><span class=\"k\">return</span> <span class=\"n\">key</span><span class=\"p\">;</span><br />\n<span class=\"p\">&#125;</span></p>\n</li>\n</ul>\n<p><span class=\"cm\">/*******************************************************************************</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-3\">\n<p>do_set_channel_key</p>\n</li>\n<li class=\"lvl-3\">\n<p>函数接收一个 table 作为参数，从 table 中获取 channel_name 的值作为 key，</p>\n</li>\n<li class=\"lvl-3\">\n<p>之后从全局渠道秘钥表中获取相应渠道的秘钥，并在 table 中添加 channel_key 条目。<br />\n*****************************************************************************<em>/</span><br />\n<span class=\"k\">static</span> <span class=\"kt\">int</span><br />\n<span class=\"nf\">do_set_channel_key</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"></em></span><span class=\"n\">L</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"c1\">// 参数必须是 table<br />\n</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">lua_istable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"p\">&#123;</span><br />\n<span class=\"k\">return</span> <span class=\"n\">luaL_error</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">“type error, should use table as param!”</span><span class=\"p\">);</span><br />\n<span class=\"p\">&#125;</span></p>\n<p><span class=\"c1\">// 将 table 的 key <code>channel</code> 压入栈顶<br />\n</span>    <span class=\"n\">lua_pushstring</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">“channel_name”</span><span class=\"p\">);</span><br />\n<span class=\"c1\">// 从 table 中获取 channel 字段，并其放到栈顶<br />\n</span>    <span class=\"c1\">// 注意：此时栈顶是 channel 值，栈顶第二个元素是 table。<br />\n</span>    <span class=\"c1\">//      原先栈顶的 “channel” 字符串已经被使用并移出栈。<br />\n</span>    <span class=\"n\">lua_gettable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">);</span><br />\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">lua_isstring</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"p\">{</span><br />\n<span class=\"k\">return</span> <span class=\"n\">luaL_error</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">“channel type error, should use string as param!”</span><span class=\"p\">);</span><br />\n<span class=\"p\">}</span></p>\n<p><span class=\"c1\">// 取出 channel 名<br />\n</span>    <span class=\"kt\">char</span> <span class=\"o\"><em></span><span class=\"n\">channel_name</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">char</span> <span class=\"o\"></em></span><span class=\"p\">)</span><span class=\"n\">lua_tostring</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">);</span></p>\n<p><span class=\"c1\">// 将栈顶的 channel 值出栈，此时栈顶元素是 table<br />\n</span>    <span class=\"n\">lua_pop</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span></p>\n<p><span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">get_key</span><span class=\"p\">(</span><span class=\"n\">channel_name</span><span class=\"p\">);</span></p>\n<p><span class=\"c1\">// 在表中添加记录<br />\n</span>    <span class=\"n\">lua_pushstring</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">“channel_key”</span><span class=\"p\">);</span><br />\n<span class=\"n\">lua_pushstring</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">);</span><br />\n<span class=\"n\">lua_settable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">);</span></p>\n<p><span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span><br />\n<span class=\"p\">}</span></p>\n</li>\n</ul>\n<p><span class=\"k\">static</span> <span class=\"k\">const</span><br />\n<span class=\"k\">struct</span> <span class=\"n\">luaL_reg</span> <span class=\"n\">private_cfg</span><span class=\"p\">[]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><br />\n<span class=\"p\">{</span><span class=\"s\">“set_channel_key”</span><span class=\"p\">,</span> <span class=\"n\">do_set_channel_key</span><span class=\"p\">},</span><br />\n<span class=\"p\">{</span><span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">}</span><br />\n<span class=\"p\">};</span></p>\n<p><span class=\"cm\">/******************************************************************************</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>注册函数<br />\n*********************************************************************<em><em><em><em><em><em><em><em><em>/</span><br />\n<span class=\"kt\">int</span><br />\n<span class=\"nf\">luaopen_private_cfg</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"></em></span><span class=\"n\">l</span><span class=\"p\">)</span> <span class=\"p\">{</span><br />\n<span class=\"n\">luaL_openlib</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"s\">“private_cfg”</span><span class=\"p\">,</span> <span class=\"n\">private_cfg</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span><br />\n<span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span><br />\n<span class=\"p\">}</span><br />\n</code></pre></div></div> <h3 id=\"2-执行\">2. 执行</h3> <div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">requrie</span> <span class=\"s2\">“private_cfg”</span><br />\n<span class=\"n\">tb</span> <span class=\"o\">=</span> <span class=\"p\">&#123;</span><span class=\"n\">channel_name</span> <span class=\"o\">=</span> <span class=\"s1\">‘mobile’</span><span class=\"p\">,</span> <span class=\"n\">channel_key</span> <span class=\"o\">=</span> <span class=\"s1\">‘no’</span><span class=\"p\">&#125;</span><br />\n<span class=\"n\">private_cfg</span><span class=\"p\">.</span><span class=\"n\">set_channel_key</span><span class=\"p\">(</span><span class=\"n\">tb</span><span class=\"p\">)</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">tb</span><span class=\"p\">[</span><span class=\"s1\">‘channel_key’</span><span class=\"p\">])</span> <span class=\"c1\">–&gt; mobile key</span><br />\n</code></pre></div></div> <h2 id=\"三-函数说明\">三 函数说明</h2> <h3 id=\"1-访问表\">1. 访问表</h3> <div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"n\">lua_gettable</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"></em></span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"p\">);</span><br />\n<span class=\"kt\">void</span> <span class=\"n\">lua_rawget</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"></em></span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"p\">);</span><br />\n<span class=\"kt\">void</span> <span class=\"n\">lua_rawgeti</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"></em></span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">);</span><br />\n</code></pre></div></div> <p><code class=\"highlighter-rouge\">lua_gettable</code> 将 <code class=\"highlighter-rouge\">t[k]</code> 的值压入栈顶，表是由 <code class=\"highlighter-rouge\">index</code> 索引确定的栈上元素，<code class=\"highlighter-rouge\">k</code> 使用栈顶元素。<strong>函数会将栈顶的 <code class=\"highlighter-rouge\">k</code> 元素 <code class=\"highlighter-rouge\">pop</code> 出栈</strong>。</p> <p><code class=\"highlighter-rouge\">lua_rawget</code> 与 <code class=\"highlighter-rouge\">lua_gettable</code> 函数功能相似，只是 <code class=\"highlighter-rouge\">lua_rawget</code> 不会使用表的元方法（<code class=\"highlighter-rouge\">metamethods</code>）。</p> <p><code class=\"highlighter-rouge\">lua_rawgeti</code> 将 <code class=\"highlighter-rouge\">t[n]</code> 值压入栈，<code class=\"highlighter-rouge\">t</code> 由 <code class=\"highlighter-rouge\">index</code> 索引指定，<code class=\"highlighter-rouge\">n</code> 为字面值，不会使用元方法。</p> <h3 id=\"2-更新表\">2. 更新表</h3> <div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"n\">lua_settable</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"></em></span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"p\">);</span><br />\n<span class=\"kt\">void</span> <span class=\"n\">lua_rawset</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"></em></span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"p\">);</span><br />\n<span class=\"kt\">void</span> <span class=\"n\">lua_rawseti</span><span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"></em></span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">);</span><br />\n</code></pre></div></div> <p><code class=\"highlighter-rouge\">lua_settable</code> 与 <code class=\"highlighter-rouge\">lua</code> 中的 <code class=\"highlighter-rouge\">t[k] = v</code> 语义相同，表 <code class=\"highlighter-rouge\">t</code> 是由 <code class=\"highlighter-rouge\">index</code> 索引确定的栈上元素，<code class=\"highlighter-rouge\">v</code> 是当前栈顶元素，<code class=\"highlighter-rouge\">k</code> 是当前次栈顶元素。<strong>此函数会将栈顶、次栈顶元素 <code class=\"highlighter-rouge\">pop</code> 出栈</strong>。</p> <p><code class=\"highlighter-rouge\">lua_rawset</code> 与 <code class=\"highlighter-rouge\">lua_settable</code> 函数功能相似，只是 <code class=\"highlighter-rouge\">lua_rawset</code> 不会使用表的元方法（<code class=\"highlighter-rouge\">metamethods</code>）。</p> <p><code class=\"highlighter-rouge\">lua_rawseti</code> 与 <code class=\"highlighter-rouge\">lua</code> 中的 <code class=\"highlighter-rouge\">t[n] = v</code> 语义相同，表 <code class=\"highlighter-rouge\">t</code> 是由 <code class=\"highlighter-rouge\">index</code> 索引确定的栈上元素，<code class=\"highlighter-rouge\">v</code> 是当前栈顶元素，<code class=\"highlighter-rouge\">n</code> 为字面值，该函数不会使用元方法。</p> <h3 id=\"3-错误输出\">3. 错误输出</h3> <div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"n\">luaL_error</span> <span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"></em></span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\"></em></span><span class=\"n\">fmt</span><span class=\"p\">,</span> <span class=\"p\">…);</span><br />\n</code></pre></div></div> <p>触发错误，并输出 <code class=\"highlighter-rouge\">fmt</code> 格式的错误信息，如果能获取文档名或行号会添加这些信息。</p> <h2 id=\"四-参考\">四 参考</h2> <ul> <li><a href=\"https://www.lua.org/pil/25.1.html\">programming in lua</a></li> <li><a href=\"https://www.lua.org/manual/5.1/manual.html\">lua 5.1 c api 手册</a></li> </ul></p>\n</li>\n</ul>\n","text":" 一 概述 在 C 中使用 API 通过栈操作表或数组类型的数据，本篇使用示例来演示如果通过栈来操作表。 二 渠道秘钥更新 set_channel_key 函数接收一个 table 作为参数，从 table 中获取 channel_name 的值作为 key，之后从动态库的全局渠...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">一 概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E6%B8%A0%E9%81%93%E7%A7%98%E9%92%A5%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">二 渠道秘钥更新</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">1. 示例代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">2. 执行</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89-%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">三 函数说明</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%AE%BF%E9%97%AE%E8%A1%A8\"><span class=\"toc-text\">1. 访问表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%9B%B4%E6%96%B0%E8%A1%A8\"><span class=\"toc-text\">2. 更新表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E9%94%99%E8%AF%AF%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">3. 错误输出</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B-%E5%8F%82%E8%80%83\"><span class=\"toc-text\">四 参考</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"centos下安装openresty+ngx_lua_waf防火墙部署","uid":"0bbecffdbf888a921316fd4ef393eaaa","slug":"zl/2016-01-01-251_centos下安装openresty+ngx_lua_waf防火墙部署","date":"2024-04-03T03:47:33.118Z","updated":"2024-04-03T03:47:33.118Z","comments":true,"path":"api/articles/zl/2016-01-01-251_centos下安装openresty+ngx_lua_waf防火墙部署.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;全文默认安装路径：/usr/local/src&lt;/p&gt; 1、安装Luagit:1234567# cd /usr/local/src# wget http://luajit.org/download/LuaJIT-2.1.0-beta3.tar.gz...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua require机制","uid":"fc07d610e727a4dac9a13d0c264a8534","slug":"zl/2016-01-01-24_lua require机制","date":"2024-04-03T03:47:33.117Z","updated":"2024-04-03T03:47:33.117Z","comments":true,"path":"api/articles/zl/2016-01-01-24_lua require机制.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"require(modname) 加载给定的模块.函数首先检查表package.loaded来判定modname是否已经存在. 如果存在,则require返回package.loaded[modname]所存储的值否则它尝试为模块找到一个加载器(loader). 要找到一个加载器...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}