{"title":"lua通用数据类型","uid":"a671ff4d1c3c5fadfd8ab3ef296a465f","slug":"zl/2016-01-01-418_lua通用数据类型","date":"2024-04-03T03:47:35.706Z","updated":"2024-04-03T03:47:35.706Z","comments":true,"path":"api/articles/zl/2016-01-01-418_lua通用数据类型.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h4 id=\"TValue结构\"><a href=\"#TValue结构\" class=\"headerlink\" title=\"TValue结构\"></a>TValue结构</h4><p>TValue这个结构体是Lua的通用结构体,,Lua中的所有的数据都可以使用这个结构体来表示.很容易想到,在面向对象中,这个结构体是一个基类,派生出来的都是其他的子类.</p>\n<p>TValue结构体内部有几个宏, 展开之后就是这样的:</p>\n<pre><code>typedef struct lua_TValue &#123;\n    union &#123;\n      union GCObject &#123;\n        struct GCheader &#123;\n          GCObject *next; lu_byte tt; lu_byte marked;\n        &#125; gch;\n<pre><code>    union TString ts;\n    union Udata u;\n    union Closure cl;\n    struct Table h;\n    struct Proto p;\n    struct UpVal uv;\n    struct lua_State th;  /* thread */\n  &#125; gc;\n\n  void *p;\n  lua_Number n;\n  int b;\n&#125; value;\nint tt;\n</code></pre>\n<p>} TValue;<br />\n</code></pre><p>这个结构体定义,总体来说分为两个部分:tt存放的数据类型,而value域存放的是各种数据.而在其中,又划分为两个部分,可gc的数据类型使用union放在一起,剩下的就是不可gc的数据类型了:void*,lua_Number,int.</p></p>\n<h4 id=\"gc-union\"><a href=\"#gc-union\" class=\"headerlink\" title=\"gc union\"></a>gc union</h4><p>gc union的定义,可以看到各种可gc的类型(Tstring,Udata..etc)和一个GCHeader放在 一起,也就是说,当这部分还是数据的时候,数据部分启用,否则就是gc部分了.这里的GCHeader包括了三个部分:next指针将可gc的数据串联成链表,tt表示数据类型,marked存放的gc处理时的颜色值.<br/>这是另一种方式的使用C语言实现的面向对象,对外部而言,TValue结构体可以看作是”基类”,真正进行处理时,再根据数据类型决定到底使用value union中的哪个数据部分.可以看到lua源代码中定义了很多宏就是这样操作Tvalue数据指针的,比如:</p>\n<pre><code>#define hvalue(o)    check_exp(ttistable(o), &amp;(o)-&gt;value.gc-&gt;h)\n</code></pre><p>这个宏定义了如何从TValue指针得到Table结构体:首先判断数据类型是Table,然后将value的gc union中Table *h取出.</p>\n<p>反之,要从一个具体的类型转换再赋值为相应的TValue,Lua源代码中也提供了相应的宏.因为TValue结构体的中的value域是一个union,所以其实随便强制转换为其中的哪一种类型都可以,不过看上去最舒服的写法还是直接转换为公共类型GCObject了,比如:</p>\n<pre><code>#define setsvalue(L,obj,x) \n  &#123; TValue *i_o=(obj); \n    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TSTRING; \ncheckliveness(G(L),i_o); &#125;\n</code></pre><h4 id=\"GCObject\"><a href=\"#GCObject\" class=\"headerlink\" title=\"GCObject\"></a>GCObject</h4><pre><code>union GCObject &#123;\n  GCheader gch;\n  union TString ts;\n  union Udata u;\n  union Closure cl;\n  struct Table h;\n  struct Proto p;\n  struct UpVal uv;\n  struct lua_State th;  /* thread */\n&#125;;\n</code></pre><p>其中的GCheader展开是这样的:</p>\n<pre><code>typedef struct GCheader &#123;\n  CommonHeader;\n&#125; GCheader;\n</code></pre><p>而随便抽在GCObject结构体中的数据类型结构体定义,都发现也包含了一个CommonHeader结构体,比如:</p>\n<pre><code>typedef struct Table &#123;\n  CommonHeader;\n  lu_byte flags;\n  lu_byte lsizenode;  /* log2 of size of `node&#39; array */\n  struct Table *metatable;\n  TValue *array;  /* array part */\n  Node *node;\n  Node *lastfree;  /* any free position is before this position */\n  GCObject *gclist;\n  int sizearray;  /* size of `array&#39; array */\n&#125; Table;\n</code></pre><p>换言之,在GCObject中,无论是哪个数据结构体,都自己有一份CommonHeader.仔细观察,其实GCObject这个union的内存分布,最开始部分无论如何都是留给CommonHeader的.这样做,就保证了一个存放在TValue结构体中的数据,既可以使用CommonHeader关于GC的部分,也可以使用到自己本身的数据部分了.</p>","text":"TValue结构TValue这个结构体是Lua的通用结构体,,Lua中的所有的数据都可以使用这个结构体来表示.很容易想到,在面向对象中,这个结构体是一个基类,派生出来的都是其他的子类. TValue结构体内部有几个宏, 展开之后就是这样的: typedef struct lua_...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TValue%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">TValue结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#gc-union\"><span class=\"toc-text\">gc union</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#GCObject\"><span class=\"toc-text\">GCObject</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"cocos2dx lua 多线程之协成理解与实战","uid":"f51b7c82932d35bf6007762646b46c8a","slug":"zl/2016-01-01-417_cocos2dx lua 多线程之协成理解与实战","date":"2024-04-03T03:47:35.706Z","updated":"2024-04-03T03:47:35.706Z","comments":true,"path":"api/articles/zl/2016-01-01-417_cocos2dx lua 多线程之协成理解与实战.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"lua是不支持多线程的，一般都是协同来调用的。但是lua却可以调用c函数。于是，我们通过lua调用C接口起一个线程，实现lua多线程的使用。子线程再调用lua中的function。就可以通过子线程获取一些数据。单纯的人儿，以为一切都是美好的。 问题就出现C调用lua中的funct...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua string hash 算法","uid":"6adde4c0d4219f400e445d71ce124e5c","slug":"zl/2016-01-01-419_Lua string hash 算法 ","date":"2024-04-03T03:47:35.706Z","updated":"2024-04-03T03:47:35.710Z","comments":true,"path":"api/articles/zl/2016-01-01-419_Lua string hash 算法 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"我在前一篇文章介绍过下面这 3 个字符串拥有相同的 hash，会导致 Hash Dos 问题： &#34;0000000000000000000000000000000000&#34; &#34;f0l0l0w0m0e0n0t0w0i0t0t0e0r0?0:0)0&#34; &#...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}