{"title":"Lua学习笔记(3) 关于pairs和ipairs","uid":"9b7dd38c8497965e07e7d3a360395c56","slug":"zl/2016-01-01-741_Lua学习笔记(3) 关于pairs和ipairs","date":"2024-04-03T03:47:35.987Z","updated":"2024-04-03T03:47:35.991Z","comments":true,"path":"api/articles/zl/2016-01-01-741_Lua学习笔记(3) 关于pairs和ipairs.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>[TOC]</p>\n<h2 id=\"pairs\">pairs</h2>\n<p>遍历table</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local tbTestPairs =&#123;\n\t[1] = 1,\n\tnTest_1 = 2,\n\tszTest = &#34;test&#34;,\n\ttbTest = &#123;&#125;,\n\tnTest_2,\n&#125;\n<p>for k, v in pairs(tbTestPairs) do<br />\nprint (k, v)<br />\nend<br />\n</code></pre></div></div></p>\n<p>结果</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>szTest\ttest\ntbTest\ttable: 000000000033a630\nnTest_1\t2\n</code></pre></div></div>\n<h2 id=\"ipairs\">ipairs</h2>\n<p>按顺序便利table</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local tbTestIpairs = &#123;1, 3, 5, nil, 7&#125;\nfor k, v in ipairs(tbTestIpairs) do\n\tprint(k ,v)\nend\n</code></pre></div></div>\n<p>结果</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1\t1\n2\t3\n3\t5\n</code></pre></div></div>\n<h2 id=\"总结\">总结</h2>\n<ul>\n  <li>pairs是无序的，ipairs是有序的。这点很重要，如果要按存储顺序处理表中内容的时候，pairs就可能得不到预期的结果；</li>\n  <li>ipairs遇到nil就停止打印，所以只打印出来前面三个，7没有打印出来</li>\n  <li>pairs中为值nil的元素，即使你定义了key是有效的，也是遍历不出来的。所以要小心对key有要求的应用！</li>\n  <li>从上面的结果可以看到tbTestPairs中nTest_2没有打印，<em>这不是因为nTest_2这个key对应的值为nil</em>，而是没有定义key的元素在table里面从前往后依次从[1][2]…开始作为key的，所以nTest_2的key为[1],也覆盖了[1]=1，因此[1]=1也没有打印出来</li>\n  <li>存储结构上pairs对应的是hash表，ipairs对应的是数组。这个很多帖子都有说明，看代码也更明白</li>\n</ul>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code></code></pre></div></div>\n<h1 id=\"理解层次\">理解层次</h1>\n<h2 id=\"学习和理解\">学习和理解</h2>\n<p>说到底，pairs和ipairs都是lua中的迭代器。迭代器是一种可以遍历一种结合中所有元素的机制[1]。可以看泛型for的语义：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for &lt;var-list&gt; in &lt;exp-list&gt; do\n\t&lt;body&gt;\nend\n</code></pre></div></div>\n<p>for在循环过程中保存了迭代器函数。for做的第一件事就是对in后面的表达式求值，这些表达式应该返回3个值供for保存（这里也就知道如果自己实现迭代器需要根据语法要求来写）：</p>\n<ul>\n  <li>迭代器函数</li>\n  <li>恒定状态</li>\n  <li>控制变量</li>\n</ul>\n<p>在初始化完成之后，for会以恒定状态和控制变量来调用迭代器函数。可以看下面的代码，更加清晰：</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for var_1, ..., var_n in &lt;explist&gt; do \n\t&lt;block&gt;\nend\n<p>– 等价于以下代码</p>\n<p>do<br />\nlocal _f, _s, _var = &lt;explist&gt;\t– 返回迭代器函数、恒定状态和控制变量的初值<br />\nwhile true do<br />\nlocal var_1, …, var_n = _f(_s, _var)<br />\n_var = var_1<br />\nif _var == nil then<br />\nbreak<br />\nend<br />\n&lt;block&gt;<br />\nend<br />\nend<br />\n</code></pre></div></div></p>\n<p>参考[1]中专门对这个泛型for问题说的非常详细！感谢作者^_^</p>\n<h2 id=\"学以致用\">学以致用</h2>\n<ul>\n  <li>pairs</li>\n</ul>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local function iter(a, k)\n\tk, v = next(a, k);\n\tif v then\n\t\treturn k, v;\n\tend\nend\n<p>function pairs(t)<br />\nreturn iter, t, nil;<br />\nend<br />\n</code></pre></div></div></p>\n<ul>\n  <li>iparis</li>\n</ul>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local function iter(a, i)\n\ti = i + 1;\n\tif a[i] then\n\t\treturn i, a[i];\n\tend\nend\n<p>function ipairs(t)<br />\nreturn iter, t, 0;<br />\nend<br />\n</code></pre></div></div></p>\n<h1 id=\"参考\">参考</h1>\n<ul>\n  <li>[1]<a href=\"http://www.jellythink.com/archives/506\">lua中的迭代器与泛型for</a></li>\n</ul>","text":"[TOC] pairs 遍历table local tbTestPairs =&#123; [1] = 1, nTest_1 = 2, szTest = &#34;test&#34;, tbTest = &#123;&#125;, nTest_2, &#125; for k, v...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pairs\"><span class=\"toc-text\">pairs</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ipairs\"><span class=\"toc-text\">ipairs</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3%E5%B1%82%E6%AC%A1\"><span class=\"toc-text\">理解层次</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%A6%E4%B9%A0%E5%92%8C%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">学习和理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%A6%E4%BB%A5%E8%87%B4%E7%94%A8\"><span class=\"toc-text\">学以致用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"基于OpenResty安装配置Nginx+LUA并实现请求分发的双层Nginx架构策略","uid":"ba17cf45fbc8e4f389116ffd1e13da5f","slug":"zl/2016-01-01-742_基于OpenResty安装配置Nginx+LUA并实现请求分发的双层Nginx架构策略","date":"2024-04-03T03:47:35.991Z","updated":"2024-04-03T03:47:35.992Z","comments":true,"path":"api/articles/zl/2016-01-01-742_基于OpenResty安装配置Nginx+LUA并实现请求分发的双层Nginx架构策略.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"台CentOS6.x192.168.1.210192.168.1.211192.168.1.212网络拓扑210和211作为应用层web服务器212作为网络请求分发代理服务器 Step1:安装Linux依赖1yum install -y readline-devel pcre-d...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua数据结构 — TString（二）","uid":"7f3fee236da971d68841808a8bab5c34","slug":"zl/2016-01-01-73_Lua数据结构 — TString（二）","date":"2024-04-03T03:47:35.986Z","updated":"2024-04-03T03:47:35.986Z","comments":true,"path":"api/articles/zl/2016-01-01-73_Lua数据结构 — TString（二）.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"存储lua里面的字符串的TString数据结构:（lobject.h 196-207） 其它结构中也会有L_Umaxalign dummy这个东西，来看看L_Umaxaliagn: 从字面意思上就是保证内存能与最大长度的类型进行对齐，事实上也是做这件事，这里感觉lua想给各种不同...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}