{"title":"Lua GC 参数的含义","uid":"10d7779567e23657008e4474a5f79998","slug":"zl/2016-01-01-74_Lua GC 参数的含义","date":"2024-04-03T03:47:35.997Z","updated":"2024-04-03T03:47:35.998Z","comments":true,"path":"api/articles/zl/2016-01-01-74_Lua GC 参数的含义.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>lua实现了简单的incremental mark-and-sweep collector，有两个参数会影响GC的工作方式：<strong>pause</strong>和<strong>step multiplier</strong>。</p>\n<h2 id=\"概念\">概念</h2>\n<p>GC完整地清理一次内存的过程(“full gc”或”cycle”)由”标记内存是否垃圾”(<em>mark</em>)和”释放垃圾内存”(<em>sweep</em>“)两个阶段构成。一个cycle的开销通常比较大，理想情况下应该分割成多个开销较小的step。lua的GC引入一个变量<strong>debt</strong>,用以分割step，单位和内存是等比例的。如果debt是无穷大，一个step就会完成一个cycle的工作。debt&lt;=0时，GC停止工作。分配内存时debt会等比例的增大。在mark过程中，每标记一个正在使用的object，就会根据这个object的大小从debt减去一个等比例的数值。在sweep过程中，每释放一个object，就会根据这个object的大小从debt减去一个等比例的数值。在一个cycle完成后，GC会根据当前使用的内存和pause的值计算一个新的debt。</p>\n<h2 id=\"数量关系\">数量关系</h2>\n<p>声明以下变量：</p>\n<ul>\n  <li>TotalMemory: Lua占用的内存。</li>\n  <li>TotalMemoryInUse : 正在被使用的对象的内存总和。</li>\n  <li>MemoryAllocatedInMark : Mark过程中分配的内存。</li>\n  <li>MemoryMarked : Mark过程中已标记的内存</li>\n  <li>MemoryAllocatedInSweep: Sweep过程中分配的内存。</li>\n  <li>MemoryFreed： 释放的对象的内存总和。</li>\n</ul>\n<p>在Mark过程中，TotalMemory增加MemoryAllocatedInMark，debt的变化量是MemoryAllocatedInMark - MemoryMarked ；在Sweep过程中，TotalMemory的变化量是MemoryAllocatedInSweep - MemoryFreed，debt的变化量是 MemoryAllocatedInSweep - MemoryFreed。\n在一个cycle完成之后，GC将debt的值重新设置为 TotalMemory * (1 - pause) * stepmul\n内存增加时，debt也会相应的增加，step multiplier是两者的比例。</p>\n<h2 id=\"示例分析\">示例分析：</h2>\n<h3 id=\"现象\">现象</h3>\n<p>在青柳谷中什么都不做，TotalMemory会有规律的波动，缓慢地增长到一个最大值(MemoryMax)后，快速地降低到一个最小值(MemoryBase)。设置不同的pause和set multiplier，统计数据如下：</p>\n<table>\n  <thead>\n    <tr>\n      <th>pause(%)</th>\n      <th>stepmul(下面的值/200)</th>\n      <th>MemoryBase(M)</th>\n      <th>MemoryMax(M)</th>\n      <th>内存增长时间(s)</th>\n      <th>内存减少时间(s)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>10</td>\n      <td>200</td>\n      <td>34</td>\n      <td>37</td>\n      <td>25.4</td>\n      <td>4.6</td>\n    </tr>\n    <tr>\n      <td>20</td>\n      <td>200</td>\n      <td>35</td>\n      <td>41</td>\n      <td>51.4</td>\n      <td>6.5</td>\n    </tr>\n    <tr>\n      <td>90</td>\n      <td>200</td>\n      <td>38</td>\n      <td>64</td>\n      <td>235.8</td>\n      <td>28.7</td>\n    </tr>\n    <tr>\n      <td>10</td>\n      <td>100</td>\n      <td>44</td>\n      <td>70</td>\n      <td>246</td>\n      <td>73</td>\n    </tr>\n  </tbody>\n</table>\n<h3 id=\"原因\">原因</h3>\n<p>在游戏中什么都不做，所以TotalMemoryInUse是基本固定的，测试数据33M。内存缓慢增长是因为每个Tick都会分配少量(大约3~4k)垃圾内存。一个cycle跑完时内存达到最小值 MemoryBase = TotalMemoryInUse + MemoryAllocatedInSweep；Mark过程中内存会持续增长，所以Mark完成时达到最大值 MemoryMax = MemoryBase + MemoryAllocatedInMark。debt累积超过34M才能完成Mark，完成前一个cycle时会设置初始debt = TotalMemory * (1 - pause) * stepmul，如果debt &gt;= TotalMemoryInUse，GC会在下一个step完成Mark，进入Sweep；否则GC会停留在Mark阶段，等待内存分配。\n以第二行数据为例，初始debt = 34 * (1 - 0.2) 即27.2M，不足以完成Mark，还缺少6.8M。内存增长到41M后，完成Mark。进入Sweep阶段后，开始释放内存，时长6.5秒，Tick分配的内存大约为  6.5* (41-35)/51.4约等于0.76M。</p>","text":"lua实现了简单的incremental mark-and-sweep collector，有两个参数会影响GC的工作方式：pause和step multiplier。 概念 GC完整地清理一次内存的过程(“full gc”或”cycle”)由”标记内存是否垃圾”(mark)和”...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">数量关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">示例分析：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%8E%B0%E8%B1%A1\"><span class=\"toc-text\">现象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">原因</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua Table Parser","uid":"f8bbaae048c871aa32045f351e18ec1c","slug":"zl/2016-01-01-750_Lua Table Parser","date":"2024-04-03T03:47:35.998Z","updated":"2024-04-03T03:47:35.999Z","comments":true,"path":"api/articles/zl/2016-01-01-750_Lua Table Parser.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"PyLuaTblParser类中有两个私有变量： self.str_praser是类LuaStrParser的实例，用来实现lua字符串的解析。 self.lua_table是一个dict或者list，用来储存从lua table字符串或者其他dict中读取的数据。 接口1234...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua + OpenResty修改response body","uid":"dc71cb9137d51b75049c4c21396aceac","slug":"zl/2016-01-01-749_Lua + OpenResty修改response body","date":"2024-04-03T03:47:35.996Z","updated":"2024-04-03T03:47:35.997Z","comments":true,"path":"api/articles/zl/2016-01-01-749_Lua + OpenResty修改response body.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 最近公司前端框架组提了个需求，希望修改response中的一个css文件，去掉一个样式：max-width:1632px;。于是便想到了利用lua。 OpenResty lua编程相关资料 OpenResty Readme OpenResty最佳实践 其中Readme要看完，是...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}