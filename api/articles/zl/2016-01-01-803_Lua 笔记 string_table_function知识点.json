{"title":"Lua 笔记 string_table_function知识点","uid":"431d049b9392ba7cebe4f6692937578c","slug":"zl/2016-01-01-803_Lua 笔记 string_table_function知识点","date":"2024-04-03T03:47:36.049Z","updated":"2024-04-03T03:47:36.050Z","comments":true,"path":"api/articles/zl/2016-01-01-803_Lua 笔记 string_table_function知识点.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>本文涉及到一些关于<code>string</code>、<code>table</code>和<code>function</code>的细碎知识点，一些常用操作的背后逻辑。本文是用于记录一次技术分享，部分内容与<a href=\"../2018-09-13-lua-notes-03\">之前的一篇Lua的笔记</a>有重叠。</p>\n<p>本文参考和使用的lua源码基于Lua 5.3.5，编写的lua脚本运行于OSX系统，使用的是64位的lua运行库。</p>\n<h3 id=\"评估方法\"><a href=\"#评估方法\" class=\"headerlink\" title=\"评估方法\"></a>评估方法</h3><p>纯lua侧的对于代码执行耗时的评估和执行过程中产生的堆内存的分析。</p>\n<h4 id=\"时间分析\"><a href=\"#时间分析\" class=\"headerlink\" title=\"时间分析\"></a>时间分析</h4><p>对应于cpu负载，借助<code>os.clock()</code>函数，以下是一个示例：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> a, b</span><br/><span class=\"line\">a = <span class=\"built_in\">os</span>.<span class=\"built_in\">clock</span>()</span><br/><span class=\"line\"></span><br/><span class=\"line\">b = <span class=\"built_in\">os</span>.<span class=\"built_in\">clock</span>()</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(b-a)</span><br/></pre></td></tr></tbody></table></figure>\n<h4 id=\"空间分析\"><a href=\"#空间分析\" class=\"headerlink\" title=\"空间分析\"></a>空间分析</h4><p>对应于内存占用，借助<code>collectgarbage()</code>函数，这个函数传入不同的参数可以对lua的gc机制进行不同的操作控制，具体不再展开，这里主要是对堆内存的占用进行评估，用到的是以下的一套组合三连，即先强制一轮完整的gc（<code>collect</code>），然后禁用gc（<code>stop</code>），在执行完一些待测试的代码之后获取对内存占用的千字节数（<code>count</code>）：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">collectgarbage</span>(<span class=\"string\">&#34;collect&#34;</span>)</span><br/><span class=\"line\"><span class=\"built_in\">collectgarbage</span>(<span class=\"string\">&#34;stop&#34;</span>)</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">collectgarbage</span>(<span class=\"string\">&#34;count&#34;</span>))</span><br/></pre></td></tr></tbody></table></figure>\n<p>来一个简单的gc演示，三次获取堆内存，分配前、分配后、gc后：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">collectgarbage</span>(<span class=\"string\">&#34;collect&#34;</span>)</span><br/><span class=\"line\"><span class=\"built_in\">collectgarbage</span>(<span class=\"string\">&#34;stop&#34;</span>)</span><br/><span class=\"line\"><span class=\"keyword\">local</span> a = <span class=\"built_in\">collectgarbage</span>(<span class=\"string\">&#34;count&#34;</span>) * <span class=\"number\">1024</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">local</span> t = {}</span><br/><span class=\"line\">t = <span class=\"literal\">nil</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">local</span> b = <span class=\"built_in\">collectgarbage</span>(<span class=\"string\">&#34;count&#34;</span>) * <span class=\"number\">1024</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"built_in\">collectgarbage</span>(<span class=\"string\">&#34;collect&#34;</span>)</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">local</span> c = <span class=\"built_in\">collectgarbage</span>(<span class=\"string\">&#34;count&#34;</span>) * <span class=\"number\">1024</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#34;before alloc &#34;</span> .. a)</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#34;after alloc &#34;</span> .. b)</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#34;after collect &#34;</span> .. c)</span><br/></pre></td></tr></tbody></table></figure>\n<p>上边输出的内容，a和c是相等的，b会多出来56个字节（这是一个空表的内存占用）。</p>\n<h3 id=\"通用的lua类型\"><a href=\"#通用的lua类型\" class=\"headerlink\" title=\"通用的lua类型\"></a>通用的lua类型</h3><h4 id=\"值类型\"><a href=\"#值类型\" class=\"headerlink\" title=\"值类型\"></a>值类型</h4><p>Lua中通用的值类型，<code>TValue</code>，使用一个联合体保存数据，和一个枚举值区分该值的类型，定义在<code>lobject.h</code>第100行：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br/><span class=\"line\"><span class=\"comment\">** Union of all Lua values</span></span><br/><span class=\"line\"><span class=\"comment\">*/</span></span><br/><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> Value {</span><br/><span class=\"line\">  GCObject *gc;    <span class=\"comment\">/* collectable objects */</span></span><br/><span class=\"line\">  <span class=\"keyword\">void</span> *p;         <span class=\"comment\">/* light userdata */</span></span><br/><span class=\"line\">  <span class=\"keyword\">int</span> b;           <span class=\"comment\">/* booleans */</span></span><br/><span class=\"line\">  lua_CFunction f; <span class=\"comment\">/* light C functions */</span></span><br/><span class=\"line\">  lua_Integer i;   <span class=\"comment\">/* integer numbers */</span></span><br/><span class=\"line\">  lua_Number n;    <span class=\"comment\">/* float numbers */</span></span><br/><span class=\"line\">} Value;</span><br/><span class=\"line\"></span><br/><span class=\"line\"></span><br/><span class=\"line\"></span><br/><span class=\"line\"></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>  {</span></span><br/><span class=\"line\">  TValuefields;</span><br/><span class=\"line\">} TValue;</span><br/></pre></td></tr></tbody></table></figure>\n<h4 id=\"GC信息\"><a href=\"#GC信息\" class=\"headerlink\" title=\"GC信息\"></a>GC信息</h4><p>gc相关的通用数据，table、string和function都是受gc管理的类型，它们的结构中都是以一个<code>CommonHeader</code>开始，其定义如下：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br/><span class=\"line\"><span class=\"comment\">** Common type for all collectable objects</span></span><br/><span class=\"line\"><span class=\"comment\">*/</span></span><br/><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GCObject</span> <span class=\"title\">GCObject</span>;</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"comment\">/*</span></span><br/><span class=\"line\"><span class=\"comment\">** Common Header for all collectable objects (in macro form, to be</span></span><br/><span class=\"line\"><span class=\"comment\">** included in other objects)</span></span><br/><span class=\"line\"><span class=\"comment\">*/</span></span><br/><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CommonHeader  GCObject *next; lu_byte tt; lu_byte marked</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"comment\">/*</span></span><br/><span class=\"line\"><span class=\"comment\">** Common type has only the common header</span></span><br/><span class=\"line\"><span class=\"comment\">*/</span></span><br/><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GCObject</span> {</span></span><br/><span class=\"line\">  CommonHeader;</span><br/><span class=\"line\">};</span><br/></pre></td></tr></tbody></table></figure>\n<h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><p>先从一段简单短Lua代码开始，尝试得到一个空字符串<code>&#34;&#34;</code>所占用的堆内存：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">collectgarbage</span>(<span class=\"string\">&#34;collect&#34;</span>)</span><br/><span class=\"line\"><span class=\"built_in\">collectgarbage</span>(<span class=\"string\">&#34;stop&#34;</span>)</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"comment\">-- -------------------------------------------------------</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">local</span> before = <span class=\"built_in\">collectgarbage</span>(<span class=\"string\">&#34;count&#34;</span>)</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">local</span> s = <span class=\"built_in\">table</span>.<span class=\"built_in\">concat</span>({})</span><br/><span class=\"line\"><span class=\"built_in\">collectgarbage</span>(<span class=\"string\">&#34;collect&#34;</span>)</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"comment\">-- -------------------------------------------------------</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">local</span> after = <span class=\"built_in\">collectgarbage</span>(<span class=\"string\">&#34;count&#34;</span>)</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"number\">1024</span> * (after - before))</span><br/></pre></td></tr></tbody></table></figure>\n<p>输出25，即一个空字符串会产生25字节的堆内存。此处之所以使用<code>table.concat(&#123;&#125;)</code>而不是直接使用<code>&#34;&#34;</code>，是因为代码中直接存在的字面字符串不会再单独分配堆内存。</p>\n<p>来看一看一个空字符串的25个字节分别是什么内容，并以此为基础计算任意一个字符串占用的内存。</p>\n<h4 id=\"结构和定义\"><a href=\"#结构和定义\" class=\"headerlink\" title=\"结构和定义\"></a>结构和定义</h4><p>字符串的类型的定义在lobject.h第303行。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br/><span class=\"line\"><span class=\"comment\">** Header for string value; string bytes follow the end of this structure</span></span><br/><span class=\"line\"><span class=\"comment\">** (aligned according to &#39;UTString&#39;; see next).</span></span><br/><span class=\"line\"><span class=\"comment\">*/</span></span><br/><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TString</span> {</span></span><br/><span class=\"line\">  CommonHeader;</span><br/><span class=\"line\">  lu_byte extra;  <span class=\"comment\">/* reserved words for short strings; &#34;has hash&#34; for longs */</span></span><br/><span class=\"line\">  lu_byte shrlen;  <span class=\"comment\">/* length for short strings */</span></span><br/><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> hash;</span><br/><span class=\"line\">  <span class=\"keyword\">union</span> {</span><br/><span class=\"line\">    <span class=\"keyword\">size_t</span> lnglen;  <span class=\"comment\">/* length for long strings */</span></span><br/><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TString</span> *<span class=\"title\">hnext</span>;</span>  <span class=\"comment\">/* linked list for hash table */</span></span><br/><span class=\"line\">  } u;</span><br/><span class=\"line\">} TString;</span><br/></pre></td></tr></tbody></table></figure>\n<p>为确保内存对齐使用结构体<code>UTString</code>又套了一层：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br/><span class=\"line\"><span class=\"comment\">** Ensures that address after this type is always fully aligned.</span></span><br/><span class=\"line\"><span class=\"comment\">*/</span></span><br/><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> UTString {</span><br/><span class=\"line\">  L_Umaxalign dummy;  <span class=\"comment\">/* ensures maximum alignment for strings */</span></span><br/><span class=\"line\">  TString tsv;</span><br/><span class=\"line\">} UTString;</span><br/></pre></td></tr></tbody></table></figure>\n<p>在<code>lstring.c</code>中有创建字符串的函数：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br/><span class=\"line\"><span class=\"comment\">** creates a new string object</span></span><br/><span class=\"line\"><span class=\"comment\">*/</span></span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> TString *<span class=\"title\">createstrobj</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">size_t</span> l, <span class=\"keyword\">int</span> tag, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> h)</span> </span>{</span><br/><span class=\"line\">  TString *ts;</span><br/><span class=\"line\">  GCObject *o;</span><br/><span class=\"line\">  <span class=\"keyword\">size_t</span> totalsize;  <span class=\"comment\">/* total size of TString object */</span></span><br/><span class=\"line\">  totalsize = sizelstring(l);</span><br/><span class=\"line\">  o = luaC_newobj(L, tag, totalsize);</span><br/><span class=\"line\">  ts = gco2ts(o);</span><br/><span class=\"line\">  ts-&gt;hash = h;</span><br/><span class=\"line\">  ts-&gt;extra = <span class=\"number\">0</span>;</span><br/><span class=\"line\">  getstr(ts)[l] = <span class=\"string\">&#39;","text":"本文涉及到一些关于string、table和function的细碎知识点，一些常用操作的背后逻辑。本文是用于记录一次技术分享，部分内容与之前的一篇Lua的笔记有重叠。 本文参考和使用的lua源码基于Lua 5.3.5，编写的lua脚本运行于OSX系统，使用的是64位的lua运行库...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">评估方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90\"><span class=\"toc-text\">时间分析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E9%97%B4%E5%88%86%E6%9E%90\"><span class=\"toc-text\">空间分析</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E7%94%A8%E7%9A%84lua%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">通用的lua类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%80%BC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">值类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#GC%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">GC信息</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#string\"><span class=\"toc-text\">string</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E5%92%8C%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">结构和定义</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua 基础知识学习总结","uid":"060da8645a00461af7b72af4a548a081","slug":"zl/2016-01-01-805_lua 基础知识学习总结","date":"2024-04-03T03:47:36.050Z","updated":"2024-04-03T03:47:36.050Z","comments":true,"path":"api/articles/zl/2016-01-01-805_lua 基础知识学习总结.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 一、lua 基本语法 二、lua 数据类型及操作 lua 学习总结文档 一、lua 基本语法 二、lua 数据类型及操作 lua 是动态类型语言，变量无需声明定义，可以直接进行赋值操作。主要包含如下表格中的数据类型： nil：表示一个无效值 boolean：包含两个值：fals...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua学习2","uid":"69b9fe694fff5591e06878257f99671e","slug":"zl/2016-01-01-802_lua学习2","date":"2024-04-03T03:47:36.048Z","updated":"2024-04-03T03:47:36.048Z","comments":true,"path":"api/articles/zl/2016-01-01-802_lua学习2.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"语句Lua支持多重赋值，就是可以将多个值同时赋值给多个变量。 123456a, b = 3, &#39;a&#39;x ,y = y, x #一行语句进行交换变量a, b, c = 1, 2print(a, b, c) a, b = 1, 2, 3print(a, b) --&g...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}