{"title":"Lua作图教程之设计模式","uid":"f5fa6c4f2499c0d40f721be59caa4a29","slug":"zl/2016-01-01-441_Lua作图教程之设计模式","date":"2024-04-03T03:47:35.726Z","updated":"2024-04-03T03:47:35.726Z","comments":true,"path":"api/articles/zl/2016-01-01-441_Lua作图教程之设计模式.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前段时间学校游戏开发课大作业，做了一个Roguelike的恐怖游戏。搜集整理了一些迷宫生成的算法。</p>\n<p>当初也受了indienova上一些文章的启发。现在在此把学到的一些东西理一理分享出来。</p>\n<p>第一次写这种东西，感觉有点啰嗦，还请大家不要介意，也可以直接看项目地址\n代码写在Unity环境下，应该可以直接使用。</p>\n<h3 id=\"第一种算法\"><a href=\"#第一种算法\" class=\"headerlink\" title=\"第一种算法\"></a>第一种算法</h3><p>先上一张图</p>\n<p><img src=\"https://www.indienova.com/farm/blog/2016/10/1348-1477897147.png\" alt=\"\"/></p>\n<p>这是我最早拍脑袋凭着感觉写的一个算法结果，给定区域长宽和分支概率，可以生成一张迷宫图。</p>\n<p>这完全就是随机挖洞大法，其步骤如下：</p>\n<p>计算当前扫描点周围可以挖的方块\n随机选一个方块挖开\n若周围还有可挖方块，按分支概率随机挖开另一方块，设为新扫描点\n所有扫描点执行 1 操作\n若周围无方块可挖，中止此扫描点工作。\n可以看出，这个算法有相当的缺陷，生成的迷宫总面积不可控，在运气不好的极端情况下，会产生比预期面积小很多的迷宫。\n即使我们将分支概率调到100%，依旧会有黑色的空洞存在：</p>\n<p><img src=\"https://www.indienova.com/farm/blog/2016/10/1348-1477897232.png\" alt=\"\"/>\n    而且生成的迷宫非常扭曲怪诞，这很克苏鲁。或许我们可以风格化一下……</p>\n<p>此时的迷宫已经勉强可以使用，但是与传统迷宫的差别依旧非常大。\n它的斜线非常多。这会使得游戏过程中包含八个方向，对玩家的方向感是极大的考验，很难再记住地图，容易晕头转向。</p>\n<p>对于这个算法，相比室内环境，更适合生成自然环境下迷宫。也可以作为无主线、弱主线沙盘游戏的大地图生成的一环。</p>\n<h3 id=\"递归分割\"><a href=\"#递归分割\" class=\"headerlink\" title=\"递归分割\"></a>递归分割</h3><p>接下来这个算法与第一个就是两个极端——生成完全没有斜线的迷宫。\n话不多说，先上图：</p>\n<p><img src=\"https://www.indienova.com/farm/blog/2016/10/1348-1477897328.png\" alt=\"\"/></p>\n<p>在介绍本算法前，需要提出一个概念</p>\n<p>完美迷宫Perfect maze：没有回路，也没有孤立区域的迷宫。用图论来解释，就是可以用生成树表示的迷宫，迷宫中两点有且仅有一条路径。</p>\n<p>这个算法是一个分治算法，即将一块大的生成区域分成4块小区域分别生成迷宫并保证联通，以此类推，直到不可细分。</p>\n<p>分块很简单，长宽上各取一个随机数即可。如何保证迷宫完美呢？\n我们看极端情况，对于一个田字形区域，生成完美迷宫的方法是敲开三堵墙。</p>\n<p>利用分治算法的特性，每一层递归都是完美迷宫，直到全图生成完美迷宫。\n算法不难，注意递归状态的边界情况就行。</p>\n<p>这种分治递归的痕迹在生成的地图俯视图上很明显，但对于置身其中的玩家或许就不是了。</p>\n<p>它生成的迷宫完全没有斜线，横平竖直，同时会生成4*4的小房间。\n用作城市地图、或建筑环境的迷宫非常合适。</p>\n<p>当然在游戏中地图没有回路是非常致命的，一个完美迷宫会让玩家疲于奔命，并不方便设计玩法。\n对于回路，我们只需要消除死路就行了，也就是那些三面临墙的格子，在地图生成完后遍历死路，按一定概率打通即可。</p>\n<h3 id=\"生成树算法-Kruskal-amp-Prim\"><a href=\"#生成树算法-Kruskal-amp-Prim\" class=\"headerlink\" title=\"生成树算法 Kruskal &amp; Prim\"></a>生成树算法 Kruskal &amp; Prim</h3><p>绝大多数的编程问题都可以用数学工具解决，当然我们的迷宫生成算法也不例外。\n数学中最适合表达迷宫的符号莫过于 图，下面两个算法是迷宫生成中应用最普遍的理论之二。</p>\n<p>首先我们需要将地图转换为便于数学表达的形式。\n之前两个算法在处理地图时都是以 方块 为单位的，即每一个方块不是墙就是路。\n而 图 的基本组成是 点 与 边 ，对于一个待处理的迷宫，我们做如下转换。</p>\n<p><img src=\"https://www.indienova.com/farm/blog/2016/10/1348-1477897403.png\" alt=\"\"/></p>\n<p>迷宫大小10*10，其中白块代表 点，红块代表 边，而黑块代表 虚无，只是填充物质罢了。</p>\n<p>如果一个 图 中，任意两 点 都能通过 边 组成的路径联通，称之为 连通图。</p>\n<p>而如果一个 连通图 上没有回路，则我们可以称之为 树，因为没有回路，所以每对点之间有且仅有一条路径联通。</p>\n<p>可以看到，树 与我们完美迷宫的概念不谋而合，所以现在我们的任务是找到包含所有点的一棵 树。</p>\n<h3 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h3><p>生成树，顾名思义，就是从给定的 点,边 集合中生成一棵符合要求的树。\n下面介绍的两种最小生成树算法都可以胜任。</p>\n<p>虽然写作最小生成树，但这两个算法其实可以做到“按一定条件生成树”。\n“最小”是算法的典型描述，即在有权边的集合中找出权值最小的树。原算法使用贪心算法求解。</p>\n<p>而在这里，我们的条件就是：随机。</p>\n<p>下面简单介绍一下这两个算法的步骤：</p>\n<p>两个算法都需要 点 的集合E,与 边 的集合V。对于上图，E代表所有白块，V代表所有红块</p>\n<p>Kruskal：\n一开始每个点将自己作为单独的一棵树。</p>\n<p>从V中随机选出一条边v\n判断v两端的e1，e2是否属于一棵生成树\n是，无动作\n否，绘制e1,v,e2并合并树\n从V中删除v\n当V不为空，则返回 1. ，V为空则完成\nps:判断与合并两点所在树可以使用并查集相关算法，在项目代码中UFset类就是并查集的c#实现之一</p>\n<p>这里简单讲下并查集，并查集是指一些不相交集合的 合并 与 查询 问题，</p>\n<p>对应到我们迷宫问题中就是：合并不相连的生成树、查找两点是否属于同一个生成树。</p>\n<p>并查集使用了一种称为 路径压缩 的算法，使得所有子节点的父节点均指向跟根节点。</p>\n<p>虽然压缩算法是为了提高合并效率，但压缩算法本身时间复杂度也是O(n)，所以我们只在查询一个节点时，才对此节点所在路径进行压缩，并且在合并时，将小树并入大树，以平衡效率。</p>\n<p>经过优化的并查集合并算法时间复杂度可达神奇的常数级，比起之前的全图标记不知道高到哪里去了，证明就在此略过，有兴趣的同学可以去深入学习一下。</p>\n<p>===============</p>\n<p>Prim：初始V为空，所有e∈E标记为0</p>\n<p>随机选一个点e\n将与e相连的边的集合{Ve}并入入V，e标记为1\n从V中随机选一条边v\n判断v两端情况\n均为1：无动作\n一个0一个1：将为0的点e标记为1，绘制v,e,将e连接的边并入V\n均为0：不可能\n从V中删除v\n当所有e∈E均被标记为1，结束，否则返回 3. 。\nps:可以维护一个包含所有v∈V的标记表，防止被重复并入V，提高效率</p>\n<p>以上为算法步骤，建议配合代码食用更佳。</p>\n<p>下为运行结果</p>\n<p><img src=\"https://www.indienova.com/farm/blog/2016/10/1348-1477898027.png\" alt=\"\"/></p>\n<p>前者为Kruskal，后者为Prim。白路黑墙。</p>\n<p>可以看到两个算法的生成迷宫风格几乎一样，并且都较为接近传统迷宫。可以用于各类需要迷宫生成的游戏。</p>\n<p>值得一提的是这两个算法都可以加入房间，只需将房间预先生成，在将剩余可生成的点与边的集合放入算法中运行即可。\n关于这个详细可以参考房间和迷宫：一个地牢生成算法</p>\n<p>到这里关于游戏中迷宫生成最常用的几个算法已经写完了。除了上述几种以外，迷宫的生成方法还深度广度优先搜索之类很多。\n此外还有诸多适用于特定游戏系统的地图生成算法，如MC中的噪音，Unexplored中的环状地图等</p>","text":"前言前段时间学校游戏开发课大作业，做了一个Roguelike的恐怖游戏。搜集整理了一些迷宫生成的算法。 当初也受了indienova上一些文章的启发。现在在此把学到的一些东西理一理分享出来。 第一次写这种东西，感觉有点啰嗦，还请大家不要介意，也可以直接看项目地址 代码写在Unit...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E7%A7%8D%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">第一种算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92%E5%88%86%E5%89%B2\"><span class=\"toc-text\">递归分割</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95-Kruskal-amp-Prim\"><span class=\"toc-text\">生成树算法 Kruskal &amp; Prim</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91\"><span class=\"toc-text\">最小生成树</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 排序算法","uid":"18c65ae79c1521b9ec150d64b8237a42","slug":"zl/2016-01-01-440_Lua 排序算法 ","date":"2024-04-03T03:47:35.726Z","updated":"2024-04-03T03:47:35.726Z","comments":true,"path":"api/articles/zl/2016-01-01-440_Lua 排序算法 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。 分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。 算法步骤 从数列中...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"fblualib在ubuntu 16.04上的安装","uid":"9bdf61dad7f856cb09cdbc9f72522e92","slug":"zl/2016-01-01-43_fblualib在ubuntu 16.04上的安装","date":"2024-04-03T03:47:35.725Z","updated":"2024-04-03T03:47:35.726Z","comments":true,"path":"api/articles/zl/2016-01-01-43_fblualib在ubuntu 16.04上的安装.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"最近需要复现一下CRNN的结果，因为自己实现的版本点数不够高，所以需要跑一下人家的代码。一共有两个依赖，一个是TORCH，这个好装，另一个是fblualib，这个项目已经停止维护了，真的是跳了无数个坑，这里做一个记录。最后也只能跑inference不能train BTW. 但是对...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}