{"title":"lua","uid":"df60e476b394b1dd4755ec96c53302ff","slug":"zl/2016-01-01-932_lua","date":"2024-04-03T03:47:36.205Z","updated":"2024-04-03T03:47:36.206Z","comments":true,"path":"api/articles/zl/2016-01-01-932_lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h3 id=\"元表-类似操作符重载\">元表（类似操作符重载）</h3>\n<p><a href=\"https://moonbingbing.gitbooks.io/openresty-best-practices/content/\" title=\"title text\">OpenResty 最佳实践</a></p>\n<h5 id=\"lua-提供的所有操作符都可以被重载\">Lua 提供的所有操作符都可以被重载：</h5>\n<p>元方法 含义\n“<strong>add” + 操作\n“</strong>sub” - 操作 其行为类似于 “add” 操作\n“<strong>mul” * 操作 其行为类似于 “add” 操作\n“</strong>div” / 操作 其行为类似于 “add” 操作\n“<strong>mod” % 操作 其行为类似于 “add” 操作\n“</strong>pow” ^ （幂）操作 其行为类似于 “add” 操作\n“<strong>unm” 一元 - 操作\n“</strong>concat”  .. （字符串连接）操作\n“<strong>len” # 操作\n“</strong>eq”  == 操作 函数 getcomphandler 定义了 Lua 怎样选择一个处理器来作比较操作 仅在两个对象类型相同且有对应操作相同的元方法时才起效\n“<strong>lt”  &lt; 操作\n“</strong>le”  &lt;= 操作</p>\n<h5 id=\"除了操作符之外-如下元方法也可以被重载-下面会依次解释使用方法\">除了操作符之外，如下元方法也可以被重载，下面会依次解释使用方法：</h5>\n<p>元方法 含义\n“<strong>index”   取下标操作用于访问 table[key]\n“</strong>newindex”    赋值给指定下标 table[key] = value\n“<strong>tostring”    转换成字符串\n“</strong>call”    当 Lua 调用一个值时调用\n“<strong>mode”    用于弱表(week table)\n“</strong>metatable”   用于保护metatable不被访问</p>\n<h5 id=\"index-元方法\">__index 元方法</h5>\n<p>下面的例子中，我们实现了在表中查找键不存在时转而在元表中查找该键的功能：</p>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tbody><tr><td class=\"lntd\">\n<pre class=\"chroma\"><span class=\"lnt\"> 1\n</span><span class=\"lnt\"> 2\n</span><span class=\"lnt\"> 3\n</span><span class=\"lnt\"> 4\n</span><span class=\"lnt\"> 5\n</span><span class=\"lnt\"> 6\n</span><span class=\"lnt\"> 7\n</span><span class=\"lnt\"> 8\n</span><span class=\"lnt\"> 9\n</span><span class=\"lnt\">10\n</span><span class=\"lnt\">11\n</span><span class=\"lnt\">12\n</span></pre></td>\n<td class=\"lntd\">\n<pre class=\"chroma\">mytable = setmetatable({key1 = &#34;value1&#34;},   --原始表\n  {__index = function(self, key)            --重载函数\n    if key == &#34;key2&#34; then\n      return &#34;metatablevalue&#34;\n    end\n  end\n})\n<p>print(mytable.key1,mytable.key2)  –&gt; output：value1 metatablevalue<br />\n关于 __index 元方法，有很多比较高阶的技巧，例如：__index 的元方法不需要非是一个函数，他也可以是一个表。<br />\nt = setmetatable({[1] = &quot;hello&quot;}, {__index = {[2] = &quot;world&quot;}})<br />\nprint(t[1], t[2])   –&gt;hello world</pre></td></tr></tbody></table></p>\n</div>\n</div>\n<h5 id=\"call-元方法\">__call 元方法</h5>\n<p>__call 元方法的功能类似于 C++ 中的仿函数，使得普通的表也可以被调用。</p>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tbody><tr><td class=\"lntd\">\n<pre class=\"chroma\"><span class=\"lnt\">1\n</span><span class=\"lnt\">2\n</span><span class=\"lnt\">3\n</span><span class=\"lnt\">4\n</span><span class=\"lnt\">5\n</span><span class=\"lnt\">6\n</span><span class=\"lnt\">7\n</span><span class=\"lnt\">8\n</span><span class=\"lnt\">9\n</span></pre></td>\n<td class=\"lntd\">\n<pre class=\"chroma\">functor = {}\nfunction func1(self, arg)\n  print (&#34;called from&#34;, arg)\nend\n<p>setmetatable(functor, {__call = func1})</p>\n<p>functor(&quot;functor&quot;)  –&gt; called from functor<br />\nprint(functor)      –&gt; output：0x00076fc8 （后面这串数字可能不一样）</pre></td></tr></tbody></table></p>\n</div>\n</div>\n<h3 id=\"面向对象编程\">面向对象编程</h3>\n<hr/>\n<h5 id=\"类\">类</h5>\n<p>account.lua</p>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tbody><tr><td class=\"lntd\">\n<pre class=\"chroma\"><span class=\"lnt\"> 1\n</span><span class=\"lnt\"> 2\n</span><span class=\"lnt\"> 3\n</span><span class=\"lnt\"> 4\n</span><span class=\"lnt\"> 5\n</span><span class=\"lnt\"> 6\n</span><span class=\"lnt\"> 7\n</span><span class=\"lnt\"> 8\n</span><span class=\"lnt\"> 9\n</span><span class=\"lnt\">10\n</span><span class=\"lnt\">11\n</span><span class=\"lnt\">12\n</span><span class=\"lnt\">13\n</span><span class=\"lnt\">14\n</span><span class=\"lnt\">15\n</span><span class=\"lnt\">16\n</span><span class=\"lnt\">17\n</span><span class=\"lnt\">18\n</span><span class=\"lnt\">19\n</span><span class=\"lnt\">20\n</span><span class=\"lnt\">21\n</span><span class=\"lnt\">22\n</span></pre></td>\n<td class=\"lntd\">\n<pre class=\"chroma\">local _M = {}\n<p>local mt = { __index = _M }</p>\n<p>function _M.deposit (self, v)<br />\nself.balance = self.balance + v<br />\nend</p>\n<p>function _M.withdraw (self, v)<br />\nif self.balance &gt; v then<br />\nself.balance = self.balance - v<br />\nelse<br />\nerror(&quot;insufficient funds&quot;)<br />\nend<br />\nend</p>\n<p>function _M.new (self, balance)<br />\nbalance = balance or 0<br />\nreturn setmetatable({balance = balance}, mt)<br />\nend</p>\n<p>return _M</pre></td></tr></tbody></table></p>\n</div>\n</div>\n<p>引用代码示例：</p>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tbody><tr><td class=\"lntd\">\n<pre class=\"chroma\"><span class=\"lnt\"> 1\n</span><span class=\"lnt\"> 2\n</span><span class=\"lnt\"> 3\n</span><span class=\"lnt\"> 4\n</span><span class=\"lnt\"> 5\n</span><span class=\"lnt\"> 6\n</span><span class=\"lnt\"> 7\n</span><span class=\"lnt\"> 8\n</span><span class=\"lnt\"> 9\n</span><span class=\"lnt\">10\n</span></pre></td>\n<td class=\"lntd\">\n<pre class=\"chroma\">local account = require(&#34;account&#34;)\n<p>local a = account:new()<br />\na:deposit(100)</p>\n<p>local b = account:new()<br />\nb:deposit(50)</p>\n<p>print(a.balance)  –&gt; output: 100<br />\nprint(b.balance)  –&gt; output: 50</pre></td></tr></tbody></table></p>\n</div>\n</div>\n<h5 id=\"继承\">继承</h5>\n<h5 id=\"判断为空\">判断为空</h5>\n<p>因此，我们要判断一个 table 是否为 {}，不能采用 #table == 0 的方式来判断。可以用下面这样的方法来判断：</p>\n<div class=\"highlight\"><div class=\"chroma\">\n<table class=\"lntable\"><tbody><tr><td class=\"lntd\">\n<pre class=\"chroma\"><span class=\"lnt\">1\n</span><span class=\"lnt\">2\n</span><span class=\"lnt\">3\n</span></pre></td>\n<td class=\"lntd\">\n<pre class=\"chroma\"> function isTableEmpty(t)\n    return t == nil or next(t) == nil\nend</pre></td></tr></tbody></table>\n</div>\n</div>","text":"元表（类似操作符重载） OpenResty 最佳实践 Lua 提供的所有操作符都可以被重载： 元方法 含义 “add” + 操作 “sub” - 操作 其行为类似于 “add” 操作 “mul” * 操作 其行为类似于 “add” 操作 “div” / 操作 其行为类似于 “ad...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%83%E8%A1%A8-%E7%B1%BB%E4%BC%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">元表（类似操作符重载）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#lua-%E6%8F%90%E4%BE%9B%E7%9A%84%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%83%BD%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">Lua 提供的所有操作符都可以被重载：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%99%A4%E4%BA%86%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%E5%A4%96-%E5%A6%82%E4%B8%8B%E5%85%83%E6%96%B9%E6%B3%95%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E8%BD%BD-%E4%B8%8B%E9%9D%A2%E4%BC%9A%E4%BE%9D%E6%AC%A1%E8%A7%A3%E9%87%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">除了操作符之外，如下元方法也可以被重载，下面会依次解释使用方法：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#index-%E5%85%83%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">__index 元方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#call-%E5%85%83%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">__call 元方法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">面向对象编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%B1%BB\"><span class=\"toc-text\">类</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">继承</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E4%B8%BA%E7%A9%BA\"><span class=\"toc-text\">判断为空</span></a></li></ol></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua学习笔记（六）","uid":"159171ab2db2dcc9927fd3c20c0193d9","slug":"zl/2016-01-01-931_lua学习笔记（六）","date":"2024-04-03T03:47:36.205Z","updated":"2024-04-03T03:47:36.205Z","comments":true,"path":"api/articles/zl/2016-01-01-931_lua学习笔记（六）.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua面向对象封装123456789101112131415161718192021222324252627282930People={isHumen=true} -- 此处定义的元素都是相当于C++的静态成员变量-- 基类方法newfunction (o,n,a) o=o or...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua","uid":"15b0cdc6d03f6c3f6bf8d3a7ff197317","slug":"zl/2016-01-01-930_Lua","date":"2024-04-03T03:47:36.204Z","updated":"2024-04-03T03:47:36.205Z","comments":true,"path":"api/articles/zl/2016-01-01-930_Lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"思考并回答以下问题： 交互基础环境配置点击下载点击下载 LuaInterface.dll：在C#代码中操作Lua代码需要依赖该文件；luanet.dll：在Lua代码中访问C#的类库脚本需要依赖该文件。 1、将两个dll文件拷贝到C#项目工程中；2、项目工程设置“引用”导入Lua...","link":"","photos":[],"count_time":{"symbolsCount":220,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}