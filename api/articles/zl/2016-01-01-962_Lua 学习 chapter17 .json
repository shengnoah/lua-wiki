{"title":"Lua 学习 chapter17","uid":"71d4be5e48e9da5655b092bfb309953f","slug":"zl/2016-01-01-962_Lua 学习 chapter17 ","date":"2024-04-03T03:47:36.230Z","updated":"2024-04-03T03:47:36.230Z","comments":true,"path":"api/articles/zl/2016-01-01-962_Lua 学习 chapter17 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h3 id=\"目录\">目录</h3>\n<ol>\n  <li>require函数</li>\n  <li>模块</li>\n  <li>搜索路径</li>\n  <li>搜索器</li>\n  <li>子模块和包</li>\n</ol>\n<blockquote>\n  <p>Continue, come on.</p>\n</blockquote>\n<h2 id=\"require函数\">require函数</h2>\n<p>ruquire函数可以加载任意模块，然后创建和返回一个表.</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n</pre></td><td class=\"rouge-code\"><pre><span class=\"kd\">local</span> <span class=\"n\">mod</span> <span class=\"o\">=</span> <span class=\"nb\">require</span> <span class=\"s2\">&#34;mod&#34;</span>\n<span class=\"n\">mod</span><span class=\"p\">.</span><span class=\"n\">foo</span><span class=\"p\">()</span>\n<p><span class=\"kd\">local</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"nb\">require</span> <span class=\"s2\">&quot;mod&quot;</span><br />\n<span class=\"kd\">local</span> <span class=\"n\">f1</span> <span class=\"o\">=</span> <span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">foo</span><br />\n<span class=\"n\">f1</span><span class=\"p\">()</span></p>\n<p><span class=\"kd\">local</span> <span class=\"n\">f2</span> <span class=\"o\">=</span> <span class=\"nb\">require</span> <span class=\"s2\">&quot;mod&quot;</span><span class=\"p\">.</span><span class=\"n\">foo</span><br />\n<span class=\"n\">f2</span><span class=\"p\">()</span><br />\n</pre></td></tr></tbody></table></code></pre></div></div></p>\n<p>require 函数在表package.loaded中检查模块是否已经被加载过。如果加载过就返回相应的值，这就避免的重复的加载。没有加载，就会通过loadfile来对其进行加载。如果没有lua文件，就回去加载c标准库，使用底层函数package.loadlib进行加载。</p>\n<p>如果加载函数有返回值，那么函数require会返回合格值，将其保存在packag.loaded中，如果没有返回值，且package.loaded[@rep{moduname}]为空，函数require就假设该模块的返回值是true。如果不存在这种，补偿会造成重复加载。</p>\n<p>要强制加载同一模块两次，可以先将模块从package.loaded中删除：package.loaded.modname = nil.</p>\n<p>对require的测试：</p>\n<p>首先我们在moduleTest.lua中声明全局的一个table，但是并不返回，这个时候我们发现package.loaded表中存了moduleTset的键，值为true，然后我们取消注释return的哪一行，发现loaded表中存的就是Pack这张全局表的内存地址了。</p>\n<p>require是存在返回值的，如果是复杂的类型，会直接返回这个复杂类型的地址。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n</pre></td><td class=\"rouge-code\"><pre><span class=\"c1\">--moduleTest.lua</span>\n<span class=\"n\">Pack</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span>\n<span class=\"k\">function</span> <span class=\"nc\">Pack</span><span class=\"p\">.</span><span class=\"nf\">Print</span><span class=\"p\">()</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&#34;lua 好恶心！&#34;</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n<span class=\"n\">Pack</span><span class=\"p\">.</span><span class=\"n\">Print</span><span class=\"p\">()</span>\n<span class=\"c1\">--return Pack</span>\n<p><span class=\"c1\">–main.lua</span><br />\n<span class=\"kd\">local</span> <span class=\"n\">test</span> <span class=\"o\">=</span> <span class=\"nb\">require</span><span class=\"p\">(</span><span class=\"s2\">&quot;moduleTest&quot;</span><span class=\"p\">)</span><br />\n<span class=\"n\">Pack</span><span class=\"p\">.</span><span class=\"n\">Print</span><span class=\"p\">()</span></p>\n<p><span class=\"kd\">local</span> <span class=\"n\">pa</span> <span class=\"o\">=</span> <span class=\"nb\">package.loaded</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">pa</span><span class=\"p\">)</span><br />\n</pre></td></tr></tbody></table></code></pre></div></div></p>\n<h2 id=\"模块\">模块</h2>\n<p>在lua中，简单的使用模块的方式就是使用表将所有属性放到这个表中（可以封装成类），然后最后返回这个表。</p>\n<p>如果不想返回的话，可以以选择给package.loaded[M] = M。赋值的方法。</p>\n<p>模块是可以重新命名的，直接将返回的值赋值给另一个就行了。</p>\n<h2 id=\"搜索路径\">搜索路径</h2>\n<p>在搜索一个lua文件时，函数require使用的路径和典型的路径略有不同。典型的路径是很多目录组成的列表，并在其中搜索指定的文件。不过 ISO C（Lua语言依赖的抽象平台）并没有目录的概念。所以，函数require使用的路径是一组模板，其中的每项都制定了模板名（函数require的参数）转换为文件名的方式。更确切的说，这种路径中的每一个模板都是一个包含可选问好的文件名。对于每一个模板，函数require会用模板名来替换每一个问号，然后检查是否存在对应的文件。路径中的模板以在大多数操作系统中很少用于文件名的分号隔开。</p>\n<p>package.searchpath中实现了搜索库的所有规则，该函数的参数包括模板名和路径，然后遵循上述规则来搜索文件。</p>\n<h2 id=\"搜索器\">搜索器</h2>\n<p>在现实中，require比此前描述过得稍微复杂一些，搜索lua文件和c标准库的方式只是更加通用的搜索器的两个实例。一个搜索器是以一个以模块名为参数，以对应的模块的加载器或nil(找不到)为返回值的简单函数。</p>\n<p>预加载（preload)搜索器使得我们能够为要加载的木块定义任意的加载函数。预加载搜索器使用一个名为package.preload的表来映射模块名称和加载函数。当搜索执行的木块名时，改搜索器只是简单地在表中搜索指定的名称。如果他找到了对应的函数，那么就将该函数作为相应模块的加载函数返回，否则，返回nil。</p>\n<h2 id=\"子模块和包\">子模块和包</h2>\n<p>lua支持具有层次结构的模块名，通过点来分隔名称中的层次。例如，一个名为mod.sub的模块是模块mod的一个子模块。一个包是一颗由模块组成的完整的树，它是lua语言中用于发行程序的单位。</p>\n<p>当加载一个名为mod.sub的模块的时候，函数require依次使用原始的模块名“mod.sub”作为键来查询表package.loaded和package.preload。这里，模块中的点像模块名中的其他字符一样，没有特殊含义。</p>\n<pre><code>            &lt;hr style=&quot;visibility: hidden;&quot;/&gt;\n            \n            &lt;hr style=&quot;visibility: hidden;&quot;/&gt;\n</code></pre>\n","text":"目录 require函数 模块 搜索路径 搜索器 子模块和包 Continue, come on. require函数 ruquire函数可以加载任意模块，然后创建和返回一个表. 1 2 3 4 5 6 7 8 9 local mod = require &#34;mod&#34...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">目录</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#require%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">require函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">模块</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">搜索路径</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%90%9C%E7%B4%A2%E5%99%A8\"><span class=\"toc-text\">搜索器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%90%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85\"><span class=\"toc-text\">子模块和包</span></a>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua","uid":"df60e476b394b1dd4755ec96c53302ff","slug":"zl/2016-01-01-967_lua","date":"2024-04-03T03:47:36.231Z","updated":"2024-04-03T03:47:36.231Z","comments":true,"path":"api/articles/zl/2016-01-01-967_lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"lua-resty-lrucache深入解析lua-resty-lrucache是openresty里常用的缓存，是一个worker级别的缓存，也是一个最近最少使用的缓存，下面我们来具体分析它的实现过程。 使用示例123456789101112131415161718192021...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua学习笔记二","uid":"050df29370421b502767448007b1cff3","slug":"zl/2016-01-01-964_Lua学习笔记二","date":"2024-04-03T03:47:36.230Z","updated":"2024-04-03T03:47:36.230Z","comments":true,"path":"api/articles/zl/2016-01-01-964_Lua学习笔记二.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"while1234while(条件)do 循环体end 代码示例及结果： 123456a = 0while(a &lt; 10)do print(a) a = a + 1end 123456789100123456789 for123for var=值1,值2,值2 do 循环体...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}