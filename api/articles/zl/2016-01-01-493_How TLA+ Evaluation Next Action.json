{"title":"How TLA+ Evaluation Next Action","uid":"7b74eee658976f909b993b4a5d56b4c3","slug":"zl/2016-01-01-493_How TLA+ Evaluation Next Action","date":"2024-04-03T03:47:35.776Z","updated":"2024-04-03T03:47:35.776Z","comments":true,"path":"api/articles/zl/2016-01-01-493_How TLA+ Evaluation Next Action.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"tlc是如何计算状态的\">TLC是如何计算状态的</h2>\n<p>当TLC计算一个invariant，直接计算值，返回TRUE/FALSE\n当TLC计算Init和Next，返回一个状态集合（这个集合被加入到sq中）:</p>\n<ol>\n  <li>Init: 所有可能的初始状态；</li>\n  <li>Next：所有可能的后继状态；</li>\n</ol>\n<h2 id=\"tlc如何计算next\">TLC如何计算Next</h2>\n<ul>\n  <li>状态：是对变量的赋值；</li>\n  <li>TLC计算一个状态s的后继状态：\n    <ol>\n      <li>对所有unprimed变量进行赋值；</li>\n      <li>对所有的primed变量赋值为null；</li>\n      <li>开始计算next Action；</li>\n    </ol>\n  </li>\n  <li>TLC在计算Next Action和普通的表达式是不同的</li>\n</ul>\n<h3 id=\"第一个不同点\">第一个不同点</h3>\n<ul>\n  <li>TLC对‘或’表达式并不是从左到右计算：\n    <ul>\n      <li>当计算 A1 / … / An，首先拆分成n个子表达式；</li>\n      <li>当计算E x in S : p，对于S中的每个元素，拆分成若干个子表达式；</li>\n      <li>P =&gt; Q，等价于(非P) / Q</li>\n    </ul>\n  </li>\n  <li>\n    <p>举个例子</p>\n<pre><code>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  (A =&amp;gt; B) / ( C / (E i in S : D(i) / E)) \n</code></pre>\n<p></code></pre></div>    </div></p>\n<pre><code>&lt;p&gt;拆分成3个子表达式：&lt;/p&gt;\n\n&lt;ol&gt;\n  &lt;li&gt;非A；&lt;/li&gt;\n  &lt;li&gt;B；&lt;/li&gt;\n  &lt;li&gt;C / (E i in S : D(i) / E)；&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;计算第3个表达式的过程是：&lt;/p&gt;\n\n&lt;ol&gt;\n  &lt;li&gt;计算C&lt;/li&gt;\n  &lt;li&gt;如果C为TRUE，把后边的E i in S : D(i) / E 根据S中的元素i拆分成多个表达式D(i) / E;&lt;/li&gt;\n  &lt;li&gt;计算D(i) / E时，应用同样的规则，先计算D(i)&lt;/li&gt;\n  &lt;li&gt;\n    &lt;p&gt;如果D(i)为TRUE，计算E&lt;/p&gt;\n\n    &lt;p&gt;# 第二个不同点&lt;/p&gt;\n  &lt;/li&gt;\n&lt;/ol&gt;\n</code></pre>\n  </li>\n  <li>如何计算primed变量\n    <ul>\n      <li>计算x’ = e时，首先把x’赋值为null，然后计算e的值给x’，返回TRUE；</li>\n      <li>计算x’ in S，等价于 E v in S : x’ = v;</li>\n      <li>UNCHANGED«e1, … , en»，等价于 (UNCHANGED e1) / … / (UNCHANGED en)</li>\n    </ul>\n  </li>\n  <li>当primed变量没有被赋值时会报错；</li>\n  <li>当一个‘与’返回FALSE，这个子表达式计算就停止了，没有找到任何状态；</li>\n  <li>当一个表达式计算完毕，就找到一些状态，这些状态就是primed变量的赋值；</li>\n</ul>\n<h2 id=\"一个具体的例子\">一个具体的例子</h2>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/ / x&#39; in 1..Len(y)\n\t/ y&#39; = Append(Tail(y), x&#39;)\n/ / x&#39; = x + 1\n\t/ y&#39; = Append(y, x&#39;)\n</code></pre></div></div>\n<ul>\n  <li>假设Init初始化之后的状态是： x = 1, y = «2, 3»\n    <ul>\n      <li>由于最外层是两个‘或’，TLC把表达式拆分成两个子表达式；</li>\n      <li>计算第一个子表达式：x’ in 1..Len(y) / y’ = Append(Tail(y), x’) 这个表达式一个‘与’因此从左往右依次计算，由于Len(y)为2，因此，这个表达式被拆成两个:\n        <ul>\n          <li>第一个：\n            <div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  / x&#39; = 1\n  / y&#39; = Append(Tail(y), x&#39;)\n</code></pre></div>            </div>\n            <p>得到x = 1, y = «3, 1»</p>\n          </li>\n          <li>第二个：\n            <div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  / x&#39; = 2\n  / y&#39; = Append(Tail(y), x&#39;)\n</code></pre></div>            </div>\n            <p>得到x = 2, y = «3, 2»</p>\n          </li>\n        </ul>\n      </li>\n      <li>计算第二个子表达式：这是一个‘与’表达式，从左往右依次计算两个\n        <ul>\n          <li>计算第一个x = 2</li>\n          <li>计算第二个y = «2, 3, 2»</li>\n        </ul>\n      </li>\n      <li>整个Next的后继状态一共有3个。</li>\n    </ul>\n  </li>\n  <li>假设Init初始化之后的状态是： x = 1, y = « »\n    <ul>\n      <li>由于最外层是两个‘或’，TLC把表达式拆分成两个子表达式；</li>\n      <li>\n        <p>计算第一个子表达式：<code class=\"highlighter-rouge\">x&#39; in 1..Len(y) / y&#39; = Append(Tail(y), x&#39;)</code>\n  由于Len(y)为0，第一个‘与’的子表达式：</p>\n<pre><code>    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  / x&amp;#39; in 1..0\n</code></pre>\n<p>/ y' = Append(Tail(y), x')<br />\n</code></pre></div>        </div><br />\n</li><br />\n</ul></p>\n<pre><code>&lt;p&gt;拆分后为：&lt;/p&gt;\n\n&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  / i in &#123;&#125; : x&amp;#39; = i\n</code></pre>\n<p>/ y' = Append(Tail(y), x')<br />\n</code></pre></div>    </div></p>\n<pre><code>&lt;p&gt;这个表达式是一个‘与’，从左往右依次计算，第一个表达式返回FALSE，计算终止&lt;/p&gt;\n&lt;ul&gt;\n  &lt;li&gt;计算第二个子表达式：\n    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  / x&amp;#39; = 2\n</code></pre>\n<p>/ y' = Append(Tail(y), x')<br />\n</code></pre></div>        </div><br />\n<p>得到 x = 2, y = «2, 2»</p><br />\n</li><br />\n<li>整个Next的后继状态一共有1个。</li><br />\n</ul></p>\n  </li>\n</ul>\n<p>​</p>\n<p>​</p>","text":"TLC是如何计算状态的 当TLC计算一个invariant，直接计算值，返回TRUE/FALSE 当TLC计算Init和Next，返回一个状态集合（这个集合被加入到sq中）: Init: 所有可能的初始状态； Next：所有可能的后继状态； TLC如何计算Next 状态：是对变量...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#tlc%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%8A%B6%E6%80%81%E7%9A%84\"><span class=\"toc-text\">TLC是如何计算状态的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#tlc%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97next\"><span class=\"toc-text\">TLC如何计算Next</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">第一个不同点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E5%85%B7%E4%BD%93%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">一个具体的例子</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Goto in LuaJIT","uid":"e23987c7aeae824b7623d6980f8e24cf","slug":"zl/2016-01-01-498_Goto in LuaJIT ","date":"2024-04-03T03:47:35.777Z","updated":"2024-04-03T03:47:35.777Z","comments":true,"path":"api/articles/zl/2016-01-01-498_Goto in LuaJIT .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua 在 5.2 之后的版本，加入了 goto 这个关键字，用来控制程序跳转到指定 label。我们可以利用这个特性，来模拟 continue 的实现。需要注意的是 goto 只能跳转到 label，而 ::name:: 的格式就可以设置一个 label。 for i=1,5 ...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua 排序算法","uid":"18c65ae79c1521b9ec150d64b8237a42","slug":"zl/2016-01-01-494_Lua 排序算法 ","date":"2024-04-03T03:47:35.776Z","updated":"2024-04-03T03:47:35.776Z","comments":true,"path":"api/articles/zl/2016-01-01-494_Lua 排序算法 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。 分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。 算法步骤 从数列中...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}