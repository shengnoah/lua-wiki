{"title":"leetcode_evaluate reverse polish notation","uid":"cd02f84ff363f602a2040ccb9523f02c","slug":"zl/2016-01-01-1069_leetcode_evaluate reverse polish notation","date":"2024-04-03T03:47:32.988Z","updated":"2024-04-03T03:47:32.989Z","comments":true,"path":"api/articles/zl/2016-01-01-1069_leetcode_evaluate reverse polish notation.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"Evaluate-Reverse-Polish-Notation\"><a href=\"#Evaluate-Reverse-Polish-Notation\" class=\"headerlink\" title=\"Evaluate Reverse Polish Notation\"></a><a href=\"https://leetcode.com/problems/evaluate-reverse-polish-notation/\" target=\"_blank\" rel=\"noopener noreferrer\">Evaluate Reverse Polish Notation</a></h2><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression.<br/>（计算逆波兰表达式）</p>\n<p><strong>Note:</strong></p>\n<ol>\n<li>Division between two integers should truncate toward zero.</li>\n<li>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.</li>\n</ol>\n<p><strong>Example:</strong> </p>\n<div align=\"center\"><br/>    <img src=\"https://sara-hy.github.io//images/leetcode_150.png\" width=\"500\" align=\"center/\"/><br/></div>\n<h3 id=\"1-栈\"><a href=\"#1-栈\" class=\"headerlink\" title=\"1. 栈\"></a>1. 栈</h3><p>使用堆栈来计算逆波兰表达式。其中需要注意的是，题目中要求除法运算没有整除时要向 0 靠近，因此在两个异号的数相除时，应该 + 1 处理，或者转换为正数除法再加负号。具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/><span class=\"line\">26</span><br/><span class=\"line\">27</span><br/><span class=\"line\">28</span><br/><span class=\"line\">29</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"params\">(object)</span>:</span></span><br/><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">evalRPN</span><span class=\"params\">(self, tokens)</span>:</span></span><br/><span class=\"line\">        <span class=\"string\">&#34;&#34;&#34;</span></span><br/><span class=\"line\"><span class=\"string\">        :type tokens: List[str]</span></span><br/><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br/><span class=\"line\"><span class=\"string\">        &#34;&#34;&#34;</span></span><br/><span class=\"line\">        stack = []</span><br/><span class=\"line\">        </span><br/><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(tokens)):</span><br/><span class=\"line\">            <span class=\"keyword\">if</span> tokens[i] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> [<span class=\"string\">&#39;+&#39;</span>, <span class=\"string\">&#39;-&#39;</span>, <span class=\"string\">&#39;*&#39;</span>, <span class=\"string\">&#39;/&#39;</span>]:</span><br/><span class=\"line\">                stack.append(int(tokens[i]))</span><br/><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br/><span class=\"line\">                right = stack.pop()</span><br/><span class=\"line\">                left = stack.pop()</span><br/><span class=\"line\">                <span class=\"keyword\">if</span> tokens[i] == <span class=\"string\">&#39;+&#39;</span>:</span><br/><span class=\"line\">                    stack.append(left + right)</span><br/><span class=\"line\">                <span class=\"keyword\">elif</span> tokens[i] == <span class=\"string\">&#39;-&#39;</span>:</span><br/><span class=\"line\">                    stack.append(left - right)</span><br/><span class=\"line\">                <span class=\"keyword\">elif</span> tokens[i] == <span class=\"string\">&#39;*&#39;</span>:</span><br/><span class=\"line\">                    stack.append(left * right)</span><br/><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br/><span class=\"line\">                    </span><br/><span class=\"line\">                    <span class=\"keyword\">if</span> left * right &lt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> left % right != <span class=\"number\">0</span>:</span><br/><span class=\"line\">                        stack.append(left / right + <span class=\"number\">1</span>)</span><br/><span class=\"line\">                        <span class=\"comment\"># stack.append(-(abs(left) / abs(right)))</span></span><br/><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br/><span class=\"line\">                        stack.append(left / right)</span><br/><span class=\"line\">        </span><br/><span class=\"line\">        <span class=\"keyword\">return</span> stack[<span class=\"number\">-1</span>]</span><br/></pre></td></tr></tbody></table></figure>","text":"Evaluate Reverse Polish NotationEvaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. E...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Evaluate-Reverse-Polish-Notation\"><span class=\"toc-text\">Evaluate Reverse Polish Notation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%A0%88\"><span class=\"toc-text\">1. 栈</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"pil.29lua中调用c函数","uid":"cbf9954abb954dd3c2fb5a3a5b929873","slug":"zl/2016-01-01-1068_pil.29lua中调用c函数","date":"2024-04-03T03:47:32.988Z","updated":"2024-04-03T03:47:32.988Z","comments":true,"path":"api/articles/zl/2016-01-01-1068_pil.29lua中调用c函数.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"我们在说Lua调用C函数的时候，不是说Lua可以调用所有的C函数，我们必须在传递参数和获得结果之间遵从一些协议。同时，必须要注册C函数，也就是说，要以合适的方式给Lua这个函数的地址。 我们先来看一个简单的函数： static int (lua_State *L) { doubl...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua串行化_序列化serialization（串行流_字节流）","uid":"e6c25c0816865cc394aa2881e93b5bd7","slug":"zl/2016-01-01-1064_lua串行化_序列化serialization（串行流_字节流）","date":"2024-04-03T03:47:32.987Z","updated":"2024-04-03T03:47:32.987Z","comments":true,"path":"api/articles/zl/2016-01-01-1064_lua串行化_序列化serialization（串行流_字节流）.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"杂乱字符串转义显示处理-- 匹配符方式 string.format -- [=[...]=]方式 a = &#39;a &#34;program lua [[ ]]]]&#34;&#39; print(string.format(&#39;%q&#39;,a)) serializ...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}