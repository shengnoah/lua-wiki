{"title":"lua支持init64","uid":"9485aec3aa9494e98d0fdf9b67a599c4","slug":"zl/2016-01-01-523_lua支持init64","date":"2024-04-03T03:47:35.796Z","updated":"2024-04-03T03:47:35.797Z","comments":true,"path":"api/articles/zl/2016-01-01-523_lua支持init64.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>lua5.3提供了很多很好的特性例如string.pack unpack这样的好东西，同时还支持ini64.在lua之前的版本中number只有一种类型double.对于init64基本按照int来处理. 对于64位的解决方案有很多种,基本的思路都是使用8byte的string或者lightuserdata或者userdata修改元表来实现.</p>\n<h4 id=\"luajit使用userdata重载元表运算符实现\"><a href=\"#luajit使用userdata重载元表运算符实现\" class=\"headerlink\" title=\"luajit使用userdata重载元表运算符实现\"></a>luajit使用userdata重载元表运算符实现</h4><p>在 luajit 中,是定义了一个 userdata 并重载其运算符完成的。用 <code>ffi.cast(&#34;int64_t&#34;,0)</code> 来构造一个 64bit 的 0 .userdata的做法存在额外开销问题，当 64bit 的 cdata 做 table 的 key 的时候，相同值的 int64 并不是同一个 key .</p>\n<h4 id=\"lightuserdata-设置-metatable实现\"><a href=\"#lightuserdata-设置-metatable实现\" class=\"headerlink\" title=\"lightuserdata 设置 metatable实现\"></a>lightuserdata 设置 metatable实现</h4><p>用 lightuserdata 无损失的表示一个 int64 ,lightuserdata是一个轻量级的cdata,通过给 lightuserdata 设置 metatable ，我们可以重载它的数据运算。存在的问题:比较一个 int64 和普通的 lua number 是否相等时，lua 不能隐式的做转换。目前使用这个方案的实现的已经有了,github上有<a href=\"https://github.com/bytemode/lua-int64.git这个库是云风大神实现的\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/bytemode/lua-int64.git这个库是云风大神实现的</a>.</p>\n<p>这个库只提供了一个显式的 api ，即构造一个 int64 数字。可以从 lua number 构造，也支持从一个 8 字节宽的小头的字符串来构造。实际在内存储存的是一个 lightuserdata 即一个 64bit 指针（所以这个库不适用于 32 位平台）。你也可以通过 C 接口 <code>lua_pushlightuserdata</code> 来把一个 64bit 整数压入堆栈。把 int64 转换为普通的 lua number 借用了 # 操作符。</p>\n<pre><code>#include &lt;lua.h&gt;\n#include &lt;lauxlib.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdbool.h&gt;\n<p>static int64_t<br />\n_int64(lua_State *L, int index) &#123;<br />\nint type = lua_type(L,index);<br />\nint64_t n = 0;<br />\nswitch(type) &#123;<br />\ncase LUA_TNUMBER: &#123;<br />\nlua_Number d = lua_tonumber(L,index);<br />\nn = (int64_t)d;<br />\nbreak;<br />\n&#125;<br />\ncase LUA_TSTRING: &#123;<br />\nsize_t len = 0;<br />\nconst uint8_t * str = (const uint8_t <em>)lua_tolstring(L, index, &amp;len);<br />\nif (len&gt;8) &#123;<br />\nreturn luaL_error(L, &quot;The string (length = %d) is not an int64 string&quot;, len);<br />\n&#125;<br />\nint i = 0;<br />\nuint64_t n64 = 0;<br />\nfor (i=0;i&lt;(int)len;i++) &#123;<br />\nn64 |= (uint64_t)str[i] &lt;&lt; (i</em>8);<br />\n&#125;<br />\nn = (int64_t)n64;<br />\nbreak;<br />\n&#125;<br />\ncase LUA_TLIGHTUSERDATA: &#123;<br />\nvoid * p = lua_touserdata(L,index);<br />\nn = (intptr_t)p;<br />\nbreak;<br />\n&#125;<br />\ndefault:<br />\nreturn luaL_error(L, &quot;argument %d error type %s&quot;, index, lua_typename(L,type));<br />\n&#125;<br />\nreturn n;<br />\n&#125;</p>\n<p>static inline void<br />\n_pushint64(lua_State *L, int64_t n) &#123;<br />\nvoid * p = (void *)(intptr_t)n;<br />\nlua_pushlightuserdata(L,p);<br />\n&#125;</p>\n<p>static int<br />\nint64_add(lua_State *L) &#123;<br />\nint64_t a = _int64(L,1);<br />\nint64_t b = _int64(L,2);<br />\n_pushint64(L, a+b);</p>\n<pre><code>return 1;\n</code></pre>\n<p>}</p>\n<p>static int<br />\nint64_sub(lua_State *L) {<br />\nint64_t a = _int64(L,1);<br />\nint64_t b = _int64(L,2);<br />\n_pushint64(L, a-b);</p>\n<pre><code>return 1;\n</code></pre>\n<p>}</p>\n<p>static int<br />\nint64_mul(lua_State *L) {<br />\nint64_t a = _int64(L,1);<br />\nint64_t b = _int64(L,2);<br />\n_pushint64(L, a * b);</p>\n<pre><code>return 1;\n</code></pre>\n<p>}</p>\n<p>static int<br />\nint64_div(lua_State *L) {<br />\nint64_t a = _int64(L,1);<br />\nint64_t b = _int64(L,2);<br />\nif (b == 0) {<br />\nreturn luaL_error(L, &quot;div by zero&quot;);<br />\n}<br />\n_pushint64(L, a / b);</p>\n<pre><code>return 1;\n</code></pre>\n<p>}</p>\n<p>static int<br />\nint64_mod(lua_State *L) {<br />\nint64_t a = _int64(L,1);<br />\nint64_t b = _int64(L,2);<br />\nif (b == 0) {<br />\nreturn luaL_error(L, &quot;mod by zero&quot;);<br />\n}<br />\n_pushint64(L, a % b);</p>\n<pre><code>return 1;\n</code></pre>\n<p>}</p>\n<p>static int64_t<br />\n_pow64(int64_t a, int64_t b) {<br />\nif (b == 1) {<br />\nreturn a;<br />\n}<br />\nint64_t a2 = a * a;<br />\nif (b % 2 == 1) {<br />\nreturn _pow64(a2, b/2) * a;<br />\n} else {<br />\nreturn _pow64(a2, b/2);<br />\n}<br />\n}</p>\n<p>static int<br />\nint64_pow(lua_State *L) {<br />\nint64_t a = _int64(L,1);<br />\nint64_t b = _int64(L,2);<br />\nint64_t p;<br />\nif (b &gt; 0) {<br />\np = _pow64(a,b);<br />\n} else if (b == 0) {<br />\np = 1;<br />\n} else {<br />\nreturn luaL_error(L, &quot;pow by nagtive number %d&quot;,(int)b);<br />\n}<br />\n_pushint64(L, p);</p>\n<pre><code>return 1;\n</code></pre>\n<p>}</p>\n<p>static int<br />\nint64_unm(lua_State *L) {<br />\nint64_t a = _int64(L,1);<br />\n_pushint64(L, -a);<br />\nreturn 1;<br />\n}</p>\n<p>static int<br />\nint64_new(lua_State *L) {<br />\nint top = lua_gettop(L);<br />\nint64_t n;<br />\nswitch(top) {<br />\ncase 0 :<br />\nlua_pushlightuserdata(L,NULL);<br />\nbreak;<br />\ncase 1 :<br />\nn = _int64(L,1);<br />\n_pushint64(L,n);<br />\nbreak;<br />\ndefault: {<br />\nint base = luaL_checkinteger(L,2);<br />\nif (base &lt; 2) {<br />\nluaL_error(L, &quot;base must be &gt;= 2&quot;);<br />\n}<br />\nconst char * str = luaL_checkstring(L, 1);<br />\nn = strtoll(str, NULL, base);<br />\n_pushint64(L,n);<br />\nbreak;<br />\n}<br />\n}<br />\nreturn 1;<br />\n}</p>\n<p>static int<br />\nint64_eq(lua_State *L) {<br />\nint64_t a = _int64(L,1);<br />\nint64_t b = _int64(L,2);<br />\nprintf(&quot;%s %sn&quot;,lua_typename(L,1),lua_typename(L,2));<br />\nprintf(&quot;%ld %ldn&quot;,a,b);<br />\nlua_pushboolean(L,a == b);<br />\nreturn 1;<br />\n}</p>\n<p>static int<br />\nint64_lt(lua_State *L) {<br />\nint64_t a = _int64(L,1);<br />\nint64_t b = _int64(L,2);<br />\nlua_pushboolean(L,a &lt; b);<br />\nreturn 1;<br />\n}</p>\n<p>static int<br />\nint64_le(lua_State *L) {<br />\nint64_t a = _int64(L,1);<br />\nint64_t b = _int64(L,2);<br />\nlua_pushboolean(L,a &lt;= b);<br />\nreturn 1;<br />\n}</p>\n<p>static int<br />\nint64_len(lua_State *L) {<br />\nint64_t a = _int64(L,1);<br />\nlua_pushnumber(L,(lua_Number)a);<br />\nreturn 1;<br />\n}</p>\n<p>static int<br />\ntostring(lua_State <em>L) {<br />\nstatic char hex[16] = &quot;0123456789ABCDEF&quot;;<br />\nuintptr_t n = (uintptr_t)lua_touserdata(L,1);<br />\nif (lua_gettop(L) == 1) {<br />\nluaL_Buffer b;<br />\nluaL_buffinitsize(L , &amp;b , 28);<br />\nluaL_addstring(&amp;b, &quot;int64: 0x&quot;);<br />\nint i;<br />\nbool strip = true;<br />\nfor (i=15;i&gt;=0;i–) {<br />\nint c = (n &gt;&gt; (i</em>4)) &amp; 0xf;<br />\nif (strip &amp;&amp; c ==0) {<br />\ncontinue;<br />\n}<br />\nstrip = false;<br />\nluaL_addchar(&amp;b, hex[c]);<br />\n}<br />\nif (strip) {<br />\nluaL_addchar(&amp;b , '0');<br />\n}<br />\nluaL_pushresult(&amp;b);<br />\n} else {<br />\nint base = luaL_checkinteger(L,2);<br />\nint shift , mask;<br />\nswitch(base) {<br />\ncase 0: {<br />\nunsigned char buffer[8];<br />\nint i;<br />\nfor (i=0;i&lt;8;i++) {<br />\nbuffer[i] = (n &gt;&gt; (i*8)) &amp; 0xff;<br />\n}<br />\nlua_pushlstring(L,(const char *)buffer, 8);<br />\nreturn 1;<br />\n}<br />\ncase 10: {<br />\nint64_t dec = (int64_t)n;<br />\nluaL_Buffer b;<br />\nluaL_buffinitsize(L , &amp;b , 28);<br />\nif (dec&lt;0) {<br />\nluaL_addchar(&amp;b, '-');<br />\ndec = -dec;<br />\n}<br />\nint buffer[32];<br />\nint i;<br />\nfor (i=0;i&lt;32;i++) {<br />\nbuffer[i] = dec%10;<br />\ndec /= 10;<br />\nif (dec == 0)<br />\nbreak;<br />\n}<br />\nwhile (i&gt;=0) {<br />\nluaL_addchar(&amp;b, hex[buffer[i]]);<br />\n–i;<br />\n}<br />\nluaL_pushresult(&amp;b);<br />\nreturn 1;<br />\n}<br />\ncase 2:<br />\nshift = 1;<br />\nmask = 1;<br />\nbreak;<br />\ncase 8:<br />\nshift = 3;<br />\nmask = 7;<br />\nbreak;<br />\ncase 16:<br />\nshift = 4;<br />\nmask = 0xf;<br />\nbreak;<br />\ndefault:<br />\nluaL_error(L, &quot;Unsupport base %d&quot;,base);<br />\nbreak;<br />\n}<br />\nint i;<br />\nchar buffer[64];<br />\nfor (i=0;i&lt;64;i+=shift) {<br />\nbuffer[i/shift] = hex[(n&gt;&gt;(64-shift-i)) &amp; mask];<br />\n}<br />\nlua_pushlstring(L, buffer, 64 / shift);<br />\n}<br />\nreturn 1;<br />\n}</p>\n<p>static void<br />\nmake_mt(lua_State *L) {<br />\nluaL_Reg lib[] = {<br />\n{ &quot;__add&quot;, int64_add },<br />\n{ &quot;__sub&quot;, int64_sub },<br />\n{ &quot;__mul&quot;, int64_mul },<br />\n{ &quot;__div&quot;, int64_div },<br />\n{ &quot;__mod&quot;, int64_mod },<br />\n{ &quot;__unm&quot;, int64_unm },<br />\n{ &quot;__pow&quot;, int64_pow },<br />\n{ &quot;__eq&quot;, int64_eq },<br />\n{ &quot;__lt&quot;, int64_lt },<br />\n{ &quot;__le&quot;, int64_le },<br />\n{ &quot;__len&quot;, int64_len },<br />\n{ &quot;__tostring&quot;, tostring },<br />\n{ NULL, NULL },<br />\n};<br />\nluaL_newlib(L,lib);<br />\n}</p>\n<p>int<br />\nluaopen_int64(lua_State *L) {<br />\nif (sizeof(intptr_t)!=sizeof(int64_t)) {<br />\nreturn luaL_error(L, &quot;Only support 64bit architecture&quot;);<br />\n}<br />\nlua_pushlightuserdata(L,NULL);<br />\nmake_mt(L);<br />\nlua_setmetatable(L,-2);<br />\nlua_pop(L,1);</p>\n<pre><code>lua_newtable(L);\nlua_pushcfunction(L, int64_new);\nlua_setfield(L, -2, &amp;#34;new&amp;#34;);\nlua_pushcfunction(L, tostring);\nlua_setfield(L, -2, &amp;#34;tostring&amp;#34;);\n\nreturn 1;\n</code></pre>\n<p>}</p>\n<p></code></pre></p>\n","text":"lua5.3提供了很多很好的特性例如string.pack unpack这样的好东西，同时还支持ini64.在lua之前的版本中number只有一种类型double.对于init64基本按照int来处理. 对于64位的解决方案有很多种,基本的思路都是使用8byte的string或...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#luajit%E4%BD%BF%E7%94%A8userdata%E9%87%8D%E8%BD%BD%E5%85%83%E8%A1%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">luajit使用userdata重载元表运算符实现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#lightuserdata-%E8%AE%BE%E7%BD%AE-metatable%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">lightuserdata 设置 metatable实现</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua程序设计（0）","uid":"41764cff92c84a96a528bcb8bddcc07c","slug":"zl/2016-01-01-522_Lua程序设计（0）","date":"2024-04-03T03:47:35.796Z","updated":"2024-04-03T03:47:35.796Z","comments":true,"path":"api/articles/zl/2016-01-01-522_Lua程序设计（0）.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua程序设计的第一篇，主要内容是基本语法以及运算符。 交互模式：在交互模式下，Lua语言解释器如果发现我们输入的某一行不完整，会等待知道程序块或表达式被输入完整后再进行解释执行。 我们可以使用-i参数让Lua语言解释器在执行完制定的程序段之后进入交互模式。 % lua -i p...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Sol2实现Cpp和Lua绑定","uid":"a0aa244da9b5db84b7a7c09b4e0b028c","slug":"zl/2016-01-01-518_Sol2实现Cpp和Lua绑定","date":"2024-04-03T03:47:35.795Z","updated":"2024-04-03T03:47:35.795Z","comments":true,"path":"api/articles/zl/2016-01-01-518_Sol2实现Cpp和Lua绑定.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;a href=&quot;/2018/06/17/cpp11_raw_string/&quot; rel=&quot;next&quot; title=&quot;C++11的Raw String Literals&quot;&gt; &lt;i class=&quot...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}