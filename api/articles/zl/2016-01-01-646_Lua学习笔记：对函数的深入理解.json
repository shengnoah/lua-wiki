{"title":"Lua学习笔记：对函数的深入理解","uid":"a4dc0fff7f26a0411253a4f7cb25eca6","slug":"zl/2016-01-01-646_Lua学习笔记：对函数的深入理解","date":"2024-04-03T03:47:35.865Z","updated":"2024-04-03T03:47:35.869Z","comments":true,"path":"api/articles/zl/2016-01-01-646_Lua学习笔记：对函数的深入理解.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<div class=\"content\" itemprop=\"articleBody\">\n    <h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><ul>\n<li><strong>lua中的函数都可以认为是闭包，只不过为了便于理解还是用了函数的概念。</strong></li>\n<li><strong>lua中函数的返回值可以是匿名函数，也就是闭包。以下面的代码为例，提出一个概念：非局部的变量。在下面的代码中，匿名函数访问了一个变量i，它对于newCount来说是局部变量，对于匿名函数来说是既不是局部变量也不是全局变量，在lua中这个称谓非局部的变量。</strong></li>\n<li><strong>在lua中一个闭包指的是一个函数和该函数所需要访问的非局部的变量。lua会把它们看做是一个整体，因此在下面的代码中多次允许c1和c2，会发现变量i是在递增的。这是因为c1 = newCount()这句代码相当于给c1赋值了一个闭包，它包含了i这个变量。因此多次执行相当于就是在反复执行一个对象，这样i就一直是原来那个i。</strong></li>\n</ul>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span></span><br/><span class=\"line\">\t<span class=\"keyword\">local</span> i =<span class=\"number\">0</span></span><br/><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span></span><br/><span class=\"line\">\t\ti=i+<span class=\"number\">1</span></span><br/><span class=\"line\">\t\t<span class=\"built_in\">print</span>(i)</span><br/><span class=\"line\">\t<span class=\"keyword\">end</span></span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\">c1 = newCount()</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(c1())</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(c1())</span><br/><span class=\"line\"></span><br/><span class=\"line\">c2 = newCount()</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(c2())</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(c2())</span><br/><span class=\"line\"><span class=\"built_in\">print</span>(c1())</span><br/><span class=\"line\"></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"number\">1</span></span><br/><span class=\"line\"><span class=\"number\">2</span></span><br/><span class=\"line\"><span class=\"number\">1</span></span><br/><span class=\"line\"><span class=\"number\">2</span></span><br/><span class=\"line\"><span class=\"number\">3</span></span><br/></pre></td></tr></tbody></table></figure>\n<h2 id=\"闭包的沙盒\"><a href=\"#闭包的沙盒\" class=\"headerlink\" title=\"闭包的沙盒\"></a>闭包的沙盒</h2><ul>\n<li><strong>下面这段代码中，修改了math库的sin方法。类似的还可以用来处理一些不安全的代码，这样的方式类似沙盒，将不安全包装了起来。</strong><figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">math</span>.<span class=\"built_in\">sin</span>(<span class=\"number\">45</span>))</span><br/><span class=\"line\"></span><br/><span class=\"line\">oldSin = <span class=\"built_in\">math</span>.<span class=\"built_in\">sin</span></span><br/><span class=\"line\"><span class=\"built_in\">math</span>.<span class=\"built_in\">sin</span> = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(x)</span></span></span><br/><span class=\"line\">\t<span class=\"keyword\">return</span> oldSin(x*<span class=\"built_in\">math</span>.<span class=\"built_in\">pi</span>/<span class=\"number\">180</span>)</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">math</span>.<span class=\"built_in\">sin</span>(<span class=\"number\">45</span>))</span><br/></pre></td></tr></tbody></table></figure>\n</li>\n</ul>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p><strong>直接使用非全局的函数递归会报错，如下代码，会报：<code>attempt to call global &#39;foo&#39; (a nil value)</code>这个是因为在调用foo(x-1)时，这个foo函数还没有定义完，因此表达式在尝试调用一个全局的函数foo，但是显然这个全局函数是不存在的。</strong></p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(x)</span></span></span><br/><span class=\"line\">\t<span class=\"keyword\">if</span> x == <span class=\"number\">1</span> <span class=\"keyword\">then</span></span><br/><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br/><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> x*foo(x<span class=\"number\">-1</span>)</span><br/><span class=\"line\">\t<span class=\"keyword\">end</span></span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"built_in\">print</span>(foo(<span class=\"number\">3</span>))</span><br/></pre></td></tr></tbody></table></figure>\n<p><strong>正确写法</strong></p>\n<pre><code class=\"lua\"><span class=\"keyword\">local</span> foo\nfool = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(x)</span></span>\n    <span class=\"keyword\">if</span> x == <span class=\"number\">1</span> <span class=\"keyword\">then</span>\n        <span class=\"keyword\">return</span> <span class=\"number\">1</span>\n    <span class=\"keyword\">else</span>\n        <span class=\"keyword\">return</span> x*foo(x<span class=\"number\">-1</span>)    \n    <span class=\"keyword\">end</span>\n<span class=\"keyword\">end</span>\n<span class=\"comment\">-- 相当于</span>\n<span class=\"keyword\">local</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span><span class=\"params\">(x)</span></span>    </code></pre>\n<p><strong>正确的尾调用本质是为了不记录函数的返回位置，这样在栈中就可以无限的调用函数。在lua中只有return <func>(<args>)这样的形式才是尾调用。</args></func></strong></p>\n  </div>","text":" 闭包 lua中的函数都可以认为是闭包，只不过为了便于理解还是用了函数的概念。 lua中函数的返回值可以是匿名函数，也就是闭包。以下面的代码为例，提出一个概念：非局部的变量。在下面的代码中，匿名函数访问了一个变量i，它对于newCount来说是局部变量，对于匿名函数来说是既不是局...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">闭包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E7%9A%84%E6%B2%99%E7%9B%92\"><span class=\"toc-text\">闭包的沙盒</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92\"><span class=\"toc-text\">递归</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C循环执行Lua","uid":"f20c2eb82b1c56d5b08c0f9c1345be87","slug":"zl/2016-01-01-645_C循环执行Lua","date":"2024-04-03T03:47:35.865Z","updated":"2024-04-03T03:47:35.865Z","comments":true,"path":"api/articles/zl/2016-01-01-645_C循环执行Lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 文章目录 &lt;/div&gt; &lt;h3 id=&quot;实现过程&quot;&gt;&lt;a href=&quot;#实现过程&quot; class=&quot;headerlink&quot; title=&quot;实现过程&quot;&gt;&lt;/a&...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"每周一个Github项目【第二期】govaluate · Zablog","uid":"885db73aeabd5ddc502d1fba79c0bba0","slug":"zl/2016-01-01-643_每周一个Github项目【第二期】govaluate · Zablog","date":"2024-04-03T03:47:35.864Z","updated":"2024-04-03T03:47:35.864Z","comments":true,"path":"api/articles/zl/2016-01-01-643_每周一个Github项目【第二期】govaluate · Zablog.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"golang环境下任意表达式的求值 // Arbitrary expression evaluation for golang 名称 govaluate 地址 Github 作者 Knetic等 brief intro Arbitrary expression evaluatio...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}