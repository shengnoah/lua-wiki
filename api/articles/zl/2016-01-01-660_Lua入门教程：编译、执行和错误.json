{"title":"Lua入门教程：编译、执行和错误","uid":"4ae02dbeefb32d47e6d19e874dd82a9f","slug":"zl/2016-01-01-660_Lua入门教程：编译、执行和错误","date":"2024-04-03T03:47:35.884Z","updated":"2024-04-03T03:47:35.885Z","comments":true,"path":"api/articles/zl/2016-01-01-660_Lua入门教程：编译、执行和错误.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"dofile-与-loadfile-函数\"><a href=\"#dofile-与-loadfile-函数\" class=\"headerlink\" title=\"dofile 与 loadfile 函数\"></a>dofile 与 loadfile 函数</h2><p>dofile 是一个辅助函数，函数 loadfile 才完成了真正的核心工作。 两个函数都是从文件中加载 Lua 代码，但它不会运行，只是编译代码，然后把编译后的代码作为函数返回。<br/>与 dofile 不同，loadfile 不会抛出异常，只会返回错误码。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(filename)</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">local</span> f = <span class=\"built_in\">assert</span>(<span class=\"built_in\">loadfile</span>(filename))</span><br/><span class=\"line\">    <span class=\"keyword\">return</span> f()</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/></pre></td></tr></tbody></table></figure>\n<h2 id=\"load-函数\"><a href=\"#load-函数\" class=\"headerlink\" title=\"load 函数\"></a>load 函数</h2><p>与 loadfile 类似，但该函数是从一个字符串中读取代码。</p>\n<p>编写用后即弃的代码：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">i = <span class=\"number\">0</span></span><br/><span class=\"line\">s = <span class=\"string\">&#34;i = i + 1&#34;</span></span><br/><span class=\"line\"><span class=\"built_in\">load</span>(s)() </span><br/></pre></td></tr></tbody></table></figure>\n<p>该函数加载的代码如果有语法错误，load 会返回 nil 和 错误信息，所以最好使用 assert：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">assert</span>(<span class=\"built_in\">load</span>(s))()</span><br/></pre></td></tr></tbody></table></figure>\n<p>laod 加载编译时不会设计词法定界，该函数总是在全局环境中编译代码：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">i = <span class=\"number\">32</span></span><br/><span class=\"line\"><span class=\"keyword\">local</span> i = <span class=\"number\">0</span></span><br/><span class=\"line\">f = <span class=\"built_in\">load</span>(<span class=\"string\">&#34;i = i + 1; print(i)&#34;</span>)</span><br/><span class=\"line\">g = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> i = i + <span class=\"number\">1</span>; <span class=\"built_in\">print</span>(i) <span class=\"keyword\">end</span></span><br/><span class=\"line\">f() <span class=\"comment\">--&gt; 33</span></span><br/><span class=\"line\">g() </span><br/></pre></td></tr></tbody></table></figure>\n<h2 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h2><p>Lua 会在遇到非预期的情绪时引发错误，如将非数值类型相加，对不是函数的值进行调用等。</p>\n<p>也可以调用函数 error 并传入一个错误信息来作为参数引发一个错误：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"built_in\">io</span>.<span class=\"built_in\">read</span>(<span class=\"string\">&#34;n&#34;</span>)</span><br/><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n <span class=\"keyword\">then</span> <span class=\"built_in\">error</span>(<span class=\"string\">&#34;invalid input&#34;</span>) <span class=\"keyword\">end</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>当然上面这种情况更简单的代码结构是使用 assert 函数来完成，assert 函数检查第一个参数是否为真，如果为真则返回该参数，否则引发一个错误，并用第二个参数作为错误提示信息：</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"built_in\">assert</span>(<span class=\"built_in\">io</span>.<span class=\"built_in\">read</span>(<span class=\"string\">&#34;n&#34;</span>), <span class=\"string\">&#34;invalid input&#34;</span>)</span><br/></pre></td></tr></tbody></table></figure>\n<p>Lua 中要给函数发现某个错误是，在进行异常处理时有两种选择：</p>\n<ul>\n<li>返回错误代码（nil 或是 false）</li>\n<li>通过函数 error 引发一个错误。</li>\n</ul>\n<p>通常容易避免的错误应该引发错误，否则应该返回错误码。</p>\n<h2 id=\"错误处理和异常\"><a href=\"#错误处理和异常\" class=\"headerlink\" title=\"错误处理和异常\"></a>错误处理和异常</h2><p>要执行一段代码并捕获一段错误(try-catch)可以使用pcall函数，该函数以一种保护模式调用它的第一个参数，如果没有发生错误会返回true和调用函数的返回参数，否则返回false和错误信息。<br/>我们可以通过 error(throw an exception) 来抛出异常，并通过 pcall 来捕获 (catch) 异常。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> ok, msg = <span class=\"built_in\">pcall</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br/><span class=\"line\">    some code</span><br/><span class=\"line\">    <span class=\"keyword\">if</span> unexpected_condition <span class=\"keyword\">then</span> <span class=\"built_in\">error</span>() <span class=\"keyword\">end</span></span><br/><span class=\"line\">    some code</span><br/><span class=\"line\"><span class=\"keyword\">end</span>)</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">if</span> ok <span class=\"keyword\">then</span></span><br/><span class=\"line\">    regular code</span><br/><span class=\"line\"><span class=\"keyword\">else</span></span><br/><span class=\"line\">    <span class=\"built_in\">error</span>-handing code</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>另外，error 函数还有第2个可选参数 level，用于只想函数调用层次中的哪层函数报告错误，以说明谁应该为错误负责。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span><span class=\"params\">(str)</span></span></span><br/><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">type</span>(str) ~= <span class=\"string\">&#34;string&#34;</span> <span class=\"keyword\">then</span></span><br/><span class=\"line\">        <span class=\"built_in\">error</span>(<span class=\"string\">&#34;string expected&#34;</span>, <span class=\"number\">2</span>)</span><br/><span class=\"line\">    <span class=\"keyword\">end</span></span><br/><span class=\"line\">    regualr code</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>最后，我们如果希望错误发生时获得更多的调试信息，比如发生错误时一个完整的函数调用栈信息。<br/>pcall 如果发生错误时，部分的调用栈已经被破坏了（从pcall到出错部分），如果希望得到一个完整的有意义的栈回溯，则必须在函数 pcall 返回前先将调用栈构好。<br/>为了实现上面的需求，我们可以使用 xpcall 函数，该函数第二个参数是一个消息处理函数，当错误发生时，Lua 会在调用栈展开前调用这个消息处理函数，我们可以使用 debug.traceback 来获取更多错误信息。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error_handler</span><span class=\"params\">(msg)</span></span></span><br/><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">debug</span>.<span class=\"built_in\">traceback</span>(<span class=\"built_in\">tostring</span>(msg), <span class=\"number\">2</span>))</span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"built_in\">xpcall</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br/><span class=\"line\">    some code</span><br/><span class=\"line\">    <span class=\"keyword\">if</span> unexpected_c  ondition <span class=\"keyword\">then</span> <span class=\"built_in\">error</span>() <span class=\"keyword\">end</span></span><br/><span class=\"line\">    some code</span><br/><span class=\"line\"><span class=\"keyword\">end</span>, error_handler)</span><br/></pre></td></tr></tbody></table></figure>","text":"dofile 与 loadfile 函数dofile 是一个辅助函数，函数 loadfile 才完成了真正的核心工作。 两个函数都是从文件中加载 Lua 代码，但它不会运行，只是编译代码，然后把编译后的代码作为函数返回。与 dofile 不同，loadfile 不会抛出异常，只会...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#dofile-%E4%B8%8E-loadfile-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">dofile 与 loadfile 函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#load-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">load 函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">错误</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%92%8C%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">错误处理和异常</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Unity3D集成Lua","uid":"1ea5df9307dc634325ed99570e17d366","slug":"zl/2016-01-01-661_Unity3D集成Lua","date":"2024-04-03T03:47:35.885Z","updated":"2024-04-03T03:47:35.886Z","comments":true,"path":"api/articles/zl/2016-01-01-661_Unity3D集成Lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" | 分类 &lt;a href=&quot;/categories/#lua之基础&quot; title=&quot;lua之基础&quot;&gt;lua之基础&lt;/a&gt; | 关于Lua、C# 的语法，这里不做介绍，之前有很多文章都有涉及，可以翻看一下（本文参考资...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Programming in Lua(Thrid Edition)笔记","uid":"a502732b8dc58224e972b6c53538b8c4","slug":"zl/2016-01-01-65_Programming in Lua(Thrid Edition)笔记","date":"2024-04-03T03:47:35.884Z","updated":"2024-04-03T03:47:35.884Z","comments":true,"path":"api/articles/zl/2016-01-01-65_Programming in Lua(Thrid Edition)笔记.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"4 Statements 多重赋值：先求出所有值，再赋值 交换两值 1x, y = y, x 多余的变量赋nil，多余的值丢弃 用局部变量保护全局变量 1local foo = foo if-then-elseif-else-end充当switch 1234567891011if...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}