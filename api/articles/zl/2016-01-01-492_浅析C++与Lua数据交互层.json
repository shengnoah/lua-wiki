{"title":"浅析C++与Lua数据交互层","uid":"c72d78f454d2a2acb9fdf206046327ce","slug":"zl/2016-01-01-492_浅析C++与Lua数据交互层","date":"2024-04-03T03:47:35.771Z","updated":"2024-04-03T03:47:35.775Z","comments":true,"path":"api/articles/zl/2016-01-01-492_浅析C++与Lua数据交互层.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"背景\">背景</h2>\n<p>​\tC++作为服务器端开发的主流语言，相比其他语言有明显的性能优势，但是它的技术门槛比较高，不支持热更新，无法进行迅速的需求迭代和线上问题的响应。另外，C++内存管理的特点，技术人员对指针的使用不当，可能会造成宕机。因此，现在越来越多的技术团队会选择在C++中嵌入脚本语言，C++提供底层支持，脚本语言进行业务逻辑的开发。这样的好处，一方面将开发人员进行划分，C++代码的维护只由核心人员进行。业务层的脚本代码开发，相对比较简单，可以交由经验比较浅的新人，甚至外包给其他团队；另外一方面，脚本语言的灵活性，可热更新，又弥补了C++的不足。</p>\n<p>​\tLua作为一门非常轻量的脚本语言，被大量的游戏团队使用。我们就来说一说，C++是如何与Lua进行数据交互的。</p>\n<p>​\t已有的类似系统有LuaBinder、LuaTinker、CppToLua等。</p>\n<h2 id=\"基本原理\">基本原理</h2>\n<p>​\tLua提供了虚拟栈的概念，C/C++可以通过push/pop从栈上逐一存取基本的数据类型，也可以通过pushcfunction/pushcclosure，将函数注册给Lua，供其调用。但对于C++来说，数据结构比较复杂，有类和对象的概念，类有成员变量和成员函数，类之间又有继承的关系。Lua的基本接口并无法支撑这么复杂的数据交互。我们要实现的数据交互层，就是为C++提供一套注册接口，方面将C++中的类、对象类型的变量、类的成员变量和成员函数注册到Lua中去，让Lua像访问原生数据一样访问它们。</p>\n<p>​       如下，在C++中定义了如下类A，并利用数据交互层提供的接口，将A类的成员变量和成员函数注册给Lua。然后，将A类型的对象ca注册到Lua的全局变量中，为了进行区分，命名为la。在Lua代码里，就可以通过la.x访问对象ca.x的变量，通过la:funcA(p1,p2,…)调用ca.funcA的函数了。</p>\n<div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">Class</span> <span class=\"n\">A</span>\n<span class=\"p\">&#123;</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">A</span><span class=\"p\">();</span>\n    <span class=\"o\">~</span><span class=\"n\">A</span><span class=\"p\">();</span>\n<pre><code>&lt;span class=&quot;n&quot;&gt;TypeX&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;\n&lt;span class=&quot;n&quot;&gt;TypeY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;funcA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Param1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Param2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...);&lt;/span&gt;\n</code></pre>\n<p><span class=\"p\">};</span></p>\n<p><span class=\"p\">…</span><br />\n<span class=\"n\">registerClass</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&quot;A&quot;</span><span class=\"p\">);</span> <span class=\"c1\">// L 为lua_State*类型<br />\n</span><span class=\"n\">registerClassFunction</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&quot;funcA&quot;</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"o\">::</span><span class=\"n\">funcA</span><span class=\"p\">);</span><br />\n<span class=\"n\">registerClassMemberVariable</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&quot;x&quot;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">A</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"p\">);</span></p>\n<p><span class=\"n\">A</span> <span class=\"n\">ca</span><span class=\"p\">;</span><br />\n<span class=\"n\">registerVariable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&quot;la&quot;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">ca</span><span class=\"p\">);</span><br />\n</code></pre></div></div></p>\n<p>​\t这背后的发生了什么？先来看一下<code class=\"highlighter-rouge\">regiserClass</code>的实现，在Lua的全局环境中注册了名为name的表，并定义几个元方法，我们称这种表为类表。</p>\n<div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">registerClass</span><span class=\"p\">(</span><span class=\"n\">lua_State</span><span class=\"o\">*</span> <span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span> <span class=\"n\">name</span><span class=\"p\">)</span>\n<span class=\"p\">&#123;</span>\n    <span class=\"n\">ClassName</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">name</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">);</span> <span class=\"c1\">//注册类名\n</span>    \n    <span class=\"n\">lua_newtable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">);</span>\n<pre><code>&lt;span class=&quot;n&quot;&gt;lua_pushstring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;__name&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;\n&lt;span class=&quot;n&quot;&gt;lua_pushstring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;\n&lt;span class=&quot;n&quot;&gt;lua_rawset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;\n\n&lt;span class=&quot;n&quot;&gt;lua_pushstring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;__index&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;\n&lt;span class=&quot;n&quot;&gt;lua_pushcclosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;meta_get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;\n&lt;span class=&quot;n&quot;&gt;lua_rawset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;\n\n&lt;span class=&quot;n&quot;&gt;lua_pushstring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;__newindex&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;\n&lt;span class=&quot;n&quot;&gt;lua_pushcclosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;meta_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;\n&lt;span class=&quot;n&quot;&gt;lua_rawset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;\n\n&lt;span class=&quot;n&quot;&gt;lua_pushstring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;__gc&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;\n&lt;span class=&quot;n&quot;&gt;lua_pushcclosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destroyer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;\n&lt;span class=&quot;n&quot;&gt;lua_rawset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;\n\n&lt;span class=&quot;n&quot;&gt;lua_setglobal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;\n</code></pre>\n<p><span class=\"p\">}</span><br />\n</code></pre></div></div></p>\n<p>当访问la.x时，会把la当作table，寻找table中key为”x”的值。la.x当作左值时会触发 <code class=\"highlighter-rouge\">__newindex</code>元方法，当作右值时会触发 <code class=\"highlighter-rouge\">__index</code>元方法。当la中没有找到key为”x”的值，就会去la的元表中进行查找。因此，需要将la的元表设置为A的类表。</p>\n<p>​\t除了上面通过注册全局变量，Lua层还有另外两个途径访问C++类的对象：通过C++类的构造函数直接构造对象、通过其他对象的成员变量或者成员函数的返回值。三种途径的关键一步，都是将userdata的元表关联到注册给Lua的类表中。</p>\n<h3 id=\"一层数据封装\">一层数据封装</h3>\n<p>​\tLua中的基本数据类型有number、string、table、function、userdata、thread。la本质上就是userdata，指向内存数据的一个指针，简单理解，可以认为是对象实例ca的地址，实际上，进行了一层封装。分别定义了ValueToUser<t>、PtrToUser<t>、RefToUser<t>三种类型，来处理值类型、指针类型和引用类型，它们都继承自UserBase。这样就可以将任意类型的值、指针、引用压入Lua虚拟栈中。注意到ValueToUser需要负责类型的创建和删除，PtrToUser和RefToUser只是持有对象的地址。</t></t></t></p>\n<div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">struct</span> <span class=\"n\">UserBase</span>\n<span class=\"p\">&#123;</span>\n    <span class=\"n\">UserBase</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"n\">m_p</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">)</span> <span class=\"p\">&#123;&#125;</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">UserBase</span><span class=\"p\">();</span>\n    <span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">m_p</span><span class=\"p\">;</span>\n<span class=\"p\">&#125;;</span>\n<p><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span><br />\n<span class=\"k\">struct</span> <span class=\"n\">ValueToUser</span><span class=\"o\">:</span> <span class=\"n\">UserBase</span><br />\n<span class=\"p\">&#123;</span><br />\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"p\">…</span> <span class=\"n\">Args</span><span class=\"o\">&gt;</span><br />\n<span class=\"n\">ValueToUser</span><span class=\"p\">(</span><span class=\"n\">Args</span><span class=\"p\">…</span> <span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"n\">UserBase</span><span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"n\">T</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">)…))</span> <span class=\"p\">&#123;&#125;</span></p>\n<pre><code>&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ValueToUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&#125;&lt;/span&gt;\n</code></pre>\n<p><span class=\"p\">};</span></p>\n<p><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span><br />\n<span class=\"k\">struct</span> <span class=\"n\">PtrToUser</span><span class=\"o\">:</span> <span class=\"n\">UserBase</span><br />\n<span class=\"p\">{</span><br />\n<span class=\"n\">PtrToUser</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\"><em></span> <span class=\"n\">t</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"n\">UserBase</span><span class=\"p\">((</span><span class=\"kt\">void</span><span class=\"o\"></em></span><span class=\"p\">)</span><span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">{}</span><br />\n<span class=\"p\">};</span></p>\n<p><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span><br />\n<span class=\"k\">struct</span> <span class=\"n\">RefToUser</span><span class=\"o\">:</span> <span class=\"n\">UserBase</span><br />\n<span class=\"p\">{</span><br />\n<span class=\"n\">RefToUser</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">&amp;</span> <span class=\"n\">t</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"n\">UserBase</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">{}</span><br />\n<span class=\"p\">};</span></p>\n<p></code></pre></div></div></p>\n<p>注意到registerClass中将destroyer<t>函数注册为__gc元方法，当Lua产生垃圾回收时，就会调用该方法：</t></p>\n<pre><code class=\"language-C++\">template&lt;typame T&gt;\nint destroyer(lua_State* L)\n&#123;\n    ((UserBase*)lua_touserdata(L, -1))-&gt;~UserBase();\n    return 0; //告诉Lua该函数没有返回值\n&#125;\n</code></pre>\n<h3 id=\"两个抽象操作\">两个抽象操作</h3>\n<p>定义两个操作：pushToLuaStack<t>可以将任意类型的数据压入Lua虚拟栈，getFromLuaStack<t>则可以从Lua虚拟栈中取出任意类型的数据。</t></t></p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>pushToLuaStack&lt;T&gt;\n\t\t\t\t|\n                | EnumToLua&lt;T&gt; ---&gt; 将number类型压入栈\n                | ObjectToLua&lt;T&gt; ---&gt; | ValueToLua&lt;T&gt; ---&gt; 将ValueToUser&lt;T&gt;类型入栈\n                                      | PtrToLua&lt;T&gt;   ---&gt; 将PtrToUser&lt;T&gt;类型入栈\n                                      | RefToLua&lt;T&gt;   ---&gt; 将RefToUser&lt;T&gt;类型入栈 \n                                      &amp; 将T的类表作为刚压入栈的userdata的元表\n</code></pre></div></div>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>getFromLuaStack&lt;T&gt;\n                |\n                | LuaToEnum&lt;T&gt; ---&gt; 从栈上取出number类型变量\n\t\t\t\t| LuaToObject&lt;T&gt; ----&gt; &amp; 1. user = LuaUserDataToType&lt;UserBase*&gt;::convert()\n\t\t\t\t\t\t               &amp; 2. VoidToType&lt;T&gt;(user-&gt;m_p)\n\t\t\t\t\t\t                           |\n\t\t\t\t\t\t                           | T如果是指针类型，VoidToPtr\n\t\t\t\t\t\t                           | T如果是引用类型，VoidToRef\n\t\t\t\t\t\t                           | T如果是值类型，  VoidToValue\n</code></pre></div></div>\n<h3 id=\"注册成员变量\">注册成员变量</h3>\n<p>​\t<code class=\"highlighter-rouge\">registerClassMemberVariable&lt;A&gt;(L, &#34;x&#34;, &amp;A::x)</code>在类表中注册了key为”x”的键值对，值是一个void* 类型的userdata，实际是一个VariableBase类型的指针，利用运行时多态和模板，是可以达到反射的目的的。把任意类的任意成员变量，都抽象成VariableBase类，它只有两个虚函数接口，get用来把成员变量的值压入栈中，set用来取出栈上的值并赋给成员变量。VariableBase根据T和V派生出MemberVariable&lt;T, V&gt;类。MemberVariable&lt;T, V&gt;记录了成员变量在类中的偏移地址，同时具现了get和set这两个接口，因为有类型信息，可以知道从栈上取出是什么类型的值。</p>\n<pre><code class=\"language-C++\">struct VariableBase\n&#123;\n    virtual void get(lua_State* L) = 0;\n    virtual void set(lua_State* L) = 0;\n&#125;;\n\ntemplate&lt;typename T, typename V&gt;\nMemberVariable: VariableBase\n&#123;\n\tV T::*_var;\n\t\n\tvoid get(lua_State* L)\n    &#123;\n    \tpushToLuaStack&lt;V&gt;(L, getFromLuaStack&lt;T*&gt;(L, 1)-&gt;*(_var));  //从栈底取出对象地址偏移到成员变量所在地址，将成员变量值压入栈中\n    &#125;\n    \n    void set(lua_State* L)\n    &#123;\n    \tgetFromLuaStack&lt;T*&gt;(L, 1)-&gt;*(_var) = getFromLuaStack&lt;V&gt;(L, 3);\n    &#125;\n&#125;;\n\nint meta_get(lua_State* L)\n&#123;\n    lua_getmetatable(L, 1); // 将栈底的元表压栈，例子中就是la的类表A\n    lua_pusvalue(L, 2);     // 将栈底上面的元素，就是key复制压入栈；例子中就是&#34;x&#34;\n    lua_rawget(L, -2);      // 得到A[x]的值\n    \n    if(lua_isuserdata(L, -1))\n    &#123;\n        LuaUserDataToType&lt;VariableBase*&gt;::convert(L, -1)-&gt;get(L); //将栈底的userdata转\n        lua_remove(L, -2); // 将类表移出栈\n    &#125;\n    ...\n&#125;\n\nint meta_set(lua_State* L)\n&#123;\n    lua_getmetatable(L, 1); // 将栈底的元表压栈，例子中就是la的类表A\n    lua_pusvalue(L, 2);     // 将栈底上面的元素，就是key复制压入栈；例子中就是&#34;x&#34;\n    lua_rawget(L, -2);      // 得到A[x]的值\n    \n    if(lua_isuserdata(L, -1))\n    &#123;\n        LuaUserDataToType&lt;VariableBase*&gt;::convert(L, -1)-&gt;set(L);\n    &#125;\n    ...\n    lua_settop(L, 3);\n&#125;\n</code></pre>\n<h3 id=\"注册成员函数\">注册成员函数</h3>\n<p>​\t<code class=\"highlighter-rouge\">registerClassFunction&lt;A&gt;(L, &#34;funcA&#34;, A::funcA)</code>做了什么？在类表中注册了key为”funcA”的键值对，值是一个闭包。<code class=\"highlighter-rouge\">lua_pushcclosure(L，func, n)</code>函数允许将一个函数func压入栈的同时，指定它之前栈上的n个元素作为upvalue，这就是闭包的概念。这里的闭包是模版类MemberFunctionDelegate&lt;Ret, T, …Args&gt;的静态函数——call函数，upvalue是A::funcA的函数指针。模板类通过模板参数，将所属类T，返回值类型Ret，以及函数的参数列表的类型都记录下来。当la:funcA调用时，实际调用的是<code class=\"highlighter-rouge\">MemberFunctionDelegate&lt;Ret, T, …Args&gt;::call</code>函数，Lua会将la(指向ca的指针)和函数的参数依次压入栈中。call的实现，首先从upvalue中取出成员函数指针，再从栈低到栈顶依次取出，ca的地址和A::funcA的各个参数，有了这些，就能真正地调用ca:funcA(p1,p2,…)，并将函数的返回值压入栈。</p>\n<pre><code class=\"language-C++\">template&lt;typename RVal, typename T, typename ... Args&gt;\nstruct MemberFunctionDelegate\n&#123;\n    static int call(lua_State* L)\n    &#123;\n        typedef RVal(T::*MemFunc)(Args ...);\n        MemFunc fun = getUpValue&lt;MemFunc&gt;(L); // 从upvalue中取出成员函数指针\n        \n        int index = 1;\n        T* t = getFromLuaStack&lt;T*&gt;(L, index++); //从栈底取出对象地址\n        pushToLuaStack(L, (t-&gt;*fun)(getFromLuaStack&lt;Args&gt;(L, index++)...));\n        \n        return 1;\n    &#125;\n&#125;;\n\ntemplate&lt;typename RVal, typename T, typename ... Args&gt;\npushFunctionDelegate(lua_State* L, RVal(T::*func)(Args...))\n&#123;\n    lua_pushcclosure(L, MemberFunctionDelegate&lt;RVal, T, Args...&gt;::call, 1);\n&#125;\n\ntemplate&lt;typename T, typename F&gt;\nvoid registerClassFunction(lua_State* L, const char* name, F func)\n&#123;\n    push_meta(L, ClassName&lt;T&gt;::name());  // 将T的类表压入栈\n    if(lua_istable(L, -1))\n    &#123;\n        lua_pushstring(L, name);\n        new(lua_newuserdata(L, sizeof(F))) F(func); //成员函数指针作为upvalue\n        pushFunctionDelegate(L, func); \n        lua_rawset(L, -3);\n    &#125;\n    lua_pop(L, 1);\n&#125;\n</code></pre>\n<h3 id=\"注册构造函数\">注册构造函数</h3>\n<p>当我们在Lua中将表当作构造表达式使用时，例如t = T(…)，就会调用T的__call元方法。通过下面代码可以看到，注册的构造函数，其实创建了一个ValueToUser<t>类型的userdata，并将它的元表设为T的类表。</t></p>\n<div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"p\">...</span> <span class=\"n\">Args</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">int</span> <span class=\"n\">constructor</span><span class=\"p\">(</span><span class=\"n\">lua_State</span><span class=\"o\">*</span> <span class=\"n\">L</span><span class=\"p\">)</span>\n<span class=\"p\">&#123;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"k\">new</span><span class=\"p\">(</span><span class=\"n\">lua_newuserdata</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">ValueToUser</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)))</span> <span class=\"n\">ValueToUser</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">getFromLuaStack</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">index</span><span class=\"o\">++</span><span class=\"p\">)...);</span>\n    <span class=\"n\">push_meta</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">ClassName</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">ClassType</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">Type</span><span class=\"o\">&gt;::</span><span class=\"n\">name</span><span class=\"p\">());</span>\n    <span class=\"n\">lua_setmetatable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"p\">&#125;</span>\n<span class=\"p\">...</span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">F</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">addClassConstructor</span><span class=\"p\">(</span><span class=\"n\">lua_State</span><span class=\"o\">*</span> <span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">F</span> <span class=\"n\">func</span><span class=\"p\">)</span>\n<span class=\"p\">&#123;</span>\n    <span class=\"n\">push_meta</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">ClassName</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">name</span><span class=\"p\">());</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">lua_istable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n    <span class=\"p\">&#123;</span>\n        <span class=\"n\">lua_newtable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">);</span>\n        <span class=\"n\">lua_pushstring</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&#34;__call&#34;</span><span class=\"p\">);</span>\n        <span class=\"n\">lua_pushcclosure</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n        <span class=\"n\">lua_rawset</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">);</span>\n        <span class=\"n\">lua_setmetatable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n    <span class=\"p\">&#125;</span>\n    <span class=\"n\">lua_pop</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"p\">&#125;</span>\n<p><span class=\"c1\">// 注册构造函数示例<br />\n</span><span class=\"n\">addClassConstrutor</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">constructor</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"o\">&gt;</span><span class=\"p\">);</span></p>\n<p><span class=\"c1\">// Lua中创建A对象示例<br />\n</span><span class=\"n\">la</span> <span class=\"o\">=</span> <span class=\"n\">A</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">);</span></p>\n<p></code></pre></div></div></p>\n<h3 id=\"注册继承关系\">注册继承关系</h3>\n<p>C++中定义如下两个类A和B，B继承自A。</p>\n<div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">Class</span> <span class=\"n\">A</span>\n<span class=\"p\">&#123;</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">A</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span>\n    <span class=\"o\">~</span><span class=\"n\">A</span><span class=\"p\">();</span>\n<pre><code>&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;\n&lt;span class=&quot;n&quot;&gt;TypeY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;funcA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Param1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Param2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...);&lt;/span&gt;\n</code></pre>\n<p><span class=\"p\">};</span></p>\n<p><span class=\"n\">Class</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">A</span><br />\n<span class=\"p\">{</span><br />\n<span class=\"k\">public</span><span class=\"o\">:</span><br />\n<span class=\"n\">B</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">);</span><br />\n<span class=\"o\">~</span><span class=\"n\">B</span><span class=\"p\">();</span></p>\n<pre><code>&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;\n&lt;span class=&quot;n&quot;&gt;TypeW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;funcB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Param&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Param2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...);&lt;/span&gt;\n</code></pre>\n<p><span class=\"p\">};</span></p>\n<p></code></pre></div></div></p>\n<p>通过数据交互层提供的接口，不仅可以注册类的成员变量和成员函数，还可以将继承关系继承到Lua中。</p>\n<div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">registerClass</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&#34;A&#34;</span><span class=\"p\">);</span> <span class=\"c1\">// L 为lua_State*类型\n</span><span class=\"n\">registerClassFunction</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&#34;funcA&#34;</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"o\">::</span><span class=\"n\">funcA</span><span class=\"p\">);</span>\n<span class=\"n\">registerClassMemberVariable</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&#34;x&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">A</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"p\">);</span>\n<p><span class=\"n\">registerClass</span><span class=\"o\">&lt;</span><span class=\"n\">B</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&quot;B&quot;</span><span class=\"p\">);</span><br />\n<span class=\"n\">registerClassFunction</span><span class=\"o\">&lt;</span><span class=\"n\">B</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&quot;funcB&quot;</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"o\">::</span><span class=\"n\">funcB</span><span class=\"p\">);</span><br />\n<span class=\"n\">registerClassMemberVariable</span><span class=\"o\">&lt;</span><span class=\"n\">B</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&quot;z&quot;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">B</span><span class=\"o\">::</span><span class=\"n\">z</span><span class=\"p\">);</span><br />\n<span class=\"n\">inherientClass</span><span class=\"o\">&lt;</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">);</span></p>\n<p><span class=\"n\">A</span> <span class=\"n\">ca</span><span class=\"p\">;</span><br />\n<span class=\"n\">registerVariable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&quot;la&quot;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">ca</span><span class=\"p\">);</span><br />\n</code></pre></div></div></p>\n<p>于是在Lua脚本中，通过实例lb不仅可以访问类B的成员变量和函数，可以访问其父类的。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">lb</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">);</span>\n<p><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">lb</span><span class=\"p\">.</span><span class=\"n\">b</span><span class=\"p\">);</span><br />\n<span class=\"n\">lb</span><span class=\"p\">:</span><span class=\"n\">funcB</span><span class=\"p\">(</span><span class=\"o\">…</span><span class=\"p\">);</span></p>\n<p><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">lb</span><span class=\"p\">.</span><span class=\"n\">a</span><span class=\"p\">);</span><br />\n<span class=\"n\">lb</span><span class=\"p\">:</span><span class=\"n\">funcA</span><span class=\"p\">(</span><span class=\"o\">…</span><span class=\"p\">);</span><br />\n</code></pre></div></div></p>\n<p>这种继承关系，是如何注册到Lua中去的？</p>\n<p>看看inherientClass函数的实现：本质上就是将一个类表的__parent指向了父类表。</p>\n<div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">P</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">inherientClass</span><span class=\"p\">(</span><span class=\"n\">lua_State</span><span class=\"o\">*</span> <span class=\"n\">L</span><span class=\"p\">)</span>\n<span class=\"p\">&#123;</span>\n    <span class=\"n\">push_meta</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">ClassName</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">name</span><span class=\"p\">());</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">lua_istable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n    <span class=\"p\">&#123;</span>\n        <span class=\"n\">lua_pushstring</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&#34;__parent&#34;</span><span class=\"p\">);</span>     <span class=\"c1\">// 通过__parent元方法，奖励两个类表之间的“继承”关系\n</span>        <span class=\"n\">push_meta</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">ClassName</span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"o\">&gt;::</span><span class=\"n\">name</span><span class=\"p\">());</span>\n        <span class=\"n\">lua_rawset</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">);</span>\n    <span class=\"p\">&#125;</span>\n    <span class=\"n\">lua_pop</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"p\">&#125;</span>\n</code></pre></div></div>\n<p>我们再来看一下完整的meta_get和meta_set函数实现，当在当前类表中查找不到键值对时，就会调用invoke_parent函数，递归地从继承关系链中，向上搜寻父类表或者祖先类表中是否存在键值对。</p>\n<div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">invoke_parent</span><span class=\"p\">(</span><span class=\"n\">lua_State</span><span class=\"o\">*</span> <span class=\"n\">L</span><span class=\"p\">)</span>\n<span class=\"p\">&#123;</span>\n    <span class=\"n\">lua_pushstring</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&#34;__parent&#34;</span><span class=\"p\">);</span>  <span class=\"c1\">// 取出继承关系中的父类表\n</span>    <span class=\"n\">lua_rawget</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n<pre><code>&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lua_istable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 如果存在父类表\n</code></pre>\n<p></span>    <span class=\"p\">{</span><br />\n<span class=\"n\">lua_pushvalue</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">);</span> <span class=\"c1\">//将栈底上面的元素，即要找的key复制入栈<br />\n</span>        <span class=\"n\">lua_rawget</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">);</span>   <span class=\"c1\">// 尝试从父类表中找到key对应的value是否存在<br />\n</span><br />\n<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">lua_isnil</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span><br />\n<span class=\"p\">{</span><br />\n<span class=\"n\">lua_remove</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">);</span> <span class=\"c1\">//如果找到，将父类表移除<br />\n</span>        <span class=\"p\">}</span><br />\n<span class=\"k\">else</span><br />\n<span class=\"p\">{</span><br />\n<span class=\"n\">lua_remove</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">);</span> <span class=\"c1\">//将栈顶的nil移除<br />\n</span>            <span class=\"n\">invoke_parent</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">);</span>  <span class=\"c1\">//递归调用在父类的父类中查找<br />\n</span>            <span class=\"n\">lua_remove</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">);</span> <span class=\"c1\">//将父类表移除<br />\n</span>        <span class=\"p\">}</span><br />\n<span class=\"p\">}</span><br />\n<span class=\"p\">}</span><br />\n<span class=\"kt\">int</span> <span class=\"nf\">meta_get</span><span class=\"p\">(</span><span class=\"n\">lua_State</span><span class=\"o\">*</span> <span class=\"n\">L</span><span class=\"p\">)</span><br />\n<span class=\"p\">{</span><br />\n<span class=\"n\">lua_getmetatable</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span> <span class=\"c1\">//将栈底元素的元表入栈<br />\n</span>    <span class=\"n\">lua_pushvalue</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">);</span>    <span class=\"c1\">// 复制key并压入栈<br />\n</span>    <span class=\"n\">lua_rawget</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">);</span>      <span class=\"c1\">// 获取元表[key]的值<br />\n</span><br />\n<span class=\"k\">if&lt;/spa</p>\n","text":"背景 ​ C++作为服务器端开发的主流语言，相比其他语言有明显的性能优势，但是它的技术门槛比较高，不支持热更新，无法进行迅速的需求迭代和线上问题的响应。另外，C++内存管理的特点，技术人员对指针的使用不当，可能会造成宕机。因此，现在越来越多的技术团队会选择在C++中嵌入脚本语言，...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">基本原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">一层数据封装</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E4%B8%AA%E6%8A%BD%E8%B1%A1%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">两个抽象操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%86%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">注册成员变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%86%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">注册成员函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%86%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">注册构造函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%86%8C%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">注册继承关系</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 的标准输出与缓存","uid":"eb6769635061336dbbe2c0540f762f81","slug":"zl/2016-01-01-491_Lua 的标准输出与缓存 ","date":"2024-04-03T03:47:35.771Z","updated":"2024-04-03T03:47:35.771Z","comments":true,"path":"api/articles/zl/2016-01-01-491_Lua 的标准输出与缓存 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"最近我遇到了个奇怪的问题，我的一个 Lua 脚本需要通过 shell 的重定向将输出追加到一个日志文件中。但是那个 Lua 脚本的输出在日志文件里看来却不是实时的，输出的文本直到脚本结束时才能看到。 在 shell 下运行这个程序，是可以看到实时输出的： -- buffer_te...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"luasocket getaddrinfo nil 问题","uid":"f597dc45b4c99d9cbe30780591e468ce","slug":"zl/2016-01-01-490_luasocket getaddrinfo nil 问题 ","date":"2024-04-03T03:47:35.770Z","updated":"2024-04-03T03:47:35.770Z","comments":true,"path":"api/articles/zl/2016-01-01-490_luasocket getaddrinfo nil 问题 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"使用 luarocks 安装 luasocket，在调用 bind 时，报： socket.lua:29: attempt to call field ‘getaddrinfo’ (a nil value) 继续执行以下 lua 代码片段： Lua 5.1.4 Copyright...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}