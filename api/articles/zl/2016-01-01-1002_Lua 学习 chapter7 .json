{"title":"Lua 学习 chapter7","uid":"d1f12ad6b4cafc4f9e33f041f7e58f17","slug":"zl/2016-01-01-1002_Lua 学习 chapter7 ","date":"2024-04-03T03:47:32.957Z","updated":"2024-04-03T03:47:32.958Z","comments":true,"path":"api/articles/zl/2016-01-01-1002_Lua 学习 chapter7 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h3 id=\"目录\">目录</h3>\n<ol>\n  <li>简单I/O模型</li>\n  <li>完整I/O模型</li>\n  <li>其它文件操作</li>\n  <li>其它系统调用</li>\n</ol>\n<blockquote>\n  <p>I want to have a talk with you my heart.</p>\n</blockquote>\n<h2 id=\"简单io模型\">简单I/O模型</h2>\n<p>对于文件操作，I/O提供了两种不同的模型。简单模型虚拟了一个当前输入流和一个当前的输出流，其I/O是通过这些流实现的。</p>\n<p>I/O库把当前的输入流初始化为进程的标准输入(C中的stdin),将当前的输出流初始化进程的标准输出(C中的stdout)。因此当执行io.read()这样的语句的时候就可以从标准的输入中读取一行。</p>\n<p>函数的io.input和函数io.output用来改变当前的输入输出流。</p>\n<p>io.input(fileName)会以只读的方式打开指定的文件，并将文件设置为当前的输入流。之后所有的输入都将来自于这个文件，除非重新调用io.input函数来改变。对于输出与之类似。</p>\n<p><strong>函数write()</strong>:</p>\n<p>由于调用该函数可以传入多个参数，所以应该避免使用io.write(a..b..b),而是使用write(a,b,c)。</p>\n<p>作为原则应该只在用后<strong>即弃</strong>的代码或者调试代码的时候调用print输出，当需要完全控制输出是，应该使用io.write()输出，和print不同，</p>\n<p>函数io.write最终的输出不会添加诸如制表符或者换行符这样的额外内容。</p>\n<p>此外函数io.write允许对输出进行重定向，而函数print只能使用标准输出。函数print会为其参数调用tostring函数。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n</pre></td><td class=\"rouge-code\"><pre><span class=\"nb\">io.write</span><span class=\"p\">(</span><span class=\"s2\">&#34;sin(3)=&#34;</span><span class=\"p\">,</span><span class=\"nb\">math.sin</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">),</span><span class=\"s2\">&#34;</span><span class=\"se\">n</span><span class=\"s2\">&#34;</span><span class=\"p\">)</span> <span class=\"c1\">-- &gt;sin(3) = 0.1411200080</span>\n<span class=\"nb\">io.write</span><span class=\"p\">(</span><span class=\"nb\">string.format</span><span class=\"p\">(</span><span class=\"s2\">&#34;sin(3)=%.4fn&#34;</span><span class=\"p\">,</span><span class=\"nb\">math.sin</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)))</span> <span class=\"c1\">-- &gt;sin(3) = 0.1411</span>\n<p><span class=\"nb\">io.read</span><span class=\"p\">(</span><span class=\"s2\">&quot;a&quot;</span><span class=\"p\">)</span> <span class=\"c1\">–&gt;从当前位置开始的读取当前输入文件的全部内容</span><br />\n</pre></td></tr></tbody></table></code></pre></div></div></p>\n<p>函数io.read可以从当前的输入流中读取字符串，其参数决定了其要读取的数据：</p>\n<ol>\n  <li>“a”  读取整个文件</li>\n  <li>“l”  读取下一行 （丢弃换行符）  默认参数</li>\n  <li>“L”  读取下一行（保留换行符）</li>\n  <li>“n”  读取一个数值(number 类型)</li>\n  <li>num  以字符串读取num个字符</li>\n</ol>\n<p>获取一个文件的所有行数可以使用 io.lines() 函数</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n</pre></td><td class=\"rouge-code\"><pre><span class=\"kd\">local</span> <span class=\"n\">lines</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span>\n<span class=\"k\">for</span> <span class=\"n\">line</span> <span class=\"k\">in</span> <span class=\"nb\">io.lines</span><span class=\"p\">()</span> <span class=\"k\">do</span>\n    <span class=\"n\">lines</span><span class=\"p\">[</span><span class=\"o\">#</span><span class=\"n\">lines</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">line</span>\n<span class=\"k\">end</span>\n<p><span class=\"nb\">table.sort</span><span class=\"p\">(</span><span class=\"n\">lines</span><span class=\"p\">)</span></p>\n<p><span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"k\">in</span> <span class=\"nb\">ipairs</span><span class=\"p\">(</span><span class=\"n\">lines</span><span class=\"p\">)</span> <span class=\"k\">do</span><br />\n<span class=\"nb\">io.write</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"s2\">&quot;</span><span class=\"se\">n</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span><br />\n<span class=\"k\">end</span><br />\n</pre></td></tr></tbody></table></code></pre></div></div></p>\n<p>io.write(n) 从当前的输入流中最多读取n个字符，如果没有字符返回nil,io.write(0)是一个特烈，它常用于测试是否达到了文件末尾。如果仍然有数据可供读取，他就会返回一个空字符串，否则返回nil。</p>\n<h2 id=\"完整io模型\">完整I/O模型</h2>\n<p>可以使用io.open来打开一个文件。该函数拥有两个参数，一个是文件名，一个是打开的模式。</p>\n<blockquote>\n  <p>file = io.open (filename [, mode])</p>\n</blockquote>\n<ol>\n  <li>“r”  只读</li>\n  <li>“w”  只写(可以用来删除文件中原来的内容)</li>\n  <li>“a”  追加,以附加的方式打开只写文件。</li>\n  <li>“b”  打开二进制文件</li>\n  <li>“r+” 以可读写方式打开文件，该文件必须存在。</li>\n  <li>“w+” 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</li>\n  <li>“a+” 与a类似，但此文件可读可写</li>\n  <li>”+” \t表示对文件既可以读也可以写</li>\n</ol>\n<p>io.open函数打开发生错的时候会返回两个值，一个是nil另一个是系统相关错误的错误码.</p>\n<p>当然我们在打开文件之后，如果要从这个文件中读写内容，需要使用这个文件流重新设置输入输出流。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n</pre></td><td class=\"rouge-code\"><pre><span class=\"c1\">-- 以只读方式打开文件</span>\n<span class=\"n\">file</span> <span class=\"o\">=</span> <span class=\"nb\">io.open</span><span class=\"p\">(</span><span class=\"s2\">&#34;test.lua&#34;</span><span class=\"p\">,</span> <span class=\"s2\">&#34;r&#34;</span><span class=\"p\">)</span>\n<p><span class=\"c1\">– 设置默认输入文件为 test.lua</span><br />\n<span class=\"nb\">io.input</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">)</span></p>\n<p><span class=\"c1\">– 输出文件第一行</span><br />\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">io.read</span><span class=\"p\">())</span></p>\n<p><span class=\"c1\">– 关闭打开的文件</span><br />\n<span class=\"nb\">io.close</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">)</span></p>\n<p><span class=\"c1\">– 以附加的方式打开只写文件</span><br />\n<span class=\"n\">file</span> <span class=\"o\">=</span> <span class=\"nb\">io.open</span><span class=\"p\">(</span><span class=\"s2\">&quot;test.lua&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;a&quot;</span><span class=\"p\">)</span></p>\n<p><span class=\"c1\">– 设置默认输出文件为 test.lua</span><br />\n<span class=\"nb\">io.output</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">)</span></p>\n<p><span class=\"c1\">– 在文件最后一行添加 Lua 注释</span><br />\n<span class=\"nb\">io.write</span><span class=\"p\">(</span><span class=\"s2\">&quot;–  test.lua 文件末尾注释&quot;</span><span class=\"p\">)</span></p>\n<p><span class=\"c1\">– 关闭打开的文件</span><br />\n<span class=\"nb\">io.close</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">)</span><br />\n</pre></td></tr></tbody></table></code></pre></div></div></p>\n<p>检测错误的一种典型方法是使用函数assert:</p>\n<p>local f = assert(io.open(fileName,mode))  发生错的时候错误信息会作为函数assert的第二个餐宿被传入。 然后assert会将错误信息展示出来。</p>\n<p>文件打开之后可以使用从流中读取和写入。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n</pre></td><td class=\"rouge-code\"><pre><span class=\"kd\">local</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"nb\">assert</span><span class=\"p\">(</span><span class=\"nb\">io.open</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">,</span><span class=\"s2\">&#34;r&#34;</span><span class=\"p\">))</span>\n<span class=\"kd\">local</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"p\">:</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"s2\">&#34;a&#34;</span><span class=\"p\">)</span>\n<span class=\"n\">f</span><span class=\"p\">:</span><span class=\"n\">close</span><span class=\"p\">()</span>\n<span class=\"c1\">-- io.stdin, io.stdout, io.stderr</span>\n<span class=\"nb\">io.stderr</span><span class=\"p\">:</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">)</span>\n</pre></td></tr></tbody></table></code></pre></div></div>\n<p>Io库提供了三个预定义的C语言流的句柄，可以直接调用。</p>\n<p>可以通过io.input 和 io.output 来改变的当前的输入输出流</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n</pre></td><td class=\"rouge-code\"><pre><span class=\"kd\">local</span> <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"nb\">io.input</span><span class=\"p\">()</span>\n<span class=\"nb\">io.input</span><span class=\"p\">(</span><span class=\"s2\">&#34;newInput&#34;</span><span class=\"p\">)</span>\n<span class=\"c1\">--对新的输入流进行操作</span>\n<span class=\"nb\">io.input</span><span class=\"p\">():</span><span class=\"n\">close</span>\n<span class=\"nb\">io.input</span><span class=\"p\">(</span><span class=\"n\">temp</span><span class=\"p\">)</span>  <span class=\"c1\">--恢复之前的输入流</span>\n</pre></td></tr></tbody></table></code></pre></div></div>\n<p><strong>注意：</strong> io.read(args) 实际上是io.input():read(args)，同样的io.write(args)和io.output():write(args)的简写。</p>\n<p>io.lines() 函数可以带参数，filename,读取文件中的内容，不带参数就是从当前输入流中读，现在次函数还可以接收像read函数一样的参数。</p>\n<h2 id=\"其他文件操作\">其他文件操作</h2>\n<p>io.tmpfile返回一个操作临时文件的句柄，该句柄是以读写模式打开的，当程序运行完成后，该句柄就会被回收。</p>\n<p>函数flush将所有的缓冲数据写入到文件中。与函数write一样，我们也可以把它当作io.flush()使用，以刷新当前的输出流，或者f:flush()，用来刷新当前流。</p>\n<p>函数setvbuf用于设置流的缓冲模式。</p>\n<ol>\n  <li>“no” 不缓冲</li>\n  <li>“full” 缓冲区满或者显示刷新文件时才写入数据</li>\n  <li>“line” 遇到换行符或从特定文件中读到了数据</li>\n</ol>\n<p>对于后面两个模式，可以跟第二个参数来设置缓冲区大小。</p>\n<p>一般情况下:io.stderr 是不缓冲的，io.stdout是按行缓冲的。</p>\n<p>函数seek用来获取和设置文件当前位置。常使用f:seek(whence,offset)的形式来调用。whence有一下三种模式：</p>\n<ol>\n  <li>“set”  文件开头</li>\n  <li>“cur”  文件当前位置</li>\n  <li>“end”  文件结尾</li>\n</ol>\n<p>偏移是以字节为单位的。</p>\n<p>whence默认值为”cur”,offset的默认值是0。file:seek() 返回当前位置且不改变当前位置。file:seek(“set”)会将位置重置到文件开头并返回0，file:seek(“end”)会将文件当前位置重置到文件结尾，并返回文件的大小。</p>\n<p>os.rename改变文件名字 os.remove删除文件。</p>\n<h2 id=\"其它系统调用\">其它系统调用</h2>\n<p>os.exit用于终止程序的执行。</p>\n<p>os.getev用于获取环境变量。</p>\n<p>os.execute用来运行系统命令，等价于c中的system。还用io.popen也是运行一条系统命令,但是该函数可以重定向命令的输入输出流。</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n</pre></td><td class=\"rouge-code\"><pre><span class=\"k\">function</span> <span class=\"nf\">create</span><span class=\"p\">(</span><span class=\"n\">dirname</span><span class=\"p\">)</span>\n\t<span class=\"nb\">os.execute</span><span class=\"p\">(</span><span class=\"s2\">&#34;mkdir &#34;</span><span class=\"o\">...</span><span class=\"n\">dirname</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n<p><span class=\"kd\">local</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"nb\">io.popen</span><span class=\"p\">(</span><span class=\"s2\">&quot;dir /B&quot;</span><span class=\"p\">,</span><span class=\"s2\">&quot;r&quot;</span><span class=\"p\">)</span> <span class=\"c1\">– 只读</span><br />\n<span class=\"kd\">local</span> <span class=\"n\">dir</span> <span class=\"o\">=</span> <span class=\"p\">&#123;&#125;</span><br />\n<span class=\"k\">for</span> <span class=\"n\">entry</span> <span class=\"k\">in</span> <span class=\"n\">f</span><span class=\"p\">:</span><span class=\"n\">lines</span><span class=\"p\">()</span> <span class=\"k\">do</span><br />\n<span class=\"n\">dir</span><span class=\"p\">[</span><span class=\"o\">#</span><span class=\"n\">dir</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">entry</span><br />\n<span class=\"k\">end</span><br />\n</pre></td></tr></tbody></table></code></pre></div></div></p>\n<pre><code>            &lt;hr style=&quot;visibility: hidden;&quot;/&gt;\n            \n            &lt;hr style=&quot;visibility: hidden;&quot;/&gt;\n</code></pre>\n","text":"目录 简单I/O模型 完整I/O模型 其它文件操作 其它系统调用 I want to have a talk with you my heart. 简单I/O模型 对于文件操作，I/O提供了两种不同的模型。简单模型虚拟了一个当前输入流和一个当前的输出流，其I/O是通过这些流实现的...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">目录</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95io%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">简单I&#x2F;O模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4io%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">完整I&#x2F;O模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">其他文件操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E5%AE%83%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">其它系统调用</span></a>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua快速入门","uid":"e2587e48319d030c7c41fb4968ade102","slug":"zl/2016-01-01-1003_lua快速入门","date":"2024-04-03T03:47:32.958Z","updated":"2024-04-03T03:47:32.959Z","comments":true,"path":"api/articles/zl/2016-01-01-1003_lua快速入门.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 概览：协同程序提供了一种协作式的多线程。每个协同程序都等于是一个线程。一对yield-resume可以将执行权在不同线程间切换。然而与常规多线程不同，协程是非抢先式的。 参照书籍：《Lua程序设计（第二版）》 Lua版本：Lua 5.3.5 协同程序 Lua将所有关于协同程序的...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua正则表达式","uid":"0fb98131247c865eb6ecfbafce819c65","slug":"zl/2016-01-01-1001_Lua正则表达式","date":"2024-04-03T03:47:32.956Z","updated":"2024-04-03T03:47:32.957Z","comments":true,"path":"api/articles/zl/2016-01-01-1001_Lua正则表达式.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"几乎所有的编程语言都有正则表达式的支持，Lua也不例外，但是Lua的正则表达式和其他编程语言不太一样，不是标准的通用正则表达式，Lua有自己的一套表示方式。 匹配模式Lua的匹配模式主要是用于Lua字符串处理函数string.find, string.match，string.g...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}