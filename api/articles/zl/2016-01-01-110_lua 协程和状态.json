{"title":"lua 协程和状态","uid":"669a225e8fdbd9153ff437c78e8b7ddb","slug":"zl/2016-01-01-110_lua 协程和状态","date":"2024-04-03T03:47:33.004Z","updated":"2024-04-03T03:47:33.005Z","comments":true,"path":"api/articles/zl/2016-01-01-110_lua 协程和状态.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>协程(协同式多线程)是一种用户级的非抢占式线程。用户级是指它的切换和调度由用户控制，非抢占指一个协程只有在其挂起(yield)或者协程结束才会返回。协程和C线程一样，有自己的堆栈，自己的局部变量，自己的指令指针，并且和其它协程共享全局变量等信息。用户可以实现自己调度协程，这主要得益于yield函数可以自动保存协程当前上下文，这样当挂起的协程被唤醒(resume)时，会从yield处继续向下执行，看起来就像是一个”可以返回多次的函数”。协程还有一个强大的功能就是可通过resume/yield来交换数据，这样使得它可以用于异步回调：当执行异步代码时，切换协程，执行完成后，再切换回来(附带异步执行结果)。由于切换都是用户控制的，在同一时刻只有一个协同程序在运行(这也是和传统线程最大的区别之一)，因此无需考虑同步和加锁的问题。</p>\n<p>Lua协程的相关函数封装在coroutine中，对应的 C API为<code>lua_newthread</code>，<code>lua_resume</code>等。Lua文档中的thread和coroutine是一个概念，但与操作系统的线程是两个东西。</p>\n<p>C API通过<code>lua_State</code>维护一个协程的状态(以及Lua虚拟机状态的引用)，协程的状态主要指协程上下文(如交互栈)，Lua虚拟机状态是全局的，可被多个协程共享。以下描述摘自Lua5.3官方文档：</p>\n<blockquote>\n<blockquote>\n<p>An opaque structure that points to a thread and indirectly (through the thread) to the whole state of a Lua interpreter. The Lua library is fully reentrant: it has no global variables. All information about a state is accessible through this structure.</p>\n<p>A pointer to this structure must be passed as the first argument to every function in the library, except to lua_newstate, which creates a Lua state from scratch.</p>\n</blockquote>\n</blockquote>\n<p>当调用<code>lua_newstate</code>时，实际上分为两步，1. 创建并初始化一个Lua虚拟机；2.创建一个主线程运行于虚拟机中。调用<code>lua_newthread</code>时，将在已有Lua虚拟机上，创建另一个协程执行环境，该协程与已有协程共享虚拟机状态。这两个函数返回不同的lua_State，但却共享同一个虚拟机状态，因此将lua_State理解为协程执行上下文可能更合适，lua_State本身也是一个类型为thread的GCObject，无需手动释放(Lua也没有提供对应close或destroy接口)。</p>\n<h3 id=\"两个例子\"><a href=\"#两个例子\" class=\"headerlink\" title=\"两个例子\"></a>两个例子</h3><p>pil上关于协程有两个很好的例子。</p>\n<p>在生产者消费者例子中，当消费者需要生产者的数据时(相当于一个异步回调)，切换到生产者协程(resume)，生产者开始运行，生产完成后，挂起自己(yield)并且传入生产的数据。此时调度回到消费者协程中，消费者从resume的返回值中得到数据，使用数据，在需要数据时再次唤醒生产者。这样我们像写同步代码一样(resume相当于函数调用，yield相当于函数返回)，完成了异步功能。而无需考虑传统生产者和消费者模型中的同步问题，因为执行顺序都由我们严格控制的。代码如下：</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">pfun = function()</span><br/><span class=\"line\">\twhile true do</span><br/><span class=\"line\">\t\tlocal value = io.read()</span><br/><span class=\"line\">\t\tprint(&#34;生产: &#34;, value)</span><br/><span class=\"line\">\t\tcoroutine.yield(value)</span><br/><span class=\"line\">\tend</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">cfun = function(p)</span><br/><span class=\"line\">\twhile true do</span><br/><span class=\"line\">\t\tlocal _, value = coroutine.resume(p)</span><br/><span class=\"line\">\t\tprint(&#34;消费: &#34;, value)</span><br/><span class=\"line\">\tend</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">p = coroutine.create(pfun)</span><br/><span class=\"line\">cfun(p)</span><br/></pre></td></tr></tbody></table></figure>\n<p>还有个例子是关于模拟多线程下载文件的，每个协程下载一个文件，由我们控制各个协程的调度，当某个协程暂时没有数据可读时(异步读取)，挂起(yield)自己，返回到调度器，开始调度(resume)下一个协程。这样总是能保证将时间片分给读取数据的协程上，而不是等待数据的协程上。当所有协程都没有数据可读时，分配器将进入忙查询，这样会空转CPU，可以通过select函数来优化，在所有协程都没有数据时，让出CPU。最终代码如下：</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/><span class=\"line\">26</span><br/><span class=\"line\">27</span><br/><span class=\"line\">28</span><br/><span class=\"line\">29</span><br/><span class=\"line\">30</span><br/><span class=\"line\">31</span><br/><span class=\"line\">32</span><br/><span class=\"line\">33</span><br/><span class=\"line\">34</span><br/><span class=\"line\">35</span><br/><span class=\"line\">36</span><br/><span class=\"line\">37</span><br/><span class=\"line\">38</span><br/><span class=\"line\">39</span><br/><span class=\"line\">40</span><br/><span class=\"line\">41</span><br/><span class=\"line\">42</span><br/><span class=\"line\">43</span><br/><span class=\"line\">44</span><br/><span class=\"line\">45</span><br/><span class=\"line\">46</span><br/><span class=\"line\">47</span><br/><span class=\"line\">48</span><br/><span class=\"line\">49</span><br/><span class=\"line\">50</span><br/><span class=\"line\">51</span><br/><span class=\"line\">52</span><br/><span class=\"line\">53</span><br/><span class=\"line\">54</span><br/><span class=\"line\">55</span><br/><span class=\"line\">56</span><br/><span class=\"line\">57</span><br/><span class=\"line\">58</span><br/><span class=\"line\">59</span><br/><span class=\"line\">60</span><br/><span class=\"line\">61</span><br/><span class=\"line\">62</span><br/><span class=\"line\">63</span><br/><span class=\"line\">64</span><br/><span class=\"line\">65</span><br/><span class=\"line\">66</span><br/><span class=\"line\">67</span><br/><span class=\"line\">68</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">socket = require &#34;socket&#34;</span><br/><span class=\"line\"></span><br/><span class=\"line\">-- 下载文件 在超时时挂起(返回: 连接c) 在接收完成时结束协程(返回: nil)</span><br/><span class=\"line\">function download(host, file)</span><br/><span class=\"line\">\tlocal c = assert(socket.connect(host, 80))</span><br/><span class=\"line\">\tlocal count = 0</span><br/><span class=\"line\">\tc:send(&#34;GET &#34;.. file .. &#34; HTTP/1.0rnrn&#34;)</span><br/><span class=\"line\">\twhile true do</span><br/><span class=\"line\">\t\tlocal s, status = receive(c)\t</span><br/><span class=\"line\">\t\tif status == &#34;closed&#34; then break end</span><br/><span class=\"line\">\t\tif s then </span><br/><span class=\"line\">\t\t\tcount = count + string.len(s) </span><br/><span class=\"line\">\t\t\tbreak </span><br/><span class=\"line\">\t\tend </span><br/><span class=\"line\">\tend</span><br/><span class=\"line\">\tc:close()</span><br/><span class=\"line\">\tprint(&#34;-- download &#34;, file, &#34; completed. file size: &#34;, count)</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">function receive(conn)</span><br/><span class=\"line\">\tconn:settimeout(0)</span><br/><span class=\"line\">\tlocal s, status = conn:receive(&#34;*a&#34;)</span><br/><span class=\"line\">\tif status == &#34;timeout&#34; then</span><br/><span class=\"line\">\t\tcoroutine.yield(conn)</span><br/><span class=\"line\">\tend</span><br/><span class=\"line\">\treturn s, status</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">-- 保存所有协程</span><br/><span class=\"line\">local threads = {}</span><br/><span class=\"line\">-- 创建一个协程 对应下载一个文件</span><br/><span class=\"line\">function get(host, file)</span><br/><span class=\"line\">\tlocal co = coroutine.create(function() </span><br/><span class=\"line\">\t\tdownload(host, file)</span><br/><span class=\"line\">\tend)</span><br/><span class=\"line\"></span><br/><span class=\"line\">\ttable.insert(threads, co)</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">-- 调度线程</span><br/><span class=\"line\">function dispatcher()</span><br/><span class=\"line\">\twhile true do</span><br/><span class=\"line\">\t\tlocal conns = {}</span><br/><span class=\"line\">\t\tlocal n = #threads</span><br/><span class=\"line\">\t\tif n == 0 then break end</span><br/><span class=\"line\">\t\tfor i = 1,n do</span><br/><span class=\"line\">\t\t\tlocal status, c = coroutine.resume(threads[i])</span><br/><span class=\"line\">\t\t\tif not c then -- 接收数据完成 即download 函数正常返回</span><br/><span class=\"line\">\t\t\t\ttable.remove(threads, i) -- 移除协程</span><br/><span class=\"line\">\t\t\t\tbreak -- 重新遍历</span><br/><span class=\"line\">\t\t\telse</span><br/><span class=\"line\">\t\t\t\ttable.insert(conns, c)</span><br/><span class=\"line\">\t\t\tend</span><br/><span class=\"line\">\t\tend</span><br/><span class=\"line\">\t\tif #conns == n then</span><br/><span class=\"line\">\t\t\tsocket.select(conns)</span><br/><span class=\"line\">\t\tend</span><br/><span class=\"line\">\tend</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">get(&#34;www.baidu.com&#34;, &#34;/index.html&#34;)</span><br/><span class=\"line\">get(&#34;wudaijun.com&#34;, &#34;/2014/12/shared_ptr-reference/&#34;)</span><br/><span class=\"line\">get(&#34;wudaijun.com&#34;, &#34;/2014/11/cpp-constructor/&#34;)</span><br/><span class=\"line\"></span><br/><span class=\"line\">local start = os.time()</span><br/><span class=\"line\">dispatcher()</span><br/><span class=\"line\">local cost = os.time()-start</span><br/><span class=\"line\">print(&#34;-- cost time: &#34;, cost)</span><br/></pre></td></tr></tbody></table></figure>","text":"协程(协同式多线程)是一种用户级的非抢占式线程。用户级是指它的切换和调度由用户控制，非抢占指一个协程只有在其挂起(yield)或者协程结束才会返回。协程和C线程一样，有自己的堆栈，自己的局部变量，自己的指令指针，并且和其它协程共享全局变量等信息。用户可以实现自己调度协程，这主要得...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">两个例子</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"design pattern - observer pattern in c++ and lua","uid":"0a15add781a9db23ff81d14c8ccc8d4b","slug":"zl/2016-01-01-1109_design pattern - observer pattern in c++ and lua","date":"2024-04-03T03:47:33.004Z","updated":"2024-04-03T03:47:33.004Z","comments":true,"path":"api/articles/zl/2016-01-01-1109_design pattern - observer pattern in c++ and lua.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" What is Observer Pattern Example in C++ Example in Lua Observer Pattern Wiki The observer pattern is a software design pattern in which an ...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"9 why's to ask when evaluating a distributed database","uid":"89e756262469d29125eb0877dc013a5d","slug":"zl/2016-01-01-1106_9 why's to ask when evaluating a distributed datab","date":"2024-04-03T03:47:33.003Z","updated":"2024-04-03T03:47:33.003Z","comments":true,"path":"api/articles/zl/2016-01-01-1106_9 why's to ask when evaluating a distributed datab.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" When I first started building TiDB with my co-founders, we encountered countless challenges, pitfalls, and critical design choices that cou...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}