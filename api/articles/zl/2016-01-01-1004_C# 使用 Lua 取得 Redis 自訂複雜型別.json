{"title":"C# 使用 Lua 取得 Redis 自訂複雜型別","uid":"ef6e0e3790ee285c739478c614658d5e","slug":"zl/2016-01-01-1004_C# 使用 Lua 取得 Redis 自訂複雜型別","date":"2024-04-03T03:47:32.960Z","updated":"2024-04-03T03:47:32.960Z","comments":true,"path":"api/articles/zl/2016-01-01-1004_C# 使用 Lua 取得 Redis 自訂複雜型別.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"c-使用-lua-取得-redis-自訂複雜型別\">C# 使用 Lua 取得 Redis 自訂複雜型別</h2>\n<p>之前筆記 <a href=\"https://blog.yowko.com/redis-lua-dcitionary/\" target=\"_blank\" rel=\"noopener noreferrer\">在 Redis 中使用 Lua 的 Dictionary</a> 紀錄到在 Redis 中使用 Lua 時可以如何模擬並使用 Dictionary，而筆記最後也提到透過這樣的方式處理時，Lua 的回傳值會不如預期，所以今天要來紀錄個人的做法，但我無法確定是不是最好的方法 XD，有錯請大家指教了</p>\n<h2 id=\"基本環境說明\">基本環境說明</h2>\n<ol>\n<li>macOS Catalina 10.15.1</li>\n<li>.NET Core SDK 3.1.100</li>\n<li>redis-cli 5.0.5</li>\n<li><p>NuGet packages</p>\n<ul>\n<li>StackExchange.Redis 2.0.601</li>\n<li>Newtonsoft.Json 12.0.3</li>\n<li>MessagePack 1.8.80</li>\n</ul></li>\n<li><p>測試用 model</p>\n<pre><code class=\"language-cs\">public class User\n&#123;\n    public int UserId &#123; get; set; &#125;\n\n    public string Name &#123; get; set; &#125;\n\n    public string Email &#123; get; set; &#125;\n&#125;\n</code></pre></li>\n</ol>\n<h2 id=\"原始-lua-內容\">原始 lua 內容</h2>\n<p>詳細內容可以參考 <a href=\"https://blog.yowko.com/redis-lua-dcitionary/\" target=\"_blank\" rel=\"noopener noreferrer\">在 Redis 中使用 Lua 的 Dictionary</a></p>\n<pre><code class=\"language-lua\">local allUsersKey=&#34;users&#34;\nlocal userdataPrefixKey=&#34;userdata&#34;\n-- 取得所有 user\nlocal allUsers = redis.call(&#34;smembers&#34;,  allUsersKey)\n--逐一處理所有 user\nlocal results = &#123;&#125; for userIndex, userId in ipairs(allUsers) do\n    -- 單一 user 的 key\n    local userdataKey=userdataPrefixKey .. &#34;:&#34; .. userId\n    -- 取得單一 user 的所有屬性值\n    local getAll= redis.call(&#34;HGETALL&#34;, userdataKey)\n    -- 暫存欄位名稱\n    local tmpSubKey=&#34;&#34;\n    -- 處理所有欄位屬性\n    local tmpSubData = &#123;&#125;\n    -- 將 userId 當做 object 的一個屬性\n    tmpSubData[&#34;userId&#34;]=userId\n    for index,value in ipairs (getAll) do\n    -- 如果 index 是單數則為欄位名稱，偶數為屬性值\n    if index % 2 == 1 then\n        tmpSubKey= value\n    else\n        -- 使用名稱設定 table \n        tmpSubData[tmpSubKey]=value\n    end\n    end\n    -- 將個別 user object 存入 table 中\n    table.insert(results, tmpSubData)\nend\nreturn results\n</code></pre>\n<h2 id=\"回傳-json\">回傳 json</h2>\n<p>將最終結果使用 <code>cjson.encode</code> 轉為 json</p>\n<ul>\n<li><p>lua</p>\n<pre><code class=\"language-lua\">local allUsersKey=&#34;users&#34;\nlocal userdataPrefixKey=&#34;userdata&#34;\n\n-- 取得所有 user\nlocal allUsers = redis.call(&#34;smembers&#34;,  allUsersKey)\n\n--逐一處理所有 user\nlocal results = &#123;&#125; for userIndex, userId in ipairs(allUsers) do\n  -- 單一 user 的 key\n  local userdataKey=userdataPrefixKey .. &#34;:&#34; .. userId\n  -- 取得單一 user 的所有屬性值\n  local getAll= redis.call(&#34;HGETALL&#34;, userdataKey)\n  -- 暫存欄位名稱\n  local tmpSubKey=&#34;&#34;\n  -- 處理所有欄位屬性\n  local tmpSubData = &#123;&#125;\n  -- 將 userId 當做 object 的一個屬性\n  tmpSubData[&#34;userId&#34;]=userId\n  for index,value in ipairs (getAll) do\n    -- 如果 index 是單數則為欄位名稱，偶數為屬性值\n    if index % 2 == 1 then\n      tmpSubKey= value\n    else\n      -- 使用名稱設定 table \n      tmpSubData[tmpSubKey]=value\n    end\n  end\n  -- 將個別 user object 存入 table 中\n  table.insert(results, tmpSubData)\nend\nreturn cjson.encode(results)\n</code></pre></li>\n<li><p>C#</p>\n<pre><code class=\"language-cs\">//準備 redis 連線\nvar redis = ConnectionMultiplexer.Connect(&#34;127.0.0.1:6379&#34;);\nvar db = redis.GetDatabase();\n\n//從專案中取得 lua (lua 設為 EmbeddedResource)\nvar script = string.Empty;\nvar assembly = Assembly.GetExecutingAssembly();\nconst string resourceName = &#34;TestRedisLuaDictionary.user.lua&#34;;\n//載入 lua 檔案\nawait using (var stream = assembly.GetManifestResourceStream(resourceName))\n&#123;\n    using var reader = new StreamReader(stream);\n    script = reader.ReadToEnd();\n&#125;\n//將文字內容轉為 lua\nvar prepared = LuaScript.Prepare(script);\n//執行 lua\nvar redisResult = db.ScriptEvaluate(prepared);\n//將 redis 回傳內容使用 json 轉為物件\nvar result = JsonConvert.DeserializeObject&lt;User[]&gt;(redisResult.ToString());\n\nConsole.WriteLine(result);\n</code></pre></li>\n<li><p>實際結果</p>\n<pre><code class=\"language-txt\">[&#123;&#34;userId&#34;:&#34;1&#34;,&#34;name&#34;:&#34;yowko&#34;,&#34;email&#34;:&#34;yowko@yowko.com&#34;&#125;,&#123;&#34;userId&#34;:&#34;3&#34;,&#34;name&#34;:&#34;test&#34;,&#34;email&#34;:&#34;test@test.com&#34;&#125;,&#123;&#34;userId&#34;:&#34;5&#34;,&#34;name&#34;:&#34;poc&#34;,&#34;email&#34;:&#34;poc@poc.com&#34;&#125;]\n</code></pre></li>\n</ul>\n<h2 id=\"回傳-messagepack\">回傳 MessagePack</h2>\n<ul>\n<li><p>lua</p>\n<pre><code class=\"language-lua\">local allUsersKey=&#34;users&#34;\nlocal userdataPrefixKey=&#34;userdata&#34;\n\n-- 取得所有 user\nlocal allUsers = redis.call(&#34;smembers&#34;,  allUsersKey)\n\n--逐一處理所有 user\nlocal results = &#123;&#125; for userIndex, userId in ipairs(allUsers) do\n-- 單一 user 的 key\nlocal userdataKey=userdataPrefixKey .. &#34;:&#34; .. userId\n-- 取得單一 user 的所有屬性值\nlocal getAll= redis.call(&#34;HGETALL&#34;, userdataKey)\n-- 暫存欄位名稱\nlocal tmpSubKey=&#34;&#34;\n-- 處理所有欄位屬性\nlocal tmpSubData = &#123;&#125;\n-- 將 userId 當做 object 的一個屬性\ntmpSubData[&#34;userId&#34;]=userId\nfor index,value in ipairs (getAll) do\n    -- 如果 index 是單數則為欄位名稱，偶數為屬性值\n    if index % 2 == 1 then\n    tmpSubKey= value\n    else\n    -- 使用名稱設定 table \n    tmpSubData[tmpSubKey]=value\n    end\nend\n-- 將個別 user object 存入 table 中\ntable.insert(results, tmpSubData)\nend\n\nreturn cmsgpack.pack(results)\n</code></pre></li>\n<li><p>C#</p>\n<ul>\n<li><p>轉換程式</p>\n<blockquote>\n<p>相關詳細說明可以參考之前筆記 <a href=\"https://blog.yowko.com/property-value-dictionary-to-object/\" target=\"_blank\" rel=\"noopener noreferrer\">C# - Property 與 Value 的 Dictionary 轉為 Object</a></p>\n</blockquote>\n<pre><code class=\"language-cs\">private static T DictionaryToObject&lt;T&gt;(IDictionary&lt;String, Object&gt; dictionary) where T : class, new()\n&#123;\n    // 取得 T 所有 property\n    var myPropertyInfo = typeof(T).GetProperties();\n    // 將 property 的 name 轉為小寫當 key，value 為原始大小寫，讓傳入的資料無論大小寫皆可轉換\n    var properties = myPropertyInfo\n        .Select(a =&gt; new KeyValuePair&lt;string, string&gt;(a.Name.ToLowerInvariant(), a.Name))\n        .ToDictionary(a =&gt; a.Key, a =&gt; a.Value);\n\n    // 建立 T 實體\n    var instance = Activator.CreateInstance&lt;T&gt;();\n\n    //處理所有欄位\n    foreach (var (key, value) in dictionary)\n    &#123;\n        var name = key.ToLowerInvariant();\n\n        //欄位名稱不存在就換下一個\n        if (!properties.TryGetValue(name, out var property)) continue;\n\n        var prop = typeof(T).GetProperty(property);\n\n        //依據不同型別來做轉換，只意思寫 int 與 string，請自行擴充\n        switch (prop.PropertyType)\n        &#123;\n            case &#123; &#125; intType when intType == typeof(int):\n                prop.SetValue(instance, Convert.ToInt32(value), null);\n\n                break;\n            case &#123; &#125; stringType when stringType == typeof(string):\n                prop.SetValue(instance, Convert.ToString(value), null);\n\n                break;\n        &#125;\n    &#125;\n\n    return instance;\n&#125;\n</code></pre></li>\n<li><p>實際使用</p>\n<pre><code class=\"language-cs\">//準備 redis 連線\nvar redis = ConnectionMultiplexer.Connect(&#34;127.0.0.1:6379&#34;);\nvar db = redis.GetDatabase();\n\n//從專案中取得 lua (lua 設為 EmbeddedResource)\nvar script = string.Empty;\nvar assembly = Assembly.GetExecutingAssembly();\nconst string resourceName = &#34;TestRedisLuaDictionary.user.lua&#34;;\n//載入 lua 檔案\nawait using (var stream = assembly.GetManifestResourceStream(resourceName))\n&#123;\n    using var reader = new StreamReader(stream);\n    script = reader.ReadToEnd();\n&#125;\n//將文字內容轉為 lua\nvar prepared = LuaScript.Prepare(script);\n//執行 lua\nvar redisResult = db.ScriptEvaluate(prepared);\n//將 redis 回傳內容轉為 byte[] 再透過 MessagePack 反序列化為 Dictionary&lt;string, object&gt;[]\nvar result = MessagePackSerializer\n        .Deserialize&lt;Dictionary&lt;string, object&gt;[]&gt;((byte[]) redisResult);\n\n// 將 Dictionary&lt;string, object&gt;[] 轉為 User\nvar outputResult = result.Select(DictionaryToObject&lt;User&gt;);\n\nConsole.WriteLine(JsonConvert.SerializeObject(outputResult));\n</code></pre></li>\n</ul></li>\n<li><p>實際結果</p>\n<pre><code class=\"language-txt\">[&#123;&#34;UserId&#34;:1,&#34;Name&#34;:&#34;yowko&#34;,&#34;Email&#34;:&#34;yowko@yowko.com&#34;&#125;,&#123;&#34;UserId&#34;:3,&#34;Name&#34;:&#34;test&#34;,&#34;Email&#34;:&#34;test@test.com&#34;&#125;,&#123;&#34;UserId&#34;:5,&#34;Name&#34;:&#34;poc&#34;,&#34;Email&#34;:&#34;poc@poc.com&#34;&#125;]\n</code></pre>\n<ul>\n<li><p>redis 回傳的 MessagePack 原始資料</p>\n<pre><code class=\"language-txt\">���userId�1�name�yowko�email�yowko@yowko.com��userId�3�name�test�email�test@test.com��userId�5�name�poc�email�poc@poc.com\n</code></pre></li>\n</ul></li>\n</ul>\n<h2 id=\"心得\">心得</h2>\n<p>透過 json 與 MessagePack 都可以將 redis 中 lua 回傳自訂型別的 dictionary 轉換為 object，當然 json 在使用上方便許多：程式碼較少，redis 的回傳內容可讀性也高，但 MessagePack 有壓縮的功用，在傳輸速度上有優勢，這個就看專案需求來選擇囉</p>\n<h2 id=\"參考資訊\">參考資訊</h2>\n<ol>\n<li><a href=\"https://redis.io/commands/eval\" target=\"_blank\" rel=\"noopener noreferrer\">EVAL script numkeys key [key …] arg [arg …]</a></li>\n<li><a href=\"https://blog.yowko.com/property-value-dictionary-to-object/\" target=\"_blank\" rel=\"noopener noreferrer\">C# - Property 與 Value 的 Dictionary 轉為 Object</a></li>\n</ol>","text":"C# 使用 Lua 取得 Redis 自訂複雜型別 之前筆記 在 Redis 中使用 Lua 的 Dictionary 紀錄到在 Redis 中使用 Lua 時可以如何模擬並使用 Dictionary，而筆記最後也提到透過這樣的方式處理時，Lua 的回傳值會不如預期，所以今天要來...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-%E4%BD%BF%E7%94%A8-lua-%E5%8F%96%E5%BE%97-redis-%E8%87%AA%E8%A8%82%E8%A4%87%E9%9B%9C%E5%9E%8B%E5%88%A5\"><span class=\"toc-text\">C# 使用 Lua 取得 Redis 自訂複雜型別</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%92%B0%E5%A2%83%E8%AA%AA%E6%98%8E\"><span class=\"toc-text\">基本環境說明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%A7%8B-lua-%E5%85%A7%E5%AE%B9\"><span class=\"toc-text\">原始 lua 內容</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E5%82%B3-json\"><span class=\"toc-text\">回傳 json</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E5%82%B3-messagepack\"><span class=\"toc-text\">回傳 MessagePack</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BF%83%E5%BE%97\"><span class=\"toc-text\">心得</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%83%E8%80%83%E8%B3%87%E8%A8%8A\"><span class=\"toc-text\">參考資訊</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"OpenResty Lua学习笔记","uid":"94a2baa5e4dd93e510852659f6351164","slug":"zl/2016-01-01-1006_OpenResty Lua学习笔记","date":"2024-04-03T03:47:32.961Z","updated":"2024-04-03T03:47:32.962Z","comments":true,"path":"api/articles/zl/2016-01-01-1006_OpenResty Lua学习笔记.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"由于公司C端业务的 Nginx 框架使用的是OpenResty。在上一篇文章学习了 Nginx 基础知识后，决定再学习一下 Lua 和 OpenResty。本文记录了自己学习过程中的一些笔记和总结，尝试了OpenResty在本地搭建简单的API Server框架的demo，包括处...","link":"","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua语言学习（二）","uid":"51cf44d856e3e23c66566852b46bc298","slug":"zl/2016-01-01-1005_Lua语言学习（二）","date":"2024-04-03T03:47:32.960Z","updated":"2024-04-03T03:47:32.961Z","comments":true,"path":"api/articles/zl/2016-01-01-1005_Lua语言学习（二）.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt;&lt;strong&gt;接下来的几篇是根据&lt;a href=&quot;http://lua-users.org/wiki/TutorialDirectory&quot;&gt; Lua-Users wiki &lt;/a&gt;梳理的一些细节&lt;...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}