{"title":"lua虚拟机概述","uid":"ff37b2c4a3c12f5e9aa2a4071cd03370","slug":"zl/2016-01-01-606_lua虚拟机概述","date":"2024-04-03T03:47:35.838Z","updated":"2024-04-03T03:47:35.838Z","comments":true,"path":"api/articles/zl/2016-01-01-606_lua虚拟机概述.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h4 id=\"何为虚拟机\"><a href=\"#何为虚拟机\" class=\"headerlink\" title=\"何为虚拟机\"></a>何为虚拟机</h4><p>用于模拟计算机运行的程序.是个中间层,它处于脚本语言和硬件之间的一个程序.每一门脚本语言都会有自己定义的opcode(”操作码”),可以理解为这门程序自己定义的”汇编语言”.一般的编译型语言,比如C等,经过编译器编译之后生成的都是与当前硬件环境相匹配的汇编代码;而脚本型的语言,经过前端的处理之后,生成的就是opcode,再将该opcode放在这门语言的虚拟机中执行.虚拟机是作为单独的程序独立存在,而Lua由于是一门嵌入式的语言是附着在宿主环境中的.   </p>\n<h3 id=\"lua代码到虚拟机执行的流程\"><a href=\"#lua代码到虚拟机执行的流程\" class=\"headerlink\" title=\"lua代码到虚拟机执行的流程\"></a>lua代码到虚拟机执行的流程</h3><p><img src=\"https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215140547779-1286988518.png\" alt=\"\"/></p>\n<p>在Lua中,Lua代码从词法分析到语法分析再到生成opcode,最后进入虚拟机执行的大体流程是什么样子的呢？</p>\n<p>Lua的API中提供了luaL_dofile函数,它实际上是个宏,内部首先调用luaL_loadfile函数,加载Lua代码进行语法,词法分析,生成Lua虚拟机可执行的代码,再调用lua_pcall函数,执行其中的代码:</p>\n<pre><code>    #define luaL_dofile(L, fn) \n        (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))\n</code></pre><p>前半部分调用luaL_loadfile函数对Lua代码进行词法和语法分析,后半部分调用lua_pcall将第一步中分析的结果(也就是opcode)到虚拟机中执行.</p>\n<p>首先来看luaL_loadfile函数,暂时不深入其中研究它如何分析一个Lua代码文件,先看它最后输出了什么.它最终会调用f_parser函数,这是对一个Lua代码进行分析的入口函数:</p>\n<pre><code>    static void f_parser (lua_State *L, void *ud) &#123;\n      int i;\n      Proto *tf;\n      Closure *cl;\n      struct SParser *p = cast(struct SParser *, ud);\n      int c = luaZ_lookahead(p-&gt;z);\n      luaC_checkGC(L);\n      tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p-&gt;z,\n                                                                 &amp;p-&gt;buff, p-&gt;name);\n      cl = luaF_newLclosure(L, tf-&gt;nups, hvalue(gt(L)));\n      cl-&gt;l.p = tf;\n      for (i = 0; i &lt; tf-&gt;nups; i++)  /* initialize eventual upvalues */\n        cl-&gt;l.upvals[i] = luaF_newupval(L);\n      setclvalue(L, L-&gt;top, cl);\n      incr_top(L);\n    &#125;\n</code></pre><p>在完成词法分析之后,返回了Proto类型的指针tf,然后将其绑定在新创建的Closure指针上,初始化UpValue,最后压入Lua栈中.</p>\n<p>不难想像,Lua词法分析之后产生的opcode等相关数据都在这个Proto类型的结构体中.</p>\n<p>再来看lua_pcall函数是如何将产生的opcode放入虚拟机执行的.</p>\n<p>lua_pcall函数中,首先获取需要调用的函数指针:</p>\n<pre><code>    c.func = L-&gt;top - (nargs+1);  /* function to be called */\n</code></pre><p>这里的nargs是由函数参数传入的,luaL_dofile中调用lua_pcall时这里传入的参数是0,换句话说,这里得到的函数对象指针就是在f_parser函数中最后放入Lua栈的指针.</p>\n<p>继续往下执行,走到luaD_call函数,有这一段代码:</p>\n<pre><code>\n      if (luaD_precall(L, func, nResults) == PCRLUA)  /* is a Lua function? */\n        luaV_execute(L, 1);  /* call it */\n</code></pre><p>进入luaV_execute函数,这里是虚拟机执行代码的主函数:</p>\n<pre><code>\n    void luaV_execute (lua_State *L, int nexeccalls) &#123;\n      LClosure *cl;\n      StkId base;\n      TValue *k;\n      const Instruction *pc;\n     reentry:  /* entry point */\n      lua_assert(isLua(L-&gt;ci));\n      pc = L-&gt;savedpc;\n      cl = &amp;clvalue(L-&gt;ci-&gt;func)-&gt;l;\n      base = L-&gt;base;\n      k = cl-&gt;p-&gt;k;\n      /* main loop of interpreter */\n      for (;;) &#123;\n        const Instruction i = *pc++;\n        StkId ra;\n        if ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp;\n            (--L-&gt;hookcount == 0 || L-&gt;hookmask &amp; LUA_MASKLINE)) &#123;\n          traceexec(L, pc);\n          if (L-&gt;status == LUA_YIELD) &#123;  /* did hook yield? */\n            L-&gt;savedpc = pc - 1;\n            return;\n          &#125;\n          base = L-&gt;base;\n        &#125;\n        /* warning!! several calls may realloc the stack and invalidate `ra&#39; */\n        ra = RA(i);\n    // 以下是各种opcode的情况处理\n    &#125;\n</code></pre><p>可以看到,这里的pc指针里存放的是虚拟机opcode代码,它最开始从L-&gt;savepc初始化而来,而L-&gt;savepc在luaD_precall中赋值:</p>\n<pre><code>    L-&gt;savedpc = p-&gt;code;  /* starting point */\n</code></pre><p>这里的p就是第一步f_parser中返回的Proto指针.</p>\n<p>回顾一下整个流程:</p>\n<ol>\n<li><p>函数f_parser中,对Lua代码文件的分析返回了Proto指针</p>\n</li>\n<li><p>函数luaD_precall中,将Lua_state的savepc指针指向1中的Proto结构体的code指针</p>\n</li>\n<li><p>函数luaV_execute中,pc指针指向2中的savepc指针,紧跟着就是一个大的循环体,依次取出其中的opcode进行执行.<br/><img src=\"https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215141251439-1865045097.png\" alt=\"\"/></p>\n</li>\n</ol>","text":"何为虚拟机用于模拟计算机运行的程序.是个中间层,它处于脚本语言和硬件之间的一个程序.每一门脚本语言都会有自己定义的opcode(”操作码”),可以理解为这门程序自己定义的”汇编语言”.一般的编译型语言,比如C等,经过编译器编译之后生成的都是与当前硬件环境相匹配的汇编代码;而脚本型...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%95%E4%B8%BA%E8%99%9A%E6%8B%9F%E6%9C%BA\"><span class=\"toc-text\">何为虚拟机</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#lua%E4%BB%A3%E7%A0%81%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">lua代码到虚拟机执行的流程</span></a>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua入门教程：模块与包","uid":"119ad173949f3ea740cc9a4efa8a474a","slug":"zl/2016-01-01-611_Lua入门教程：模块与包","date":"2024-04-03T03:47:35.839Z","updated":"2024-04-03T03:47:35.839Z","comments":true,"path":"api/articles/zl/2016-01-01-611_Lua入门教程：模块与包.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua 从 5.1 版本开始为模块与包定义了一系列规则，这些规则不需要引入额外的功能特性。对用户来说，一个模块就是一些代码，这些代码可以通过 require 函数加载。 值得注意的是，从 Lua 5.2 开始编写模块的建议方式已经发生改变，而不在是 Lua 5.1 中的 modu...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"如何用 openresty + lua 快速搭建一个简单网站","uid":"8b44d23281c1aae6a8ca72eab735ba22","slug":"zl/2016-01-01-609_如何用 openresty + lua 快速搭建一个简单网站","date":"2024-04-03T03:47:35.838Z","updated":"2024-04-03T03:47:35.838Z","comments":true,"path":"api/articles/zl/2016-01-01-609_如何用 openresty + lua 快速搭建一个简单网站.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"最近在折腾 OpenResty，OpenResty 就不用多介绍了，这方面国内质量好的资料也不多，如果非要选一个入门级别的资料，自然是《OpenResty 最佳实践》。断断续续看了一些 Lua 的语法和 OpenResty 基础，就想做点什么练练手。碰巧某天。同事介绍了几个 Op...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}