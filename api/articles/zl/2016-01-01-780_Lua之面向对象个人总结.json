{"title":"Lua之面向对象个人总结","uid":"852c964e0ebf9776baeac392aedb9bd9","slug":"zl/2016-01-01-780_Lua之面向对象个人总结","date":"2024-04-03T03:47:36.017Z","updated":"2024-04-03T03:47:36.017Z","comments":true,"path":"api/articles/zl/2016-01-01-780_Lua之面向对象个人总结.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<hr/>\n<blockquote>\n<p>面向对象的三个特征：封装、继承和多态。Lua并没有类，没有直接实现<strong>面向对象</strong>的方法。不过Lua的Table，有内部对象和内部方法。Lua的面向对象主要是通过Table来模拟面向对象。</p>\n</blockquote>\n<hr/>\n<h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><p>在<a href=\"Lua之Table学习.md\">Lua之Table学习</a>中，曾以Computer为例子，介绍了Table 也是可以有自己内部的属性和方法。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">local CPU = { name = &#39;CPU&#39;, cost = 400 }</span><br/><span class=\"line\">local Monitor = { name = &#39;bird&#39;, cost = 200 }</span><br/><span class=\"line\">local Memory = { name = &#39;memory&#39;, cost = 100 }</span><br/><span class=\"line\">local Computer = {</span><br/><span class=\"line\">  description = &#34;this is a computer&#34;,</span><br/><span class=\"line\">  cpu = CPU,</span><br/><span class=\"line\">  monitor = Monitor,   </span><br/><span class=\"line\">  memory = Memory</span><br/><span class=\"line\">}</span><br/><span class=\"line\">function Computer.getDescription()</span><br/><span class=\"line\">    return Computer.description</span><br/><span class=\"line\">end</span><br/><span class=\"line\">print(Computer.getDescription())</span><br/><span class=\"line\">&gt;</span><br/></pre></td></tr></tbody></table></figure>\n</blockquote>\n<p>上面的代码有几个问题<br/>1、没有构造函数，没办法实例化对象<br/>2、内部的方法更像Java中的静态方法，不需要有具体对象都能够调用。内部的成员更像静态成员。<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/><span class=\"line\">26</span><br/><span class=\"line\">27</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">local Computer={}</span><br/><span class=\"line\">Computer.cpu = { name = &#39;cpu&#39;,cost = 400 }</span><br/><span class=\"line\">Computer.memory = {name = &#39;memory&#39;,cost = 200 }</span><br/><span class=\"line\">Computer.monitor = {name = &#39;monitor&#39;,cost = 100 }</span><br/><span class=\"line\">Computer.description = &#39;this is a computer&#39;</span><br/><span class=\"line\">function Computer:getDescription()  --内部方法</span><br/><span class=\"line\">    print(self.description)</span><br/><span class=\"line\">end</span><br/><span class=\"line\">function Computer:new ()  --构造函数</span><br/><span class=\"line\">    t = {}</span><br/><span class=\"line\">    setmetatable(t, { __index = self })</span><br/><span class=\"line\">    return t</span><br/><span class=\"line\">end</span><br/><span class=\"line\">function Computer:getCost()   --内部方法</span><br/><span class=\"line\">    cost =  self.cpu.cost + self.memory.cost + self.monitor.cost</span><br/><span class=\"line\">    print(self.description..&#39;:cost &#39;.. cost)</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">c1=Computer:new()</span><br/><span class=\"line\">c1.description = &#39;this is c1&#39;  --改变Computer实例化对象内部的description</span><br/><span class=\"line\">c1:getDescription()</span><br/><span class=\"line\">c1:getCost()</span><br/><span class=\"line\"></span><br/><span class=\"line\">c2=Computer:new()</span><br/><span class=\"line\">c2.memory.cost = 900      --改变Computer实例化对象内部的memory.cost</span><br/><span class=\"line\">c2:getDescription()</span><br/><span class=\"line\">c2:getCost()</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>输出<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">this is c1  </span><br/><span class=\"line\">this is c1:cost 700   --c2的memory.cost改变，c1不受影响</span><br/><span class=\"line\">this is a computer    --c1的description改变，c2不受影响</span><br/><span class=\"line\">this is a computer:cost 1400</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>改良后的代码，有了构造函数，能够实例化对象。上面实例化了两个对象c1和c2，内部成员相互独立，无法相互影响。</p>\n<h4 id=\"访问成员\"><a href=\"#访问成员\" class=\"headerlink\" title=\"访问成员\"></a>访问成员</h4><p>使用点访问类内成员<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">c1.description = &#39;this is c1&#39;</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<h4 id=\"成员函数\"><a href=\"#成员函数\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">function getCost()  --普通函数</span><br/><span class=\"line\">  --do something</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">function Computer:getCost() --成员函数，</span><br/><span class=\"line\">  cost =  self.cpu.cost + self.memory.cost + self.monitor.cost</span><br/><span class=\"line\">  print(self.description..&#39;:cost &#39;.. cost)</span><br/><span class=\"line\">end</span><br/></pre></td></tr></tbody></table></figure>\n<p>普通函数只需要function修饰就可以了，成员函数除了function 关键字还需要声明属于某个类。前面的Computer 表示这个是Computer 类的成员函数。之间需要用冒号(:)来连接。<br/>成员函数内部的self相当于Java 的this，表示实例对象自身。<br/>如果用普通函数声明为成员函数，调用自身成员需要传入self<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">function Computer.getDescription(self) --成员函数</span><br/><span class=\"line\">    print(self.description)</span><br/><span class=\"line\">end</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>实例对象访问成员函数通过冒号(:)访问，也可以通过点号(.)访问，后者访问时候需要传入self，即自身<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">function Computer.getDescription(self)</span><br/><span class=\"line\">    print(self.description)</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">function Computer:getCost()</span><br/><span class=\"line\">    cost =  self.cpu.cost + self.memory.cost + self.monitor.cost</span><br/><span class=\"line\">    print(self.description .. &#39;:cost &#39; .. cost)</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">c1:getCost() </span><br/><span class=\"line\">c1.getCost(c1)</span><br/><span class=\"line\">c1:getDescription()</span><br/><span class=\"line\">c1.getDescription(c1)</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>输出<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">this is c1:cost 700 </span><br/><span class=\"line\">this is c1:cost 700  --只用冒号(:)式声明getCost()，用点式(.)传入自身也能访问</span><br/><span class=\"line\">this is c1   --只用点式(.)式声明getCost()，用冒号(:)式不传参也能访问</span><br/><span class=\"line\">this is c1</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>可以看到两种成员函数声明方式是等价的，使用也是等价的。</p>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>使用构造函数来为类的实例分配内存，每个类都有属于自己的内存并共享公共数据。<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">function Computer:new ()  --构造函数</span><br/><span class=\"line\">    t = {}</span><br/><span class=\"line\">    setmetatable(t, { __index = self })</span><br/><span class=\"line\">    return t</span><br/><span class=\"line\">end</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<h5 id=\"构造函数本质上也是成员函数，同时需要使用关键字new-来说明这是一个构造函数。\"><a href=\"#构造函数本质上也是成员函数，同时需要使用关键字new-来说明这是一个构造函数。\" class=\"headerlink\" title=\"构造函数本质上也是成员函数，同时需要使用关键字new 来说明这是一个构造函数。\"></a>构造函数本质上也是成员函数，同时需要使用关键字new 来说明这是一个构造函数。</h5><p>为什么要用元表来构造呢，不能直接<code>return self</code>呢，下面举个例子，构造函数直接返回self<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">local Computer = {}</span><br/><span class=\"line\">Computer.description = &#39;this is a computer&#39;</span><br/><span class=\"line\"></span><br/><span class=\"line\">function Computer:getDescription()</span><br/><span class=\"line\">    print(self.description)</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">function Computer:new()</span><br/><span class=\"line\">    return self</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">c1 = Computer:new()</span><br/><span class=\"line\">c1.description = &#39;this is c1&#39;</span><br/><span class=\"line\">c1:getDescription()</span><br/><span class=\"line\">c2 = Computer:new()</span><br/><span class=\"line\">c2:getDescription()</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>输出<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">this is c1</span><br/><span class=\"line\">this is c1</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>按照思维，只改变了c1的description，c1和c2是独立的对象，c2应该不受影响才对。编译过程也没有报错，但是c2的description也被改变了。<br/>如果我们把self本身也看做一块独立的内存，实例化c1的时候，构造函数返回self，c1 -&gt; self,对象c1指向self的内存位置。在实例化c2的时候，构造函数也返回了self，c2也指向了self。改变c1的description，实质改变了self的description，这样c2读取的description，也受到了改变。</p>\n<h5 id=\"如何正确地构造对象呢\"><a href=\"#如何正确地构造对象呢\" class=\"headerlink\" title=\"如何正确地构造对象呢\"></a>如何正确地构造对象呢</h5><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">function Computer:new()</span><br/><span class=\"line\">    t = {}</span><br/><span class=\"line\">    setmetatable(t, { __index = self })</span><br/><span class=\"line\">    return t</span><br/><span class=\"line\">end</span><br/></pre></td></tr></tbody></table></figure>\n<p>这个构造函数，先是构造了一个空表t，然后把self传入到__index元方法，作为元表。最后返回t对象。</p>\n<blockquote>\n<p>Lua查找一个表元素时的规则，其实就是如下3个步骤:<br/>1.在表中查找，如果找到，返回该元素，找不到则继续<br/>2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续。<br/>3.判断元表有没有__index 方法，如果__index 方法为nil，则返回nil；如果__index方法是一个表，则重复1、2、3；如果__index方法是一个函数，则返回该函数的返回值。  </p>\n</blockquote>\n<p>Lua的“面向对象”，实质上是利用表和元表制造的一层层“嵌套关系”。<code>c1.description = &#39;this is c1&#39;</code>这行函数，本质上没有改变self的值，而是在c1对象中增加了description这一属性，因为在表中已经找到了，所以就不会访问元表中的description属性，造成‘改写’这现象。而如果访问的是cpu这个属性，因为c1中找不到，会访问元表，然后直到找到为止。如果访问gpu这个不存在的属性，会一直找下去，直到元方法__index为nil时退出。<br/>下面的代码应该可以验证这一猜想。<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">c1 = Computer:new()</span><br/><span class=\"line\">print(&#39;before init description&#39;)</span><br/><span class=\"line\">for k, v in pairs(c1) do</span><br/><span class=\"line\">    print(k, v)       </span><br/><span class=\"line\">end</span><br/><span class=\"line\">print(c1.description)</span><br/><span class=\"line\">c1.description = &#39;this is c1&#39;</span><br/><span class=\"line\">print(&#39;after init description&#39;)</span><br/><span class=\"line\">for k, v in pairs(c1) do</span><br/><span class=\"line\">    print(k, v)</span><br/><span class=\"line\">end</span><br/><span class=\"line\">print(c1.description)</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>输出：在<code>c1.description = &#39;this is c1&#39;</code>前key-value是没有任何输出的，说明c1没有这些东西（不包括元表的部分）,但是又确确实实能输出（因为找不到就会访问元表）。<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">before init description</span><br/><span class=\"line\">this is a computer</span><br/><span class=\"line\">after init description</span><br/><span class=\"line\">description\tthis is c1</span><br/><span class=\"line\">this is c1</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>上面是无参的构造函数，如果是有参的，需要在构造函数中同时改变self中的值。<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">function Computer:new(description)</span><br/><span class=\"line\">    local o = {}</span><br/><span class=\"line\">    setmetatable(o, self)</span><br/><span class=\"line\">    self.__index = self</span><br/><span class=\"line\">    self.description = description</span><br/><span class=\"line\">    return o</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">c1 = Computer:new(&#39;init description&#39;)</span><br/><span class=\"line\">print(&#39;c1 before&#39;, c1.description)   --c1 before\tinit description</span><br/><span class=\"line\">c1.description = &#39;this is c1&#39;</span><br/><span class=\"line\">print(&#39;c1 after&#39;, c1.description)   --c1 after\tthis is c1</span><br/><span class=\"line\">c2 = Computer:new()</span><br/><span class=\"line\">print(&#39;c2&#39;, c2.description)         --c2\tnil</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<hr/>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>在介绍Lua封装的时候，说过封装利用的是表与元表之间的‘层层嵌套’关系。这不多不少也体验了继承的思想。Lua的继承正是基于这种‘层层嵌套’的思想。<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/><span class=\"line\">26</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">local Shape = {} --定义基类</span><br/><span class=\"line\">Shape.area = 0   --基类的成员area</span><br/><span class=\"line\">function Shape:new()</span><br/><span class=\"line\">    local s = {}</span><br/><span class=\"line\">    setmetatable(s, self)</span><br/><span class=\"line\">    self.__index = self</span><br/><span class=\"line\">    return s</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">function Shape:getArea()    --父类方法，可见子类也能访问</span><br/><span class=\"line\">    return self.area</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">local Square = Shape:new()   --关键语句，Square继承Shape</span><br/><span class=\"line\">function Square:new(side)    --Square的构造函数</span><br/><span class=\"line\">    local s = {}</span><br/><span class=\"line\">    setmetatable(s, self)</span><br/><span class=\"line\">    self.__index = self       --关键语句，元方法__index为空时候不会向元表查找area值</span><br/><span class=\"line\">    s.side = side or 0        --Square自身定义了成员变量side</span><br/><span class=\"line\">    self.area = side * side   --改变基类的area的值</span><br/><span class=\"line\">    return s</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">local square = Square:new(10)</span><br/><span class=\"line\">print(&#39;square side&#39;, square.side)  --square side\t10</span><br/><span class=\"line\">print(&#39;square area&#39;, square:getArea())  --square area\t100</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>这个例子，定义了一个基类图像Share，拥有成员area，然后正方形Square继承了Share，增加成员变量side，并重写构造函数。派生类拥有父类的方法和属性。<br/>对比下Java的实现<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">class Share {</span><br/><span class=\"line\">    double area = 0;</span><br/><span class=\"line\">    double getArea(){</span><br/><span class=\"line\">        return area;</span><br/><span class=\"line\">    }</span><br/><span class=\"line\">}</span><br/><span class=\"line\">class Square extends Share {</span><br/><span class=\"line\">    double size;</span><br/><span class=\"line\">    Square(double size) {</span><br/><span class=\"line\">        this.size = size;</span><br/><span class=\"line\">        area = size * size;</span><br/><span class=\"line\">    }</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>上面例子中，面积的计算放在了构造函数中，总有一点不妥。假装我们对面向对象思想很熟悉了，写出的Java代码应该是这样的<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">abstract class Share {</span><br/><span class=\"line\">    double area = 0;</span><br/><span class=\"line\">    abstract void calcArea();</span><br/><span class=\"line\">}</span><br/><span class=\"line\">class Square extends Share {</span><br/><span class=\"line\">    double size;</span><br/><span class=\"line\">    Square(double size) {</span><br/><span class=\"line\">        this.size = size;</span><br/><span class=\"line\">    }</span><br/><span class=\"line\">    @Override</span><br/><span class=\"line\">    void calcArea() {</span><br/><span class=\"line\">        area = size * size;</span><br/><span class=\"line\">    }</span><br/><span class=\"line\">}</span><br/><span class=\"line\"></span><br/><span class=\"line\">class Circle extends Share {</span><br/><span class=\"line\">    double radius;</span><br/><span class=\"line\">    Circle(double radius) {</span><br/><span class=\"line\">        this.radius = radius;</span><br/><span class=\"line\">    }</span><br/><span class=\"line\">    @Override</span><br/><span class=\"line\">    void calcArea() {</span><br/><span class=\"line\">        area = 3.14 * radius * radius;</span><br/><span class=\"line\">    }</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>通过对calcArea的不同实现，在不同的子类完成不同的计算。这是多态的体现。Lua也可以，子类通过重写父类的方法实现不同的实现。<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/><span class=\"line\">26</span><br/><span class=\"line\">27</span><br/><span class=\"line\">28</span><br/><span class=\"line\">29</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">local Shape = {}</span><br/><span class=\"line\">Shape.area = 0</span><br/><span class=\"line\">function Shape:new()</span><br/><span class=\"line\">    local s = {}</span><br/><span class=\"line\">    setmetatable(s, self)</span><br/><span class=\"line\">    self.__index = self</span><br/><span class=\"line\">    return s</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">function Shape:getArea()</span><br/><span class=\"line\">    return self.area</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">local Square = Shape:new()</span><br/><span class=\"line\">function Square:new(side)</span><br/><span class=\"line\">    local s = {}</span><br/><span class=\"line\">    setmetatable(s, self)</span><br/><span class=\"line\">    self.__index = self</span><br/><span class=\"line\">    s.side = side or 0</span><br/><span class=\"line\">    return s</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">function Square:getArea()</span><br/><span class=\"line\">    return &#39;I am Square s function&#39;, self.side * self.side</span><br/><span class=\"line\">end</span><br/><span class=\"line\"></span><br/><span class=\"line\">local square = Square:new(10)</span><br/><span class=\"line\">print(&#39;square side&#39;, square.side)</span><br/><span class=\"line\">print(&#39;square area&#39;, square:getArea())</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<p>上面的代码有两个getArea函数，其中子类Square复写了父类Share的getArea，并按新内容输出。<br/></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">square side\t10</span><br/><span class=\"line\">square area\tI am Square s function\t100</span><br/></pre></td></tr></tbody></table></figure><p></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://www.cnblogs.com/yyxt/p/4224784.html\" target=\"_blank\" rel=\"noopener noreferrer\">lua中类的实现原理和实践</a><br/><a href=\"http://www.runoob.com/lua/lua-object-oriented.html\" target=\"_blank\" rel=\"noopener noreferrer\">Lua 面向对象</a><br/><a href=\"https://www.jianshu.com/p/467840d7ad13\" target=\"_blank\" rel=\"noopener noreferrer\">Lua面向对象编程详解</a>  </p>","text":" 面向对象的三个特征：封装、继承和多态。Lua并没有类，没有直接实现面向对象的方法。不过Lua的Table，有内部对象和内部方法。Lua的面向对象主要是通过Table来模拟面向对象。 封装在Lua之Table学习中，曾以Computer为例子，介绍了Table 也是可以有自己内部...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">封装</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98\"><span class=\"toc-text\">访问成员</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">成员函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">构造函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8%E4%B8%8A%E4%B9%9F%E6%98%AF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%8C%E5%90%8C%E6%97%B6%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97new-%E6%9D%A5%E8%AF%B4%E6%98%8E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%82\"><span class=\"toc-text\">构造函数本质上也是成员函数，同时需要使用关键字new 来说明这是一个构造函数。</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%9E%84%E9%80%A0%E5%AF%B9%E8%B1%A1%E5%91%A2\"><span class=\"toc-text\">如何正确地构造对象呢</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">多态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua之Table个人总结","uid":"8e148f7d0ca183bc864d5f807e1a3198","slug":"zl/2016-01-01-782_Lua之Table个人总结","date":"2024-04-03T03:47:36.018Z","updated":"2024-04-03T03:47:36.018Z","comments":true,"path":"api/articles/zl/2016-01-01-782_Lua之Table个人总结.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 在lua中Table是数组和集合的混合物。作为数组时，可以使用除了nil以外的值作为索引。 Table的构造利用下标来标明元素123456local table = {}table[1]=&#39;hello&#39;table[5]=&#39;world&#39;for i,...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua学习笔记","uid":"d112c00bf05f368c0020529ea6c8efaf","slug":"zl/2016-01-01-781_Lua学习笔记","date":"2024-04-03T03:47:36.017Z","updated":"2024-04-03T03:47:36.017Z","comments":true,"path":"api/articles/zl/2016-01-01-781_Lua学习笔记.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 学习资料地址：http://www.runoob.com/lua/lua-tutorial.html 安装环境 在Windows环境下，使用SciTE来运行Lua程序。 项目GitHub地址：https://github.com/rjpcomputing/luaforwindo...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}