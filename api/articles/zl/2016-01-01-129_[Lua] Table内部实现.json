{"title":"Table内部实现","uid":"3923f57b9545e582cf01153ed3469253","slug":"zl/2016-01-01-129_[Lua] Table内部实现","date":"2024-04-03T03:47:33.032Z","updated":"2024-04-03T03:47:33.032Z","comments":true,"path":"api/articles/zl/2016-01-01-129_[Lua] Table内部实现.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"table-结构定义\">Table 结构定义</h2>\n<p>Lua 的Table是由数组、哈希表一起实现的。</p>\n<p>所以如果不清楚哈希表，建议先看看哈希表。\n<a href=\"http://mdgsf.github.io/c/2016/07/01/c-hashtable.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://mdgsf.github.io/c/2016/07/01/c-hashtable.html</a></p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">typedef</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">char</span> <span class=\"n\">lu_byte</span><span class=\"p\">;</span>\n<p><span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">Table</span> <span class=\"p\">&#123;</span><br />\n<span class=\"n\">CommonHeader</span><span class=\"p\">;</span><br />\n<span class=\"n\">lu_byte</span> <span class=\"n\">flags</span><span class=\"p\">;</span>  <span class=\"cm\">/* 1&lt;&lt;p means tagmethod(p) is not present <em>/</span><br />\n<span class=\"n\">lu_byte</span> <span class=\"n\">lsizenode</span><span class=\"p\">;</span>  <span class=\"cm\">/</em> log2 of size of 'node' array <em>/</span><br />\n<span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">sizearray</span><span class=\"p\">;</span>  <span class=\"cm\">/</em> size of 'array' array <em>/</span><br />\n<span class=\"n\">TValue</span> <span class=\"o\"></em></span><span class=\"n\">array</span><span class=\"p\">;</span>  <span class=\"cm\">/* array part <em>/</span><br />\n<span class=\"n\">Node</span> <span class=\"o\"></em></span><span class=\"n\">node</span><span class=\"p\">;</span><br />\n<span class=\"n\">Node</span> <span class=\"o\"><em></span><span class=\"n\">lastfree</span><span class=\"p\">;</span>  <span class=\"cm\">/</em> any free position is before this position <em>/</span><br />\n<span class=\"k\">struct</span> <span class=\"n\">Table</span> <span class=\"o\"></em></span><span class=\"n\">metatable</span><span class=\"p\">;</span><br />\n<span class=\"n\">GCObject</span> <span class=\"o\">*</span><span class=\"n\">gclist</span><span class=\"p\">;</span><br />\n<span class=\"p\">&#125;</span> <span class=\"n\">Table</span><span class=\"p\">;</span><br />\n</code></pre></div></div></p>\n<p>TValue *array; 是数组</p>\n<p>unsigned int sizearray; 是数组的大小</p>\n<p>Node *node; 应该就是哈希表了。</p>\n<p>lu_byte lsizenode; 如果哈希表的容量为Size，那么lsizenode = log2(Size)</p>\n<p>其他的成员变量暂时不关心。 等等主要看下 TValue 和 Node 的结构体。</p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">Table</span> <span class=\"o\">*</span><span class=\"nf\">luaH_new</span> <span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\">*</span><span class=\"n\">L</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span>\n  <span class=\"n\">GCObject</span> <span class=\"o\">*</span><span class=\"n\">o</span> <span class=\"o\">=</span> <span class=\"n\">luaC_newobj</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">LUA_TTABLE</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">Table</span><span class=\"p\">));</span> <span class=\"c1\">//其实就是分配一款内存空间</span>\n  <span class=\"n\">Table</span> <span class=\"o\">*</span><span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">gco2t</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"p\">);</span> <span class=\"c1\">//把指针类型转换为Table类型。</span>\n  <span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">metatable</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span> <span class=\"c1\">//接下来的都是一些初始化的操作。</span>\n  <span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">flags</span> <span class=\"o\">=</span> <span class=\"n\">cast_byte</span><span class=\"p\">(</span><span class=\"o\">~</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n  <span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n  <span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">sizearray</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n  <span class=\"n\">setnodevector</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n  <span class=\"k\">return</span> <span class=\"n\">t</span><span class=\"p\">;</span>\n<span class=\"p\">&#125;</span>\n<p><span class=\"k\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">setnodevector</span> <span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\"><em></span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">Table</span> <span class=\"o\"></em></span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">size</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span><br />\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">size</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span>  <span class=\"cm\">/* no elements to hash part? <em>/</span><br />\n<span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">cast</span><span class=\"p\">(</span><span class=\"n\">Node</span> <span class=\"o\"></em></span><span class=\"p\">,</span> <span class=\"n\">dummynode</span><span class=\"p\">);</span>  <span class=\"cm\">/* use common 'dummynode' <em>/</span><br />\n<span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">lsizenode</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span><br />\n<span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">lastfree</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>  <span class=\"cm\">/</em> signal that it is using dummy node */</span><br />\n<span class=\"p\">&#125;</span><br />\n<span class=\"k\">else</span> <span class=\"p\">&#123;</span><br />\n<span class=\"p\">…</span> <span class=\"c1\">//这里我们暂时不关心，就先不看。</span><br />\n<span class=\"p\">&#125;</span><br />\n<span class=\"p\">&#125;</span><br />\n</code></pre></div></div></p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cp\">#define cast(t, exp) ((t)(exp))   //类型转换，把表达式exp转换为t类型。\n</span>\n<span class=\"cp\">#define twoto(x) (1&lt;&lt;(x)) //计算2^x\n</span>\n<span class=\"cp\">#define sizenode(t) (twoto((t)-&gt;lsizenode)) //计算2^(t-&gt;lsizenode)的大小\n</span>\n<span class=\"kt\">void</span> <span class=\"nf\">luaH_free</span> <span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\">*</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">Table</span> <span class=\"o\">*</span><span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">isdummy</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">))</span>\n    <span class=\"n\">luaM_freearray</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"n\">cast</span><span class=\"p\">(</span><span class=\"kt\">size_t</span><span class=\"p\">,</span> <span class=\"n\">sizenode</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)));</span> <span class=\"c1\">//释放哈希表的空间，大小为2^(t-&gt;lsizenode)</span>\n  <span class=\"n\">luaM_freearray</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">sizearray</span><span class=\"p\">);</span> <span class=\"c1\">//释放数组的空间，大小为t-&gt;sizearray</span>\n  <span class=\"n\">luaM_free</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">);</span> <span class=\"c1\">//释放Table的内存空间</span>\n<span class=\"p\">&#125;</span>\n</code></pre></div></div>\n<h2 id=\"node-tkey-tvalue\">Node TKey TValue</h2>\n<p>可以看到，数组是用TValue来保存值的，而哈希表是使用Node来保存值。</p>\n<p>TValue *array; 是数组</p>\n<p>Node *node; 应该就是哈希表了。</p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">Node</span> <span class=\"p\">&#123;</span>\n  <span class=\"n\">TValue</span> <span class=\"n\">i_val</span><span class=\"p\">;</span>\n  <span class=\"n\">TKey</span> <span class=\"n\">i_key</span><span class=\"p\">;</span>\n<span class=\"p\">&#125;</span> <span class=\"n\">Node</span><span class=\"p\">;</span>\n</code></pre></div></div>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">typedef</span> <span class=\"k\">union</span> <span class=\"n\">TKey</span> <span class=\"p\">&#123;</span>\n  <span class=\"k\">struct</span> <span class=\"p\">&#123;</span>\n    <span class=\"n\">TValuefields</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">next</span><span class=\"p\">;</span>  <span class=\"cm\">/* for chaining (offset for next node) */</span>\n  <span class=\"p\">&#125;</span> <span class=\"n\">nk</span><span class=\"p\">;</span>\n  <span class=\"n\">TValue</span> <span class=\"n\">tvk</span><span class=\"p\">;</span>\n<span class=\"p\">&#125;</span> <span class=\"n\">TKey</span><span class=\"p\">;</span>\n</code></pre></div></div>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/*\n** Tagged Values. This is the basic representation of values in Lua,\n** an actual value plus a tag with its type.\n*/</span>\n<p><span class=\"cm\">/*<br />\n** Union of all Lua values<br />\n<em>/</span><br />\n<span class=\"k\">typedef</span> <span class=\"k\">union</span> <span class=\"n\">Value</span> <span class=\"p\">&#123;</span><br />\n<span class=\"n\">GCObject</span> <span class=\"o\"></em></span><span class=\"n\">gc</span><span class=\"p\">;</span>    <span class=\"cm\">/* collectable objects <em>/</span><br />\n<span class=\"kt\">void</span> <span class=\"o\"></em></span><span class=\"n\">p</span><span class=\"p\">;</span>         <span class=\"cm\">/* light userdata <em>/</span><br />\n<span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"p\">;</span>           <span class=\"cm\">/</em> booleans <em>/</span><br />\n<span class=\"n\">lua_CFunction</span> <span class=\"n\">f</span><span class=\"p\">;</span> <span class=\"cm\">/</em> light C functions <em>/</span><br />\n<span class=\"n\">lua_Integer</span> <span class=\"n\">i</span><span class=\"p\">;</span>   <span class=\"cm\">/</em> integer numbers <em>/</span><br />\n<span class=\"n\">lua_Number</span> <span class=\"n\">n</span><span class=\"p\">;</span>    <span class=\"cm\">/</em> float numbers */</span><br />\n<span class=\"p\">&#125;</span> <span class=\"n\">Value</span><span class=\"p\">;</span></p>\n<p><span class=\"cp\">#define TValuefields Value value_; int tt_<br />\n</span><br />\n<span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">lua_TValue</span> <span class=\"p\">&#123;</span><br />\n<span class=\"n\">TValuefields</span><span class=\"p\">;</span><br />\n<span class=\"p\">&#125;</span> <span class=\"n\">TValue</span><span class=\"p\">;</span><br />\n</code></pre></div></div></p>\n<p>其实 TKey 和 TValue 是同一个东西，只不过TKey里面多了一个next，主要是哈希表出现冲突时，用来解决冲突用的。</p>\n<p>TKey中tvk是这个key的值，nk中的next则指向key冲突的下一个节点。lua的hash表的hash算法比较特别，一般的hash表都是根据key算出hash(key)，然后把这个key放在hash表的hash(key)位置上，如果有冲突的话，就放在hash(key)位置的链表上。</p>\n<p>但是lua的hash表中，如果有冲突的话，lua会找hash表中一个空的位置（从后往前找，假设为x），然后把新的key放在这个空的位置x上，并且让hash表中hash(key)处的节点的nk.next指向x。这个意思就是，假如有冲突的话，不用重新分配空间来存储冲突的key，而是利用hash表上未用过的空格来存储。但是这样会引入另外一个问题，本来key是不应该放在x的，假设有另外一个key2，hash(key2)算出来的位置也在x的话，那就表示本来x这个位置应该是给key2的，但是由于x被key占用了，导致key2没地方放了。这时候lua的处理方式是把key放到另外一个空格，然后让key2占回x。当hash表已经没有空格的时候，lua就会resize这个hash表。这样做的好处主要是不用动态申请内存空间，hash表初始化的时候有多少内存空间就用多少，不够就resize这个hash表。</p>\n<p><a href=\"http://blog.csdn.net/u012611878/article/details/51873648\" target=\"_blank\" rel=\"noopener noreferrer\">http://blog.csdn.net/u012611878/article/details/51873648</a></p>\n<p>冲突解决技术可以分为两类：<strong>开散列方法</strong>( open hashing，也称为拉链法，separate chaining )和<strong>闭散列方法</strong>( closed hashing，也称为开地址方法，open addressing )。这两种方法的不同之处在于：开散列法把发生冲突的关键码存储在散列表主表之外，而闭散列法把发生冲突的关键码存储在表中另一个槽内。</p>\n<p>Lua这里使用的是闭散列。</p>\n<h2 id=\"增删查改\">增删查改</h2>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">LUAI_DDEC</span> <span class=\"k\">const</span> <span class=\"n\">TValue</span> <span class=\"n\">luaO_nilobject_</span><span class=\"p\">;</span>\n<span class=\"cp\">#define luaO_nilobject (&amp;luaO_nilobject_) //这是一个空对象，这样的好处是可以不需要处理NULL指针，在&lt;&lt;代码整洁之道&gt;&gt;里面有说。\n</span>\n<span class=\"n\">TValue</span> <span class=\"o\">*</span><span class=\"nf\">luaH_set</span> <span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\">*</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">Table</span> <span class=\"o\">*</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">TValue</span> <span class=\"o\">*</span><span class=\"n\">key</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span>\n  <span class=\"k\">const</span> <span class=\"n\">TValue</span> <span class=\"o\">*</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">luaH_get</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">);</span> <span class=\"c1\">//应该是到Table中去查找key是不是存在。</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"o\">!=</span> <span class=\"n\">luaO_nilobject</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">cast</span><span class=\"p\">(</span><span class=\"n\">TValue</span> <span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">);</span> <span class=\"c1\">//如果存在，直接返回对应的TValue</span>\n  <span class=\"k\">else</span> <span class=\"k\">return</span> <span class=\"n\">luaH_newkey</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">);</span> <span class=\"c1\">//如果不存在，则创建一个新的TValue，再返回。</span>\n<span class=\"p\">&#125;</span>\n</code></pre></div></div>\n<p>很明显，上面有两个重要的函数 luaH_newkey 和 luaH_get。</p>\n<p>luaH_newkey 应该就是插入函数了，向Table内插入一个新的值。</p>\n<p>luaH_get 则是查找函数，在Table中查找对应的key是不是存在。</p>\n<h3 id=\"luah_newkey\">luaH_newkey</h3>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/*\n** inserts a new key into a hash table; first, check whether key&#39;s main\n** position is free. If not, check whether colliding node is in its main\n** position or not: if it is not, move colliding node to an empty place and\n** put new key in its main position; otherwise (colliding node is in its main\n** position), new key goes to an empty position.\n*/</span>\n<span class=\"cm\">/*\n插入一个新的key到Table中。首先，检查key的main position是不是空的，main position 就是key要插入的位置吧。\nif(main position != 空)\n&#123;\n    检查冲突节点的main position是不是在它自己的位置上。\n    if(冲突节点不是在它自己的位置上)\n    &#123;\n        把冲突节点移动到一个空的位置上。\n        把新的key放在它自己的main position上。\n    &#125;\n    else\n    &#123;\n        把新的key放到一个空的位置上。\n    &#125;\n&#125;\nelse //main position == 空\n&#123;\n    把新的key放在它自己的main position上。\n&#125;\n*/</span>\n<span class=\"n\">TValue</span> <span class=\"o\">*</span><span class=\"nf\">luaH_newkey</span> <span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\">*</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">Table</span> <span class=\"o\">*</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">TValue</span> <span class=\"o\">*</span><span class=\"n\">key</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span>\n  <span class=\"n\">Node</span> <span class=\"o\">*</span><span class=\"n\">mp</span><span class=\"p\">;</span>\n  <span class=\"n\">TValue</span> <span class=\"n\">aux</span><span class=\"p\">;</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ttisnil</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">))</span> <span class=\"n\">luaG_runerror</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&#34;table index is nil&#34;</span><span class=\"p\">);</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ttisfloat</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">))</span> <span class=\"p\">&#123;</span>\n    <span class=\"n\">lua_Integer</span> <span class=\"n\">k</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">luaV_tointeger</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">))</span> <span class=\"p\">&#123;</span>  <span class=\"cm\">/* does index fit in an integer? */</span>\n      <span class=\"n\">setivalue</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">aux</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">);</span>\n      <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">aux</span><span class=\"p\">;</span>  <span class=\"cm\">/* insert it as an integer */</span>\n    <span class=\"p\">&#125;</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">luai_numisnan</span><span class=\"p\">(</span><span class=\"n\">fltvalue</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">)))</span>\n      <span class=\"n\">luaG_runerror</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"s\">&#34;table index is NaN&#34;</span><span class=\"p\">);</span>\n  <span class=\"p\">&#125;</span>\n  <span class=\"n\">mp</span> <span class=\"o\">=</span> <span class=\"n\">mainposition</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">);</span>  <span class=\"o\">------------------------------------------</span><span class=\"c1\">//通过key可以获取到Table中的一个位置mp，哈希函数就在mainposition()这函数里面。</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">ttisnil</span><span class=\"p\">(</span><span class=\"n\">gval</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"p\">))</span> <span class=\"o\">||</span> <span class=\"n\">isdummy</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">))</span> <span class=\"p\">&#123;</span>  <span class=\"cm\">/* main position is taken? */</span>\n    <span class=\"n\">Node</span> <span class=\"o\">*</span><span class=\"n\">othern</span><span class=\"p\">;</span>\n    <span class=\"n\">Node</span> <span class=\"o\">*</span><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">getfreepos</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">);</span>  <span class=\"cm\">/* get a free place */</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span>  <span class=\"cm\">/* cannot find a free place? */</span>\n      <span class=\"n\">rehash</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">);</span>  <span class=\"cm\">/* grow table */</span>    <span class=\"o\">----------------------------</span><span class=\"c1\">//空间不足了，扩大空间。</span>\n      <span class=\"cm\">/* whatever called &#39;newkey&#39; takes care of TM cache */</span>\n      <span class=\"k\">return</span> <span class=\"n\">luaH_set</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">);</span>  <span class=\"cm\">/* insert key into grown table */</span>\n    <span class=\"p\">&#125;</span>\n    <span class=\"n\">lua_assert</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">isdummy</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">));</span>\n    <span class=\"n\">othern</span> <span class=\"o\">=</span> <span class=\"n\">mainposition</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">gkey</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"p\">));</span>  <span class=\"o\">---------------------------------</span><span class=\"c1\">//获取冲突节点的main position。</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">othern</span> <span class=\"o\">!=</span> <span class=\"n\">mp</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span>  <span class=\"cm\">/* is colliding node out of its main position? */</span>\n      <span class=\"cm\">/* yes; move colliding node into free position */</span>\n      <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">othern</span> <span class=\"o\">+</span> <span class=\"n\">gnext</span><span class=\"p\">(</span><span class=\"n\">othern</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"n\">mp</span><span class=\"p\">)</span>  <span class=\"cm\">/* find previous */</span>\n        <span class=\"n\">othern</span> <span class=\"o\">+=</span> <span class=\"n\">gnext</span><span class=\"p\">(</span><span class=\"n\">othern</span><span class=\"p\">);</span>\n      <span class=\"n\">gnext</span><span class=\"p\">(</span><span class=\"n\">othern</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">cast_int</span><span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">-</span> <span class=\"n\">othern</span><span class=\"p\">);</span>  <span class=\"cm\">/* rechain to point to &#39;f&#39; */</span>\n      <span class=\"o\">*</span><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">mp</span><span class=\"p\">;</span>  <span class=\"cm\">/* copy colliding node into free pos. (mp-&gt;next also goes) */</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">gnext</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span>\n        <span class=\"n\">gnext</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span> <span class=\"o\">+=</span> <span class=\"n\">cast_int</span><span class=\"p\">(</span><span class=\"n\">mp</span> <span class=\"o\">-</span> <span class=\"n\">f</span><span class=\"p\">);</span>  <span class=\"cm\">/* correct &#39;next&#39; */</span>\n        <span class=\"n\">gnext</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>  <span class=\"cm\">/* now &#39;mp&#39; is free */</span>\n      <span class=\"p\">&#125;</span>\n      <span class=\"n\">setnilvalue</span><span class=\"p\">(</span><span class=\"n\">gval</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"p\">));</span>\n    <span class=\"p\">&#125;</span>\n    <span class=\"k\">else</span> <span class=\"p\">&#123;</span>  <span class=\"cm\">/* colliding node is in its own main position */</span>\n      <span class=\"cm\">/* new node will go into free position */</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">gnext</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"n\">gnext</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">cast_int</span><span class=\"p\">((</span><span class=\"n\">mp</span> <span class=\"o\">+</span> <span class=\"n\">gnext</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"p\">))</span> <span class=\"o\">-</span> <span class=\"n\">f</span><span class=\"p\">);</span>  <span class=\"cm\">/* chain new position */</span>\n      <span class=\"k\">else</span> <span class=\"n\">lua_assert</span><span class=\"p\">(</span><span class=\"n\">gnext</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n      <span class=\"n\">gnext</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">cast_int</span><span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"o\">-</span> <span class=\"n\">mp</span><span class=\"p\">);</span>  <span class=\"o\">-------------------------------------</span><span class=\"c1\">//发生冲突时，next保存的是两个指针的差值，也就是当前节点到下一个节点在内存中的距离。</span>\n      <span class=\"n\">mp</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"p\">;</span>\n    <span class=\"p\">&#125;</span>\n  <span class=\"p\">&#125;</span>\n  <span class=\"n\">setnodekey</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">mp</span><span class=\"o\">-&gt;</span><span class=\"n\">i_key</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">);</span>\n  <span class=\"n\">luaC_barrierback</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">);</span>\n  <span class=\"n\">lua_assert</span><span class=\"p\">(</span><span class=\"n\">ttisnil</span><span class=\"p\">(</span><span class=\"n\">gval</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"p\">)));</span>\n  <span class=\"k\">return</span> <span class=\"n\">gval</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"p\">);</span>\n<span class=\"p\">&#125;</span>\n<p><span class=\"c1\">//这里是上面用到的一些宏</span><br />\n<span class=\"cp\">#define gnode(t,i) (&amp;(t)-&gt;node[i])<br />\n#define gnext(n) ((n)-&gt;i_key.nk.next)<br />\n#define gkey(n) cast(const TValue*, (&amp;(n)-&gt;i_key.tvk))  //获取Node的key<br />\n#define gval(n) (&amp;(n)-&gt;i_val)  //获取Node的value<br />\n</span><br />\n<span class=\"cm\">/* type casts (a macro highlights casts in the code) */</span><br />\n<span class=\"cp\">#define cast(t, exp) ((t)(exp))<br />\n#define cast_int(i) cast(int, (i)) //转换为整形<br />\n</span><br />\n<span class=\"cp\">#define isdummy(t) ((t)-&gt;lastfree == NULL)<br />\n</span><br />\n<span class=\"cp\">#define LUA_TNIL 0<br />\n#define rttype(o) ((o)-&gt;tt_)<br />\n#define checktag(o,t) (rttype(o) == (t))<br />\n#define ttisnil(o) checktag((o), LUA_TNIL)<br />\n</span></code></pre></div></div></p>\n<p>在这个函数里面，用到了3个函数：getfreepos，mainposition，rehash。我们需要看看到底是怎么实现的。</p>\n<p>getfreepos: 获取一个空的位置。</p>\n<p>rehash: 重新分配Table的内存空间。</p>\n<p>mainposition: 根据key值，通过哈希函数算出在Table中的main position。</p>\n<h3 id=\"getfreepos\">getfreepos</h3>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">static</span> <span class=\"n\">Node</span> <span class=\"o\">*</span><span class=\"nf\">getfreepos</span> <span class=\"p\">(</span><span class=\"n\">Table</span> <span class=\"o\">*</span><span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">isdummy</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">))</span> <span class=\"p\">&#123;</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">lastfree</span> <span class=\"o\">&gt;</span> <span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">node</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span>\n      <span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">lastfree</span><span class=\"o\">--</span><span class=\"p\">;</span> <span class=\"c1\">//这里再不断的向前遍历</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ttisnil</span><span class=\"p\">(</span><span class=\"n\">gkey</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">lastfree</span><span class=\"p\">)))</span>\n        <span class=\"k\">return</span> <span class=\"n\">t</span><span class=\"o\">-&gt;</span><span class=\"n\">lastfree</span><span class=\"p\">;</span>\n    <span class=\"p\">&#125;</span>\n  <span class=\"p\">&#125;</span>\n  <span class=\"k\">return</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>  <span class=\"cm\">/* could not find a free place */</span>\n<span class=\"p\">&#125;</span>\n</code></pre></div></div>\n<p>看来Table 中的 lastfree 这个变量是用来保存最后一个空闲位置的指针。</p>\n<h3 id=\"rehash\">rehash</h3>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/*\n** nums[i] = number of keys &#39;k&#39; where 2^(i - 1) &lt; k &lt;= 2^i\n*/</span>\n<span class=\"cm\">/*\nna: Table中数组中的元素个数 和 哈希表中可以放到数组中去的元素的个数 的总和。\ntotaluse: Table中所有元素的个数，包括数组和哈希表。\n*/</span>\n<span class=\"k\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">rehash</span> <span class=\"p\">(</span><span class=\"n\">lua_State</span> <span class=\"o\">*</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">Table</span> <span class=\"o\">*</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">TValue</span> <span class=\"o\">*</span><span class=\"n\">ek</span><span class=\"p\">)</span> <span class=\"p\">&#123;</span>\n  <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">asize</span><span class=\"p\">;</span>  <span class=\"cm\">/* optimal size for array part */</span>\n  <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">na</span><span class=\"p\">;</span>  <span class=\"cm\">/* number of keys in the array part */</span>\n  <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">MAXABITS</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">];</span>\n  <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">;</span>\n  <span class=\"kt\">int</span> <span class=\"n\">totaluse</span><span class=\"p\">;</span>\n  <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">MAXABITS</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>  <span class=\"cm\">/* reset counts */</span>\n  <span class=\"n\">na</span> <span class=\"o\">=</span> <span class=\"n\">numusearray</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">);</span>  <span class=\"cm\">/* count keys in array part */</span>\n  <span class=\"n\">totaluse</span> <span class=\"o\">=</span> <span class=\"n\">na</span><span class=\"p\">;</span>  <span class=\"cm\">/* all those keys are integer keys */</span>\n  <span class=\"n\">totaluse</span> <span class=\"o\">+=</span> <span class=\"n\">numusehash</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">na</span><span class=\"p\">);</span>  <span class=\"cm\">/* count keys in hash part */</span>\n  <span class=\"cm\">/* count extra key */</span>\n  <span class=\"n\">na</span> <span class=\"o\">+=</span> <span class=\"n\">countint</span><span class=\"p\">(</span><span class=\"n\">ek</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">);</span>\n  <span class=\"n\">totaluse</span><span class=\"o\">++</span><span class=\"p\">;</span>\n  <span class=\"cm\">/* compute new size for array part */</span>\n  <span class=\"n\">asize</span> <span class=\"o\">=</span> <span class=\"n\">computesizes</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">na</span><span class=\"p\">);</span>\n  <span class=\"cm\">/* resize the table to new computed sizes */</span>\n  <span class=\"n\">luaH_resize</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">asize</span><span class=\"p\">,</span> <span class=\"n\">totaluse</span> <span class=\"o\">-</span> <span class=\"n\">na</span><span class=\"p\">);</span>\n<span class=\"p\">&#125;</span>\n</code></pre></div></div>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/*\n** Count keys in array part of table &#39;t&#39;: Fill &#39;nums[i]&#39; with\n** number of keys that will go into corresponding slice and return\n** total number of non-nil keys.\n*/</span>\n<span class=\"cm\">/*\n@brief 这个函数是用来计算Table中的数组部分的信息的。\n@param t[in]: Table。\n@param nums[out]: 这个数组的大小是32。\n    nums[0]: array[0]\n    nums[1]: array[1 - 2]\n    nums[2]: array[2 - 4]\n    nums[3]: arr","text":"Table 结构定义 Lua 的Table是由数组、哈希表一起实现的。 所以如果不清楚哈希表，建议先看看哈希表。 http://mdgsf.github.io/c/2016/07/01/c-hashtable.html typedef unsigned char lu_byte;...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#table-%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">Table 结构定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#node-tkey-tvalue\"><span class=\"toc-text\">Node TKey TValue</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9\"><span class=\"toc-text\">增删查改</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#luah_newkey\"><span class=\"toc-text\">luaH_newkey</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#getfreepos\"><span class=\"toc-text\">getfreepos</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#rehash\"><span class=\"toc-text\">rehash</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua table只读","uid":"17f6d66111f0c01620fec40a9ad0c055","slug":"zl/2016-01-01-12_lua table只读","date":"2024-04-03T03:47:33.032Z","updated":"2024-04-03T03:47:33.033Z","comments":true,"path":"api/articles/zl/2016-01-01-12_lua table只读.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"nginx lua waf","uid":"b7629b20ac900d8f1fafabf105306db6","slug":"zl/2016-01-01-125_nginx lua waf","date":"2024-04-03T03:47:33.031Z","updated":"2024-04-03T03:47:33.031Z","comments":true,"path":"api/articles/zl/2016-01-01-125_nginx lua waf.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"ngx_lua_waf是一个基于lua-nginx-module(openresty)的web应用防火墙###用途： 防止sql注入，本地包含，部分溢出，fuzzing测试，xss,SSRF等web攻击 防止svn/备份之类文件泄漏 防止ApacheBench之类压力测试工具的攻...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}