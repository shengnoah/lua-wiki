{"title":"lua函数定义","uid":"83698ed043c00a6ae2036e425e46e554","slug":"zl/2016-01-01-52_lua函数定义","date":"2024-04-03T03:47:35.803Z","updated":"2024-04-03T03:47:35.803Z","comments":true,"path":"api/articles/zl/2016-01-01-52_lua函数定义.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h4 id=\"FuncState\"><a href=\"#FuncState\" class=\"headerlink\" title=\"FuncState\"></a>FuncState</h4><p>proto结构数组保存函数原型信息;prev保存父函数体指针；actvar保存定义的局部变量；upvalues保存upvalue</p>\n<p>Lua源码中,专门有一个结构体FuncState用来保存函数相关的信息.其实,即使没有创建任何函数,对于Lua而言也有一个最外层的FuncState数据.这个结构体的定义:</p>\n<pre><code>typedef struct FuncState &#123;\n  Proto *f;  /* current function header */\n  Table *h;  /* table to find (and reuse) elements in  */\n  struct FuncState *prev;  /* enclosing function */\n  struct LexState *ls;  /* lexical state */\n  struct lua_State *L;  /* copy of the Lua state */\n  struct BlockCnt *bl;  /* chain of current blocks */\n  int pc;  /* next position to code (equivalent to `ncode&#39;) */\n  int lasttarget;   /* `pc&#39; of last `jump target&#39;  */\n  int jpc;  /* list of pending jumps to `pc&#39; */\n  int freereg;  /* first free register */\n  int nk;  /* number of elements in `k&#39;  */\n  int np;  /* number of elements in `p&#39;  */\n  short nlocvars;  /* number of elements in `locvars&#39; */\n  lu_byte nactvar;  /* number of active local variables  */\n  upvaldesc upvalues[LUAI_MAXUPVALUES];  /* upvalues */\n  unsigned short actvar[LUAI_MAXVARS];  /* declared-variable stack */\n&#125; FuncState;\n</code></pre><p>其中的Proto结构体数组用于保存函数原型信息,包括函数体代码(opcode),之所以使用数组,是因为在某个函数内,可能存在多个局部函数.而prev指针就是指向这个函数的”父函数体”的指针.</p>\n<p>比如以下代码:</p>\n<pre><code>function fun()\n   function test()\n   end\nend\n</code></pre><p>那么,在保存test函数原型的Proto数据就存放在保存fun函数的FuncState结构体的p数组中,反之,保存test函数的FuncState.prev指针就指向保存func函数的FuncState指针.</p>\n<p>接着看Funcstate结构体的成员,actvar数组用于保存局部变量,比如函数的参数就是保存在这里.另外还有一个存放upval值的upvalues数组.这里有两种不同的处理.如果这个upval是父函数内的局部变量,则生成的是MOVE指令用于赋值;如果对于父函数而言也是它的upval,则生成GET_UPVAL指令用于赋值.</p>\n<p>当开始处理一个函数的定义时,首先调用open_func函数,创建一个新的Proto结构体用于保存函数原型信息,接着将该函数的FuncState的prev指针指向父函数.<br/>最后当函数处理完毕时,调用pushclosure函数将这个新的函数的信息push到父函数的Proto数组中.</p>\n<h4 id=\"函数也是第一类值-可以存在变量里\"><a href=\"#函数也是第一类值-可以存在变量里\" class=\"headerlink\" title=\"函数也是第一类值 可以存在变量里\"></a>函数也是第一类值 可以存在变量里</h4><p>最后,由于函数在Lua中是所谓的”first class type”,所以其实以下两段Lua代码是等价的:</p>\n<pre><code>local function test()\n  -- 可以test\nend\n<p>–以上相当于 local test； test = function() …  end</p>\n<p>local test = function ()<br />\n–不可以调用test 以为第一类之定义完成之后才可以使用<br />\nend<br />\n</code></pre><p>也就是说,其实是生成一段代码,用于保存函数test的相关信息,之后再将这些信息赋值给变量test,这里的test可以是local,也可以是global的,这一点跟一般的变量无异.</p></p>\n<h4 id=\"函数定义词法分析\"><a href=\"#函数定义词法分析\" class=\"headerlink\" title=\"函数定义词法分析\"></a>函数定义词法分析</h4><p>所以在与函数定义相关的词法分析代码中:</p>\n<pre><code>static void funcstat (LexState *ls, int line) &#123;\n  /* funcstat -&gt; FUNCTION funcname body */\n  int needself;\n  expdesc v, b;\n  luaX_next(ls);  /* skip FUNCTION */\n  needself = funcname(ls, &amp;v);\n  body(ls, &amp;b, needself, line);\n  luaK_storevar(ls-&gt;fs, &amp;v, &amp;b);\n  luaK_fixline(ls-&gt;fs, line);  /* definition `happens&#39; in the first line */\n&#125;\n</code></pre><p>上面的变量v首先在funcname函数中获得该函数的函数名,变量b在进入函数body之后可以得到函数体相关的内容.在这之后的luaK_storevar调用,就是把b的值赋值给v,也就是前面提到的函数体赋值给函数名.</p>","text":"FuncStateproto结构数组保存函数原型信息;prev保存父函数体指针；actvar保存定义的局部变量；upvalues保存upvalue Lua源码中,专门有一个结构体FuncState用来保存函数相关的信息.其实,即使没有创建任何函数,对于Lua而言也有一个最外层的F...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#FuncState\"><span class=\"toc-text\">FuncState</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E4%B9%9F%E6%98%AF%E7%AC%AC%E4%B8%80%E7%B1%BB%E5%80%BC-%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E9%87%8C\"><span class=\"toc-text\">函数也是第一类值 可以存在变量里</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90\"><span class=\"toc-text\">函数定义词法分析</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua 原生api解读","uid":"295283d9501912df4611655107bb5066","slug":"zl/2016-01-01-532_lua 原生api解读","date":"2024-04-03T03:47:35.804Z","updated":"2024-04-03T03:47:35.807Z","comments":true,"path":"api/articles/zl/2016-01-01-532_lua 原生api解读.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 简介 LuaAPI 1.创建新表 2.取表中元素 3.表中的元素赋值 4.取表元素 4.表元素赋值 5.对table的一些操作[不引发原方法] 6.复制栈上元素并压入栈 参考资料 简介 研究lua也有一段时间了，对lua也算是小有了解，对于lua的api可能和其他脚本语言不是 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua数据结构table的键值存取过程源码分析","uid":"9b656271fc49c3ddbaf216361a033b92","slug":"zl/2016-01-01-529_lua数据结构table的键值存取过程源码分析","date":"2024-04-03T03:47:35.803Z","updated":"2024-04-03T03:47:35.803Z","comments":true,"path":"api/articles/zl/2016-01-01-529_lua数据结构table的键值存取过程源码分析.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"一、相关数据结构定义1、Table结构定义1234567891011typedef struct { CommonHeader; lu_byte flags; lu_byte lsizenode; /* log2 of size of `node&#39; array */ st...","link":"","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}