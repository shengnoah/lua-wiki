{"title":"Lua Table","uid":"8cb65eb3b9a904681d4c6e1e9f1f7448","slug":"zl/2016-01-01-956_Lua Table","date":"2024-04-03T03:47:36.227Z","updated":"2024-04-03T03:47:36.227Z","comments":true,"path":"api/articles/zl/2016-01-01-956_Lua Table.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h2 id=\"前言\">前言</h2>\n<p><b>table</b> 是lua中是lua中唯一的复合结构， 大多数高级语言中具有的：Array/Map/Class/Struct 数据组织结构均可通过table去实现。table核心的实现主要有：</p>\n<ul>\n  <li>Array part： 存储数组部分数据结构</li>\n  <li>Hash part： 存储Map相关数据</li>\n  <li>metatable： 实现核心func以及运算符重载逻辑，class的数据模式也是利用这个机制实现</li>\n</ul>\n<h3 id=\"数据结构定义\">数据结构定义</h3>\n<p>table也是可gc object，所以”继承”了CommonHeader,类似大多数的map/dictionary实现，lua hash部分每个kv都封装在一个Node（也就是entry）中，其中的key决定pos。</p>\n<ul>\n  <li>flags 8bit标记了Lua是否实现了对应的元方法，Lua一共可以实现24个元方法，其中前6个lua认为是tag method，需要标记出来，避免每次都查表</li>\n  <li>lsizenode hash部分已分配内存size的平方根（证明都是szie^2分配）</li>\n  <li>sizearray array部分已经分配的size</li>\n  <li>array 存储array数据的部分</li>\n  <li>node 存储hash数据</li>\n  <li>lastfree 指向一个free，可存储node的数据节点</li>\n  <li>metatable 元表</li>\n</ul>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/*\n** Tables\n*/\ntypedef struct Table &#123;\n  CommonHeader;\n  lu_byte flags;  /* 1&lt;&lt;p means tagmethod(p) is not present */\n  lu_byte lsizenode;  /* log2 of size of &#39;node&#39; array */\n  unsigned int sizearray;  /* size of &#39;array&#39; array */\n  TValue *array;  /* array part */\n  Node *node;\n  Node *lastfree;  /* any free position is before this position */\n  struct Table *metatable;\n  GCObject *gclist;\n&#125; Table;\n<p>typedef union TKey &#123;<br />\nstruct &#123;<br />\nTValuefields;<br />\nint next;  /* for chaining (offset for next node) */<br />\n&#125; nk;<br />\nTValue tvk;<br />\n&#125; TKey;</p>\n<p>typedef struct Node &#123;<br />\nTValue i_val;<br />\nTKey i_key;<br />\n&#125; Node;<br />\n</code></pre></div></div></p>\n<h3 id=\"table-存数据\">Table 存数据</h3>\n<p>类似<code class=\"language-plaintext highlighter-rouge\">tbl[k]=v</code>操作，都是在执行一条set table的指令：OP_SETTABLE，具体指令定义暂不分析，下图是指令执行流程：</p>\n<p><img src=\"http://www.plantuml.com/plantuml/png/RSn12u9040NW-_wAEHRK7_0G5WWTX8IaguphCyNLO7UMwDytUuhGmnmUyxwN1s4lSNRcLZNtegxFbxAWuua2HBXrgFnBO0LTHhloG9xrMZsxDsRLIT15VZGz1z5lbjArUKBIHtp45lgfSHd3i78zkw3mlxA5x00xqOoqlmtIweBtX4z67TYH1j9aSYnTdDqN\" alt=\"\"/></p>\n<p>luaH_newkey 向table中插入一个不存在的key。类似大多数map实现，此处也有个mainpostion概念，对于任意key，hash空间长度:sizehash, 那么mainposition就是使得<code class=\"language-plaintext highlighter-rouge\">tbl-&gt;node[pos] = hash(val)%sizehash</code>的position。hash算法必然有冲突的情况，遇到冲突则就需要把entry 链到首位，流程如下：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/*\n** 向table中插入一个新key；1. 检查key的main position是否被占据。 2. 如果已经被占，检查目前占领\n** 该mian position的node是否是它自己的main position，如果不是则它该node移动到其他free节点，\n** 新key即可占领改main position。 3.如果main position未被占，则直接赋值即可\n*/\nTValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) &#123;\n  Node *mp;\n  TValue aux;\n  if (ttisnil(key)) luaG_runerror(L, &#34;table index is nil&#34;);\n  else if (ttisfloat(key)) &#123; //如果是可以转换为integer的number则转化一下，对流程无影响\n    lua_Integer k;\n    if (luaV_tointeger(key, &amp;k, 0)) &#123;  /* does index fit in an integer? */\n      setivalue(&amp;aux, k);\n      key = &amp;aux;  /* insert it as an integer */\n    &#125;\n    else if (luai_numisnan(fltvalue(key)))\n      luaG_runerror(L, &#34;table index is NaN&#34;);\n  &#125;\n  mp = mainposition(t, key); //计算main position\n  if (!ttisnil(gval(mp)) || isdummy(t)) &#123;  /* main position 被占领了 */\n    Node *othern;\n    Node *f = getfreepos(t);  /* get a free place */\n    if (f == NULL) &#123;  /* cannot find a free place? */\n      rehash(L, t, key);  /* rehash 保证一定要能找到一个free pos*/\n      return luaH_set(L, t, key); \n    &#125;\n    lua_assert(!isdummy(t));\n    othern = mainposition(t, gkey(mp)); //计算pos上node对应的main position\n    if (othern != mp) &#123;  /* 当前占领mainPos的节点并不是这个节点的main position/\n      /* yes; move colliding node into free position */\n      while (othern + gnext(othern) != mp)  /* 说明other一定是f这个mainpPos的pre节点，通过next偏移找到它*/\n        othern += gnext(othern);\n      gnext(othern) = cast_int(f - othern);  /* rechain to point to &#39;f&#39; */\n      *f = *mp;  /* copy colliding node into free pos. (mp-&gt;next also goes) */\n      if (gnext(mp) != 0) &#123;\n        gnext(f) += cast_int(mp - f);  /* correct &#39;next&#39;  现在f是mp的深拷贝了，但是mp可能chain 某个pre，所以这里还需要处理一下偏移问题*/\n        gnext(mp) = 0;  /* now &#39;mp&#39; is free */\n      &#125;\n      setnilvalue(gval(mp));\n    &#125;\n    else &#123;  /*mp就是 main position，冲突的情况  */\n      /* new node will go into free position */\n      if (gnext(mp) != 0)\n        gnext(f) = cast_int((mp + gnext(mp)) - f);  /* chain new position 让f成为mainPos的第二个节点 */\n      else lua_assert(gnext(f) == 0);\n      gnext(mp) = cast_int(f - mp); //把f chain到mp上\n      mp = f;\n    &#125;\n  &#125;\n  setnodekey(L, &amp;mp-&gt;i_key, key);\n  luaC_barrierback(L, t, key);\n  lua_assert(ttisnil(gval(mp)));\n  return gval(mp);\n&#125;\n</code></pre></div></div>\n<p><img src=\"https://wiki.jikexueyuan.com/project/java-collection/images/hashmap1.jpg\" alt=\"\"/></p>\n<h3 id=\"table-rehash\">Table rehash</h3>\n<p>当luaH_newkey过程中无法找到free pos时，就会触发 rehash。</p>\n<ol>\n  <li>计算各个bit段的key count</li>\n  <li>计算出array部分需要扩展的size</li>\n  <li>resize 扩展array和hash部分size</li>\n</ol>\n<p>注：先统计nums，再计算array size，主要为了避免array size低效率扩展，参考：computesizes实现即可</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/*\n** nums[i] = number of keys &#39;k&#39; where 2^(i - 1) &lt; k &lt;= 2^i\n*/\nstatic void rehash (lua_State *L, Table *t, const TValue *ek) &#123;\n  unsigned int asize;  /* optimal size for array part */\n  unsigned int na;  /* number of keys in the array part */\n  unsigned int nums[MAXABITS + 1];\n  int i;\n  int totaluse;\n  for (i = 0; i &lt;= MAXABITS; i++) nums[i] = 0;  /* reset counts */\n  na = numusearray(t, nums);  /* count keys in array part */\n  totaluse = na;  /* all those keys are integer keys */\n  totaluse += numusehash(t, nums, &amp;na);  /* count keys in hash part */\n  /* count extra key */\n  na += countint(ek, nums);\n  totaluse++;\n  /* compute new size for array part */\n  asize = computesizes(nums, &amp;na);\n  /* resize the table to new computed sizes */\n  luaH_resize(L, t, asize, totaluse - na);\n&#125;\n</code></pre></div></div>\n<h3 id=\"table-resize\">Table resize</h3>\n<p>resize 时rehash的中间过程，真正处理array&amp;hash的部分内存扩展。</p>\n<ul>\n  <li>array 部分比较简单，直接realloc就行，然后把新alloc出来的obj setnilval即可</li>\n  <li>hash部分相对费一点，主要分四步： 1.保存old hash指针 2.alloc新的hash空间 3.把old hash空间调整到new hash 空间 4.释放old hash空间内存</li>\n</ul>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>void luaH_resize (lua_State *L, Table *t, unsigned int nasize,\n                                          unsigned int nhsize) &#123;\n  unsigned int i;\n  int j;\n  AuxsetnodeT asn;\n  unsigned int oldasize = t-&gt;sizearray;\n  int oldhsize = allocsizenode(t);\n  Node *nold = t-&gt;node;  /* save old hash ... */\n  if (nasize &gt; oldasize)  /* array part must grow? */\n    setarrayvector(L, t, nasize);\n  /* create new hash part with appropriate size */\n  asn.t = t; asn.nhsize = nhsize;\n  if (luaD_rawrunprotected(L, auxsetnode, &amp;asn) != LUA_OK) &#123;  /* mem. error? */\n    setarrayvector(L, t, oldasize);  /* array back to its original size */\n    luaD_throw(L, LUA_ERRMEM);  /* rethrow memory error */\n  &#125;\n  if (nasize &lt; oldasize) &#123;  /* array part must shrink? */\n    t-&gt;sizearray = nasize;\n    /* re-insert elements from vanishing slice */\n    for (i=nasize; i&lt;oldasize; i++) &#123;\n      if (!ttisnil(&amp;t-&gt;array[i]))\n        luaH_setint(L, t, i + 1, &amp;t-&gt;array[i]);\n    &#125;\n    /* shrink array */\n    luaM_reallocvector(L, t-&gt;array, oldasize, nasize, TValue);\n  &#125;\n  /* re-insert elements from hash part */\n  for (j = oldhsize - 1; j &gt;= 0; j--) &#123;\n    Node *old = nold + j;\n    if (!ttisnil(gval(old))) &#123;\n      /* doesn&#39;t need barrier/invalidate cache, as entry was\n         already present in the table */\n      setobjt2t(L, luaH_set(L, t, gkey(old)), gval(old));\n    &#125;\n  &#125;\n  if (oldhsize &gt; 0)  /* not the dummy node? */\n    luaM_freearray(L, nold, cast(size_t, oldhsize)); /* free old hash */\n&#125;\n</code></pre></div></div>\n<h3 id=\"table-使用注意事项\">Table 使用注意事项</h3>\n<ul>\n  <li>#table 取array长度指令</li>\n</ul>\n<p>“#” 操作符仅仅算table的array部分，并且是不是逐项遍历，用二分法找nil obj，然后算出一个pos，实现如下：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/*\n** Try to find a boundary in table &#39;t&#39;. A &#39;boundary&#39; is an integer index\n** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).\n*/\nlua_Unsigned luaH_getn (Table *t) &#123;\n  unsigned int j = t-&gt;sizearray;\n  if (j &gt; 0 &amp;&amp; ttisnil(&amp;t-&gt;array[j - 1])) &#123;\n    /* there is a boundary in the array part: (binary) search for it */\n    unsigned int i = 0;\n    while (j - i &gt; 1) &#123;\n      unsigned int m = (i+j)/2;\n      if (ttisnil(&amp;t-&gt;array[m - 1])) j = m;\n      else i = m;\n    &#125;\n    return i;\n  &#125;\n  /* else must find a boundary in hash part */\n  else if (isdummy(t))  /* hash part is empty? */\n    return j;  /* that is easy... */\n  else return unbound_search(t, j);\n&#125;\n</code></pre></div></div>\n<p>那么在计算array size时，如果确定array中间无空洞则可以使用“#”，否则还是手搬一个逐项遍历， 如下面测试就可能出现意外结果了：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local arr = &#123;1,nil,3,nil, 5,6, nil, nil&#125;\nprint(#arr)\n--output: 1\n</code></pre></div></div>\n<ul>\n  <li>metable 中__newindex, 如果fastset找到已存在的key, 则不会执行到__newindex,具体实现：</li>\n</ul>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#define settableProtected(L,t,k,v) &#123; const TValue *slot; \n  if (!luaV_fastset(L,t,k,slot,luaH_get,v)) \n    Protect(luaV_finishset(L,t,k,v,slot)); &#125;\n</code></pre></div></div>\n<p>测试代码：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local arr = &#123;&#125;\narr[1] = 5\nlocal mt = &#123;&#125;\nmt.__newindex = function(tbl, k, v)\n    print(&#34;hello&#34;, k, v)\nend\nsetmetatable(arr, mt)\narr[1] = 4\narr[2] = 6\n<p>–output:<br />\n–hello   2       6<br />\n</code></pre></div></div></p>\n<ul>\n  <li>ipairs 迭代器实现简单说就是遍历array部分，如果对应的val不是nil，则继续，否则就终止，所以中间不能有“空洞”</li>\n</ul>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>static int ipairsaux (lua_State *L) &#123;\n  lua_Integer i = luaL_checkinteger(L, 2) + 1;\n  lua_pushinteger(L, i);\n  return (lua_geti(L, 1, i) == LUA_TNIL) ? 1 : 2;\n&#125;\n</code></pre></div></div>\n<p>测试用例：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>local arr = &#123;1,nil,3,nil, 5,6, nil, nil&#125;\nfor i,v in ipairs(arr) do\n    print(v)\nend\n<p>–output:<br />\n–1<br />\n</code></pre></div></div></p>\n<pre><code>            &lt;hr style=&quot;visibility: hidden;&quot;/&gt;\n\n            \n\n\n            \n            \n            \n            &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;/&gt;\n            &lt;script src=&quot;https://unpkg.com/gitalk@latest/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;\n            &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;\n            \n            \n            &lt;script src=&quot;/js/md5.min.js&quot;&gt;&lt;/script&gt;\n            &lt;script type=&quot;text/javascript&quot;&gt;\n                var gitalk = new Gitalk(&#123;\n                clientID: 'd468c9684ec424e3e5cc',\n                clientSecret: 'b52faba288acb42039032014d5fd6f781ef3054a',\n                repo: 'lixiang-share.github.io',\n                owner: 'lixiang-share',\n                admin: ['lixiang-share'],\n                distractionFreeMode: true,\n                id: md5(location.pathname),\n                &#125;);\n                gitalk.render('gitalk-container');\n            &lt;/script&gt;\n</code></pre>\n","text":"前言 table 是lua中是lua中唯一的复合结构， 大多数高级语言中具有的：Array/Map/Class/Struct 数据组织结构均可通过table去实现。table核心的实现主要有： Array part： 存储数组部分数据结构 Hash part： 存储Map相关数据...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">数据结构定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#table-%E5%AD%98%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">Table 存数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#table-rehash\"><span class=\"toc-text\">Table rehash</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#table-resize\"><span class=\"toc-text\">Table resize</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#table-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">Table 使用注意事项</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua中ipairs和pairs的区别与使用","uid":"ee708369e43d7b01905981d2b3485e2f","slug":"zl/2016-01-01-959_Lua中ipairs和pairs的区别与使用","date":"2024-04-03T03:47:36.228Z","updated":"2024-04-03T03:47:36.229Z","comments":true,"path":"api/articles/zl/2016-01-01-959_Lua中ipairs和pairs的区别与使用.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;a href=&quot;/2015/11/11/lua_cpp_toluapp_tutorial/&quot; rel=&quot;next&quot; title=&quot;tolua++安装&quot;&gt; &lt;i class=&quot;fa fa-c...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"tolua实现分析","uid":"badacccfdd679d5ed5e22c4988c3b87d","slug":"zl/2016-01-01-955_tolua实现分析","date":"2024-04-03T03:47:36.227Z","updated":"2024-04-03T03:47:36.227Z","comments":true,"path":"api/articles/zl/2016-01-01-955_tolua实现分析.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"tolua++如何将c++对象导入到lua里tolua++为每一个传入lua的对象建立一个userdata，userdata的值，是c++对象的地址。userdata的metatable，是一个tolua++建立的，记录了userdata对应c++类型信息的表格，包括导出的成员变...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}