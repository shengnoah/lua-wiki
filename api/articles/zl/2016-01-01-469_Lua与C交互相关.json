{"title":"Lua与C交互相关","uid":"6987918132963fa97d63d894b303d6a0","slug":"zl/2016-01-01-469_Lua与C交互相关","date":"2024-04-03T03:47:35.749Z","updated":"2024-04-03T03:47:35.750Z","comments":true,"path":"api/articles/zl/2016-01-01-469_Lua与C交互相关.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>C语言API总览。</p>\n<p>C语言和Lua语言的两种交互形式：</p>\n<ol>\n<li>C语言拥有控制权，而Lua语言被用作库，这种交互形式中的C代码被称为应用代码。</li>\n<li>Lua语言拥有控制权，而C语言被用作库，此时的C代码被称为库代码。</li>\n</ol>\n<p>应用代码和库代码都适用相同的API和Lua语言通信，这些API称为C API。</p>\n<h3 id=\"一个简单的独立解释器：\"><a href=\"#一个简单的独立解释器：\" class=\"headerlink\" title=\"一个简单的独立解释器：\"></a>一个简单的独立解释器：</h3><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/><span class=\"line\">26</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br/><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br/><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&#34;lua.h&#34;</span></span></span><br/><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&#34;lauxlib.h&#34;</span></span></span><br/><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&#34;lualib.h&#34;</span></span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br/><span class=\"line\"><span class=\"function\"></span>{</span><br/><span class=\"line\">  <span class=\"keyword\">char</span> buff[<span class=\"number\">256</span>];</span><br/><span class=\"line\">  <span class=\"keyword\">int</span> error;</span><br/><span class=\"line\">  lua_State *L = luaL_newstate();\t\t\t\t</span><br/><span class=\"line\">  luaL_openlibs(L);\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/* 打开标准库 */</span></span><br/><span class=\"line\">  </span><br/><span class=\"line\">  <span class=\"keyword\">while</span>(fgets(buuff,<span class=\"keyword\">sizeof</span>(buff),<span class=\"built_in\">stdin</span>) != <span class=\"literal\">NULL</span>)</span><br/><span class=\"line\">  {</span><br/><span class=\"line\">    error = luaL_loadstring(L,buff) || lua_pcall(L,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br/><span class=\"line\">    <span class=\"keyword\">if</span>(error)</span><br/><span class=\"line\">    {</span><br/><span class=\"line\">      <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>,<span class=\"string\">&#34;%sn&#34;</span>,lua_tostring(L,<span class=\"number\">-1</span>));</span><br/><span class=\"line\">      lua_pop(L,<span class=\"number\">1</span>);\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/* 从栈中弹出错误信息 */</span></span><br/><span class=\"line\">    }</span><br/><span class=\"line\">  }</span><br/><span class=\"line\">  </span><br/><span class=\"line\">  lua_close(L);</span><br/><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure>\n<p>头文件lua.h声明了Lua提供的基础函数，其中包括创建新Lua环境的函数、调用Lua函数的函数、读写环境中的全局变量的函数，以及注册供Lua语言调用的新函数的函数，等等。其中声明的所有内容都有一个前缀lua_。</p>\n<p>头文件lauxlib.h声明了辅助库所提供的函数，其中所有的声明均以luaL_开头。</p>\n<p>头文件lualib.h中声明了用于打开这些库的函数。</p>\n<h3 id=\"栈：\"><a href=\"#栈：\" class=\"headerlink\" title=\"栈：\"></a>栈：</h3><p>Lua和C之间通信的主要组件是虚拟栈，几乎所有的API的调用都是在操作这个栈中的值，Lua和C之间所有的数据交换都是通过这个栈完成的，此外，还可以利用栈保存中间结果。</p>\n<p>为了解决<strong>动态类型和静态类型体系之间不匹配</strong>，以及<strong>自动内存管理和手动内存管理之间不匹配</strong>：Lua API中没有定义任何类似于lua_Value的类型，而是使用栈在Lua和C之间交换数据。栈中的每个元素都能保存Lua中任意类型的值。当我们想要从Lua中获取一个值时，只需调用Lua，Lua就会将指定的值压入栈中。当想要将一个值传给Lua时，首先要将这个值压入栈，然后调用Lua将其从栈中弹出即可。这需要每个C语言类型都有一个函数将其压入栈，还需要每个类型都有一个弹出的函数，但是避免了过多的组合，<strong>另外由于这个栈是Lua状态的一部分，因此垃圾收集器知道C语言正在使用哪些值。</strong></p>\n<h4 id=\"压入元素：\"><a href=\"#压入元素：\" class=\"headerlink\" title=\"压入元素：\"></a>压入元素：</h4><p>针对每一种能用C语言直接表示的Lua数据类型，C API中都有一个对应的压栈函数。</p>\n<p>对栈空间的检查可以使用int lua_checkstack(lua_State *L,int sz);这里，sz是我们所需的额外栈位置的数量，如果可能，函数 lua_checkstack 会增加栈的大小，以容纳所需的额外空间；否则该函数返回0。</p>\n<h4 id=\"查询元素：\"><a href=\"#查询元素：\" class=\"headerlink\" title=\"查询元素：\"></a>查询元素：</h4><p>第一个被压入栈的元素索引为1，第二个被压入的元素索引为2，依此类推。也可以使用负数索引来访问栈中的元素，栈顶的元素为-1，-2表示在它之前被压入栈中的元素。</p>\n<p>与Lua栈相关的函数游一系列，在此不做赘述。</p>\n<h3 id=\"使用C-API进行错误处理：\"><a href=\"#使用C-API进行错误处理：\" class=\"headerlink\" title=\"使用C API进行错误处理：\"></a>使用C API进行错误处理：</h3><h4 id=\"处理应用程序中的错误：\"><a href=\"#处理应用程序中的错误：\" class=\"headerlink\" title=\"处理应用程序中的错误：\"></a>处理应用程序中的错误：</h4><p>Lua语言通常通过长跳转来提示错误，但是如果没有相应的setjmp，解释器就无法进行长跳转。此时，API中的任何错误都会导致Lua调用紧急函数。当这个函数返回后，应用就会退出。</p>\n<p>要正确的处理应用代码中的错误，就必须通过Lua语言调用我们自己的代码，即在setjmp的上下文中运行代码。</p>\n<p>我们可以把C代码封装到一个函数F中，然后使用lua_pcall调用这个函数F，通过这种方式，我们的C代码会在保护模式下运行。即便发生内存分配失败，函数lua_pcall也会返回一个对应的错误码，使解释器能够保持一致的状态：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(lua_State *L)</span></span></span><br/><span class=\"line\"><span class=\"function\"></span>{</span><br/><span class=\"line\">\t<span class=\"comment\">//code to run in protected mode</span></span><br/><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br/><span class=\"line\">}</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">secure_foo</span><span class=\"params\">(lua_State *L)</span></span></span><br/><span class=\"line\"><span class=\"function\"></span>{</span><br/><span class=\"line\">\tlua_pushcfunction(L,foo);</span><br/><span class=\"line\">\t<span class=\"keyword\">return</span> (lua_pcall(L,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>) == <span class=\"number\">0</span>)</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure>\n<p>无论发生什么，调用secure_foo时都会返回一个布尔值，来表示foo执行是否成功。</p>\n<h4 id=\"处理库代码中的错误：\"><a href=\"#处理库代码中的错误：\" class=\"headerlink\" title=\"处理库代码中的错误：\"></a>处理库代码中的错误：</h4><p>当C语言库中的函数检测到错误时，只需简单的调用lua_error即可。</p>\n<h3 id=\"内存分配：\"><a href=\"#内存分配：\" class=\"headerlink\" title=\"内存分配：\"></a>内存分配：</h3><p>Lua语言核心对内存分配不进行任何假设，只会通过一个分配函数来分配和释放内存，当用户创建lua状态时必须提供该函数。</p>\n<p>luaL_newstate是一个用默认分配函数来创建Lua状态的辅助函数。该默认分配函数使用了来自C语言标准函数库的标准函数malloc-realloc-free，对于大多数应用程序来说已经够了，但是，要完全控制Lua的内存分配也很容易，使用原始的lua_newstate来创建我们自己的Lua状态即可：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">lua_State *<span class=\"title\">lua_newstate</span><span class=\"params\">(lua_Alloc f,<span class=\"keyword\">void</span> *ud)</span></span></span><br/></pre></td></tr></tbody></table></figure>\n<p>该函数有两个参数：一个是分配函数，另一个是用户数据。用这种方式创建的Lua状态会通过调用f完成所有的内存分配和释放，甚至结构lua_State也是由f分配的。</p>\n<p>分配函数f必须满足lua_Alloc的类型声明：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span> *(*lua_Alloc)(<span class=\"keyword\">void</span> *ud,\t\t\t\t\t\t<span class=\"comment\">// 为lua_newstate所提供的用户数据</span></span><br/><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t <span class=\"keyword\">void</span> *ptr,\t\t\t\t\t\t<span class=\"comment\">// 正要被分配或者释放的块的地址</span></span><br/><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t <span class=\"keyword\">size_t</span> osize,\t\t\t\t<span class=\"comment\">// 原始块的大小</span></span><br/><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t <span class=\"keyword\">size_t</span> nsize);\t\t\t\t<span class=\"comment\">// 请求的块大小</span></span><br/></pre></td></tr></tbody></table></figure>\n<p>如果ptr不是NULL，则lua会保证其之前被分配的大小就是osize。</p>\n<p>当nsize为0时，分配函数必须释放ptr指向的块并返回NULL，对应于所要求的大小为零的块。当ptr时NULL时，该函数必须分配并返回一个指定大小的块；如果无法分配指定的块，则必须返回NULL。</p>\n<h3 id=\"pcall：\"><a href=\"#pcall：\" class=\"headerlink\" title=\"pcall：\"></a>pcall：</h3><p>在调用函数lua_pcall时，第二个参数表示传递的参数数量，第三个参数是期望的结果数量，第四个参数代表错误处理函数。就像Lua语言的赋值一样，函数lua_pcall会根据所要求的数量来调整返回值的个数，即压入nil或丢弃多余的结果。在压入结果前，lua_pcall会把函数和其参数从栈中移除。当一个函数返回多个结果时，那么第一个结果最后被压入。</p>\n<h3 id=\"在Lua中调用C语言：\"><a href=\"#在Lua中调用C语言：\" class=\"headerlink\" title=\"在Lua中调用C语言：\"></a>在Lua中调用C语言：</h3><p>当Lua调用C函数时，我们必须注册该函数，即必须以一种恰当的方式为Lua提供该C函数的地址。Lua调用C函数时，也使用了一个与C语言调用Lua函数时相同类型的栈，C函数从栈中获取参数，并将结果压入栈中。</p>\n<p>这个栈不是一个全局结构；每个函数都有其私有的局部栈。当Lua调用一个C函数时，第一个参数总是位于这个局部栈中索引为1的位置。即使一个C函数调用了Lua代码，而且Lua代码又再次调用了同一个的C函数，这些调用每一个都只会看到本次调用自己的私有栈，其中索引为1的位置上就是第一个参数。</p>\n<p>所有在Lua中注册的函数都必须使用一个相同的原型，该原型就是定义在lua.h中的lua_CFunction：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*lua_CFunction)</span><span class=\"params\">(lua_State *L)</span></span></span><br/></pre></td></tr></tbody></table></figure>\n<p>在Lua中，调用这个函数前，还必须通过lua_pushcfunction注册该函数。函数lua_pushcfunction会获取一个指向C函数的指针，然后在Lua中创建一个“function”类型，代表待注册的函数。一旦完成注册，C函数就可以像其他Lua函数一样行事了。</p>","text":"C语言API总览。 C语言和Lua语言的两种交互形式： C语言拥有控制权，而Lua语言被用作库，这种交互形式中的C代码被称为应用代码。 Lua语言拥有控制权，而C语言被用作库，此时的C代码被称为库代码。 应用代码和库代码都适用相同的API和Lua语言通信，这些API称为C API...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%8B%AC%E7%AB%8B%E8%A7%A3%E9%87%8A%E5%99%A8%EF%BC%9A\"><span class=\"toc-text\">一个简单的独立解释器：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88%EF%BC%9A\"><span class=\"toc-text\">栈：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8E%8B%E5%85%A5%E5%85%83%E7%B4%A0%EF%BC%9A\"><span class=\"toc-text\">压入元素：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%EF%BC%9A\"><span class=\"toc-text\">查询元素：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8C-API%E8%BF%9B%E8%A1%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">使用C API进行错误处理：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%EF%BC%9A\"><span class=\"toc-text\">处理应用程序中的错误：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E5%BA%93%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%EF%BC%9A\"><span class=\"toc-text\">处理库代码中的错误：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9A\"><span class=\"toc-text\">内存分配：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#pcall%EF%BC%9A\"><span class=\"toc-text\">pcall：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8Lua%E4%B8%AD%E8%B0%83%E7%94%A8C%E8%AF%AD%E8%A8%80%EF%BC%9A\"><span class=\"toc-text\">在Lua中调用C语言：</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 什么是闭包函数","uid":"5a779acb102a1de04b14659eedba112c","slug":"zl/2016-01-01-468_Lua 什么是闭包函数","date":"2024-04-03T03:47:35.749Z","updated":"2024-04-03T03:47:35.749Z","comments":true,"path":"api/articles/zl/2016-01-01-468_Lua 什么是闭包函数.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"为路由器写脚本，顺带学了一下lua.对闭包函数做个理解笔记 普通函数内部可以直接读取全局变量。如：1234567local n = 1function f1( ... ) return nendprint(f1()) --1 但普通函数内部却无法读取一个与自己不同作用域的局部变量...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua 排序算法","uid":"18c65ae79c1521b9ec150d64b8237a42","slug":"zl/2016-01-01-466_Lua 排序算法 ","date":"2024-04-03T03:47:35.748Z","updated":"2024-04-03T03:47:35.748Z","comments":true,"path":"api/articles/zl/2016-01-01-466_Lua 排序算法 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"设有一组关键字｛K1， K2，…， Kn｝；排序开始就认为 K1 是一个有序序列；让 K2 插入上述表长为 1 的有序序列，使之成为一个表长为 2 的有序序列；然后让 K3 插入上述表长为 2 的有序序列，使之成为一个表长为 3 的有序序列；依次类推，最后让 Kn 插入上述表长为...","link":"","photos":[],"count_time":{"symbolsCount":878,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}