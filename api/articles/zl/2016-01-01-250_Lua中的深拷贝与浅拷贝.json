{"title":"Lua中的深拷贝与浅拷贝","uid":"08ce81cf0af59271fcc247bbc48f18d2","slug":"zl/2016-01-01-250_Lua中的深拷贝与浅拷贝","date":"2024-04-03T03:47:33.117Z","updated":"2024-04-03T03:47:33.118Z","comments":true,"path":"api/articles/zl/2016-01-01-250_Lua中的深拷贝与浅拷贝.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<pre><code>    &lt;p&gt;有关深拷贝、浅拷贝在Lua中的一系列事情。&lt;/p&gt;\n</code></pre>\n<h3 id=\"为什么要写深拷贝：\"><a href=\"https://bitzhangmo.github.io/#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9A\" class=\"headerlink\" title=\"为什么要写深拷贝：\"></a>为什么要写深拷贝：</h3><p>在《Lua进程设计（第四版）》第五章开头，作者描述了表的性质：</p>\n<p>已经描述的很清楚了，对于表的操作，Lua语言不会进行深拷贝（即Lua语言拷贝的是对象的引用而非整个对象本身。）</p>\n<p>先看一下Lua的源码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Table * <span class=\"params\">(lua_State *L)</span> </span>{</span><br><span class=\"line\">  GCObject *o = luaC_newobj(L, LUA_TTABLE, <span class=\"keyword\">sizeof</span>(Table));</span><br><span class=\"line\">  Table *t = gco2t(o);</span><br><span class=\"line\">  t-&gt;metatable = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  t-&gt;flags = cast_byte(~<span class=\"number\">0</span>);</span><br><span class=\"line\">  t-&gt;<span class=\"built_in\">array</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  t-&gt;sizearray = <span class=\"number\">0</span>;</span><br><span class=\"line\">  setnodevector(L, t, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>当生成一个Table时，会返回一个Table类型的指针（t），可以看出，如果在Lua中进行表的赋值的话，实际上是将一个表的指针赋给了另一个变量，而这两个量指向的是同一个地址，也就是说，这次赋值并没有创造出一个新的副本出来，而只是给原来的变量起了一个别名。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">table1 = {<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>}</span><br><span class=\"line\">table2 = table1</span><br><span class=\"line\"><span class=\"built_in\">table</span>.<span class=\"built_in\">insert</span>(table1,<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i,v <span class=\"keyword\">in</span> <span class=\"built_in\">ipairs</span>(table2) <span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(v)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt; \t<span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"number\">3</span></span><br><span class=\"line\">\t\t<span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>如果要复制出一份独立的表，该怎么写呢？</p>\n<h3 id=\"深拷贝与浅拷贝：\"><a href=\"https://bitzhangmo.github.io/#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9A\" class=\"headerlink\" title=\"深拷贝与浅拷贝：\"></a>深拷贝与浅拷贝：</h3><h4 id=\"深拷贝（DeepCopy）：\"><a href=\"https://bitzhangmo.github.io/#%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%88DeepCopy%EF%BC%89%EF%BC%9A\" class=\"headerlink\" title=\"深拷贝（DeepCopy）：\"></a>深拷贝（DeepCopy）：</h4><p>拷贝整个对象本身，在上例的Lua代码中，如果table2对table1进行深拷贝，则改变table1不会同时改变table2，即table2是table1完全独立的一份复制。</p>\n<h4 id=\"深拷贝的实现方式：\"><a href=\"https://bitzhangmo.github.io/#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A\" class=\"headerlink\" title=\"深拷贝的实现方式：\"></a>深拷贝的实现方式：</h4><p>具体讲解可以参考wiki上的这一篇：<a href=\"http://lua-users.org/wiki/CopyTable\" target=\"_blank\" rel=\"noopener noreferrer\">CopyTable</a></p>\n<h5 id=\"一种快速但不怎么好的实现：\"><a href=\"https://bitzhangmo.github.io/#%E4%B8%80%E7%A7%8D%E5%BF%AB%E9%80%9F%E4%BD%86%E4%B8%8D%E6%80%8E%E4%B9%88%E5%A5%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A\" class=\"headerlink\" title=\"一种快速但不怎么好的实现：\"></a>一种快速但不怎么好的实现：</h5><p>这个版本的clone使用到了标准库中的unpack函数，这个函数会返回列表中的元素。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>  （<span class=\"title\">org</span>）</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"title\">return</span> { <span class=\"title\">table.unpack</span>（<span class=\"title\">org</span>）}</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">end</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">local</span> <span class=\"title\">abc</span> = {5,12,1}</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">local</span> <span class=\"title\">def</span> = <span class=\"title\">table.clone</span>（<span class=\"title\">abc</span>）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">table.sort</span>（<span class=\"title\">def</span>）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span>（<span class=\"title\">abc</span> [2]，<span class=\"title\">def</span> [2]）-  12 5</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Shallow-Copy：\"><a href=\"https://bitzhangmo.github.io/#Shallow-Copy%EF%BC%9A\" class=\"headerlink\" title=\"Shallow Copy：\"></a>Shallow Copy：</h5><p>这个实现很简单，但是有一些缺陷：它只复制了顶层的值，没有对更加深层的元素、元表和特殊类型（如userdata或coroutines）进行处理，它也容易受到__pairs元方法的影响。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shallowcopy</span><span class=\"params\">(orig)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> orig_type = <span class=\"built_in\">type</span>(orig)</span><br><span class=\"line\">    <span class=\"keyword\">local</span> copy</span><br><span class=\"line\">    <span class=\"keyword\">if</span> orig_type == <span class=\"string\">'table'</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">        copy = {}</span><br><span class=\"line\">        <span class=\"keyword\">for</span> orig_key, orig_value <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(orig) <span class=\"keyword\">do</span></span><br><span class=\"line\">            copy[orig_key] = orig_value</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        copy = orig</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Deep-Copy：\"><a href=\"https://bitzhangmo.github.io/#Deep-Copy%EF%BC%9A\" class=\"headerlink\" title=\"Deep Copy：\"></a>Deep Copy：</h5><p>这个版本的实现可以复制所有层级的元素，是一个简单的递归实现，并且会将原表的元表复制一份到新表的元表中。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepcopy</span><span class=\"params\">(orig)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> orig_type = <span class=\"built_in\">type</span>(orig)</span><br><span class=\"line\">    <span class=\"keyword\">local</span> copy</span><br><span class=\"line\">    <span class=\"keyword\">if</span> orig_type == <span class=\"string\">'table'</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">        copy = {}</span><br><span class=\"line\">        <span class=\"keyword\">for</span> orig_key, orig_value <span class=\"keyword\">in</span> <span class=\"built_in\">next</span>, orig, <span class=\"literal\">nil</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">            copy[deepcopy(orig_key)] = deepcopy(orig_value)</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"built_in\">setmetatable</span>(copy, deepcopy(<span class=\"built_in\">getmetatable</span>(orig)))</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        copy = orig</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>将表的拷贝存储在copies中，由原始的表索引，这是通过创建已复制的表的哈希表并将其作为第二个参数提供给deepcopy函数来完成的。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepcopy</span><span class=\"params\">(orig, copies)</span></span></span><br><span class=\"line\">    copies = copies <span class=\"keyword\">or</span> {}</span><br><span class=\"line\">    <span class=\"keyword\">local</span> orig_type = <span class=\"built_in\">type</span>(orig)</span><br><span class=\"line\">    <span class=\"keyword\">local</span> copy</span><br><span class=\"line\">    <span class=\"keyword\">if</span> orig_type == <span class=\"string\">'table'</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> copies[orig] <span class=\"keyword\">then</span></span><br><span class=\"line\">            copy = copies[orig]</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            copy = {}</span><br><span class=\"line\">            <span class=\"keyword\">for</span> orig_key, orig_value <span class=\"keyword\">in</span> <span class=\"built_in\">next</span>, orig, <span class=\"literal\">nil</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">                copy[deepcopy(orig_key, copies)] = deepcopy(orig_value, copies)</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">            copies[orig] = copy</span><br><span class=\"line\">            <span class=\"built_in\">setmetatable</span>(copy, deepcopy(<span class=\"built_in\">getmetatable</span>(orig), copies))</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        copy = orig</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>","text":" &lt;p&gt;有关深拷贝、浅拷贝在Lua中的一系列事情。&lt;/p&gt; 为什么要写深拷贝：在《Lua进程设计（第四版）》第五章开头，作者描述了表的性质： 已经描述的很清楚了，对于表的操作，Lua语言不会进行深拷贝（即Lua语言拷贝的是对象的引用而非整个对象本身。） 先...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9A\"><span class=\"toc-text\">为什么要写深拷贝：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9A\"><span class=\"toc-text\">深拷贝与浅拷贝：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%88DeepCopy%EF%BC%89%EF%BC%9A\"><span class=\"toc-text\">深拷贝（DeepCopy）：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">深拷贝的实现方式：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%80%E7%A7%8D%E5%BF%AB%E9%80%9F%E4%BD%86%E4%B8%8D%E6%80%8E%E4%B9%88%E5%A5%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A\"><span class=\"toc-text\">一种快速但不怎么好的实现：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Shallow-Copy%EF%BC%9A\"><span class=\"toc-text\">Shallow Copy：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Deep-Copy%EF%BC%9A\"><span class=\"toc-text\">Deep Copy：</span></a></li></ol></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua require机制","uid":"fc07d610e727a4dac9a13d0c264a8534","slug":"zl/2016-01-01-24_lua require机制","date":"2024-04-03T03:47:33.117Z","updated":"2024-04-03T03:47:33.117Z","comments":true,"path":"api/articles/zl/2016-01-01-24_lua require机制.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"require(modname) 加载给定的模块.函数首先检查表package.loaded来判定modname是否已经存在. 如果存在,则require返回package.loaded[modname]所存储的值否则它尝试为模块找到一个加载器(loader). 要找到一个加载器...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"浅析android手游lua脚本的加密与解密（后续）","uid":"bd350126d0e97ae395bee5fd654c1540","slug":"zl/2016-01-01-249_浅析android手游lua脚本的加密与解密（后续）","date":"2024-04-03T03:47:33.116Z","updated":"2024-04-03T03:47:33.117Z","comments":true,"path":"api/articles/zl/2016-01-01-249_浅析android手游lua脚本的加密与解密（后续）.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" &lt;p&gt; 趁着周末，把lua的后续文章也写完了。&lt;/p&gt; 反编译对抗 众所周知，反汇编/反编译 工具在逆向人员工作中第一步被使用，其地位非常之高，而对于软件保护者来说，如何对抗 反汇编/反编译 就显得尤为重要。例如，动态调试中对OD的的检测、内核调试对wi...","link":"","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}