{"title":"Lua热更新注意事项","uid":"6cfaff3d0f2cb19bea925a3c9275e75f","slug":"zl/2016-01-01-950_Lua热更新注意事项 ","date":"2024-04-03T03:47:36.225Z","updated":"2024-04-03T03:47:36.225Z","comments":true,"path":"api/articles/zl/2016-01-01-950_Lua热更新注意事项 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>lua热更新，是当下最成熟、最热门，也是使用最多的热更新方案，单说热更新的话，它是完美的解决方案，但要从性能上说，它其实比C#要差上不少，自然而然地，如何优化性能也就成了开发人员最头痛的问题。<br/>\n本文讲从一些数据调研出发，结合一些大牛的文章，对lua中性能优化的点进行汇总。</p>\n<h3 id=\"关于热更新\">关于热更新</h3>\n<p>相信有一定经验的游戏从业者都听说过“热更新”，想象一下你在打开农药之后，登录之前总是要检查资源包更新，时不时还要下载一些东西，这其实就是热更新了。与之相对的是整端更新，就是重新下载安装包重新安装那一种。手游嘛，一般要求快速迭代，很多游戏都是一周一个小版本，如果每更一次都要让你下一个整端，你自然不乐意，说不定就要退坑了。在每天有几十款游戏上线的当下，玩家们都被惯坏了，他们可禁不起这么折腾，所以这就是热更新的必要性。</p>\n<h4 id=\"热更新的方案选择\">热更新的方案选择</h4>\n<p>现在市面上常见的热更新方案，无非就那么几种，真要分类的话就两大类，lua热更新和c#热更新，c#热更新本人知之甚少，基于ILRuntime的方式只听说在性能上并不占优势，但好处是c#语言在写代码时比lua爽，如果用c#做服务器的话还能做到客户端服务器统一语言，但终归是新兴起的方案，资料上和完善程度上都不如lua。<br/>\nlua家族里有ulua、tolua、xlua以及各种各样奇怪的lua，但基本上万变不离其宗，通过lua和c#互相调用的方式实现lua和c#的通信，在底层上要么是基于native lua，要么是基于luajit。</p>\n<h4 id=\"luajit和lua\">luajit和lua</h4>\n<p>luajit是lua的高性能版本，其内部实现比较复杂，就不在此讨论了，总之luajit和native lua，几乎无甚区别，只是luajit的性能要高得多。除此之外，luajit目前最新版本是基于lua5.1，目测也很难再更新了，所以如果想要使用lua的新特性，比如原生的位运算，比如原生的int类型，在luajit里基本是做不到了。</p>\n<p>常见的热更新方案，ulua、tolua就是基于luajit，xlua默认是基于lua5.3，不过据说可配置或者可以自定义。这里面的取舍，一是看项目类型，二是看方案的必要性。<br/>\n下面是一组测试数据，主要是针对简单的乘法或者移位运算，从中可以看出原生lua和luajit的差别。</p>\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align: left\">serial</th>\n      <th style=\"text-align: left\">language</th>\n      <th style=\"text-align: left\">operate</th>\n      <th style=\"text-align: left\">count</th>\n      <th style=\"text-align: left\">time</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align: left\">1</td>\n      <td style=\"text-align: left\">C# fixed</td>\n      <td style=\"text-align: left\">mul</td>\n      <td style=\"text-align: left\">10000000</td>\n      <td style=\"text-align: left\">230ms</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: left\">2</td>\n      <td style=\"text-align: left\">C# double</td>\n      <td style=\"text-align: left\">mul</td>\n      <td style=\"text-align: left\">10000000</td>\n      <td style=\"text-align: left\">34ms</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: left\">3</td>\n      <td style=\"text-align: left\">C#</td>\n      <td style=\"text-align: left\">rshift</td>\n      <td style=\"text-align: left\">10000000</td>\n      <td style=\"text-align: left\">28ms</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: left\">4</td>\n      <td style=\"text-align: left\">luajit</td>\n      <td style=\"text-align: left\">fixed mul</td>\n      <td style=\"text-align: left\">10000000</td>\n      <td style=\"text-align: left\">2600ms</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: left\">5</td>\n      <td style=\"text-align: left\">luajit</td>\n      <td style=\"text-align: left\">double mul</td>\n      <td style=\"text-align: left\">10000000</td>\n      <td style=\"text-align: left\">37ms</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: left\">6</td>\n      <td style=\"text-align: left\">luajit</td>\n      <td style=\"text-align: left\">bit.rshift</td>\n      <td style=\"text-align: left\">10000000</td>\n      <td style=\"text-align: left\">167ms</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: left\">7</td>\n      <td style=\"text-align: left\">luajit jit mode</td>\n      <td style=\"text-align: left\">double mul</td>\n      <td style=\"text-align: left\">10000000</td>\n      <td style=\"text-align: left\">10ms</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: left\">8</td>\n      <td style=\"text-align: left\">lua native</td>\n      <td style=\"text-align: left\">mul</td>\n      <td style=\"text-align: left\">10000000</td>\n      <td style=\"text-align: left\">100ms</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: left\">9</td>\n      <td style=\"text-align: left\">xLua</td>\n      <td style=\"text-align: left\">fixed mul</td>\n      <td style=\"text-align: left\">10000000</td>\n      <td style=\"text-align: left\">5038ms</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: left\">10</td>\n      <td style=\"text-align: left\">xLua</td>\n      <td style=\"text-align: left\">native rshift</td>\n      <td style=\"text-align: left\">10000000</td>\n      <td style=\"text-align: left\">90ms</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: left\">11</td>\n      <td style=\"text-align: left\">luajit</td>\n      <td style=\"text-align: left\">int64 mul</td>\n      <td style=\"text-align: left\">10000000</td>\n      <td style=\"text-align: left\">1500ms</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: left\">12</td>\n      <td style=\"text-align: left\">luajit</td>\n      <td style=\"text-align: left\">ffi-int mul</td>\n      <td style=\"text-align: left\">10000000</td>\n      <td style=\"text-align: left\">1000ms</td>\n    </tr>\n  </tbody>\n</table>\n<h3 id=\"关于升级lua53对性能的影响\">关于升级Lua5.3对性能的影响</h3>\n<p>目前luajit官方支持的lua版本是Lua5.1，如果要升级5.3则需要自己修改luajit的源码编译，代价较高。如果直接使用原生lua的话反而会降低性能，因为luajit性能要比原生lua高。<br/>\nluajit是lua代码的解释器，效率比原生lua要高很多，从表中的对比也可窥见一二(5, 8)。<br/>\n而luajit在运行时实际上又分为两种模式，即jit模式和interpreter模式。jit模式一般情况下会比interpreter模式快5-10倍。表中对于这种差别也有所体现(5,7)。但要成功jit，需要很多条件，但即使不用jit模式，只在interpreter模式下运行，效率也比原生lua要高很多。<br/>\n(9)是在xLua中定点数的乘法运算测试，耗时比在tolua中多了一倍。猜测其原因为xLua默认情况下是基于原生的lua5.3，虽然它的位运算效率和其乘除法运算效率相近，但是因为没有jit的高性能，所以总体下来反而变慢了。</p>\n<h3 id=\"引入int类型以及相关位运算的补丁\">引入int类型以及相关位运算的补丁</h3>\n<p>在tolua中，其实有一个int64的补丁，但是运算效率并不高。如(11)所示。原因仍需调研。  <br/>\n通过ffi调C的int类型做乘法，效率依然不高。如(12)。原因可能是lua和c之间的频繁调用，耗时较多。<br/>\n找到一个lnum的补丁，看见作者的介绍里，它提供了int32、int64、double、float等数据类型，且运算效率和原生的number类型相近。但是在windows平台编译后，只有double类型可用，尚不知其原因，需要逐步排查。</p>\n<h3 id=\"修改luajit的bit库\">修改luajit的bit库</h3>\n<p>目前使用的bit库是基于luajit自带的bit库的，但效率并不高，其运算速度比简单的乘除法要慢得多，目前来看，它是客户端定点数库的主要性能瓶颈，但是在服务器端则不同，因为把lua代码解释成java后，在位运算上时会直接调用java原生的位运算方式，但是因为它把lua中的数据类型抽象成了类，所以在计算时会产生额外的GC，导致性能下降。所以修改luajit的bit库这种方法，并不能提高服务器端的运算效率。</p>\n<h4 id=\"总结\">总结</h4>\n<p>在不能修改luajit重新编译Lua5.3的情况下，使用Lua5.3以提升位运算以及整数运算效率并不现实，无论能否成功进入jit模式，其带来的效率提升都不及luajit。<br/>\n如果能修改luajit使其支持Lua5.3，无疑是最好的方法，但是代价较高。<br/>\n修改luajit中的bit库，这种方式暂时不考虑，因为其作用仅体现在客户端，原因上面已经说过了。所以后续主要尝试方向还是前两种，即在lua中添加int32/64类型，这样服务器端可以直接将其解释成java本身的数据类型。</p>\n<h3 id=\"luajit的jit\">luajit的jit</h3>\n<p>luajit分为jit模式和interpreter模式，jit模式更快，快到令人发指（与c++接近，甚至更快），但是因为其对平台的高度依赖，导致它在安卓平台上不一定能发挥出PC上的威力，因为，luajit无法保证所有代码都可以jit化，只有在编译时才能知道，而一旦jit失败，其运算速度会骤降百倍。<br/>\njit模式的开启方式:</p>\n<div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n</pre></td><td class=\"rouge-code\"><pre><span class=\"k\">if</span> <span class=\"n\">jit</span> <span class=\"k\">then</span>\n  <span class=\"n\">jit</span><span class=\"p\">.</span><span class=\"n\">on</span><span class=\"p\">();</span> <span class=\"c1\">--关闭 jit.off()</span>\n  <span class=\"n\">jit</span><span class=\"p\">.</span><span class=\"n\">flush</span><span class=\"p\">()</span>\n<span class=\"k\">end</span>\n</pre></td></tr></tbody></table></code></pre></div></div>\n<p>至于jit模式究竟能带来多少性能提升，或者其稳定性到底如何，需要在真机上进行大量的测试。<br/>\n需要注意的是jit模式在ios平台下并不可用。</p>\n<h3 id=\"luajit的ffi\">luajit的ffi</h3>\n<p>ffi是luajit独有的一个神器，用于进行高效的luajit与c的交互。借助ffi也可以提高luajit和c#交互的性能，原理是利用ffi调用自己定义的c函数，再从c函数调用c#。\n必须要注意的是，ffi只有在jit开启下才能发挥其性能，如果是在ios下，ffi反而会拖慢性能。所以使用的时候必须要做好快关。<br/>\n首先，我们在c中定义一个方法，用于将c#的函数注册到c中，以便在c中可以直接调用c#的函数，这样只要luajit可以ffi调用c，也就自然可以调用c#的函数了</p>\n<div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n</pre></td><td class=\"rouge-code\"><pre><span class=\"kt\">void</span> <span class=\"nf\">gse_ffi_register_csharp</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">func</span><span class=\"p\">)</span>\n<span class=\"p\">&#123;</span>\n  <span class=\"n\">s_reg_funcs</span><span class=\"p\">[</span><span class=\"n\">id</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">func</span><span class=\"p\">;</span>\n<span class=\"p\">&#125;</span>\n</pre></td></tr></tbody></table></code></pre></div></div>\n<p>这里，id是一个你自由分配给c#函数的id，lua通过这个id来决定调用哪个函数。</p>\n<p>然后在c#中将c#函数注册到c中</p>\n<div class=\"language-c# highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n</pre></td><td class=\"rouge-code\"><pre><span class=\"p\">[</span><span class=\"nf\">DllImport</span><span class=\"p\">(</span><span class=\"n\">LUADLL</span><span class=\"p\">,</span> <span class=\"n\">CallingConvention</span> <span class=\"p\">=</span> <span class=\"n\">CallingConvention</span><span class=\"p\">.</span><span class=\"n\">Cdecl</span><span class=\"p\">,</span> <span class=\"n\">ExactSpelling</span> <span class=\"p\">=</span> <span class=\"k\">true</span><span class=\"p\">)]</span>\n<span class=\"k\">public</span> <span class=\"k\">static</span> <span class=\"k\">extern</span> <span class=\"k\">void</span> <span class=\"nf\">gse_ffi_register_csharp</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">funcid</span><span class=\"p\">,</span> <span class=\"n\">IntPtr</span> <span class=\"n\">func</span><span class=\"p\">);</span>\n<p><span class=\"k\">public</span> <span class=\"k\">static</span> <span class=\"k\">void</span> <span class=\"nf\">gse_ffi_register_v_i1f3</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">funcid</span><span class=\"p\">,</span> <span class=\"n\">f_v_i1f3</span> <span class=\"n\">func</span><span class=\"p\">)</span><br />\n<span class=\"p\">&#123;</span><br />\n<span class=\"nf\">gse_ffi_register_csharp</span><span class=\"p\">(</span><span class=\"n\">funcid</span><span class=\"p\">,</span> <span class=\"n\">Marshal</span><span class=\"p\">.</span><span class=\"nf\">GetFunctionPointerForDelegate</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">));</span><br />\n<span class=\"p\">&#125;</span></p>\n<p><span class=\"nf\">gse_ffi_register_v_i1f3</span><span class=\"p\">(</span><span class=\"m\">1</span><span class=\"p\">,</span> <span class=\"n\">GObjSetPositionAddTerrainHeight</span><span class=\"p\">);</span><span class=\"c1\">//将GObjSetPositionAddTerrainHeight注册为id1的函数</span><br />\n</pre></td></tr></tbody></table></code></pre></div></div></p>\n<p>然后lua中使用的时候，这么调用</p>\n<div class=\"language-c# highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><table class=\"rouge-table\"><tbody><tr><td class=\"rouge-gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n</pre></td><td class=\"rouge-code\"><pre><span class=\"n\">local</span> <span class=\"n\">ffi</span> <span class=\"p\">=</span> <span class=\"nf\">require</span><span class=\"p\">(</span><span class=\"s\">&#34;ffi&#34;</span><span class=\"p\">)</span>\n<span class=\"n\">ffi</span><span class=\"p\">.</span><span class=\"n\">cdef</span><span class=\"p\">[[</span>\n<span class=\"kt\">int</span> <span class=\"nf\">gse_ffi_i_f3</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">funcid</span><span class=\"p\">,</span> <span class=\"kt\">float</span> <span class=\"n\">f1</span><span class=\"p\">,</span> <span class=\"kt\">float</span> <span class=\"n\">f2</span><span class=\"p\">,</span> <span class=\"kt\">float</span> <span class=\"n\">f3</span><span class=\"p\">);</span>\n<span class=\"p\">]]</span>\n<p><span class=\"n\">local</span> <span class=\"n\">funcid</span> <span class=\"p\">=</span> <span class=\"m\">1</span><br />\n<span class=\"n\">ffi</span><span class=\"p\">.</span><span class=\"n\">C</span><span class=\"p\">.</span><span class=\"nf\">gse_ffi_i_f3</span><span class=\"p\">(</span><span class=\"n\">funcid</span><span class=\"p\">,</span> <span class=\"n\">objID</span><span class=\"p\">,</span> <span class=\"n\">posx</span><span class=\"p\">,</span> <span class=\"n\">posy</span><span class=\"p\">,</span> <span class=\"n\">posz</span><span class=\"p\">)</span><br />\n</pre></td></tr></tbody></table></code></pre></div></div></p>\n<p>就可以从lua中利用ffi调用c#的函数了。</p>\n<h3 id=\"lua和c的交互的注意事项\">lua和c#的交互的注意事项</h3>\n<p>减少Lua中C# object的引用<br/>\n避免在Lua和C#之间传递Unity独有的值类型（Vector3、Quaternion）  <br/>\n减少传递bool string object，用int float double替代<br/>\n频繁调用的函数，参数的数量尽量少<br/>\n优先使用static函数导出<br/>\n在lua中只使用自己管理的ID，而不直接引用C#的object</p>\n<p>以上结论主要来源于UWA-Blog https://blog.uwa4d.com/archives/USparkle_Lua.html</p>\n<pre><code>            &lt;hr style=&quot;visibility: hidden;&quot;/&gt;\n            \n            &lt;hr style=&quot;visibility: hidden;&quot;/&gt;\n</code></pre>\n","text":"lua热更新，是当下最成熟、最热门，也是使用最多的热更新方案，单说热更新的话，它是完美的解决方案，但要从性能上说，它其实比C#要差上不少，自然而然地，如何优化性能也就成了开发人员最头痛的问题。 本文讲从一些数据调研出发，结合一些大牛的文章，对lua中性能优化的点进行汇总。 关于热...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E7%83%AD%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">关于热更新</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">热更新的方案选择</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#luajit%E5%92%8Clua\"><span class=\"toc-text\">luajit和lua</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E5%8D%87%E7%BA%A7lua53%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">关于升级Lua5.3对性能的影响</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5int%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E8%A1%A5%E4%B8%81\"><span class=\"toc-text\">引入int类型以及相关位运算的补丁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9luajit%E7%9A%84bit%E5%BA%93\"><span class=\"toc-text\">修改luajit的bit库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#luajit%E7%9A%84jit\"><span class=\"toc-text\">luajit的jit</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#luajit%E7%9A%84ffi\"><span class=\"toc-text\">luajit的ffi</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#lua%E5%92%8Cc%E7%9A%84%E4%BA%A4%E4%BA%92%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">lua和c#的交互的注意事项</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua 排序算法","uid":"18c65ae79c1521b9ec150d64b8237a42","slug":"zl/2016-01-01-954_Lua 排序算法 ","date":"2024-04-03T03:47:36.226Z","updated":"2024-04-03T03:47:36.226Z","comments":true,"path":"api/articles/zl/2016-01-01-954_Lua 排序算法 .json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序的主要优点与...","link":"","photos":[],"count_time":{"symbolsCount":957,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"wrk搭配lua脚本，个性化压测","uid":"5169212eef43cfe5f6352b48192f0e28","slug":"zl/2016-01-01-951_wrk搭配lua脚本，个性化压测","date":"2024-04-03T03:47:36.225Z","updated":"2024-04-03T03:47:36.226Z","comments":true,"path":"api/articles/zl/2016-01-01-951_wrk搭配lua脚本，个性化压测.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"压测工具 wrk wrk -t2 -c10 -d10s -s wrk.lua http://www.baidu.com apache benchmark：性能基准测试时使用 Hey：go实现的压测工具 http_load： http_load -p 100 -s 10 urls ...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}