{"title":"lua闭包","uid":"ebfbb50f53b101f0d14d04eed8e77a61","slug":"zl/2016-01-01-343_lua闭包","date":"2024-04-03T03:47:35.622Z","updated":"2024-04-03T03:47:35.623Z","comments":true,"path":"api/articles/zl/2016-01-01-343_lua闭包.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h4 id=\"lua中有两种闭包-c闭包和lua闭包\"><a href=\"#lua中有两种闭包-c闭包和lua闭包\" class=\"headerlink\" title=\"lua中有两种闭包, c闭包和lua闭包\"></a>lua中有两种闭包, c闭包和lua闭包</h4><p>两种闭包的公共部分:</p>\n<pre><code>#define ClosureHeader CommonHeader;\nlu_byte isC;   是否c闭包\nlua_byte nupvalues;  upvalue的个数\nGCObject* gclist; \nstruct Table env 闭包的环境\n</code></pre><p>C闭包的结构</p>\n<pre><code>struct CClosure&#123;\n   ClosureHeader;\n   lua_CFunction f;\n   TValue upvalue[1];\n&#125;\n</code></pre><p>结构比较简单, f是一个满足 int lua_func(lua_State*) 类型的c函数</p>\n<p>upvalue是创建C闭包时压入的upvalue, 类型是TValue, 可以得知, upvalue可以是任意的lua类型 </p>\n<p>Lua闭包结构</p>\n<pre><code>struct LClosure&#123;\n  ClosureHeader;\n  strcut Proto* p;\n  UpVal* upvals[1];\n&#125;\n</code></pre><p>Proto的结构比较复杂, 这里先不做分析</p>\n<p>统一的闭包结构, 一个联合体, 说明一个闭包要么是C闭包, 要么是lua闭包, 这个是用isC表识出来的.</p>\n<pre><code>union Closure&#123;\n    CClosure c;\n    LClosure  l;\n&#125;\n</code></pre><p> <strong>闭包 == {功能抽象, upvalue, env}</strong> </p>\n<h4 id=\"向lua中注册c函数的过程是通过lua-pushcclosure-L-f-n-函数实现的\"><a href=\"#向lua中注册c函数的过程是通过lua-pushcclosure-L-f-n-函数实现的\" class=\"headerlink\" title=\"向lua中注册c函数的过程是通过lua_pushcclosure(L, f, n)函数实现的\"></a>向lua中注册c函数的过程是通过lua_pushcclosure(L, f, n)函数实现的</h4><p>流程: </p>\n<ol>\n<li><p>创建一个 sizeof(CClosure) + (n - 1) * sizeof(TValue)大小的内存, 这段内存是 CClosure + TValue[n],,  isC= 1 标示其是一个C闭包.</p>\n</li>\n<li><p>c-&gt;f = f绑定c函数.         ———  <strong>闭包.功能抽象 = f</strong></p>\n</li>\n<li><p>env = 当前闭包的env.  ———- <strong>闭包.env = env</strong></p>\n</li>\n<li><p>把栈上的n个元素赋值到c-&gt;upvalue[]数组中, 顺序是越先入栈的值放在upvalue数组的越开始位置, c-&gt;nupvalues指定改闭包upvalue的个数.  ———- <strong>闭包.upvalue = upvalue</strong></p>\n</li>\n<li><p>弹出栈上n个元素, 并压入新建的Closure到栈顶.</p>\n</li>\n</ol>\n<p>整个流程是: 分配内存, 填写属性, 链入gc监控, 绑定c函数, 绑定upvalue, 绑定env一个C闭包就ok了</p>\n<h4 id=\"C闭包被调用的过程\"><a href=\"#C闭包被调用的过程\" class=\"headerlink\" title=\"C闭包被调用的过程\"></a>C闭包被调用的过程</h4><p>lua 闭包调用信息结构:</p>\n<pre><code>struct CallInfo&#123;\n    StkId base; ----闭包调用的栈基\n    StkId func; ----要调用的闭包在栈上的位置\n    StkId top;  ----闭包的栈使用限制\n    const Instruction *savedpc; ----如果在本闭包中再次调用别的闭包, 那么该值就保存下一条指令以便在返回时继续执行\n    int nresults; ----闭包要返回的值个数\n    int tailcalls;----尾递归用, 暂时不管\n&#125;\n</code></pre><p>这个结构是比较简单的, 它的作用就是维护一个函数调用的有关信息, 其实和c函数调用的栈帧是一样的, 重要的信息base –&gt; ebp, func –&gt; 要调用的函数的栈index, savedpc –&gt; eip, top, nresults和tailcalls没有明显的对应.</p>\n<p><strong>在lua初始化的时候, 分配了一个CallInfo数组, 并用L-&gt;base_ci指向该数组第一个元素, 用L-&gt;end_ci指向该数组最后一个指针, 用L-&gt;size_ci记录数组当前的大小, L-&gt;ci记录的是当前被调用的闭包的调用信息.</strong></p>\n<p>下面讲解一个c闭包的调用的过程:<br/>情景: c 函数</p>\n<pre><code>int lua_test(lua_State* L)&#123;\n    int a = lua_tonumber(L, 1);\n    int b = lua_tonumber(L, 2);\n    a = a + b;\n    lua_pushnumber(L, a);\n&#125;\n</code></pre><p>已经注册到了lua 中, 形成了一个C闭包, 起名为”test”, 下面去调用它<br/><code>luaL_dostring(L, &#34;c = test(3, 4)&#34;)</code></p>\n<p>调用过程堆栈变化情况如下：</p>\n<p>1.初始栈</p>\n<p><img src=\"https://thumbnail0.baidupcs.com/thumbnail/da6b672bfe31efd925d1b07252d8d61f?fid=1259087893-250528-828474891656030&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-2cCI6%2FKUHKD74rb5zUmgnkHU678%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=21047001409346822&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video\" alt=\"\"/></p>\n<p>2.压入了函数和参数的堆栈 </p>\n<pre><code>lua_getglobal(L, “test”)\nlua_pushnumber(L, 3)\nlua_pushnumber(L, 4) \n</code></pre><p><img src=\"https://thumbnail0.baidupcs.com/thumbnail/fbb22d3ec714edd9bbe59e9f1a727f5b?fid=1259087893-250528-1072131023144167&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-RE7mQ7%2BV8SIVj7JObpxAupx2Kt0%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092046924209033410&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video\" alt=\"\"/></p>\n<p>3.调用lua_test开始时的堆栈    lua_call(L,3, 4) </p>\n<p><img src=\"https://thumbnail0.baidupcs.com/thumbnail/88d243fb39e38c3d56cefd3a5b2e3459?fid=1259087893-250528-712458354988681&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-QKj7KqKkVTuusQ8o0UkkVwLDB%2B0%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092063733828165106&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video\" alt=\"\"/></p>\n<p>4.调用结束的堆栈 </p>\n<p><img src=\"https://thumbnail0.baidupcs.com/thumbnail/ca3dd633932be0c1bb59256e44276e6d?fid=1259087893-250528-574814416488756&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-4jo1Tky2%2FALRP0b%2Bv49ptjJVAgw%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092105420285105960&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video\" alt=\"\"/></p>\n<ol start=\"5\">\n<li>取出结果的栈 lua_setglobal(L, “c”)     </li>\n</ol>\n<p><img src=\"https://thumbnail0.baidupcs.com/thumbnail/da6b672bfe31efd925d1b07252d8d61f?fid=1259087893-250528-381860168682101&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-WW5zL3p%2Bf6EDOcBSTdSYtECt4cw%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092179093472688280&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video\" alt=\"\"/></p>\n<h4 id=\"lua-call函数的过程\"><a href=\"#lua-call函数的过程\" class=\"headerlink\" title=\"lua_call函数的过程\"></a>lua_call函数的过程</h4><ol>\n<li>lua具有很强一致性, 不管是dostring, 还是dofile, 都会形成一个闭包, 也就是说, 闭包是lua中用来组织结构的基本构件, 这个特点使得lua中的结构具有一致性, 是一种简明而强大的概念.</li>\n<li>根据1， a = test(3, 4)其实是被组织成为一个闭包放在lua栈顶[方便期间, 给这个lua闭包起名为bb], 也就说dostring真正调用的是bb闭包, 然后bb闭包执行时才调用的是test[保存当前信息到当前函数的CallInfo中]</li>\n<li>在调用test的时刻, L-&gt;ci记载着bb闭包的调用信息, 所以, 先把下一个要执行的指令放在L-&gt;ci-&gt;savedpc中, 以供从test返回后继续执行.</li>\n<li>取栈上的test C闭包 cl, 用 cl-&gt;isC == 1断定它的确是一个C闭包[进入一个新的CallInfo, 布置堆栈]</li>\n<li><p>从L中新分配一个CallInfo ci来记录test的调用信息, 并把它的值设置到L-&gt;ci, 这表明一个新的函数调用开始了, 这里还要指定test在栈中的位置, L-&gt;base = ci-&gt;base = ci-&gt;func+1, 注意, 这几个赋值很重要, 导致的堆栈状态由图2转化到图3, 从图中可以看出, L-&gt;base指向了第一个参数, ci-&gt;base也指向了第一个参数, 所以在test中, 我们调用lua_gettop函数返回的值就是2， 因为在调用它的时候, 它的栈帧上只有2个元素, 实现了lua向c语言中传参数.<br/>[调用实际的函数]</p>\n</li>\n<li><p>安排好堆栈, 下面就是根据L-&gt;ci-&gt;func指向的栈上的闭包(及test的C闭包), 找到对应的cl-&gt;c-&gt;f, 并调用, 就进入了c函数lua_test [获取返回值调整堆栈, 返回原来的CallInfo]</p>\n</li>\n<li><p>根据lua_test的返回值, 把test闭包和参数弹出栈, 并把返回值压入并调整L-&gt;top</p>\n</li>\n<li><p>恢复 L-&gt;base, L-&gt;ci 和 L-&gt;savedpc, 继续执行.</p>\n</li>\n</ol>\n<h4 id=\"调用一个新的闭包时：\"><a href=\"#调用一个新的闭包时：\" class=\"headerlink\" title=\"调用一个新的闭包时：\"></a>调用一个新的闭包时：</h4><ol>\n<li>保存当前信息到当前函数的CallInfo中 （CallInfo函数调用的状态信息）</li>\n<li>进入一个新的CallInfo, 布置堆栈  </li>\n<li>调用实际的函数  </li>\n<li>获取返回值调整堆栈, 返回原来的CallInfo</li>\n</ol>","text":"lua中有两种闭包, c闭包和lua闭包两种闭包的公共部分: #define ClosureHeader CommonHeader; lu_byte isC; 是否c闭包 lua_byte nupvalues; upvalue的个数 GCObject* gclist; struc...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#lua%E4%B8%AD%E6%9C%89%E4%B8%A4%E7%A7%8D%E9%97%AD%E5%8C%85-c%E9%97%AD%E5%8C%85%E5%92%8Clua%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">lua中有两种闭包, c闭包和lua闭包</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%91lua%E4%B8%AD%E6%B3%A8%E5%86%8Cc%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E9%80%9A%E8%BF%87lua-pushcclosure-L-f-n-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E7%9A%84\"><span class=\"toc-text\">向lua中注册c函数的过程是通过lua_pushcclosure(L, f, n)函数实现的</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#C%E9%97%AD%E5%8C%85%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">C闭包被调用的过程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#lua-call%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">lua_call函数的过程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E9%97%AD%E5%8C%85%E6%97%B6%EF%BC%9A\"><span class=\"toc-text\">调用一个新的闭包时：</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"lua学习笔记（二）","uid":"e07778deeaf81d4e352e39b31a6e0149","slug":"zl/2016-01-01-345_lua学习笔记（二）","date":"2024-04-03T03:47:35.623Z","updated":"2024-04-03T03:47:35.624Z","comments":true,"path":"api/articles/zl/2016-01-01-345_lua学习笔记（二）.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"Lua变量12345678910111213141516171819202122232425Lua变量三种类型：全局变量（储存在名称为_G的table中）、局部变量、table中的域Lua中的变量全都是全局变量，即使在语句块或函数里，除非用local显式声明为局部变量局部变量作用...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Redis lua 脚本简述","uid":"cbe59be328103b88b33e74beb07f1009","slug":"zl/2016-01-01-342_Redis lua 脚本简述","date":"2024-04-03T03:47:35.621Z","updated":"2024-04-03T03:47:35.622Z","comments":true,"path":"api/articles/zl/2016-01-01-342_Redis lua 脚本简述.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"前言从2.6.0版开始，Redis增加了对Lua运行环境的支持。在了解Redis lua 脚本使用前，最好能够了解 lua 的语言基础。 本篇包含如下 lua 脚本内容： Redis加载（初始化lua运行环境） Lua与Redis数据类型的转换 脚本命令执行分析 脚本执行过程分析...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}