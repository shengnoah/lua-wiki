{"title":"在openresty中是使用lua脚本实现新老路由平滑升级","uid":"151a961eee10fb762ab491ac88468502","slug":"zl/2016-01-01-567_在openresty中是使用lua脚本实现新老路由平滑升级","date":"2024-04-03T03:47:35.823Z","updated":"2024-04-03T03:47:35.823Z","comments":true,"path":"api/articles/zl/2016-01-01-567_在openresty中是使用lua脚本实现新老路由平滑升级.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>想升级PHP框架phalcon到3.x, 但是发现升级后与老版本基本不兼容, 也就意味着代码基本要重写了。考虑到不可能一下把所有的接口切换到新的框架上去（不能短时间内全部迁移所有的接口，新的框架提供的接口需要测试时间）。想到的方案是， 一方面提供新的接口使用新的框架编写，然后网关判断， 如果是新的接口就路由到新的框架部署的服务器上。空闲的时间，慢慢的把老的接口往新的框架上迁移。一下简单的实现了一个demo案列。</p>\n<p><strong>环境以及依赖软件</strong></p>\n<ul>\n<li>window 10。</li>\n<li>openresty/1.13.6.1 提供网关服务。</li>\n<li>redis-server 提供新路由存储。</li>\n<li>golang 模拟提供web服务。</li>\n</ul>\n<p>这里不对<a href=\"http://openresty.org\" target=\"_blank\" rel=\"noopener noreferrer\">openresty</a>, <a href=\"https://golang.org/\" target=\"_blank\" rel=\"noopener noreferrer\">golang</a>做介绍了。</p>\n<p><strong>openresty配置</strong></p>\n<p>编辑<code>nginx.conf</code>文件, 默认使用<code>phalcon1</code>upstream,当<code>rewrite_by_lua_file</code>执行完后, 如果是新的路由, 会重写<code>phalcon1</code>到<code>phalcon3</code>。</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/><span class=\"line\">26</span><br/><span class=\"line\">27</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\">upstream phalcon1 {</span><br/><span class=\"line\">    server 127.0.0.1:8088 fail_timeout=53 weight=4 max_fails=100;</span><br/><span class=\"line\">}</span><br/><span class=\"line\">upstream phalcon3 {</span><br/><span class=\"line\">    server 127.0.0.1:8089 fail_timeout=53 weight=10 max_fails=100;</span><br/><span class=\"line\">}</span><br/><span class=\"line\">server {</span><br/><span class=\"line\">    listen       80;</span><br/><span class=\"line\">    server_name  localhost;</span><br/><span class=\"line\">    #charset koi8-r;</span><br/><span class=\"line\">    access_log  logs/host.access.log  main;</span><br/><span class=\"line\">    error_page   500 502 503 504  /50x.html;</span><br/><span class=\"line\">    location / {</span><br/><span class=\"line\">        root   html;</span><br/><span class=\"line\">        index  index.html index.htm;</span><br/><span class=\"line\">    }</span><br/><span class=\"line\">    location /api/user {</span><br/><span class=\"line\">        default_type text/html;</span><br/><span class=\"line\">        set $upstream &#34;phalcon1&#34;;</span><br/><span class=\"line\">        # set_by_lua_file $upstream &#34;lualib/zq/chrbyuri.lua&#34;; # set_by_lua_file 关闭了 resty_redis API</span><br/><span class=\"line\">        rewrite_by_lua_file &#34;lualib/zq/chrbyuri.lua&#34;;</span><br/><span class=\"line\">        proxy_pass http://$upstream;</span><br/><span class=\"line\">    }</span><br/><span class=\"line\">    location = /50x.html {</span><br/><span class=\"line\">        root   html;</span><br/><span class=\"line\">    }</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure>\n<p><strong>chrbyuri.lua</strong></p>\n<p>从redis中查找是否是新的路由, 新的话重写<code>phalcon1</code>到<code>phalcon3</code>, 这里有个小规则, 框架中有的路由是 <code>/api/user/&#123;page&#125;/&#123;num&#125;.json</code> 由于这些路由是动态, 不好固化存在redis中, 这列只做了简单的处理, 就是替换成 <code>&#123;num&#125;</code>, 比如请求路由: <code>/api/user/100/10/post.json</code> =&gt; <code>/api/user/&#123;num&#125;/&#123;num&#125;/post.json</code>, 对应的在redis存替换的key就好了。</p>\n<figure class=\"highlight lua\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/><span class=\"line\">18</span><br/><span class=\"line\">19</span><br/><span class=\"line\">20</span><br/><span class=\"line\">21</span><br/><span class=\"line\">22</span><br/><span class=\"line\">23</span><br/><span class=\"line\">24</span><br/><span class=\"line\">25</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> newupstream = <span class=\"string\">&#34;phalcon3&#34;</span></span><br/><span class=\"line\"><span class=\"keyword\">local</span> redis_host = <span class=\"string\">&#34;127.0.0.1&#34;</span></span><br/><span class=\"line\"><span class=\"keyword\">local</span> redis_port = <span class=\"number\">6379</span></span><br/><span class=\"line\"><span class=\"keyword\">local</span> redis = <span class=\"built_in\">require</span> <span class=\"string\">&#34;resty.redis&#34;</span></span><br/><span class=\"line\"><span class=\"keyword\">local</span> uri = ngx.var.uri</span><br/><span class=\"line\"><span class=\"keyword\">local</span> r = uri:<span class=\"built_in\">gsub</span>(<span class=\"string\">&#34;/%d+&#34;</span>, <span class=\"string\">&#34;/{num}&#34;</span>)</span><br/><span class=\"line\">ngx.<span class=\"built_in\">log</span>(ngx.INFO, <span class=\"string\">&#34;origin document_uri:&#34;</span>, uri)</span><br/><span class=\"line\">ngx.<span class=\"built_in\">log</span>(ngx.INFO, <span class=\"string\">&#34;replace document_uri:&#34;</span>, r)</span><br/><span class=\"line\"></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">local</span> route_redis = redis:new()</span><br/><span class=\"line\"><span class=\"keyword\">local</span> ok, err = route_redis:connect(redis_host, redis_port)</span><br/><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> ok <span class=\"keyword\">then</span></span><br/><span class=\"line\">    ngx.<span class=\"built_in\">log</span>(ngx.ERR, <span class=\"string\">&#34;connect to redis error&#34;</span>, err)</span><br/><span class=\"line\">    <span class=\"keyword\">return</span></span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"><span class=\"comment\">-- query document_uri is exists or not</span></span><br/><span class=\"line\"><span class=\"keyword\">local</span> newsrv, err = route_redis:get(r)</span><br/><span class=\"line\"><span class=\"keyword\">if</span> newsrv == ngx.null <span class=\"keyword\">then</span></span><br/><span class=\"line\">  ngx.<span class=\"built_in\">log</span>(ngx.INFO, <span class=\"built_in\">string</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&#34;route %s is not new route&#34;</span>, r))</span><br/><span class=\"line\">  <span class=\"keyword\">return</span></span><br/><span class=\"line\"><span class=\"keyword\">end</span></span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"comment\">-- override upstream</span></span><br/><span class=\"line\">ngx.var.upstream = newupstream</span><br/></pre></td></tr></tbody></table></figure>\n<p><strong>golang实现的web服务</strong></p>\n<p>端口8088为老的接口服务器，提供 <code>/api/user/user.info1</code> <code>/api/user/user.info2</code> 2个接口。</p>\n<figure class=\"highlight golang\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/><span class=\"line\">14</span><br/><span class=\"line\">15</span><br/><span class=\"line\">16</span><br/><span class=\"line\">17</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"># filename: phalcon1.<span class=\"keyword\">go</span></span><br/><span class=\"line\"><span class=\"keyword\">package</span> main</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"keyword\">import</span> (</span><br/><span class=\"line\">\t<span class=\"string\">&#34;net/http&#34;</span></span><br/><span class=\"line\">\t<span class=\"string\">&#34;log&#34;</span></span><br/><span class=\"line\">)</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">()</span></span>  {</span><br/><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">&#34;/api/user/user.info1&#34;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(rw http.ResponseWriter, r *http.Request)</span></span> {</span><br/><span class=\"line\">\t\trw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">&#34;phalcon1:8088 handle route: {api/user/user.info2}&#34;</span>))</span><br/><span class=\"line\">\t})</span><br/><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">&#34;/api/user/user.info2&#34;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(rw http.ResponseWriter, r *http.Request)</span></span> {</span><br/><span class=\"line\">\t\trw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">&#34;phalcon1:8088 handle route: {api/user/user.info2}&#34;</span>))</span><br/><span class=\"line\">\t})</span><br/><span class=\"line\">\tlog.Fatalf(<span class=\"string\">&#34;server exception: %+v n&#34;</span>, http.ListenAndServe(<span class=\"string\">&#34;:8088&#34;</span>, <span class=\"literal\">nil</span>))</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure>\n<p>端口8089为新的接口服务器，提供 <code>/api/user/user.info3</code> 1个接口。</p>\n<figure class=\"highlight golang\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br/><span class=\"line\">2</span><br/><span class=\"line\">3</span><br/><span class=\"line\">4</span><br/><span class=\"line\">5</span><br/><span class=\"line\">6</span><br/><span class=\"line\">7</span><br/><span class=\"line\">8</span><br/><span class=\"line\">9</span><br/><span class=\"line\">10</span><br/><span class=\"line\">11</span><br/><span class=\"line\">12</span><br/><span class=\"line\">13</span><br/></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br/><span class=\"line\"># filename: phalcon3.<span class=\"keyword\">go</span></span><br/><span class=\"line\"><span class=\"keyword\">import</span> (</span><br/><span class=\"line\">\t<span class=\"string\">&#34;net/http&#34;</span></span><br/><span class=\"line\">\t<span class=\"string\">&#34;log&#34;</span></span><br/><span class=\"line\">)</span><br/><span class=\"line\"></span><br/><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">()</span></span>  {</span><br/><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">&#34;/api/user/user.info3&#34;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(rw http.ResponseWriter, r *http.Request)</span></span> {</span><br/><span class=\"line\">\t\trw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">&#34;phalcon1:8089 handle route: {api/user/user.info2}&#34;</span>))</span><br/><span class=\"line\">\t})</span><br/><span class=\"line\">\tlog.Fatalf(<span class=\"string\">&#34;server exception: %+v n&#34;</span>, http.ListenAndServe(<span class=\"string\">&#34;:8089&#34;</span>, <span class=\"literal\">nil</span>))</span><br/><span class=\"line\">}</span><br/></pre></td></tr></tbody></table></figure>\n<p><strong>测试</strong></p>\n<ol>\n<li>启动openresty <code>cd /path/to/openresty/nginx.exe</code>。</li>\n<li>启动redis-server <code>cd /path/to/redis-server/redis-server -c /path/to/redis-server.conf</code>。</li>\n<li>启动phalcon2 <code>go run phalcon3.go</code>。</li>\n<li><p>启动phalcon1 <code>go run phalcon1.go</code>。</p>\n</li>\n<li><p>将新的路由写入到redis中 <code>redis-cli set /api/user/user.info3 1</code>。</p>\n</li>\n<li><p>访问 <code>http://localhost/api/user/user.info1</code>  <code>http://localhost/api/user/user.info2</code> 还是代理到了phalcon1上。</p>\n</li>\n<li>访问 <code>http://localhost/api/user/user.info3</code> 就代理到了phalcon3上了。</li>\n</ol>\n<p><strong>后续</strong></p>\n<p>当有新的接口发布时候, 记得往redis写入新的路由标识即可了。</p>","text":"想升级PHP框架phalcon到3.x, 但是发现升级后与老版本基本不兼容, 也就意味着代码基本要重写了。考虑到不可能一下把所有的接口切换到新的框架上去（不能短时间内全部迁移所有的接口，新的框架提供的接口需要测试时间）。想到的方案是， 一方面提供新的接口使用新的框架编写，然后网关...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ulua的简单解析，cs和Lua的相互调用","uid":"793661612b73172fb8f974a4ce18be1f","slug":"zl/2016-01-01-570_ulua的简单解析，cs和Lua的相互调用","date":"2024-04-03T03:47:35.824Z","updated":"2024-04-03T03:47:35.825Z","comments":true,"path":"api/articles/zl/2016-01-01-570_ulua的简单解析，cs和Lua的相互调用.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"热更新是unity一个长久的话题，热更新主要有两部分，一部分就是资源，这个靠u3d的assetbundle就可以做，另一部分就是逻辑了。游戏更新难免会遇到一些流程或者UI的逻辑变动。在PC和Android上可以使用C#的反射来动态的生成代码，而IOS的Full AOT（完全 预先...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Anguluar的基本基本概念(一)","uid":"0bcef579901b5575dee4343fc86edd46","slug":"zl/2016-01-01-568_Anguluar的基本基本概念(一)","date":"2024-04-03T03:47:35.823Z","updated":"2024-04-03T03:47:35.823Z","comments":true,"path":"api/articles/zl/2016-01-01-568_Anguluar的基本基本概念(一).json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"带着问题学习，效果可能更好一些，本文基于 Angular 1.5.8 版本. 1.AnguluarJS是什么？ AngularJS是一款由Google公司开发维护的前端MVC框架. 作用：克服了HTML在构建应用上的诸多不足，降低开发成本，提升开发效率。 2.AnguluarJS...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua文章","slug":"lua文章","count":1133,"path":"api/tags/lua文章.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}