{"title":"Lua调试","uid":"374513b04e64d95f7bc41ddb08581b8d","slug":"lua/2016-06-01-debugging","date":"2024-03-14T07:45:09.089Z","updated":"2024-03-27T03:24:40.142Z","comments":true,"path":"api/articles/lua/2016-06-01-debugging.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h1 id=\"lua-调试\"><a class=\"markdownIt-Anchor\" href=\"#lua-调试\"></a> Lua 调试</h1>\n<p>Lua 提供一个调试库，这个库中提供了创建自己的调试器所需的所有原语函数。虽然，Lua 没有内置调试器，但是开发者们为 Lua 开发了许多的开源调试器。</p>\n<p>Lua 调试库包括的函数如下表所示。</p>\n<table>\n\t<tr>\n\t\t<th>S.N.</th>\n\t\t<th>方法和描述</th>\n\t</tr>\n\t<tr>\n\t<td>1</td>\n\t\t<td>debug():进入交互式调试模式，在此模式下用户可以用其它函数查看变量的值。</td>\n\t</tr>\n\t<tr>\n\t\t<td>2</td>\n\t\t<td>getfenv(object):返回对象的环境。</td>\n\t</tr>\n\t<tr>\n\t\t<td>3</td>\n\t\t<td>gethook(optional thread)：返回线程当前的钩子设置，总共三个值：当前钩子函数、当前的钩子掩码与当前的钩子计数。</td>\n\t</tr>\n\t<tr>\n\t\t<td>4</td>\n\t\t<td>getinfo(optional thread,function or stack leve,optional flag)：返回保存函数信息的一个表。你可以直接指定函数，或者你也可以通过一个值指定函数，该值为函数在当前线程的函数调用栈的层次。其中，0 表示当前函数（getinfo 本身）；层次 1 表示调用 getinfo 的函数，依次类推。如果数值大于活跃函数的总量，getinfo 则返回 nil。</td>\n\t</tr>\n\t<tr>\n\t\t<td>5</td>\n\t\t<td>getlocal(optional thread,stack level,local index)：此函数返回在 level 层次的函数中指定索引位置处的局部变量和对应的值。如果指定的索引处不存在局部变量，则返回 nil。当 level 超出范围时，则抛出错误。</td>\n\t</tr>\n\t<tr>\n\t\t<td>6</td>\n\t\t<td>getmetatable(value)：返回指定对象的元表，如果不存在则返回 nil。</td>\n\t</tr>\n\t<tr>\n\t\t<td>7</td>\n\t\t<td>getregistry()：返回寄存器表。寄存器表是一个预定义的用于 C 代码存储 Lua 值的表。</td>\n\t</tr>\n\t<tr>\n\t\t<td>8</td>\n\t\t<td>getupvalue(func function,upvalue index)：根据指定索引返回函数 func 的 upvalue 值（译注：upvalue 值与函数局部变量的区别在于，即使函数并非活跃状态也可能有 upvalue 值，而非活跃函数则不存在局部变量，所以其第一个参数不是栈的层次而是函数）。如果不存在，则返回 nil。</td>\n\t</tr>\n\t<tr>\n\t\t<td>9</td>\n\t\t<td>setfenv(function or thread or userdata,environment table)：将指定的对象的环境设置为 table,即改变对象的作用域。</td>\n\t</tr>\n\t<tr>\n\t\t<td>10</td>\n\t\t<td>sethook(optional thread,hook function,hook mask string with \"c\" and/or \"r\" and/or \"l\",optional instruction count)：把指定函数设置为钩子。字符串掩码和计数值表示钩子被调用的时机。这里，c 表示每次调用函数时都会执行钩子；r 表示每次从函数中返回时都调用钩子；l 表示每进入新的一行调用钩子。</td>\n\t</tr>\n\t<tr>\n\t\t<td>11</td>\n\t\t<td>setlocal(optional thread,stack level,local index,value):在指定的栈深度的函数中，为 index 指定的局部变量赋予值。如果局部变量不存在，则返回 nil。若 level 超出范围则抛出错误；否则返回局部变量的名称。</td>\n\t</tr>\n\t<tr>\n\t\t<td>12</td>\n\t\t<td>setmetatable(value,metatable):为指定的对象设置元表，元表可以为 nil。</td>\n\t</tr>\n\t<tr>\n\t\t<td>13</td>\n\t\t<td>setupvalue(function,upvalue index,value):为指定函数中索引指定的 upvalue 变量赋值。如果 upvalue 不存在，则返回 nil。否则返回此 upvalue 的名称。</td>\n\t</tr>\n\t<tr>\n\t\t<td>14</td>\n\t\t<td>traceback(optional thread,optional meesage string,opitona level argument)：用 traceback 构建扩展错误消息。</td>\n\t</tr>\n</table>\n<p>上面的表中列出了 Lua 的全部调试函数，我们经常用到的调试库都会用到上面的函数，它让调试变得非常容易。虽然提供了便捷的接口，但是想要用上面的函数创建一个自己的调试器并不是件容易的事。无论怎样，我们可以看一下下面这个例子中怎么使用这些调试函数的。</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\"><span class=\"token keyword\">function</span> <span class=\"token function\">myfunction</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">print</span><span class=\"token punctuation\">(</span>debug<span class=\"token punctuation\">.</span><span class=\"token function\">traceback</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Stack trace\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">print</span><span class=\"token punctuation\">(</span>debug<span class=\"token punctuation\">.</span><span class=\"token function\">getinfo</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Stack trace end\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">10</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token function\">myfunction</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">print</span><span class=\"token punctuation\">(</span>debug<span class=\"token punctuation\">.</span><span class=\"token function\">getinfo</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>执行上面的程序，我们可以得到如下的栈轨迹信息：</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\">Stack trace\nstack traceback<span class=\"token punctuation\">:</span>\n\ttest2<span class=\"token punctuation\">.</span>lua<span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">in</span> <span class=\"token keyword\">function</span> <span class=\"token string\">'myfunction'</span>\n\ttest2<span class=\"token punctuation\">.</span>lua<span class=\"token punctuation\">:</span><span class=\"token number\">8</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">in</span> main chunk\n\t<span class=\"token punctuation\">[</span>C<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> ?\ntable<span class=\"token punctuation\">:</span> 0054C6C8\nStack trace <span class=\"token keyword\">end</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面的例子中，我们使用 debug.trace 函数输出了栈轨迹。 debug.getinfo 函数获得函数的当前表。</p>\n<h2 id=\"示例二\"><a class=\"markdownIt-Anchor\" href=\"#示例二\"></a> 示例二</h2>\n<p>在调试过程中，我们常常需要查看或修改函数局部变量的值。因此，我们可以用 getupvalue 获得变量的值，用 setupvalue 修改变量的值。示例如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">function</span> newCounter <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token builtin class-name\">local</span> n <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token builtin class-name\">local</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token builtin class-name\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    k <span class=\"token operator\">=</span> n\n    n <span class=\"token operator\">=</span> n + <span class=\"token number\">1</span>\n    <span class=\"token builtin class-name\">return</span> n\n    end\nend\n\ncounter <span class=\"token operator\">=</span> newCounter <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nprint<span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">(</span><span class=\"token punctuation\">))</span>\nprint<span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">(</span><span class=\"token punctuation\">))</span>\n\n<span class=\"token builtin class-name\">local</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\nrepeat\n  name, val <span class=\"token operator\">=</span> debug.getupvalue<span class=\"token punctuation\">(</span>counter, i<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> name <span class=\"token keyword\">then</span>\n    print <span class=\"token punctuation\">(</span><span class=\"token string\">\"index\"</span>, i, name, <span class=\"token string\">\"=\"</span>, val<span class=\"token punctuation\">)</span>\n\tif<span class=\"token punctuation\">(</span>name <span class=\"token operator\">==</span> <span class=\"token string\">\"n\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">then</span>\n\t\tdebug.setupvalue <span class=\"token punctuation\">(</span>counter,2,10<span class=\"token punctuation\">)</span>\n\tend\n    i <span class=\"token operator\">=</span> i + <span class=\"token number\">1</span>\n  end -- <span class=\"token keyword\">if</span>\n<span class=\"token keyword\">until</span> not name\n\nprint<span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">(</span><span class=\"token punctuation\">))</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>运行上面的程序，我们可以得到如下面的输出结果：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">1</span>\n<span class=\"token number\">2</span>\nindex\t<span class=\"token number\">1</span>\tk\t<span class=\"token operator\">=</span>\t<span class=\"token number\">1</span>\nindex\t<span class=\"token number\">2</span>\tn\t<span class=\"token operator\">=</span>\t<span class=\"token number\">2</span>\n<span class=\"token number\">11</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在这个例子中，每次调用 counter 都会更新该闭包函数。我们可以通过 getupvalue 查看其当前的局部变量值。随后，我们更新局部变量的值。在为 n 设置新值之前，其值为 2。调用 setupvalue 后，n 被设置为 10。再调用 counter 时，它就会返回值 11 而不再是 3。</p>\n<h2 id=\"调试类型\"><a class=\"markdownIt-Anchor\" href=\"#调试类型\"></a> 调试类型</h2>\n<ul>\n\t<li>命令行调试</li>\n\t<li>图形界面调试</li>\n</ul>\n<h3 id=\"命令行调试工具\"><a class=\"markdownIt-Anchor\" href=\"#命令行调试工具\"></a> 命令行调试工具</h3>\n<p>命令行调试就是使用命令行命令和 print 语句来调试程序。已经有许多现成的 Lua 命令行调试工具，下面列出了其中的一部分：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>RemDebug：RemDebug 是一个远程的调试器，它支持 Lua 5.0 和 5.1 版本。允许远程调试 Lua 程序，设置断点以及查看程序的当前状态。同时，它还能调试 CGILua 脚本。</p>\n</li>\n<li class=\"lvl-2\">\n<p>clidebugger：此调试器是用纯 Lua 脚本开发的命令行调试工具，支持 Lua 5.1。除了 Lua 5.1 标准库以外，它不依赖于任何其它的 Lua 库。虽然它受到了 RemDebug 影响而产生的，但是它没有远程调试的功能。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ctrace：跟踪 Lua API 调用的小工具。</p>\n</li>\n<li class=\"lvl-2\">\n<p>xdbLua：windows 平台下的 Lua 命令行调试工具。</p>\n</li>\n<li class=\"lvl-2\">\n<p>LuaInterface - Debuger：这个项目是 LuaInterface 的扩展，它对 Lua 调试接口进行进一步的抽象，允许通过事件和方法调用的方式调试程序。</p>\n</li>\n<li class=\"lvl-2\">\n<p>RIdb：使用套接字的远程 Lua 调试器，支持 Linux 和 Windows 平台。它的特性比任何其它调试器都丰富。</p>\n</li>\n<li class=\"lvl-2\">\n<p>ModDebug：允许远程控制另外一个 Lua　程序的执行、设置断点以及查看程序的当前状态。</p>\n</li>\n</ul>\n<h3 id=\"图形界面调试工具\"><a class=\"markdownIt-Anchor\" href=\"#图形界面调试工具\"></a> 图形界面调试工具</h3>\n<p>图形界面的调试工具往往和集成开发环境（IDE）打包在一起。它允许在可视环境下进行调试，比如查看变量值，栈跟踪等。通过 IDE 的图形界面，你可以设置断点单步执行程序。</p>\n<p>下面列出了几种图形界面的调试工具。</p>\n<ul>\n\t<li>SciTE：Windows 系统上默认的 Lua 集成开发环境，它提供了丰富的调试功能，比如，断点、单步、跳过、查看变量等等。</li>\n\t<li>Decoda：一个允许远程调试的图形界面调试工具。</li>\n\t<li>ZeroBrane Studio：一个 Lua 的集成开发环境，它集成了远程调试器、栈视图、远程控制终端、静态分析等诸多功能。它兼容各类 Lua 引擎，例如 LuaJIT,Love2d,Moai等。支持 Windows, OSX, Linux；开源。</li>\n\t<li>akdebugger：eclipse 的 Lua 调试器和编辑器插件。</li>\n\t<li>luaedit：支持运程调试、本地调试、语法高亮、自动补完、高级断点管理（包括有条件地触发断和断点计数）、函数列表、全局和本地变量列表、面对方案的管理等。</li>\n</ul>","text":" Lua 调试 Lua 提供一个调试库，这个库中提供了创建自己的调试器所需的所有原语函数。虽然，Lua 没有内置调试器，但是开发者们为 Lua 开发了许多的开源调试器。 Lua 调试库包括的函数如下表所示。 S.N. 方法和描述 1 debug():进入交互式调试模式，在此模式下...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":34,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#lua-%E8%B0%83%E8%AF%95\"><span class=\"toc-text\"> Lua 调试</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E4%BA%8C\"><span class=\"toc-text\"> 示例二</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%83%E8%AF%95%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\"> 调试类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\"> 命令行调试工具</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\"> 图形界面调试工具</span></a></li></ol></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua数学函数库","uid":"3f4bda6307129cf6a3004f8fe27cd085","slug":"lua/2016-06-01-math-library","date":"2024-03-14T07:45:09.090Z","updated":"2024-03-27T04:00:27.608Z","comments":true,"path":"api/articles/lua/2016-06-01-math-library.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" Lua 数学函数库 在科学计算与工程计算领域，我们都需要用到大量的数学函数。在 Lua 的数学库提供了大量的数学函数，如下表所示： S.N. 函数与功能 1 math.abs(x)：返回 x 的绝对值。 2 math.acos(x)：返回 x 的反余弦值（弧度）。 3 math...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":34,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua中的嵌套 if 语句","uid":"5244c371e170ba321efd30c500d79562","slug":"lua/2016-06-01-nested-if-statement","date":"2024-03-14T07:45:09.089Z","updated":"2024-03-14T07:45:09.089Z","comments":true,"path":"api/articles/lua/2016-06-01-nested-if-statement.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"#Lua 中的嵌套 if 语句 在 Lua 语言中，你可以合法的嵌套使用 if-else 语句。这也就是说，你可以在一个 if 或 if-else 语句内再使用一个 if 或 if-else 语句。 ##语法 嵌套 if 语句的语法规则如下： if( boolean_expres...","link":"","photos":[],"count_time":{"symbolsCount":723,"symbolsTime":"1 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":34,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}