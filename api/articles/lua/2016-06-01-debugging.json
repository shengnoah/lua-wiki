{"title":"Lua调试","uid":"374513b04e64d95f7bc41ddb08581b8d","slug":"lua/2016-06-01-debugging","date":"2024-03-14T07:45:09.089Z","updated":"2024-03-14T07:45:09.089Z","comments":true,"path":"api/articles/lua/2016-06-01-debugging.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<h1>Lua 调试</h1>\n<p>Lua 提供一个调试库，这个库中提供了创建自己的调试器所需的所有原语函数。虽然，Lua 没有内置调试器，但是开发者们为 Lua 开发了许多的开源调试器。</p>\n<p>Lua 调试库包括的函数如下表所示。</p>\n<table>\n\t<tr>\n\t\t<th>S.N.</th>\n\t\t<th>方法和描述</th>\n\t</tr>\n\t<tr>\n\t<td>1</td>\n\t\t<td>debug():进入交互式调试模式，在此模式下用户可以用其它函数查看变量的值。</td>\n\t</tr>\n\t<tr>\n\t\t<td>2</td>\n\t\t<td>getfenv(object):返回对象的环境。</td>\n\t</tr>\n\t<tr>\n\t\t<td>3</td>\n\t\t<td>gethook(optional thread)：返回线程当前的钩子设置，总共三个值：当前钩子函数、当前的钩子掩码与当前的钩子计数。</td>\n\t</tr>\n\t<tr>\n\t\t<td>4</td>\n\t\t<td>getinfo(optional thread,function or stack leve,optional flag)：返回保存函数信息的一个表。你可以直接指定函数，或者你也可以通过一个值指定函数，该值为函数在当前线程的函数调用栈的层次。其中，0 表示当前函数（getinfo 本身）；层次 1 表示调用 getinfo 的函数，依次类推。如果数值大于活跃函数的总量，getinfo 则返回 nil。</td>\n\t</tr>\n\t<tr>\n\t\t<td>5</td>\n\t\t<td>getlocal(optional thread,stack level,local index)：此函数返回在 level 层次的函数中指定索引位置处的局部变量和对应的值。如果指定的索引处不存在局部变量，则返回 nil。当 level 超出范围时，则抛出错误。</td>\n\t</tr>\n\t<tr>\n\t\t<td>6</td>\n\t\t<td>getmetatable(value)：返回指定对象的元表，如果不存在则返回 nil。</td>\n\t</tr>\n\t<tr>\n\t\t<td>7</td>\n\t\t<td>getregistry()：返回寄存器表。寄存器表是一个预定义的用于 C 代码存储 Lua 值的表。</td>\n\t</tr>\n\t<tr>\n\t\t<td>8</td>\n\t\t<td>getupvalue(func function,upvalue index)：根据指定索引返回函数 func 的 upvalue 值（译注：upvalue 值与函数局部变量的区别在于，即使函数并非活跃状态也可能有 upvalue 值，而非活跃函数则不存在局部变量，所以其第一个参数不是栈的层次而是函数）。如果不存在，则返回 nil。</td>\n\t</tr>\n\t<tr>\n\t\t<td>9</td>\n\t\t<td>setfenv(function or thread or userdata,environment table)：将指定的对象的环境设置为 table,即改变对象的作用域。</td>\n\t</tr>\n\t<tr>\n\t\t<td>10</td>\n\t\t<td>sethook(optional thread,hook function,hook mask string with \"c\" and/or \"r\" and/or \"l\",optional instruction count)：把指定函数设置为钩子。字符串掩码和计数值表示钩子被调用的时机。这里，c 表示每次调用函数时都会执行钩子；r 表示每次从函数中返回时都调用钩子；l 表示每进入新的一行调用钩子。</td>\n\t</tr>\n\t<tr>\n\t\t<td>11</td>\n\t\t<td>setlocal(optional thread,stack level,local index,value):在指定的栈深度的函数中，为 index 指定的局部变量赋予值。如果局部变量不存在，则返回 nil。若 level 超出范围则抛出错误；否则返回局部变量的名称。</td>\n\t</tr>\n\t<tr>\n\t\t<td>12</td>\n\t\t<td>setmetatable(value,metatable):为指定的对象设置元表，元表可以为 nil。</td>\n\t</tr>\n\t<tr>\n\t\t<td>13</td>\n\t\t<td>setupvalue(function,upvalue index,value):为指定函数中索引指定的 upvalue 变量赋值。如果 upvalue 不存在，则返回 nil。否则返回此 upvalue 的名称。</td>\n\t</tr>\n\t<tr>\n\t\t<td>14</td>\n\t\t<td>traceback(optional thread,optional meesage string,opitona level argument)：用 traceback 构建扩展错误消息。</td>\n\t</tr>\n</table>\n<p>上面的表中列出了 Lua 的全部调试函数，我们经常用到的调试库都会用到上面的函数，它让调试变得非常容易。虽然提供了便捷的接口，但是想要用上面的函数创建一个自己的调试器并不是件容易的事。无论怎样，我们可以看一下下面这个例子中怎么使用这些调试函数的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function myfunction ()</span><br><span class=\"line\">print(debug.traceback(&quot;Stack trace&quot;))</span><br><span class=\"line\">print(debug.getinfo(1))</span><br><span class=\"line\">print(&quot;Stack trace end&quot;)</span><br><span class=\"line\">\treturn 10</span><br><span class=\"line\">end</span><br><span class=\"line\">myfunction ()</span><br><span class=\"line\">print(debug.getinfo(1))</span><br></pre></td></tr></table></figure>\n<p>执行上面的程序，我们可以得到如下的栈轨迹信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack trace</span><br><span class=\"line\">stack traceback:</span><br><span class=\"line\">\ttest2.lua:2: in function &#x27;myfunction&#x27;</span><br><span class=\"line\">\ttest2.lua:8: in main chunk</span><br><span class=\"line\">\t[C]: ?</span><br><span class=\"line\">table: 0054C6C8</span><br><span class=\"line\">Stack trace end</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">上面的例子中，我们使用 debug.trace 函数输出了栈轨迹。 debug.getinfo 函数获得函数的当前表。  </span><br><span class=\"line\"></span><br><span class=\"line\">## 示例二  </span><br><span class=\"line\"></span><br><span class=\"line\">在调试过程中，我们常常需要查看或修改函数局部变量的值。因此，我们可以用 getupvalue 获得变量的值，用 setupvalue 修改变量的值。示例如下：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function newCounter ()<br>\nlocal n = 0<br>\nlocal k = 0<br>\nreturn function ()<br>\nk = n<br>\nn = n + 1<br>\nreturn n<br>\nend<br>\nend</p>\n<p>counter = newCounter ()<br>\nprint(counter())<br>\nprint(counter())</p>\n<p>local i = 1</p>\n<p>repeat<br>\nname, val = debug.getupvalue(counter, i)<br>\nif name then<br>\nprint (“index”, i, name, “=”, val)<br>\nif(name == “n”) then<br>\ndebug.setupvalue (counter,2,10)<br>\nend<br>\ni = i + 1<br>\nend – if<br>\nuntil not name</p>\n<p>print(counter())</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">运行上面的程序，我们可以得到如下面的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>1<br>\n2<br>\nindex\t1\tk\t=\t1<br>\nindex\t2\tn\t=\t2<br>\n11</p>\n<pre><code>\n在这个例子中，每次调用 counter 都会更新该闭包函数。我们可以通过 getupvalue 查看其当前的局部变量值。随后，我们更新局部变量的值。在为 n 设置新值之前，其值为 2。调用 setupvalue 后，n 被设置为 10。再调用 counter 时，它就会返回值 11 而不再是 3。  \n\n## 调试类型  \n\n&lt;ul&gt;\n\t&lt;li&gt;命令行调试&lt;/li&gt;\n\t&lt;li&gt;图形界面调试&lt;/li&gt;\n&lt;/ul&gt;\n\n### 命令行调试工具  \n\n命令行调试就是使用命令行命令和 print 语句来调试程序。已经有许多现成的 Lua 命令行调试工具，下面列出了其中的一部分：\n  \n- RemDebug：RemDebug 是一个远程的调试器，它支持 Lua 5.0 和 5.1 版本。允许远程调试 Lua 程序，设置断点以及查看程序的当前状态。同时，它还能调试 CGILua 脚本。\n- clidebugger：此调试器是用纯 Lua 脚本开发的命令行调试工具，支持 Lua 5.1。除了 Lua 5.1 标准库以外，它不依赖于任何其它的 Lua 库。虽然它受到了 RemDebug 影响而产生的，但是它没有远程调试的功能。\n- ctrace：跟踪 Lua API 调用的小工具。\n- xdbLua：windows 平台下的 Lua 命令行调试工具。\n- LuaInterface - Debuger：这个项目是 LuaInterface 的扩展，它对 Lua 调试接口进行进一步的抽象，允许通过事件和方法调用的方式调试程序。\n- RIdb：使用套接字的远程 Lua 调试器，支持 Linux 和 Windows 平台。它的特性比任何其它调试器都丰富。\n- ModDebug：允许远程控制另外一个 Lua　程序的执行、设置断点以及查看程序的当前状态。\n\n\n### 图形界面调试工具  \n\n图形界面的调试工具往往和集成开发环境（IDE）打包在一起。它允许在可视环境下进行调试，比如查看变量值，栈跟踪等。通过 IDE 的图形界面，你可以设置断点单步执行程序。  \n\n下面列出了几种图形界面的调试工具。  \n\n&lt;ul&gt;\n\t&lt;li&gt;SciTE：Windows 系统上默认的 Lua 集成开发环境，它提供了丰富的调试功能，比如，断点、单步、跳过、查看变量等等。&lt;/li&gt;\n\t&lt;li&gt;Decoda：一个允许远程调试的图形界面调试工具。&lt;/li&gt;\n\t&lt;li&gt;ZeroBrane Studio：一个 Lua 的集成开发环境，它集成了远程调试器、栈视图、远程控制终端、静态分析等诸多功能。它兼容各类 Lua 引擎，例如 LuaJIT,Love2d,Moai等。支持 Windows, OSX, Linux；开源。&lt;/li&gt;\n\t&lt;li&gt;akdebugger：eclipse 的 Lua 调试器和编辑器插件。&lt;/li&gt;\n\t&lt;li&gt;luaedit：支持运程调试、本地调试、语法高亮、自动补完、高级断点管理（包括有条件地触发断和断点计数）、函数列表、全局和本地变量列表、面对方案的管理等。&lt;/li&gt;\n&lt;/ul&gt;</code></pre>\n","text":"Lua 调试 Lua 提供一个调试库，这个库中提供了创建自己的调试器所需的所有原语函数。虽然，Lua 没有内置调试器，但是开发者们为 Lua 开发了许多的开源调试器。 Lua 调试库包括的函数如下表所示。 S.N. 方法和描述 1 debug():进入交互式调试模式，在此模式下用...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\">Lua 调试</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua数学函数库","uid":"3f4bda6307129cf6a3004f8fe27cd085","slug":"lua/2016-06-01-math-library","date":"2024-03-14T07:45:09.090Z","updated":"2024-03-14T07:45:09.090Z","comments":true,"path":"api/articles/lua/2016-06-01-math-library.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"Lua 数学函数库 在科学计算与工程计算领域，我们都需要用到大量的数学函数。在 Lua 的数学库提供了大量的数学函数，如下表所示： S.N. 函数与功能 1 math.abs(x)：返回 x 的绝对值。 2 math.acos(x)：返回 x 的反余弦值（弧度）。 3 math....","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua中的嵌套 if 语句","uid":"5244c371e170ba321efd30c500d79562","slug":"lua/2016-06-01-nested-if-statement","date":"2024-03-14T07:45:09.089Z","updated":"2024-03-14T07:45:09.089Z","comments":true,"path":"api/articles/lua/2016-06-01-nested-if-statement.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"#Lua 中的嵌套 if 语句 在 Lua 语言中，你可以合法的嵌套使用 if-else 语句。这也就是说，你可以在一个 if 或 if-else 语句内再使用一个 if 或 if-else 语句。 ##语法 嵌套 if 语句的语法规则如下： 123456789101112131...","link":"","photos":[],"count_time":{"symbolsCount":718,"symbolsTime":"1 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":68,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}