{"title":"Lua垃圾回收机制","uid":"a34942b7e84e08a52441ea25cc5475d6","slug":"lua/2016-06-01-garbage-collection","date":"2024-03-14T07:45:09.084Z","updated":"2024-03-27T03:37:48.800Z","comments":true,"path":"api/articles/lua/2016-06-01-garbage-collection.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h1 id=\"lua-垃圾回收机制\"><a class=\"markdownIt-Anchor\" href=\"#lua-垃圾回收机制\"></a> Lua 垃圾回收机制</h1>\n<p>Lua 通过特定算法的垃圾回收机制实现自动内存管理。由于自动内存管理机制的存在，作为程序开发人员：</p>\n<ul>\n\t<li>不需要关心对象的内存分配问题。</li>\n\t<li>不再使用对象时，除了将引用它的变量设为 nil，不需要主动释放对象。</li>\n</ul>  \nLua 的垃圾回收器会不断运行去收集不再被 Lua 程序访问的对象。\n所有的对象，包括表、userdata、函数、线程、字符串等都由自动内存管理机制管理它们空间的分配和释放。Lua 实现了一个增量式标记清除垃圾收集器。它用两个数值控制垃圾回收周期，垃圾收集器暂停时间（garbage-collector pause） 和垃圾收集器步长倍增器（garbage-collector step multiplier）。其数值是以百分制计数的，即数值 100 内部表示 1。\n<h2 id=\"垃圾收集器暂停时间\"><a class=\"markdownIt-Anchor\" href=\"#垃圾收集器暂停时间\"></a> 垃圾收集器暂停时间</h2>\n<p>该数值被用于控制垃圾收集器被 Lua 自动内存管理再次运行之前需要的等待时长。当其小于 100 时意味着收集器在新周期开始前不再等待。其值越大垃圾回收器被运行的频率越低，越不主动。当其值 200 时，收集器在总使用内存数量达到上次垃圾收集时的两倍时再开启新的收集周期。因此，根据程序不同的特征，可以通过修改该值使得程序达到最佳的性能。</p>\n<h2 id=\"垃圾收集器步长倍增器\"><a class=\"markdownIt-Anchor\" href=\"#垃圾收集器步长倍增器\"></a> 垃圾收集器步长倍增器</h2>\n<p>步长倍增器用于控制了垃圾收集器相对内存分配的速度。数值越大收集器工作越主动，但同时也增加了垃圾收集每次迭代步长的大小。值小于 100 可能会导致垃圾器一个周期永远不能结束，建议不要这么设置。默认值为 200，表示垃圾收集器运行的速率是内存分配的两倍。</p>\n<h2 id=\"垃圾回收器相关函数\"><a class=\"markdownIt-Anchor\" href=\"#垃圾回收器相关函数\"></a> 垃圾回收器相关函数</h2>\n<p>作为开发人员，我们可能需要控制 Lua 的自动内存管理机制，可以使用下面的这些方法：</p>\n<ul>\n\t<li>collectgarbage(\"collect\")：运行一个完整的垃圾回收周期。</li>\n\t<li>collectgarbage(\"count\")：返回当前程序使用的内存总量，以 KB 为单位。</li>\n\t<li>collectgarbage(\"restart\")：如果垃圾回收器停止，则重新运行它。</li>\n\t<li>collectgarbage(\"setpause\")：设置垃圾收集暂停时间变量的值，值由第二个参数指出（第二参数的值除以 100 后赋予变量）。稍后，我们将详细讨论它的用法。</li>\n\t<li>collectgarbage(\"setsetmul\")：设置垃圾收集器步长倍增器的值，第二个参数的含义与上同。</li>\n\t<li>collectgarbage(\"step\")：进行一次垃圾回收迭代。第二个参数值越大，一次迭代的时间越长；如果本次迭代是垃圾回收的最后一次迭代则此函数返回 true。</li>\n\t<li>collectgarbage(\"stop\")：停止垃圾收集器运行。</li>\n</ul>\n<p>下面的示例代码中使用了垃圾收集器相关函数，如下所示：</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\">mytable <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"orange\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"banana\"</span><span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token function\">collectgarbage</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"count\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\nmytable <span class=\"token operator\">=</span> <span class=\"token keyword\">nil</span>\n\n<span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token function\">collectgarbage</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"count\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token function\">collectgarbage</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"collect\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token function\">collectgarbage</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"count\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>运行上面的程序，我们可以得到如下的输出结果。请注意，输出结果与操作系统类型与 Lua 自动内存管理都有关，所以可能实际运行的结果与下面不相同。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">20.9560546875</span>\n<span class=\"token number\">20.9853515625</span>\n<span class=\"token number\">0</span>\n<span class=\"token number\">19.4111328125</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从上面的程序，我们可以看出，一旦垃圾回收运行后，使用的内存量立即就减少了。但是，我们并不需要主动去调用它。因为，即使我们不调用此函数，Lua 也会按配置的周期自动的调用垃圾回收器。<br />\n显然，如果需要，我们可以用上面的这些函数调整垃圾回收器的行为。这些函数帮且程序开发人员处理更加复杂的场景。根据开发的不同程序的内存需求，我们可以使用到这些方法来提高程序的性能。虽然大部分情况下，我们都不会用到这些函数，但是了解这些方法可以帮助我们调试程序，以免应用上线后带来的损失。</p>\n<p>译注：更多垃圾回收器的内容请参考官网或者此<a href= \"http://www.xuebuyuan.com/1636688.html\">博客</a>。</p>\n","text":" Lua 垃圾回收机制 Lua 通过特定算法的垃圾回收机制实现自动内存管理。由于自动内存管理机制的存在，作为程序开发人员： 不需要关心对象的内存分配问题。 不再使用对象时，除了将引用它的变量设为 nil，不需要主动释放对象。 Lua 的垃圾回收器会不断运行去收集不再被 Lua 程...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":34,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#lua-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\"> Lua 垃圾回收机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4\"><span class=\"toc-text\"> 垃圾收集器暂停时间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%AD%A5%E9%95%BF%E5%80%8D%E5%A2%9E%E5%99%A8\"><span class=\"toc-text\"> 垃圾收集器步长倍增器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0\"><span class=\"toc-text\"> 垃圾回收器相关函数</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua数据库访问","uid":"5593d949c022c9556ceb62d288c587d5","slug":"lua/2016-06-01-database-access","date":"2024-03-14T07:45:09.084Z","updated":"2024-03-27T04:20:42.980Z","comments":true,"path":"api/articles/lua/2016-06-01-database-access.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" Lua 数据库访问 简单的数据操作，我们用文件就可以处理。但是，某些时候文件操作存在性能、扩展性等问题。这时候，我们就需要使用数据库。LuaSQL 是一个提供数据库操作的库，它支持多种 SQL 数据库的操作。包括： SQLite MySQL ODBC 在本教程中，我们会讲解用 ...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":34,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua循环嵌套","uid":"cce4b5e763b43300a4fad206fcb6b9e4","slug":"lua/2016-06-01-nested-loop","date":"2024-03-14T07:45:09.084Z","updated":"2024-03-27T03:22:46.541Z","comments":true,"path":"api/articles/lua/2016-06-01-nested-loop.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"#Lua 循环嵌套 Lua 编程语言允许使用循环嵌套。接下来这一节中将用例子来说嵌套循环的使用方法： 语法 for 循环嵌套的语法如下： for init,max/min value, increment do for init,max/min value, increment ...","link":"","photos":[],"count_time":{"symbolsCount":722,"symbolsTime":"1 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":34,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}