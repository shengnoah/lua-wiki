{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"lua/2016-06-01-metatables","date":"2024-03-14T07:45:09.086Z","updated":"2024-03-14T07:45:09.086Z","comments":true,"path":"api/articles/lua/2016-06-01-metatables.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<h1>Lua 元表</h1>\n<p>正如其名，元表也是表。不过，将元表与表相关联后，我们就可以通过设置元表的键和相关方法来改变表的行为。元方法的功能十分强大，使用元方法可以实现很多的功能，比如：</p>\n<ul>\n\t<li>修改表的操作符功能或为操作符添加新功能（译注：如果您学过 C++ 之类的面向对象的语言，应该比较好理解，其实它实现的是操作的重载）。</li>\n\t<li>使用元表中的 __index 方法，我们可以实现在表中查找键不存在时转而在元表中查找键值的功能。</li>\n</ul>  \n<p>Lua 提供了两个十分重要的用来处理元表的方法，如下：</p>\n<ul>\n\t<li>setmetatable(table,metatable):此方法用于为一个表设置元表。</li>\n\t<li>getmetatable(table)：此方法用于获取表的元表对象。</li>\n</ul>  \n<p>首先，让我们看一下如何将一个表设置为另一个表的元表。示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mytable = &#123;&#125;</span><br><span class=\"line\">mymetatable = &#123;&#125;</span><br><span class=\"line\">setmetatable(mytable,mymetatable)</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">上面的代码可以简写成如下的一行代码：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mytable = setmetatable({},{})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## __index  </span><br><span class=\"line\"></span><br><span class=\"line\">下面的例子中，我们实现了在表中查找键不存在时转而在元表中查找该键的功能：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mytable = setmetatable({key1 = “value1”}, {<br>\n__index = function(mytable, key)<br>\nif key == “key2” then<br>\nreturn “metatablevalue”<br>\nelse<br>\nreturn mytable[key]<br>\nend<br>\nend<br>\n})</p>\n<p>print(mytable.key1,mytable.key2)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">运行上面的程序，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>value1\tmetatablevalue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">接下来逐步解释上面例子运行的过程：  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">\t&lt;li&gt;表 mytable 为 &#123;key = &quot;values1&quot;&#125;&lt;/li&gt;</span><br><span class=\"line\">\t&lt;li&gt;为 mytable 设置了一个元表，该元表的键 __index 存储了一个函数，我们称这个函数为元方法。&lt;/li&gt;</span><br><span class=\"line\">\t&lt;li&gt;这个元方法的工作也十分简单。它仅查找索引 “key2”,如果找到该索引值，则返回 &quot;metatablevalue&quot;,否则返回 mytable 中索引对应的值。&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">上面的程序同样可以简化成如下的形式：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mytable = setmetatable({key1 = “value1”}, { __index = { key2 = “metatablevalue” } })<br>\nprint(mytable.key1,mytable.key2)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## __newindex  </span><br><span class=\"line\"></span><br><span class=\"line\">为元表添加 __newindex 后，当访问的键在表中不存在时，此时添加新键值对的行为将由此元方法（__newindex）定义。下面的例子中，如果访问的索引在表中不存在则在元表中新加该索引值（注意，是添加在另外一个表 mymetatable 中而非在原表 mytable 中。），具体代码如下(译注：请注意此处 __newindex 的值并非一个方法而是一个表。)：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mymetatable = {}<br>\nmytable = setmetatable({key1 = “value1”}, { __newindex = mymetatable })</p>\n<p>print(mytable.key1)</p>\n<p>mytable.newkey = “new value 2”<br>\nprint(mytable.newkey,mymetatable.newkey)</p>\n<p>mytable.key1 = “new  value 1”<br>\nprint(mytable.key1,mymetatable.newkey1)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">执行上面的程序，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>value1<br>\nnil\tnew value 2<br>\nnew  value 1\tnil</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">可以看出，在上面的程序中，如果键存在于主表中，只会简单更新相应的键值。而如果键不在表中时，会在另外的表 mymetatable 中添加该键值对。  </span><br><span class=\"line\">在接下来这个例子中，我们用 rawset 函数在相同的表（主表）中更新键值，而不再是将新的键添加到另外的表中。代码如下所示：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mytable = setmetatable({key1 = “value1”}, {<br>\n__newindex = function(mytable, key, value)<br>\nrawset(mytable, key, “&quot;”…value…“&quot;”)</p>\n<p>end<br>\n})</p>\n<p>mytable.key1 = “new value”<br>\nmytable.key2 = 4</p>\n<p>print(mytable.key1,mytable.key2)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">执行上面的程序，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>new value\t“4”</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">rawset 函数设置值时不会使用元表中的 __newindex 元方法。同样的，Lua 中也存的一个 rawget 方法，该方法访问表中键值时也不会调用 __index 的元方法。  </span><br><span class=\"line\"></span><br><span class=\"line\">## 为表添加操作符行为  </span><br><span class=\"line\"></span><br><span class=\"line\">使用 + 操作符完成两个表组合的方法如下所示（译注：可以看出重载的意思了）：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mytable = setmetatable({ 1, 2, 3 }, {<br>\n__add = function(mytable, newtable)<br>\nfor i = 1, table.maxn(newtable) do<br>\ntable.insert(mytable, table.maxn(mytable)+1,newtable[i])<br>\nend<br>\nreturn mytable<br>\nend<br>\n})</p>\n<p>secondtable = {4,5,6}</p>\n<p>mytable = mytable + secondtable<br>\nfor k,v in ipairs(mytable) do<br>\nprint(k,v)<br>\nend</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">执行上面的的程序，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>1\t1<br>\n2\t2<br>\n3\t3<br>\n4\t4<br>\n5\t5<br>\n6\t6</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">元表中 __add 键用于修改加法操作符的行为。其它操作对应的元表中的键值如下表所示。  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;th&gt;键&lt;/th&gt;</span><br><span class=\"line\">\t\t&lt;th&gt;描述&lt;/th&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__add&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变加法操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__sub&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变减法操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__mul&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变乘法操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__div&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变除法操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__mod&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变模除操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__unm&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变一元减操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__concat&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变连接操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__eq&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变等于操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__lt&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变小于操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;tr&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;__le&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;td&gt;改变小于等于操作符的行为。&lt;/td&gt;</span><br><span class=\"line\">\t&lt;/tr&gt;</span><br><span class=\"line\">&lt;/table&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">## __call  </span><br><span class=\"line\"></span><br><span class=\"line\">使用 __call 可以使表具有像函数一样可调用的特性。下面的例子中涉及两个表，主表 mytable 和 传入的实参表结构 newtable，程序完成两个表中值的求和。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mytable = setmetatable({10}, {<br>\n__call = function(mytable, newtable)<br>\nsum = 0<br>\nfor i = 1, table.maxn(mytable) do<br>\nsum = sum + mytable[i]<br>\nend<br>\nfor i = 1, table.maxn(newtable) do<br>\nsum = sum + newtable[i]<br>\nend<br>\nreturn sum<br>\nend<br>\n})<br>\nnewtable = {10,20,30}<br>\nprint(mytable(newtable))</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">运行上面的代码，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>70</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## __tostring  </span><br><span class=\"line\"></span><br><span class=\"line\">要改变 print 语句的行为，我们需要用到 __tostring 元方法。下面是一个简单的例子：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mytable = setmetatable({ 10, 20, 30 }, {<br>\n__tostring = function(mytable)<br>\nsum = 0<br>\nfor k, v in pairs(mytable) do<br>\nsum = sum + v<br>\nend<br>\nreturn &quot;The sum of values in the table is &quot; … sum<br>\nend<br>\n})<br>\nprint(mytable)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">运行上面的代码，我们可以得到如下的输出结果：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>The sum of values in the table is 60</p>\n<pre><code>\n如果你完全掌握了元表的用法，你就可以实现很多看上面很复杂的操作。如果不使用元表，就不仅仅是看上去很复杂了，而是真的非常复杂。所以，多做一些使用元表的练习，并熟练掌握所有元表的可选项，这会让你受益匪浅。</code></pre>\n","text":"Lua 元表 正如其名，元表也是表。不过，将元表与表相关联后，我们就可以通过设置元表的键和相关方法来改变表的行为。元方法的功能十分强大，使用元方法可以实现很多的功能，比如： 修改表的操作符功能或为操作符添加新功能（译注：如果您学过 C++ 之类的面向对象的语言，应该比较好理解，其...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":34,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"LUA教程","slug":"LUA教程","count":4,"path":"api/tags/LUA教程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\">Lua 元表</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua中的for循环","uid":"26bfa2ece82537ab5f6962e2d31968f1","slug":"lua/2016-06-11-for","date":"2024-03-14T07:45:09.087Z","updated":"2024-03-14T07:45:09.087Z","comments":true,"path":"api/articles/lua/2016-06-11-for.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"text":"#Lua 中的 for 循环 for 循环控制结构可以让你高效地写出需要执行特定次数的循环代码。 ##语法 Lua 语言中 for 循环的语法如下： 1234for init,max/min value, incrementdo statement(s)end 下面是 for 循...","link":"","photos":[],"count_time":{"symbolsCount":483,"symbolsTime":"1 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":34,"path":"api/categories/lua-guide.json"},{"name":"lua教程","slug":"lua-guide/lua教程","count":2,"path":"api/categories/lua-guide/lua教程.json"}],"tags":[{"name":"LUA","slug":"LUA","count":1,"path":"api/tags/LUA.json"},{"name":"abc","slug":"abc","count":1,"path":"api/tags/abc.json"},{"name":"basic","slug":"basic","count":1,"path":"api/tags/basic.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Lua表","uid":"038bf88a1c7598385fc79ad2a48f60ba","slug":"lua/2016-06-01-tables","date":"2024-03-14T07:45:09.086Z","updated":"2024-03-14T07:45:09.086Z","comments":true,"path":"api/articles/lua/2016-06-01-tables.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"Lua 表 在 Lua 语言中，表是唯一可以用来创建不同数据类型的数据结构，比如常见的数组和字典都是用表来创建的。 Lua 语言中经常到关联数组这种数据类型，它不仅可以用数值作为索引值，除了 nil 以外的字符串同样可以作为其索引。表没有固定的大小，当数据量增加时表会自动增大。 ...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"lua_guide","slug":"lua-guide","count":34,"path":"api/categories/lua-guide.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}