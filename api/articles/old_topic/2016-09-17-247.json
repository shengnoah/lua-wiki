{"title":"用Django构建REST网页服务","uid":"b3a6fb6eb4424ca7a4f65fdb6f39a8d3","slug":"old_topic/2016-09-17-247","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.743Z","comments":true,"path":"api/articles/old_topic/2016-09-17-247.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>作者:糖果</p>\n<p>Django的高版本自身提供了很好REST服务组件和方便的库,Djano REST Framework提供了一个现成的方案，可以将对外的REST服务，与类似Mysql的数据存储建立有机关联，直接与ORM一起使用就更便利。</p>\n<p>JSONRenderer和JSONParser提供了方便的JSON解析和响应服务。不过用这些库意味着要按装的新包，对版本和环境可能也有要求，所以，要想在更低的Django版本下支持JSON数据接收和响应，就不要使用这些高级的库，而是直接使用老的API。</p>\n<p>如果用Lua来解析和响应JSON，也是同样方便的，关于这些json数据的存储也有很多的选择， mysql,ES,mongo都可以，甚至在SAE上，用kvdb也没有问题。</p>\n<p>下面是Django 1.5.x支持的实现。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@csrf_exempt</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">testcase</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> request.method == <span class=\"string\">&#x27;POST&#x27;</span>:</span><br><span class=\"line\">            receive_data = json.loads(request.body)</span><br><span class=\"line\">            phone = receive_data[<span class=\"string\">&#x27;phone&#x27;</span>]</span><br><span class=\"line\">            <span class=\"keyword\">return</span> HttpResponse(json.dumps(receive_data), content_type=<span class=\"string\">&quot;application/json&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span>: </span><br><span class=\"line\">        <span class=\"keyword\">import</span> sys </span><br><span class=\"line\">        info = <span class=\"string\">&quot;%s || %s&quot;</span> % (sys.exc_info()[<span class=\"number\">0</span>], sys.exc_info()[<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponse(<span class=\"string\">&quot;Parse JSON data error!&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpResponse(<span class=\"string\">&quot;Building  JSON REST Web Service!&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n\n<p>因为django使用的了中间件django.middleware.csrf.CsrfViewMiddleware，对要测试的函数需要加上@csrf_exempt装饰器，不然会报警。</p>\n<p>需要引用下面的包：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.views.decorators.csrf <span class=\"keyword\">import</span> csrf_exempt</span><br></pre></td></tr></table></figure>\n\n\n\n<p>对于”testcase“这个方法说，主要用做的处理就两件事，一是接收用户传过的JSON数据，另一个处理，就是直接再把这个数据，依JSON数据形式传回给用户，中途并没有对JSON做过任何的操作。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\">receive_data = json.loads(request.body)</span><br></pre></td></tr></table></figure>\n\n<p>如果是POST类型的请求，JSON数据，主要取得的API是request.body,在1.5.x较高的版本中，用的是这个，也可以用另外一个等价的API是raw_post_data，这是一个旧的接口，虽然可以执行，但会给出警告信息。</p>\n<p>净raw数据解析成json，主要靠的函数是json.loads(request.body).</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">receive_data = json.loads(request.body)</span><br><span class=\"line\">phone = receive_data[<span class=\"string\">&#x27;phone&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n\n<p>接口返回json数据时要指明一下mime类型。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> HttpResponse(json.dumps(receive_data), content_type=<span class=\"string\">&quot;application/json&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n\n<p> 就是这个比较简单的就可以实现json数据的接收和返回。</p>\n<p>可以简单的用curl测试一下，这个接口：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -b <span class=\"string\">&quot;key=value&quot;</span> http://<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>/json/ -d<span class=\"string\">&#x27;&#123;&quot;phone&quot;:&quot;15811111111&quot; ,&quot;identity&quot;:&quot;xxx&quot;, &quot;credit&quot;:&quot;xxx&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>这接口的圈复杂度其实不高，主要要测试的就三个分支，基本都有Message输出。</p>\n<p><a href=\"https://github.com/shengnoah/django_json_rest\" target=\"_blank\">源码地址:</a></p>\n","text":"作者:糖果 Django的高版本自身提供了很好REST服务组件和方便的库,Djano REST Framework提供了一个现成的方案，可以将对外的REST服务，与类似Mysql的数据存储建立有机关联，直接与ORM一起使用就更便利。 JSONRenderer和JSONParser...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"在Coding.net上使用SVN部署代码","uid":"5385226c4dd69806de6132d1a0edacdd","slug":"old_topic/2016-09-17-245","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.743Z","comments":true,"path":"api/articles/old_topic/2016-09-17-245.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"在Coding.net上使用SVN部署代码 coding.net上新建的工程是支持svn部署的。 我们需要在coding上新建一个普通git工程然后开起svn功能。 例如我新建了一个工程叫svntest， 是一个公开的地址： 1https://coding.net/u/sheng...","link":"","photos":[],"count_time":{"symbolsCount":819,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Octopress评论方本框的样式问题","uid":"f47eb985f6ae8a0bdc7e70fa6ba8170e","slug":"old_topic/2016-09-17-252","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.744Z","comments":true,"path":"api/articles/old_topic/2016-09-17-252.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者：糖果 前几天改octopress的样式，发现评论框的样式没了，变成了普通的表单。然后，想用vimdiff在vps上比较一下，发现新版的css就行一行，没有经过格式化，再小伙伴们的支持下，用chrome把css格式化了，然后在老版的css找到了评论文本框的样式，添加到新的cs...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}