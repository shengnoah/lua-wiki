{"title":"OPENRESTY 中的简易HTTP加密","uid":"ceeda26fcc5b2c890a2ed530be0ef341","slug":"old_topic/2016-09-17-136","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.165Z","comments":true,"path":"api/articles/old_topic/2016-09-17-136.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>需求速度快；可逆；容易实现，不存在语言障碍；思考将一个任意内容的字符串作为密钥，从明文中取等长字符串，逐字节将明文和密钥进行异或计算，得到密文。循环处理整个明文，得到完整密文。对密文进行同样的运算即可解密。</p>\n<p>算法</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> bit = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;bit&quot;</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">--- 使用密钥对字符串进行加密(解密)</span></span><br><span class=\"line\"><span class=\"comment\">--</span></span><br><span class=\"line\"><span class=\"comment\">-- @param string str 原始字符串(加密后的密文)</span></span><br><span class=\"line\"><span class=\"comment\">-- @param string key 密钥</span></span><br><span class=\"line\"><span class=\"comment\">-- @return string 加密后的密文(原始字符串)</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">encrypt</span><span class=\"params\">(str, key)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> strBytes = &#123; str:<span class=\"built_in\">byte</span>(<span class=\"number\">1</span>, #str) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">local</span> keyBytes = &#123; key:<span class=\"built_in\">byte</span>(<span class=\"number\">1</span>, #key) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">local</span> n, keyLen = <span class=\"number\">1</span>, #keyBytes</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, #strBytes <span class=\"keyword\">do</span></span><br><span class=\"line\">        strBytes[i] = bit.bxor(strBytes[i], keyBytes[n])</span><br><span class=\"line\"> </span><br><span class=\"line\">        n = n + <span class=\"number\">1</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; keyLen <span class=\"keyword\">then</span></span><br><span class=\"line\">            n = n - keyLen</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">string</span>.<span class=\"built_in\">char</span>(<span class=\"built_in\">unpack</span>(strBytes))</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>测试</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 加密密钥</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> ENCRYPT_KEY = <span class=\"string\">&quot;EFH@^&amp;%#^&amp;*@#G@&amp;()*!&amp;*@)(#$!@$GJHGHJ$G#HJ!$G&quot;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">-- 原始字符串</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> originalStr = <span class=\"string\">&quot;Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world!&quot;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">-- 加密字符串</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> encryptStr = encrypt(originalStr, ENCRYPT_KEY)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">-- 打印密文</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;encryptStr:&quot;</span> .. encryptStr)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">-- 打印原文</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;originalStr:&quot;</span> .. encrypt(encryptStr, ENCRYPT_KEY))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>处理加密 POST 数据客户端将通讯数据组成 URI 模式字符串，并用本地语言实现加密算法，将加密后的密文通过 POST 方式提交，服务端使用加密算法将 POST 数据还原成明文并解析成参数表。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 准备body数据</span></span><br><span class=\"line\">ngx.req.read_body()</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">-- 解密body数据，并解析成table格式</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> postData = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">local</span> encryptData = ngx.req.get_body_data()</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span> encryptData <span class=\"keyword\">then</span></span><br><span class=\"line\">    postData = ngx.decode_args(encrypt(encryptData, ENCRYPT_KEY))</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>感谢原作者分享：<br>\n<a href=\"http://zivn.me/?p=183\">http://zivn.me/?p=183</a></p>\n","text":"需求速度快；可逆；容易实现，不存在语言障碍；思考将一个任意内容的字符串作为密钥，从明文中取等长字符串，逐字节将明文和密钥进行异或计算，得到密文。循环处理整个明文，得到完整密文。对密文进行同样的运算即可解密。 算法 123456789101112131415161718192021...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"关于 OPENRESTY 的两三事","uid":"a924894efc1b5c05addcec2e153c3f2f","slug":"old_topic/2016-09-17-135","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.235Z","comments":true,"path":"api/articles/old_topic/2016-09-17-135.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"编辑：糖果 基础原理 Nginx 采用的是 master-worker 模型，一个 master 进程管理多个 worker 进程，基本的事件处理都是放在 woker 中，master 负责一些全局初始化，以及对 worker 的管理。 每个 woker 使用一个 LuaVM，当...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"最简单的LUA随机数生成","uid":"cbbd7e228645caa3cfb0dd345f9fe075","slug":"old_topic/2016-09-17-139","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.190Z","comments":true,"path":"api/articles/old_topic/2016-09-17-139.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"[code] math.randomseed(os.time()) for i=1, 5 do print(math.random()) end [/code] ","link":"","photos":[],"count_time":{"symbolsCount":81,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}