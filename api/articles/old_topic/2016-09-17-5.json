{"title":"通过进程信息，检查内存泄露。","uid":"bc51e73d376d390e21ec280bce3ba4f7","slug":"old_topic/2016-09-17-5","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.755Z","comments":true,"path":"api/articles/old_topic/2016-09-17-5.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>作者：糖果</p>\n<p>【问题】<br>寻找内存泄露，有时是一件困难的事情。代码的内存申请和释放动作不配对，或是在并发环境下，时序变换的异常，都会引起的内存泄露，即使从core dump回溯调用栈，也未必能找到快速内存的泄露点。</p>\n<p>某些嵌入式系统，对制造方式有特殊的限制，不允许使用智能指针或是STL库。编码的错误引起的内存泄露机率等问题，可以提前通过第三方软件静态检查，输出错误报告，从而找到问题的代码。</p>\n<p>对稍微复杂的嵌入式系统而言，在UI层，中间件层，驱动层，都可能发生泄露。特别是在并发环境下的时序异常，引起的泄露就比较难找，可以用GDB attach 断点，或是输出系统Log，进行问题的切分。</p>\n<p>如何解决？<br>Linux也提供了一种，不需要debug或是改代码的情况下，进行内从泄露检查的机制。在linux的proc目录下，有与系统进程同名的文件目录，进入目录后可以查看此进程的各种相关信息。</p>\n<p>例如，要查看系统中一个叫做candy的进程的内存使用情况，就可以按如下步骤进行。</p>\n<p>1）取得“candy”进程的PID号。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -elf | grep candy</span><br></pre></td></tr></table></figure>\n<p>2）查看进程使用内存的信息,假设candy的PID号是1688。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/1688/status</span><br></pre></td></tr></table></figure>\n<p>在屏幕上输出的项目中有一项“VmData: xxxK”这一项就是进程使用堆的情况。</p>\n<p>3)打印时间戳和内存占用情况(时间间隔3秒)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;date;cat /proc/1688/status | grep VmData;sleep 3;echo &quot;######&quot;;date;echo &quot;######&quot;;cat /proc/1688/status | grep VmData</span><br></pre></td></tr></table></figure>\n<p>如果想查看系统UI进程是否有异常，就可以在UI进程启动后，通过运行类似于上面这种脚本，查看系统内存变化，进入某页面，然后不触发UI界面上的任何操作，分别在观察开始结束两个时间点，观察系统占用情况，如果伴随时间的变化，VmData的值变化明显，越来越大，基本可以切分出，这个页面内存泄露的可能性很大，然后在进行系统log代码级别的问题切分。</p>\n<p>有些时候，我们希望有一个声音提醒，可以在脚本结尾，加一句gst-launch播放音乐的命令，在等待一定时间后，通过播放音乐，进行提醒，另外也可以把结果直接通过管道输入到文件里。</p>\n<p>如何查看进程使用了那些文件句柄？</p>\n<p>有些功能需要频繁的打开关闭文件，如果程序执行的某个时间点，忽略了文件关闭的动作，特别是写实时log到文件里的功能，某一处没关闭该关的文件，造成log内容逻辑错乱。<br>{问题：在复杂的时序条件下，很难判断是哪个文件没关上。}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -anl /proc/1688/fd</span><br></pre></td></tr></table></figure>\n<p>通过这行命令就可以看到，当前的进程都使用了那些文件，其中也包括socket句柄。</p>\n<p>如何有兴趣，可以看看nginx进程的这个数据。</p>\n<p>注释：个人劳动成果，使用请注明，本文作者及出处链接，谢谢合作！</p>\n<p>测试</p>\n","text":"作者：糖果 【问题】寻找内存泄露，有时是一件困难的事情。代码的内存申请和释放动作不配对，或是在并发环境下，时序变换的异常，都会引起的内存泄露，即使从core dump回溯调用栈，也未必能找到快速内存的泄露点。 某些嵌入式系统，对制造方式有特殊的限制，不允许使用智能指针或是STL库...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DIV+CSS","uid":"21c5fcf79f3b2d72db7be480f2522eaa","slug":"old_topic/2016-09-17-47","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.755Z","comments":true,"path":"api/articles/old_topic/2016-09-17-47.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"【概要】选择Python做全栈解决方案，但是希望前段简单一些，可以向QML一样被重复的利用。选择用DIV+CSS控制页面的元素，一步步的构建社区。将JQuery融入进来。本篇太简单，其他内容之后带入。 [code] #div1 { font-style: italic; text...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"SWIFT之旅","uid":"588827ea99547898fdc61cb9e0f76523","slug":"old_topic/2016-09-17-53","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.756Z","comments":true,"path":"api/articles/old_topic/2016-09-17-53.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"对于一个新语言的第一个程序来说，比较传统的搞法是，在屏幕上，打印一行”hello,word” 。看看swift吧，一行语句就能搞定。 println(“Hello, world”)如果你之前玩过C或是Objective-C, Swift的这种语法你可能眼熟。这一行代码就完成了这个...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}