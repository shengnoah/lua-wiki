{"title":"输出响应体","uid":"9aa16bf014a426133910ab8bd80b8292","slug":"old_topic/2016-09-17-325","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.182Z","comments":true,"path":"api/articles/old_topic/2016-09-17-325.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h1 id=\"输出响应体\"><a class=\"markdownIt-Anchor\" href=\"#输出响应体\"></a> 输出响应体</h1>\n<p>HTTP响应报文分为三个部分：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>响应行</p>\n</li>\n<li class=\"lvl-3\">\n<p>响应头</p>\n</li>\n<li class=\"lvl-3\">\n<p>响应体</p>\n</li>\n</ol>\n<p><img src=\"../images/http_response_protocal.jpg\" alt=\"\" /></p>\n<p>对于 HTTP 响应体的输出，在 OpenResty 中调用 <code>ngx.say</code> 或 <code>ngx.print</code> 即可。经过查看官方 wiki ，这两者都是输出响应体，区别是 <code>ngx.say</code> 会对输出响应体多输出一个 <code>\\n</code> 。如果你用的是浏览器完成的功能调试，使用这两着是没有区别的。但是如果使用各种终端工具，这时候使用 <code>ngx.say</code> 明显就更方便了。</p>\n<h3 id=\"ngxsay-与-ngxprint-均为异步输出\"><a class=\"markdownIt-Anchor\" href=\"#ngxsay-与-ngxprint-均为异步输出\"></a> <code>ngx.say</code> 与 <code>ngx.print</code> 均为异步输出</h3>\n<p>首先需要明确一下的，是这两个函数都是异步输出的，也就是说当调用 <code>ngx.say</code> 后并不会立刻输出响应体。参考下面的例子：</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span>    <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">location</span> /test</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">content_by_lua_block</span></span> <span class=\"token punctuation\">&#123;</span>\n            ngx.say(\"hello\")\n            ngx.sleep(3)\n            ngx.say(\"the world\")\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">location</span> /test2</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">content_by_lua_block</span></span> <span class=\"token punctuation\">&#123;</span>\n            ngx.say(\"hello\")\n            ngx.flush() -- 显式的向客户端刷新响应输出\n            ngx.sleep(3)\n            ngx.say(\"the world\")\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>测试接口可以观察到， <code>/test</code> 响应内容实在触发请求 3s 后一起接收到响应体，而 <code>/test2</code> 则是先收到一个 <code>hello</code> 停顿 3s 后又接收到后面的 <code>the world</code>。</p>\n<p>再看下面的例子：</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span>    <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">lua_code_cache</span> <span class=\"token boolean\">off</span></span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">location</span> /test</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">content_by_lua_block</span></span> <span class=\"token punctuation\">&#123;</span>\n            ngx.say(string.rep(\"hello\", 1000))\n            ngx.sleep(3)\n            ngx.say(\"the world\")\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>执行测试，可以发现首先收到了所有的 “hello” ，停顿大约 3 秒后，接着又收到了 “the world” 。</p>\n<p>通过两个例子对比，可以知道，因为是异步输出，两个响应体的输出时机是 <em>不一样</em> 的。</p>\n<h3 id=\"如何优雅处理响应体过大的输出\"><a class=\"markdownIt-Anchor\" href=\"#如何优雅处理响应体过大的输出\"></a> 如何优雅处理响应体过大的输出</h3>\n<p>如果响应体比较小，这时候相对就比较随意。但是如果响应体过大（例如超过 2G），是不能直接调用 API 完成响应体输出的。响应体过大，分两种情况：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>输出内容本身体积很大，例如超过 2G 的文件下载</p>\n</li>\n<li class=\"lvl-3\">\n<p>输出内容本身是由各种碎片拼凑的，碎片数量庞大，例如应答数据是某地区所有人的姓名</p>\n</li>\n</ol>\n<p>第①个情况，要利用 HTTP 1.1 特性 CHUNKED 编码来完成，一起来看看 CHUNKED 编码格式样例：</p>\n<p><img src=\"../images/http_chunked.png\" alt=\"\" /></p>\n<p>可以利用 CHUNKED 格式，把一个大的响应体拆分成多个小的应答体，分批、有节制的响应给请求方。</p>\n<p>参考下面的例子：</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\">location <span class=\"token operator\">/</span><span class=\"token function\">test</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">content_by_lua_block</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">-- ngx.var.limit_rate = 1024*1024</span>\n        <span class=\"token keyword\">local</span> file<span class=\"token punctuation\">,</span> err <span class=\"token operator\">=</span> io<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span>ngx<span class=\"token punctuation\">.</span>config<span class=\"token punctuation\">.</span><span class=\"token function\">prefix</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">..</span> <span class=\"token string\">\"data.db\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"r\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> file <span class=\"token keyword\">then</span>\n            ngx<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>ngx<span class=\"token punctuation\">.</span>ERR<span class=\"token punctuation\">,</span> <span class=\"token string\">\"open file error:\"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n            ngx<span class=\"token punctuation\">.</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span>ngx<span class=\"token punctuation\">.</span>HTTP_SERVICE_UNAVAILABLE<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">end</span>\n\n        <span class=\"token keyword\">local</span> data\n        <span class=\"token keyword\">while</span> <span class=\"token keyword\">true</span> <span class=\"token keyword\">do</span>\n            data <span class=\"token operator\">=</span> file<span class=\"token punctuation\">:</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token keyword\">nil</span> <span class=\"token operator\">==</span> data <span class=\"token keyword\">then</span>\n                <span class=\"token keyword\">break</span>\n            <span class=\"token keyword\">end</span>\n            ngx<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n            ngx<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">true</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">end</span>\n        file<span class=\"token punctuation\">:</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>按块读取本地文件内容（每次 1KB），并以流式方式进行响应。笔者本地文件 <code>data.db</code> 大小是 4G ， Nginx 服务可以稳定运行，并维持内存占用在 几MB 范畴。</p>\n<p>注：其实 nginx 自带的静态文件解析能力已经非常好了。这里只是一个例子，实际中过大响应体都是后端服务生成的，为了演示环境相对封闭，所以这里选择本地文件。</p>\n<p>第②个情况，其实就是要利用 <code>ngx.print</code> 的特性了，它的输入参数可以是单个或多个字符串参数，也可以是 table 对象。</p>\n<p>参考官方示例代码：</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\"><span class=\"token keyword\">local</span> table <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token string\">\"hello, \"</span><span class=\"token punctuation\">,</span>\n     <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"world: \"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">true</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" or \"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">false</span><span class=\"token punctuation\">,</span>\n         <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\": \"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">nil</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">&#125;</span>\n <span class=\"token punctuation\">&#125;</span>\n ngx<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>table<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>将输出：</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\">hello<span class=\"token punctuation\">,</span> world<span class=\"token punctuation\">:</span> <span class=\"token keyword\">true</span> <span class=\"token keyword\">or</span> <span class=\"token keyword\">false</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">nil</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>也就是说当有非常多碎片数据时，没有必要一定连接成字符串后再进行输出。完全可以直接存放在 table 中，用数组的方式把这些碎片数据统一起来，直接调用 <code>ngx.print(table)</code> 即可。这种方式效率更高，并且更容易被优化。</p>\n","text":" 输出响应体 HTTP响应报文分为三个部分： 响应行 响应头 响应体 对于 HTTP 响应体的输出，在 OpenResty 中调用 ngx.say 或 ngx.print 即可。经过查看官方 wiki ，这两者都是输出响应体，区别是 ngx.say 会对输出响应体多输出一个 \\n...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E5%93%8D%E5%BA%94%E4%BD%93\"><span class=\"toc-text\"> 输出响应体</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ngxsay-%E4%B8%8E-ngxprint-%E5%9D%87%E4%B8%BA%E5%BC%82%E6%AD%A5%E8%BE%93%E5%87%BA\"><span class=\"toc-text\"> ngx.say 与 ngx.print 均为异步输出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94%E4%BD%93%E8%BF%87%E5%A4%A7%E7%9A%84%E8%BE%93%E5%87%BA\"><span class=\"toc-text\"> 如何优雅处理响应体过大的输出</span></a></li></ol></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"防止 SQL 注入","uid":"8da56c97a3037418bdb94143c7040828","slug":"old_topic/2016-09-17-324","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.158Z","comments":true,"path":"api/articles/old_topic/2016-09-17-324.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 防止 SQL 注入 所谓 SQL 注入，就是通过把 SQL 命令插入到 Web 表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。具体来说，它是利用现有应用程序，将（恶意）的 SQL 命令注入到后台数据库引擎执行的能力，它可以通过在 Web ...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"编码为array还是object","uid":"dcced3e4781903088f00b4d841a17520","slug":"old_topic/2016-09-17-326","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.220Z","comments":true,"path":"api/articles/old_topic/2016-09-17-326.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"编码为array还是object 首先大家请看这段源码： -- http://www.kyne.com.au/~mark/software/lua-cjson.php -- version: 2.1 devel local json = require(\"cjson\") ngx....","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}