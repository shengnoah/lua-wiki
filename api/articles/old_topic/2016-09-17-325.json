{"title":"输出响应体","uid":"9aa16bf014a426133910ab8bd80b8292","slug":"old_topic/2016-09-17-325","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.182Z","comments":true,"path":"api/articles/old_topic/2016-09-17-325.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"content":"<h1>输出响应体</h1>\n<p>HTTP响应报文分为三个部分：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>响应行</p>\n</li>\n<li class=\"lvl-3\">\n<p>响应头</p>\n</li>\n<li class=\"lvl-3\">\n<p>响应体</p>\n</li>\n</ol>\n<p><img src=\"../images/http_response_protocal.jpg\" alt=\"\"></p>\n<p>对于 HTTP 响应体的输出，在 OpenResty 中调用 <code>ngx.say</code> 或 <code>ngx.print</code> 即可。经过查看官方 wiki ，这两者都是输出响应体，区别是 <code>ngx.say</code> 会对输出响应体多输出一个 <code>\\n</code> 。如果你用的是浏览器完成的功能调试，使用这两着是没有区别的。但是如果使用各种终端工具，这时候使用 <code>ngx.say</code> 明显就更方便了。</p>\n<h3 id=\"ngx-say-与-ngx-print-均为异步输出\"><code>ngx.say</code> 与 <code>ngx.print</code> 均为异步输出</h3>\n<p>首先需要明确一下的，是这两个函数都是异步输出的，也就是说当调用 <code>ngx.say</code> 后并不会立刻输出响应体。参考下面的例子：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span>    <span class=\"number\">80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"section\">location</span> /test &#123;</span><br><span class=\"line\">        <span class=\"section\">content_by_lua_block</span> &#123;</span><br><span class=\"line\">            ngx.say(&quot;hello&quot;)</span><br><span class=\"line\">            ngx.sleep(3)</span><br><span class=\"line\">            ngx.say(&quot;<span class=\"attribute\">the</span> world<span class=\"string\">&quot;)</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    location /test2 &#123;</span></span><br><span class=\"line\"><span class=\"string\">        content_by_lua_block &#123;</span></span><br><span class=\"line\"><span class=\"string\">            ngx.say(&quot;</span>hello<span class=\"string\">&quot;)</span></span><br><span class=\"line\"><span class=\"string\">            ngx.flush() -- 显式的向客户端刷新响应输出</span></span><br><span class=\"line\"><span class=\"string\">            ngx.sleep(3)</span></span><br><span class=\"line\"><span class=\"string\">            ngx.say(&quot;</span>the world<span class=\"string\">&quot;)</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>测试接口可以观察到， <code>/test</code> 响应内容实在触发请求 3s 后一起接收到响应体，而 <code>/test2</code> 则是先收到一个 <code>hello</code> 停顿 3s 后又接收到后面的 <code>the world</code>。</p>\n<p>再看下面的例子：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span>    <span class=\"number\">80</span>;</span><br><span class=\"line\">    <span class=\"attribute\">lua_code_cache</span> <span class=\"literal\">off</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"section\">location</span> /test &#123;</span><br><span class=\"line\">        <span class=\"section\">content_by_lua_block</span> &#123;</span><br><span class=\"line\">            ngx.say(string.rep(&quot;hello&quot;, 1000))</span><br><span class=\"line\">            ngx.sleep(3)</span><br><span class=\"line\">            ngx.say(&quot;<span class=\"attribute\">the</span> world<span class=\"string\">&quot;)</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>执行测试，可以发现首先收到了所有的 “hello” ，停顿大约 3 秒后，接着又收到了 “the world” 。</p>\n<p>通过两个例子对比，可以知道，因为是异步输出，两个响应体的输出时机是 <em>不一样</em> 的。</p>\n<h3 id=\"如何优雅处理响应体过大的输出\">如何优雅处理响应体过大的输出</h3>\n<p>如果响应体比较小，这时候相对就比较随意。但是如果响应体过大（例如超过 2G），是不能直接调用 API 完成响应体输出的。响应体过大，分两种情况：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>输出内容本身体积很大，例如超过 2G 的文件下载</p>\n</li>\n<li class=\"lvl-3\">\n<p>输出内容本身是由各种碎片拼凑的，碎片数量庞大，例如应答数据是某地区所有人的姓名</p>\n</li>\n</ol>\n<p>第①个情况，要利用 HTTP 1.1 特性 CHUNKED 编码来完成，一起来看看 CHUNKED 编码格式样例：</p>\n<p><img src=\"../images/http_chunked.png\" alt=\"\"></p>\n<p>可以利用 CHUNKED 格式，把一个大的响应体拆分成多个小的应答体，分批、有节制的响应给请求方。</p>\n<p>参考下面的例子：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /test &#123;</span><br><span class=\"line\">    content_by_lua_block &#123;</span><br><span class=\"line\">        <span class=\"comment\">-- ngx.var.limit_rate = 1024*1024</span></span><br><span class=\"line\">        <span class=\"keyword\">local</span> file, err = <span class=\"built_in\">io</span>.<span class=\"built_in\">open</span>(ngx.<span class=\"built_in\">config</span>.prefix() .. <span class=\"string\">&quot;data.db&quot;</span>,<span class=\"string\">&quot;r&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> file <span class=\"keyword\">then</span></span><br><span class=\"line\">            ngx.<span class=\"built_in\">log</span>(ngx.ERR, <span class=\"string\">&quot;open file error:&quot;</span>, err)</span><br><span class=\"line\">            ngx.<span class=\"built_in\">exit</span>(ngx.HTTP_SERVICE_UNAVAILABLE)</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">local</span> data</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">true</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">            data = file:<span class=\"built_in\">read</span>(<span class=\"number\">1024</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"literal\">nil</span> == data <span class=\"keyword\">then</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">            ngx.<span class=\"built_in\">print</span>(data)</span><br><span class=\"line\">            ngx.<span class=\"built_in\">flush</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        file:<span class=\"built_in\">close</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>按块读取本地文件内容（每次 1KB），并以流式方式进行响应。笔者本地文件 <code>data.db</code> 大小是 4G ， Nginx 服务可以稳定运行，并维持内存占用在 几MB 范畴。</p>\n<p>注：其实 nginx 自带的静态文件解析能力已经非常好了。这里只是一个例子，实际中过大响应体都是后端服务生成的，为了演示环境相对封闭，所以这里选择本地文件。</p>\n<p>第②个情况，其实就是要利用 <code>ngx.print</code> 的特性了，它的输入参数可以是单个或多个字符串参数，也可以是 table 对象。</p>\n<p>参考官方示例代码：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> <span class=\"built_in\">table</span> = &#123;</span><br><span class=\"line\">     <span class=\"string\">&quot;hello, &quot;</span>,</span><br><span class=\"line\">     &#123;<span class=\"string\">&quot;world: &quot;</span>, <span class=\"literal\">true</span>, <span class=\"string\">&quot; or &quot;</span>, <span class=\"literal\">false</span>,</span><br><span class=\"line\">         &#123;<span class=\"string\">&quot;: &quot;</span>, <span class=\"literal\">nil</span>&#125;&#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> ngx.<span class=\"built_in\">print</span>(<span class=\"built_in\">table</span>)</span><br></pre></td></tr></table></figure>\n<p>将输出：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello, world: <span class=\"literal\">true</span> <span class=\"keyword\">or</span> <span class=\"literal\">false</span>: <span class=\"literal\">nil</span></span><br></pre></td></tr></table></figure>\n<p>也就是说当有非常多碎片数据时，没有必要一定连接成字符串后再进行输出。完全可以直接存放在 table 中，用数组的方式把这些碎片数据统一起来，直接调用 <code>ngx.print(table)</code> 即可。这种方式效率更高，并且更容易被优化。</p>\n","text":"输出响应体 HTTP响应报文分为三个部分： 响应行 响应头 响应体 对于 HTTP 响应体的输出，在 OpenResty 中调用 ngx.say 或 ngx.print 即可。经过查看官方 wiki ，这两者都是输出响应体，区别是 ngx.say 会对输出响应体多输出一个 \\n ...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\">输出响应体</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ngx-say-%E4%B8%8E-ngx-print-%E5%9D%87%E4%B8%BA%E5%BC%82%E6%AD%A5%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">ngx.say 与 ngx.print 均为异步输出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94%E4%BD%93%E8%BF%87%E5%A4%A7%E7%9A%84%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">如何优雅处理响应体过大的输出</span></a></li></ol></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"防止 SQL 注入","uid":"8da56c97a3037418bdb94143c7040828","slug":"old_topic/2016-09-17-324","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.158Z","comments":true,"path":"api/articles/old_topic/2016-09-17-324.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"防止 SQL 注入 所谓 SQL 注入，就是通过把 SQL 命令插入到 Web 表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。具体来说，它是利用现有应用程序，将（恶意）的 SQL 命令注入到后台数据库引擎执行的能力，它可以通过在 Web 表...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"跨平台的库选择","uid":"9292b5d7db49cf3a15a4dacf7bf55d0e","slug":"old_topic/2016-09-17-327","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.226Z","comments":true,"path":"api/articles/old_topic/2016-09-17-327.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"跨平台的库选择 大家看过上面三个json的例子就发现，都是围绕cjson库的。原因也比较简单，就是cjson是默认绑定到openresty上的。很多开发喜欢 windows 系统，可以选择 dkjson（编解码效率没有cjson快，优势是纯Lua，完美跨任何平台）。 并且我们的代...","link":"","photos":[],"count_time":{"symbolsCount":770,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}