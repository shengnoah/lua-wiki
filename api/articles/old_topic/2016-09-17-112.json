{"title":"《Lua游戏AI开发指南 --- C/C++中调用Lua函数》","uid":"878333f17299242d2af5675db3efb934","slug":"old_topic/2016-09-17-112","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.162Z","comments":true,"path":"api/articles/old_topic/2016-09-17-112.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>C/C++ calling Lua functions</p>\n<p>The sandbox hooks into the Lua script through three predefined global Lua functions:</p>\n<p>Sandbox_Initialize, Sandbox_Cleanup, and Sandbox_Update. When the sandbox is first</p>\n<p>attached to the corresponding Lua script, the Sandbox_Initialize function is called. Each</p>\n<p>update tick of the sandbox will also invoke the Sandbox_Update function in the Lua script.</p>\n<p>When the sandbox is being destroyed or reloaded, the Sandbox_Cleanup function will</p>\n<p>have an opportunity to perform any script-side cleanup.</p>\n<p>In order for C++ to call a Lua function, the function must be retrieved from Lua and</p>\n<p>pushed onto the stack. Function parameters are then pushed on top of the stack, followed</p>\n<p>by a call to lua_pcall, which executes the Lua function. The lua_pcall function</p>\n<p>specifies the number of arguments the Lua function receives, the number of expected</p>\n<p>return values, and specifies how to handle errors:</p>\n<p>lua.h</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nint lua_pcall(\n\nlua_State* luaVM, int numberOfArguments,\n\nint numberOfResults, int errorFunction);\n\nFor example, the Agent_Initialize Lua script function is called in the AgentUtilities\n\nclass in the following manner:\n\nAgent.lua\n\nfunction Agent_Initialize(agent)\n\n...\n\nend<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>First, the Lua function is retrieved from Lua by name and pushed onto the stack. Next, the</p>\n<p>agent itself is pushed as the only parameter to the Agent_Initialize function. Lastly,</p>\n<p>lua_pcall executes the function and checks whether it succeeded successfully; otherwise,</p>\n<p>an assertion is raised by the sandbox:</p>\n<p>AgentUtilities.cpp</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void AgentUtilities::Initialize(Agent* const agent)\n\n&#123;\n\n&#x2F;&#x2F; Retrieves the lua virtual machine the agent script is\n\n&#x2F;&#x2F; running on. lua_State* luaVM &#x3D; agent-&gt;GetLuaVM();\n\nlua_getglobal(luaVM, &quot;Agent_Initialize&quot;);\n\n&#x2F;&#x2F; Agent_Initialize accepts one parameter, an Agent.\n\nAgentUtilities::PushAgent(luaVM, agent);\n\n&#x2F;&#x2F; Execute the Agent_Initialize function and check for\n\n&#x2F;&#x2F; success.\n\nif (lua_pcall(luaVM, 1, 0, 0) !&#x3D; 0)\n\n&#123;\n\nassert(false);\n\n&#125;\n\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>“C/C++中调用Lua函数”</p>\n<p>Lua脚本的沙盒钩子是通过预先定义了三个全局的Lua函数：</p>\n<p>1.Sandbox_Initalize。</p>\n<p>2.Sandboxk_Cleanup。</p>\n<p>3.Sandbox_Update。</p>\n<p>当沙盒首次载入对应的Lua脚本，Sandbox_Initialize函数被调用。每次有所更新，沙盒调用脚本中内Sandbox_Update函数。当沙盒初建，或重新载入时，Sanbox_Cleanup函数，有机会执行任何脚本端的清理工作。</p>\n<p>C++调用Lua函数，函数要从Lua中取得，并入栈，其参数要入栈顶，之后，用lua_pacall执行对应Lua函数。lua_pcall指定Lua函数接受的参数个数，返回值个数和容错处理。</p>\n<p>lua.h</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int lua_pcall(lua_State* luaVM, int numberOfArguments,\n\nint numberOfResults, int errorFunction);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>例如，“Agent_Initialize”脚本函数，被在“AgentUtilities”类中调用，脚本如下：</p>\n<p>Agent.lua</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function Agent_Initialize(agent)\n\n...\n\nend<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>首先，用函数名取得Lua函数，并入栈。</p>\n<p>然后，&quot;agen&quot;作为唯一参数，赋给Agent_Initialize函数。</p>\n<p>最后，用lua_pcall执行函数，并验证是否成功；</p>\n<p>其他情况，会抛出一个沙盒的失败断言“assert(false)”。</p>\n<p>AgentUtilities.cpp</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void AgentUtilities::Initialize(Agent* const agent)\n\n&#123;\n\n“取得一个agent脚本的运行虚拟机。”\n\n&#x2F;&#x2F; Retrieves the lua virtual machine the agent script is running on. \n\nlua_State* luaVM &#x3D; agent-&gt;GetLuaVM();\n\nlua_getglobal(luaVM, &quot;Agent_Initialize&quot;);\n\n&#x2F;&#x2F; Agent_Initialize accepts one parameter, an Agent.\n\n“Agent_Initialize函数接收的参数，“agent”。”\n\nAgentUtilities::PushAgent(luaVM, agent);\n\n“执行Agent_Initialize函数，并验证是否成功。”\n\n&#x2F;&#x2F; Execute the Agent_Initialize function and check for success.\n\nif (lua_pcall(luaVM, 1, 0, 0) !&#x3D; 0) \n\n&#123;\n\nassert(false);\n\n&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>本文译自David Young《Lua游戏AI开发指南》一书。</p>\n<p>翻译：糖果</p>\n<p>PS:转载到其它平台请注明作者姓名及原文链接。</p>\n<p>别动我代码可以不<br />\n<img src=\"http://wx1.sinaimg.cn/mw690/805c3d47ly1fdemxx4zwmg20ak05xu0z.gif\" alt=\"别动我代码可以不\" /></p>\n","text":"C/C++ calling Lua functions The sandbox hooks into the Lua script through three predefined global Lua functions: Sandbox_Initialize, Sandbox...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"《Lua游戏AI开发指南 --- Lua调用C/C++函数》","uid":"e724a88ffa1659f5de4d93477c189f2b","slug":"old_topic/2016-09-17-111","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.230Z","comments":true,"path":"api/articles/old_topic/2016-09-17-111.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"作者：糖果 Exposing C++ functions to Lua takes place through a process called function binding. Any bound functions exposed to Lua become accessi...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Openresty的Lua定时器（计划任务）","uid":"1e5b544e537ce9e8013f8d5d976629a9","slug":"old_topic/2016-09-17-114","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.214Z","comments":true,"path":"api/articles/old_topic/2016-09-17-114.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"在系统中有一类需求是：周期性的执行某些任务，利用定时的timer去实现这种操作。 Openresty为Lua提供了这种机制实现的API，通过设定timer来完成这种类似计划任务功能。 下面，就是一个典型的Openresty的timer API的使用例子： 实现思路是，通过一个ti...","link":"","photos":[],"count_time":{"symbolsCount":744,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}