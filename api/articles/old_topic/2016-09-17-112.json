{"title":"《Lua游戏AI开发指南 --- C/C++中调用Lua函数》","uid":"878333f17299242d2af5675db3efb934","slug":"old_topic/2016-09-17-112","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.162Z","comments":true,"path":"api/articles/old_topic/2016-09-17-112.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"content":"<p>C/C++ calling Lua functions</p>\n<p>The sandbox hooks into the Lua script through three predefined global Lua functions:</p>\n<p>Sandbox_Initialize, Sandbox_Cleanup, and Sandbox_Update. When the sandbox is first</p>\n<p>attached to the corresponding Lua script, the Sandbox_Initialize function is called. Each</p>\n<p>update tick of the sandbox will also invoke the Sandbox_Update function in the Lua script.</p>\n<p>When the sandbox is being destroyed or reloaded, the Sandbox_Cleanup function will</p>\n<p>have an opportunity to perform any script-side cleanup.</p>\n<p>In order for C++ to call a Lua function, the function must be retrieved from Lua and</p>\n<p>pushed onto the stack. Function parameters are then pushed on top of the stack, followed</p>\n<p>by a call to lua_pcall, which executes the Lua function. The lua_pcall function</p>\n<p>specifies the number of arguments the Lua function receives, the number of expected</p>\n<p>return values, and specifies how to handle errors:</p>\n<p>lua.h</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int lua_pcall(</span><br><span class=\"line\"></span><br><span class=\"line\">lua_State* luaVM, int numberOfArguments,</span><br><span class=\"line\"></span><br><span class=\"line\">int numberOfResults, int errorFunction);</span><br><span class=\"line\"></span><br><span class=\"line\">For example, the Agent_Initialize Lua script function is called in the AgentUtilities</span><br><span class=\"line\"></span><br><span class=\"line\">class in the following manner:</span><br><span class=\"line\"></span><br><span class=\"line\">Agent.lua</span><br><span class=\"line\"></span><br><span class=\"line\">function Agent_Initialize(agent)</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>First, the Lua function is retrieved from Lua by name and pushed onto the stack. Next, the</p>\n<p>agent itself is pushed as the only parameter to the Agent_Initialize function. Lastly,</p>\n<p>lua_pcall executes the function and checks whether it succeeded successfully; otherwise,</p>\n<p>an assertion is raised by the sandbox:</p>\n<p>AgentUtilities.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void AgentUtilities::Initialize(Agent* const agent)</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">// Retrieves the lua virtual machine the agent script is</span><br><span class=\"line\"></span><br><span class=\"line\">// running on. lua_State* luaVM = agent-&gt;GetLuaVM();</span><br><span class=\"line\"></span><br><span class=\"line\">lua_getglobal(luaVM, &quot;Agent_Initialize&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Agent_Initialize accepts one parameter, an Agent.</span><br><span class=\"line\"></span><br><span class=\"line\">AgentUtilities::PushAgent(luaVM, agent);</span><br><span class=\"line\"></span><br><span class=\"line\">// Execute the Agent_Initialize function and check for</span><br><span class=\"line\"></span><br><span class=\"line\">// success.</span><br><span class=\"line\"></span><br><span class=\"line\">if (lua_pcall(luaVM, 1, 0, 0) != 0)</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">assert(false);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>“C/C++中调用Lua函数”</p>\n<p>Lua脚本的沙盒钩子是通过预先定义了三个全局的Lua函数：</p>\n<p>1.Sandbox_Initalize。</p>\n<p>2.Sandboxk_Cleanup。</p>\n<p>3.Sandbox_Update。</p>\n<p>当沙盒首次载入对应的Lua脚本，Sandbox_Initialize函数被调用。每次有所更新，沙盒调用脚本中内Sandbox_Update函数。当沙盒初建，或重新载入时，Sanbox_Cleanup函数，有机会执行任何脚本端的清理工作。</p>\n<p>C++调用Lua函数，函数要从Lua中取得，并入栈，其参数要入栈顶，之后，用lua_pacall执行对应Lua函数。lua_pcall指定Lua函数接受的参数个数，返回值个数和容错处理。</p>\n<p>lua.h</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int lua_pcall(lua_State* luaVM, int numberOfArguments,</span><br><span class=\"line\"></span><br><span class=\"line\">int numberOfResults, int errorFunction);</span><br></pre></td></tr></table></figure>\n<p>例如，“Agent_Initialize”脚本函数，被在“AgentUtilities”类中调用，脚本如下：</p>\n<p>Agent.lua</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Agent_Initialize(agent)</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>首先，用函数名取得Lua函数，并入栈。</p>\n<p>然后，&quot;agen&quot;作为唯一参数，赋给Agent_Initialize函数。</p>\n<p>最后，用lua_pcall执行函数，并验证是否成功；</p>\n<p>其他情况，会抛出一个沙盒的失败断言“assert(false)”。</p>\n<p>AgentUtilities.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void AgentUtilities::Initialize(Agent* const agent)</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">“取得一个agent脚本的运行虚拟机。”</span><br><span class=\"line\"></span><br><span class=\"line\">// Retrieves the lua virtual machine the agent script is running on. </span><br><span class=\"line\"></span><br><span class=\"line\">lua_State* luaVM = agent-&gt;GetLuaVM();</span><br><span class=\"line\"></span><br><span class=\"line\">lua_getglobal(luaVM, &quot;Agent_Initialize&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Agent_Initialize accepts one parameter, an Agent.</span><br><span class=\"line\"></span><br><span class=\"line\">“Agent_Initialize函数接收的参数，“agent”。”</span><br><span class=\"line\"></span><br><span class=\"line\">AgentUtilities::PushAgent(luaVM, agent);</span><br><span class=\"line\"></span><br><span class=\"line\">“执行Agent_Initialize函数，并验证是否成功。”</span><br><span class=\"line\"></span><br><span class=\"line\">// Execute the Agent_Initialize function and check for success.</span><br><span class=\"line\"></span><br><span class=\"line\">if (lua_pcall(luaVM, 1, 0, 0) != 0) </span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">assert(false);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本文译自David Young《Lua游戏AI开发指南》一书。</p>\n<p>翻译：糖果</p>\n<p>PS:转载到其它平台请注明作者姓名及原文链接。</p>\n<p>别动我代码可以不<br>\n<img src=\"http://wx1.sinaimg.cn/mw690/805c3d47ly1fdemxx4zwmg20ak05xu0z.gif\" alt=\"别动我代码可以不\"></p>\n","text":"C/C++ calling Lua functions The sandbox hooks into the Lua script through three predefined global Lua functions: Sandbox_Initialize, Sandbox...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"WEB IDE环境运行Lua网页应用","uid":"94c79648b27c71adf58b46e7d0e952fe","slug":"old_topic/2016-09-17-113","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.170Z","comments":true,"path":"api/articles/old_topic/2016-09-17-113.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者：糖果 如Python和Ruby一样，Lua也可以创建WEB应用，之前提过的一个Lua WEB框架 这次就在WEB IDE环境下，部署一下LuaWEB的运行环境，并创建一个Lua WEB应用。 第一步：安装WEB服务器， Openresty。 1).下载安装包 1wget h...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"配置VIM的插件补全功能---(在WEB IDE中)","uid":"41d81acfc6ba0ec970d542063973ecdd","slug":"old_topic/2016-09-17-116","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.149Z","comments":true,"path":"api/articles/old_topic/2016-09-17-116.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"VIM提供了很多的第三方插件，足可以把VIM武装成强大的开发IDE，这次抛砖引玉，介绍一下在coding的WEB IDE环境下，家法配置VIM插件，补全插件。 1.进入VIM管理目录。 1cd ~/.vim 2.创建工作目录。 1mkdir neo 3.下载插件。 123wget...","link":"","photos":[],"count_time":{"symbolsCount":475,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}