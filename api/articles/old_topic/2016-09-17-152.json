{"title":"LUA与STOMP协议","uid":"9aeff2cf84352e0facabfc6256b648d7","slug":"old_topic/2016-09-17-152","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.171Z","comments":true,"path":"api/articles/old_topic/2016-09-17-152.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>作者：糖果</p>\n<p>STOMP协议是一种简单的消息文本协议。协义本身简单明了，用消息头定义和消息体数据传输。</p>\n<p>RabbitMQ做为一种队列中间件，提供了STOMP协议的支持，我们可以通过STOMP协议向队列发送消息。下面的例子中，我们将使用LUA程序向RabbitMQ发送消息， 通过Python程序读取消息。</p>\n<p>send.lua文件</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> client = <span class=\"built_in\">require</span> <span class=\"string\">&quot;stomp&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> mq, err = client:new()</span><br><span class=\"line\"><span class=\"keyword\">local</span> ok, err = mq:connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">61613</span>)</span><br><span class=\"line\"><span class=\"keyword\">local</span> msg = <span class=\"string\">&quot;say hi!&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> headers = &#123;&#125;</span><br><span class=\"line\">headers[<span class=\"string\">&quot;destination&quot;</span>] = <span class=\"string\">&quot;/queue/test&quot;</span></span><br><span class=\"line\">headers[<span class=\"string\">&quot;app-id&quot;</span>] = <span class=\"string\">&quot;APP&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> ok, err = mq:send(info_json, headers)</span><br></pre></td></tr></table></figure>\n<p>对上面的代码说明一下：</p>\n<p>连接时候RabbitMQ的IP是本机的127.0.0.1， STOMP协议的服务的端口是默认的61613。</p>\n<p>在headers的头定义部分，指明了我们发送信息的目的地“/queue/test“名字为Test的队列。</p>\n<p>其实可以深入到STOMP的LUA的实现内部，仔细研究一下是如何实现，如何直接通过sock，发送数据帧到服务器，可以作为独立的章节。</p>\n<p>与LUA不同，Python对STOMP协议支持的比较好，不需要甄别第三库，然后再选择使用。用pythonstomp就好。</p>\n<p>receive.py文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> stomp</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyListener</span>(stomp.ConnectionListener):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">on_error</span>(<span class=\"params\">self, headers, message</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;received an error %s&#x27;</span> % message)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">on_message</span>(<span class=\"params\">self, headers, message</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k,v <span class=\"keyword\">in</span> headers.iteritems():</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;header: key %s , value %s&#x27;</span> %(k,v))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;received message\\n %s&#x27;</span>% message)</span><br><span class=\"line\">conn=stomp.Connection([(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>,<span class=\"number\">61613</span>)])</span><br><span class=\"line\">conn.set_listener(<span class=\"string\">&#x27;somename&#x27;</span>,MyListener())</span><br><span class=\"line\">conn.start()</span><br><span class=\"line\">conn.connect(wait=<span class=\"literal\">True</span>)</span><br><span class=\"line\">message=<span class=\"string\">&#x27;say hi!&#x27;</span></span><br><span class=\"line\">dest = <span class=\"string\">&#x27;/queue/test&#x27;</span></span><br><span class=\"line\">headers=&#123;<span class=\"string\">&#x27;seltype&#x27;</span>:<span class=\"string\">&#x27;mandi-age-to-man&#x27;</span>,<span class=\"string\">&#x27;type&#x27;</span>:<span class=\"string\">&#x27;textMessage&#x27;</span>,<span class=\"string\">&#x27;MessageNumber&#x27;</span>:random.randint(<span class=\"number\">0</span>,<span class=\"number\">65535</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">metadata = [</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"> info_json = json.dumps(metadata)</span><br><span class=\"line\">conn.send(body=info_json, destination=<span class=\"string\">&#x27;/queue/test&#x27;</span>)</span><br><span class=\"line\">conn.disconnect()</span><br></pre></td></tr></table></figure>\n<p>接受程序和发送程序的主要流程区别是：要在接受端注册监听回调程序。</p>\n<p>上面的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn.set_listener(<span class=\"string\">&#x27;somename&#x27;</span>,MyListener())</span><br><span class=\"line\">conn.start()</span><br></pre></td></tr></table></figure>\n<p>这两行代码就是注册监听类，在队列上有消息的时候，就会调用监听回调。</p>\n<p>on_message。发生错误的时候调用。on_error函数。</p>\n<p>具体的实现不完全列出来，针对一般的STOMP连接过程，列出”连接“和</p>\n<p>发送的”消息包”的数据结构，结构采用的是LUA语法，table类型定义的。</p>\n<p>共计二帧的数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connect_frame = &#123;</span><br><span class=\"line\">  &quot;CONNECT\\n&quot;,</span><br><span class=\"line\">  &quot;accept-version:1.2\\n&quot;,</span><br><span class=\"line\">  &quot;login:guest\\n&quot;,</span><br><span class=\"line\">  &quot;passcode:guest\\n&quot;,</span><br><span class=\"line\">  &quot;host:/\\n&quot;,</span><br><span class=\"line\">  &quot;\\n\\n&quot;,</span><br><span class=\"line\">  &quot;\\0&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">send_frame = &#123;</span><br><span class=\"line\">  &quot;SEND\\n&quot;,</span><br><span class=\"line\">  &quot;destination:/queue/test\\n&quot;,</span><br><span class=\"line\">  &quot;app-id:APP\\n&quot;,</span><br><span class=\"line\">  &quot;\\n&quot;,</span><br><span class=\"line\">  &quot;say hi!\\n&quot;,</span><br><span class=\"line\">  &quot;\\0&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>包体的第一个字段“CONNECT,SEND”都是协议的命令，剩下的是说明字段。</p>\n<p>文字不能把所有的问题和协议都描述清楚，可参考以下网站：</p>\n<p><a href=\"http://stomp.github.io/stomp-specification-1.1.html\">http://stomp.github.io/stomp-specification-1.1.html</a></p>\n<p>PS:转载到其它平台请注明作者姓名及原文链接，请勿用于商业用途。</p>\n<p><a href=\"http://www.lua.ren/topic/133/lua-faq\" target=\"_blank\">点击查看Lua FAQ</a></p>\n","text":"作者：糖果 STOMP协议是一种简单的消息文本协议。协义本身简单明了，用消息头定义和消息体数据传输。 RabbitMQ做为一种队列中间件，提供了STOMP协议的支持，我们可以通过STOMP协议向队列发送消息。下面的例子中，我们将使用LUA程序向RabbitMQ发送消息， 通过Py...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua的转义符号“%”","uid":"40c3b450ff372f1daa99baee2e917fc2","slug":"old_topic/2016-09-17-150","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.232Z","comments":true,"path":"api/articles/old_topic/2016-09-17-150.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者：糖果 Lua有些符号在用户字符替换的时候，可能会发生转义。今天群里的一位小伙伴，就需要到类似的问题，比如说要将字符串中的’（‘变成’['。 解答问题的伙伴给出如下代码： 123a = &#x27;123.(456)&#x27;c = string.gsub(a, &#x27...","link":"","photos":[],"count_time":{"symbolsCount":287,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"LUA的WEB开发框架Vanilla","uid":"087f4f77da99a0fec1375818d3495ed6","slug":"old_topic/2016-09-17-153","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.163Z","comments":true,"path":"api/articles/old_topic/2016-09-17-153.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"text":"作者：糖果 图片：vanilla_logo.jpg 这次我们介绍的框架和以往有些不同，最大的不同是，这是介绍的是一个国产Openresty Lua WEB框架，名字叫做Vanilia 我们先简单的安装，和创建一个建工的工程，然后分析一下项目的源码。 我们假定用户用系统是cento...","link":"","photos":[],"count_time":{"symbolsCount":552,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}