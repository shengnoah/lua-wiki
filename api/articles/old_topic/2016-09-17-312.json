{"title":"日志输出","uid":"7971c98c6c54521c1f721d0c7bf2b182","slug":"old_topic/2016-09-17-312","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.217Z","comments":true,"path":"api/articles/old_topic/2016-09-17-312.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<h1>日志输出</h1>\n<p>你如何测试和调试你的代码呢？Lua 的两个主力作者是这样回复的：</p>\n<p>Luiz Henrique de Figueiredo：我主要是一块一块的构建，分块测试。我很少使用调试器。即使用调试器，也只是调试 C 代码。我从不用调试器调试 Lua 代码。对于 Lua 来说，在适当的位置放几条打印语句通常就可以胜任了。</p>\n<p>Roberto Ierusalimschy：我差不多也是这样。当我使用调试器时，通常只是用来查找代码在哪里崩溃了。对于 C 代码，有个像 Valgrind 或者 Purify 这样的工具是必要的。</p>\n<p>摘自《编程之魂 – 采访 Lua 发明人的一篇文章》。</p>\n<p>由此可见掌握日志输出是多么重要，下至入门同学，上至 Lua 作者，使用日志输出来确定问题，是很必要的基本手段。</p>\n<h3 id=\"标准日志输出\">标准日志输出</h3>\n<p>OpenResty 的标准日志输出原句为 <code>ngx.log(log_level, ...)</code> ，几乎可以在任何 ngx_lua 阶段进行日志的输出。</p>\n<p>请看下面的示例：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#user  nobody;</span></span><br><span class=\"line\"><span class=\"attribute\">worker_processes</span>  <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">error_log</span>  logs/<span class=\"literal\">error</span>.log <span class=\"literal\">error</span>;    <span class=\"comment\"># 日志级别</span></span><br><span class=\"line\"><span class=\"comment\">#pid        logs/nginx.pid;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">events</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">worker_connections</span>  <span class=\"number\">1024</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">http</span> &#123;</span><br><span class=\"line\">    <span class=\"section\">server</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">listen</span>    <span class=\"number\">80</span>;</span><br><span class=\"line\">        <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">            <span class=\"section\">content_by_lua_block</span> &#123;</span><br><span class=\"line\">                <span class=\"attribute\">local</span> num = <span class=\"number\">55</span></span><br><span class=\"line\">                local str = <span class=\"string\">&quot;string&quot;</span></span><br><span class=\"line\">                local obj</span><br><span class=\"line\">                ngx.log(ngx.ERR, <span class=\"string\">&quot;num:&quot;</span>, num)</span><br><span class=\"line\">                ngx.log(ngx.INFO, <span class=\"string\">&quot; string:&quot;</span>, str)</span><br><span class=\"line\">                print([[i am print]])</span><br><span class=\"line\">                ngx.log(ngx.ERR, <span class=\"string\">&quot; object:&quot;</span>, obj)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>访问网页，生成日志（logs/error.log 文件）结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016/01/22 16:43:34 [error] 61610#0: *10 [lua] content_by_lua(nginx.conf:26):5:</span><br><span class=\"line\"> num:55, client: 127.0.0.1, server: , request: &quot;GET /hello HTTP/1.1&quot;,</span><br><span class=\"line\"> host: &quot;127.0.0.1&quot;</span><br><span class=\"line\">2016/01/22 16:43:34 [error] 61610#0: *10 [lua] content_by_lua(nginx.conf:26):7:</span><br><span class=\"line\"> object:nil, client: 127.0.0.1, server: , request: &quot;GET /hello HTTP/1.1&quot;,</span><br><span class=\"line\"> host: &quot;127.0.0.1&quot;</span><br></pre></td></tr></table></figure>\n<p>大家可以在单行日志中获取很多有用的信息，例如：时间、日志级别、请求ID、错误代码位置、内容、客户端 IP 、请求参数等等，这些信息都是环境信息，可以用来辅助完成更多其他操作。当然我们也可以根据自己需要定义日志格式，具体可以参考 nginx 的 <a href=\"http://nginx.org/en/docs/http/ngx_http_log_module.html#log_format\">log_format</a> 章节。</p>\n<p>细心的读者发现了，中间的两行日志哪里去了？这里不卖关子，其实是日志输出级别的原因。上面的例子，日志输出级别使用的 error，只有等于或大于这个级别的日志才会输出。这里还有一个知识点就是 OpenResty 里面的 <code>print</code> 语句是 INFO 级别。</p>\n<p>有关 Nginx 的日志级别，请看下表：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ngx.STDERR     <span class=\"comment\">-- 标准输出</span></span><br><span class=\"line\">ngx.EMERG      <span class=\"comment\">-- 紧急报错</span></span><br><span class=\"line\">ngx.ALERT      <span class=\"comment\">-- 报警</span></span><br><span class=\"line\">ngx.CRIT       <span class=\"comment\">-- 严重，系统故障，触发运维告警系统</span></span><br><span class=\"line\">ngx.ERR        <span class=\"comment\">-- 错误，业务不可恢复性错误</span></span><br><span class=\"line\">ngx.WARN       <span class=\"comment\">-- 告警，业务中可忽略错误</span></span><br><span class=\"line\">ngx.NOTICE     <span class=\"comment\">-- 提醒，业务比较重要信息</span></span><br><span class=\"line\">ngx.INFO       <span class=\"comment\">-- 信息，业务琐碎日志信息，包含不同情况判断等</span></span><br><span class=\"line\">ngx.DEBUG      <span class=\"comment\">-- 调试</span></span><br></pre></td></tr></table></figure>\n<p>他们是一些常量，越往上等级越高。读者朋友可以尝试把 error log 日志级别修改为 info，然后重新执行一下测试用例，就可以看到全部日志输出结果了。</p>\n<p>对于应用开发，一般使用 <a href=\"http://ngx.INFO\">ngx.INFO</a> 到 ngx.CRIT 就够了。生产中错误日志开启到 error 级别就够了。如何正确使用这些级别呢？可能不同的人、不同的公司可能有不同见解。</p>\n<h3 id=\"网络日志输出\">网络日志输出</h3>\n<p>如果你的日志需要归集，并且对时效性要求比较高那么这里要推荐的库可能就让你很喜欢了。 <a href=\"https://github.com/cloudflare/lua-resty-logger-socket\">lua-resty-logger-socket</a> ，可以说很好的解决了上面提及的几个特性。</p>\n<p><a href=\"https://github.com/cloudflare/lua-resty-logger-socket\">lua-resty-logger-socket</a> 的目标是替代 Nginx 标准的 <a href=\"http://nginx.org/en/docs/http/ngx_http_log_module.html\">ngx_http_log_module</a> 以非阻塞 IO 方式推送 access log 到远程服务器上。对远程服务器的要求是支持 <a href=\"http://www.balabit.com/network-security/syslog-ng\">syslog-ng</a> 的日志服务。</p>\n<p>引用官方示例：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">lua_package_path</span> <span class=\"string\">&quot;/path/to/lua-resty-logger-socket/lib/?.lua;;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"section\">server</span> &#123;</span><br><span class=\"line\">        <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">            <span class=\"attribute\">log_by_lua</span> <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">                local logger = require &quot;resty.logger.socket&quot;</span></span><br><span class=\"line\"><span class=\"string\">                if not logger.initted() then</span></span><br><span class=\"line\"><span class=\"string\">                    local ok, err = logger.init&#123;</span></span><br><span class=\"line\"><span class=\"string\">                        host = &#x27;</span>xxx<span class=\"string\">&#x27;,</span></span><br><span class=\"line\"><span class=\"string\">                        port = 1234,</span></span><br><span class=\"line\"><span class=\"string\">                        flush_limit = 1234,</span></span><br><span class=\"line\"><span class=\"string\">                        drop_limit = 5678,</span></span><br><span class=\"line\"><span class=\"string\">                    &#125;</span></span><br><span class=\"line\"><span class=\"string\">                    if not ok then</span></span><br><span class=\"line\"><span class=\"string\">                        ngx.log(ngx.ERR, &quot;failed to initialize the logger: &quot;,</span></span><br><span class=\"line\"><span class=\"string\">                                err)</span></span><br><span class=\"line\"><span class=\"string\">                        return</span></span><br><span class=\"line\"><span class=\"string\">                    end</span></span><br><span class=\"line\"><span class=\"string\">                end</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">                -- construct the custom access log message in</span></span><br><span class=\"line\"><span class=\"string\">                -- the Lua variable &quot;msg&quot;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">                local bytes, err = logger.log(msg)</span></span><br><span class=\"line\"><span class=\"string\">                if err then</span></span><br><span class=\"line\"><span class=\"string\">                    ngx.log(ngx.ERR, &quot;failed to log message: &quot;, err)</span></span><br><span class=\"line\"><span class=\"string\">                    return</span></span><br><span class=\"line\"><span class=\"string\">                end</span></span><br><span class=\"line\"><span class=\"string\">            &#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>例举几个好处：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>基于 cosocket 非阻塞 IO 实现</p>\n</li>\n<li class=\"lvl-2\">\n<p>日志累计到一定量，集体提交，增加网络传输利用率</p>\n</li>\n<li class=\"lvl-2\">\n<p>短时间的网络抖动，自动容错</p>\n</li>\n<li class=\"lvl-2\">\n<p>日志累计到一定量，如果没有传输完毕，直接丢弃</p>\n</li>\n<li class=\"lvl-2\">\n<p>日志传输过程完全不落地，没有任何磁盘 IO 消耗</p>\n</li>\n</ul>\n","text":"日志输出 你如何测试和调试你的代码呢？Lua 的两个主力作者是这样回复的： Luiz Henrique de Figueiredo：我主要是一块一块的构建，分块测试。我很少使用调试器。即使用调试器，也只是调试 C 代码。我从不用调试器调试 Lua 代码。对于 Lua 来说，在适当...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\">日志输出</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%87%E5%87%86%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">标准日志输出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">网络日志输出</span></a></li></ol></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"cosocket.md","uid":"3c01632b3d6ff48483bb42fd53fbe2b7","slug":"old_topic/2016-09-17-313","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.225Z","comments":true,"path":"api/articles/old_topic/2016-09-17-313.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"怎样理解 cosocket todo: waiting to todo ","link":"","photos":[],"count_time":{"symbolsCount":36,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"helloworld","uid":"7feb1bc48352a2bd04c7a6d1cf8eb726","slug":"old_topic/2016-09-17-314","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.165Z","comments":true,"path":"api/articles/old_topic/2016-09-17-314.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"text":"HelloWorld HelloWorld 是我们亘古不变的第一个入门程序。但是 OpenResty 不是一门编程语言，跟其他编程语言的 HelloWorld 不一样，让我们看看都有哪些不一样吧。 创建工作目录 OpenResty 安装之后就有配置文件及相关的目录的，为了工作目录...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}