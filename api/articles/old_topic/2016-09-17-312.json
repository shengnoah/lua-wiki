{"title":"日志输出","uid":"7971c98c6c54521c1f721d0c7bf2b182","slug":"old_topic/2016-09-17-312","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.217Z","comments":true,"path":"api/articles/old_topic/2016-09-17-312.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h1 id=\"日志输出\"><a class=\"markdownIt-Anchor\" href=\"#日志输出\"></a> 日志输出</h1>\n<p>你如何测试和调试你的代码呢？Lua 的两个主力作者是这样回复的：</p>\n<p>Luiz Henrique de Figueiredo：我主要是一块一块的构建，分块测试。我很少使用调试器。即使用调试器，也只是调试 C 代码。我从不用调试器调试 Lua 代码。对于 Lua 来说，在适当的位置放几条打印语句通常就可以胜任了。</p>\n<p>Roberto Ierusalimschy：我差不多也是这样。当我使用调试器时，通常只是用来查找代码在哪里崩溃了。对于 C 代码，有个像 Valgrind 或者 Purify 这样的工具是必要的。</p>\n<p>摘自《编程之魂 – 采访 Lua 发明人的一篇文章》。</p>\n<p>由此可见掌握日志输出是多么重要，下至入门同学，上至 Lua 作者，使用日志输出来确定问题，是很必要的基本手段。</p>\n<h3 id=\"标准日志输出\"><a class=\"markdownIt-Anchor\" href=\"#标准日志输出\"></a> 标准日志输出</h3>\n<p>OpenResty 的标准日志输出原句为 <code>ngx.log(log_level, ...)</code> ，几乎可以在任何 ngx_lua 阶段进行日志的输出。</p>\n<p>请看下面的示例：</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\"><span class=\"token comment\">#user  nobody;</span>\n<span class=\"token directive\"><span class=\"token keyword\">worker_processes</span>  <span class=\"token number\">1</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token directive\"><span class=\"token keyword\">error_log</span>  logs/error.log error</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\"># 日志级别</span>\n<span class=\"token comment\">#pid        logs/nginx.pid;</span>\n\n<span class=\"token directive\"><span class=\"token keyword\">events</span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">worker_connections</span>  <span class=\"token number\">1024</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token directive\"><span class=\"token keyword\">http</span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">listen</span>    <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">location</span> /</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token directive\"><span class=\"token keyword\">content_by_lua_block</span></span> <span class=\"token punctuation\">&#123;</span>\n                local num = 55\n                local str = \"string\"\n                local obj\n                ngx.log(ngx.ERR, \"num:\", num)\n                ngx.log(ngx.INFO, \" string:\", str)\n                print([[i am print]])\n                ngx.log(ngx.ERR, \" object:\", obj)\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>访问网页，生成日志（logs/error.log 文件）结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">2016</span>/01/22 <span class=\"token number\">16</span>:43:34 <span class=\"token punctuation\">[</span>error<span class=\"token punctuation\">]</span> <span class=\"token number\">61610</span><span class=\"token comment\">#0: *10 [lua] content_by_lua(nginx.conf:26):5:</span>\n num:55, client: <span class=\"token number\">127.0</span>.0.1, server: , request: <span class=\"token string\">\"GET /hello HTTP/1.1\"</span>,\n host: <span class=\"token string\">\"127.0.0.1\"</span>\n<span class=\"token number\">2016</span>/01/22 <span class=\"token number\">16</span>:43:34 <span class=\"token punctuation\">[</span>error<span class=\"token punctuation\">]</span> <span class=\"token number\">61610</span><span class=\"token comment\">#0: *10 [lua] content_by_lua(nginx.conf:26):7:</span>\n object:nil, client: <span class=\"token number\">127.0</span>.0.1, server: , request: <span class=\"token string\">\"GET /hello HTTP/1.1\"</span>,\n host: <span class=\"token string\">\"127.0.0.1\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>大家可以在单行日志中获取很多有用的信息，例如：时间、日志级别、请求ID、错误代码位置、内容、客户端 IP 、请求参数等等，这些信息都是环境信息，可以用来辅助完成更多其他操作。当然我们也可以根据自己需要定义日志格式，具体可以参考 nginx 的 <a href=\"http://nginx.org/en/docs/http/ngx_http_log_module.html#log_format\">log_format</a> 章节。</p>\n<p>细心的读者发现了，中间的两行日志哪里去了？这里不卖关子，其实是日志输出级别的原因。上面的例子，日志输出级别使用的 error，只有等于或大于这个级别的日志才会输出。这里还有一个知识点就是 OpenResty 里面的 <code>print</code> 语句是 INFO 级别。</p>\n<p>有关 Nginx 的日志级别，请看下表：</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\">ngx<span class=\"token punctuation\">.</span>STDERR     <span class=\"token comment\">-- 标准输出</span>\nngx<span class=\"token punctuation\">.</span>EMERG      <span class=\"token comment\">-- 紧急报错</span>\nngx<span class=\"token punctuation\">.</span>ALERT      <span class=\"token comment\">-- 报警</span>\nngx<span class=\"token punctuation\">.</span>CRIT       <span class=\"token comment\">-- 严重，系统故障，触发运维告警系统</span>\nngx<span class=\"token punctuation\">.</span>ERR        <span class=\"token comment\">-- 错误，业务不可恢复性错误</span>\nngx<span class=\"token punctuation\">.</span>WARN       <span class=\"token comment\">-- 告警，业务中可忽略错误</span>\nngx<span class=\"token punctuation\">.</span>NOTICE     <span class=\"token comment\">-- 提醒，业务比较重要信息</span>\nngx<span class=\"token punctuation\">.</span>INFO       <span class=\"token comment\">-- 信息，业务琐碎日志信息，包含不同情况判断等</span>\nngx<span class=\"token punctuation\">.</span>DEBUG      <span class=\"token comment\">-- 调试</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>他们是一些常量，越往上等级越高。读者朋友可以尝试把 error log 日志级别修改为 info，然后重新执行一下测试用例，就可以看到全部日志输出结果了。</p>\n<p>对于应用开发，一般使用 <a href=\"http://ngx.INFO\">ngx.INFO</a> 到 ngx.CRIT 就够了。生产中错误日志开启到 error 级别就够了。如何正确使用这些级别呢？可能不同的人、不同的公司可能有不同见解。</p>\n<h3 id=\"网络日志输出\"><a class=\"markdownIt-Anchor\" href=\"#网络日志输出\"></a> 网络日志输出</h3>\n<p>如果你的日志需要归集，并且对时效性要求比较高那么这里要推荐的库可能就让你很喜欢了。 <a href=\"https://github.com/cloudflare/lua-resty-logger-socket\">lua-resty-logger-socket</a> ，可以说很好的解决了上面提及的几个特性。</p>\n<p><a href=\"https://github.com/cloudflare/lua-resty-logger-socket\">lua-resty-logger-socket</a> 的目标是替代 Nginx 标准的 <a href=\"http://nginx.org/en/docs/http/ngx_http_log_module.html\">ngx_http_log_module</a> 以非阻塞 IO 方式推送 access log 到远程服务器上。对远程服务器的要求是支持 <a href=\"http://www.balabit.com/network-security/syslog-ng\">syslog-ng</a> 的日志服务。</p>\n<p>引用官方示例：</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">lua_package_path</span> <span class=\"token string\">\"/path/to/lua-resty-logger-socket/lib/?.lua;;\"</span></span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">location</span> /</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token directive\"><span class=\"token keyword\">log_by_lua</span> <span class=\"token string\">'\n                local logger = require \"resty.logger.socket\"\n                if not logger.initted() then\n                    local ok, err = logger.init&#123;\n                        host = '</span>xxx<span class=\"token string\">',\n                        port = 1234,\n                        flush_limit = 1234,\n                        drop_limit = 5678,\n                    &#125;\n                    if not ok then\n                        ngx.log(ngx.ERR, \"failed to initialize the logger: \",\n                                err)\n                        return\n                    end\n                end\n\n                -- construct the custom access log message in\n                -- the Lua variable \"msg\"\n\n                local bytes, err = logger.log(msg)\n                if err then\n                    ngx.log(ngx.ERR, \"failed to log message: \", err)\n                    return\n                end\n            '</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>例举几个好处：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>基于 cosocket 非阻塞 IO 实现</p>\n</li>\n<li class=\"lvl-2\">\n<p>日志累计到一定量，集体提交，增加网络传输利用率</p>\n</li>\n<li class=\"lvl-2\">\n<p>短时间的网络抖动，自动容错</p>\n</li>\n<li class=\"lvl-2\">\n<p>日志累计到一定量，如果没有传输完毕，直接丢弃</p>\n</li>\n<li class=\"lvl-2\">\n<p>日志传输过程完全不落地，没有任何磁盘 IO 消耗</p>\n</li>\n</ul>\n","text":" 日志输出 你如何测试和调试你的代码呢？Lua 的两个主力作者是这样回复的： Luiz Henrique de Figueiredo：我主要是一块一块的构建，分块测试。我很少使用调试器。即使用调试器，也只是调试 C 代码。我从不用调试器调试 Lua 代码。对于 Lua 来说，在适...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA\"><span class=\"toc-text\"> 日志输出</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%87%E5%87%86%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA\"><span class=\"toc-text\"> 标准日志输出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA\"><span class=\"toc-text\"> 网络日志输出</span></a></li></ol></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"与其他 location 配合","uid":"66c1d79a932fd4e754d2057db394f613","slug":"old_topic/2016-09-17-311","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.179Z","comments":true,"path":"api/articles/old_topic/2016-09-17-311.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 与其他 location 配合 nginx 世界的 location 是异常强大的，毕竟 nginx 的主要应用场景是在负载均衡、API server，在不同 server、location 之间跳转更是家常便饭。利用不同 location 的功能组合，我们可以完成内部调用、流...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"cosocket.md","uid":"3c01632b3d6ff48483bb42fd53fbe2b7","slug":"old_topic/2016-09-17-313","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.225Z","comments":true,"path":"api/articles/old_topic/2016-09-17-313.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 怎样理解 cosocket todo: waiting to todo ","link":"","photos":[],"count_time":{"symbolsCount":37,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}