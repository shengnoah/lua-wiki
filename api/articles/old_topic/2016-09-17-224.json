{"title":"Lapis的数据库查询分页功能","uid":"4a3d58a7b2640de2406b2e1d53c042d1","slug":"old_topic/2016-09-17-224","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.175Z","comments":true,"path":"api/articles/old_topic/2016-09-17-224.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>作者：leafo</p>\n<p>翻译：糖果</p>\n<h3>Pagination分页</h3> \n<blockquote>Using the paginated method on models we can easily paginate through a query that might otherwise return many results. The arguments are the same as the select method but instead of the result it returns a specialPaginator object.</blockquote> \n<p>使用paginated方法，我们可以很轻松的实现多检索结果的分页效果。select方法的参数都是一样的，但是返回的查询结果是特定的Paginator对象。</p>\n<blockquote>For example, say we have the following table and model: (See Database Schemas for more information on creating tables.)</blockquote> \n<p>例如,下面的数据表定义：（Database Schemas那章有更多关于表创建的细节内容。）</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create_table(<span class=\"string\">&quot;users&quot;</span>, &#123;</span><br><span class=\"line\">  &#123; <span class=\"string\">&quot;id&quot;</span>, types.serial &#125;,</span><br><span class=\"line\">  &#123; <span class=\"string\">&quot;name&quot;</span>, types.varchar &#125;,</span><br><span class=\"line\">  &#123; <span class=\"string\">&quot;group_id&quot;</span>, types.foreign_key &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"string\">&quot;PRIMARY KEY(id)&quot;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">local</span> Users = Model:extend(<span class=\"string\">&quot;users&quot;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>We can create a paginator like so:</blockquote> \n<p>我们可以创建一个分页器：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> paginated = Users:paginated(<span class=\"string\">&quot;where group_id = ? order by name asc&quot;</span>, <span class=\"number\">123</span>)</span><br></pre></td></tr></table></figure>\n<blockquote>A paginator can be configured by passing a table as the last argument. The following options are supported: per_page: sets the number of items per page</blockquote> \n<p>可以在最后一个参数传个lua table定义来配置分页器，下面的这个设置：per_page:设置每页显示项目的条数。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> paginated2 = Users:paginated(<span class=\"string\">&quot;where group_id = ?&quot;</span>, <span class=\"number\">4</span>, &#123; per_page = <span class=\"number\">100</span> &#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>prepare_results: a function that is passed the results of get_page and get_all for processing before they are returned. This is useful for bundling preloading information into the paginator. The prepare function takes 1 argument, the results, and it must return the results after they have been processed:</blockquote> \n<p>prepare_results:此函数在把结果传给get_page和get_all处理之前就返回了。这个为分页器提前绑定信息很有用。预处理函数有一个参数，结果， 在返回结果之后就已对处理完了。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> preloaded = Posts:paginated(<span class=\"string\">&quot;where category = ?&quot;</span>, <span class=\"string\">&quot;cats&quot;</span>, &#123;</span><br><span class=\"line\">  per_page = <span class=\"number\">10</span>,</span><br><span class=\"line\">  prepare_results = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(posts)</span></span></span><br><span class=\"line\">    Users:include_in(posts, <span class=\"string\">&quot;user_id&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> posts</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>Any additional options sent to paginated are passed directly to the underlying select method call when a page is loaded. For example you can provide a fields option in order to limit the fields returned by a page.</blockquote> \n<p>在页面被加载后，任何附加参数被传给分页器都直接被select底层方法调用， 例如你可提供一个fields 选项，来限制每页返回的字段数。</p>\n<blockquote>Whenever possible you should specify an ORDER clause in your paginated query, as the database might returned unexpected results for each page. The paginator has the following methods:</blockquote> \n<p>可能你在查询中指定了一个ORDER语句， 数据库的分页数据可能返回了非预期的结果，分页器有下面的这些方法。</p>\n<h4>get_all()</h4> \n<blockquote>Gets all the items that the query can return, is the same as calling the select method directly. Returns an array table of model instances.</blockquote> \n<p>返回所有的查询项目，效果和直接调用select一样，Model返回的是lua的数组table。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> users = paginated:get_all()</span><br><span class=\"line\">SELECT * from <span class=\"string\">&quot;users&quot;</span> where group_id = <span class=\"number\">123</span> order by name asc</span><br><span class=\"line\">get_page(page_num)</span><br></pre></td></tr></table></figure>\n<blockquote>Gets page_numth page, where pages are 1 indexed. The number of items per page is controlled by theper_page option, and defaults to 10. Returns an array table of model instances.</blockquote> \n<p>取得提定的page_num页， 页数从1索引 ，每页多少项是通过per_page这个参数来控制的，默认是10， Model返回的是lua的数组table。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> page1 = paginated:get_page(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">local</span> page6 = paginated:get_page(<span class=\"number\">6</span>)</span><br><span class=\"line\">SELECT * from <span class=\"string\">&quot;users&quot;</span> where group_id = <span class=\"number\">123</span> order by name asc limit <span class=\"number\">10</span> offset <span class=\"number\">0</span></span><br><span class=\"line\">SELECT * from <span class=\"string\">&quot;users&quot;</span> where group_id = <span class=\"number\">123</span> order by name asc limit <span class=\"number\">10</span> offset <span class=\"number\">50</span></span><br></pre></td></tr></table></figure>\n<h4>num_pages()</h4> \n<blockquote>Returns the total number of pages.</blockquote> \n<p>返回总页数。</p>\n<h4>total_items()</h4> \n<blockquote>Gets the total number of items that can be returned. The paginator will parse the query and remove all clauses except for the WHERE when issuing a COUNT.</blockquote> \n<p>返回总项目数，分页器会分析查询，当查询是COUNT就移去WHERE之句。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> users = paginated:total_items()</span><br><span class=\"line\">SELECT COUNT(*) as c from <span class=\"string\">&quot;users&quot;</span> where group_id = <span class=\"number\">123</span></span><br></pre></td></tr></table></figure>\n<blockquote>Returns an iterator function that can be used to iterate through each page of the results. Useful for processing a large query without having the entire result set loaded in memory at once.</blockquote> \n<p>返回一个迭代函数，被用于遍历每页的结果。在有大型查询处理，内存一次放不下时，很有用。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> page_results, page_num <span class=\"keyword\">in</span> paginated:each_page() <span class=\"keyword\">do</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(page_results, page_num)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<blockquote>Be careful modifying rows when iterating over each page, as your modifications might change the pagination order and you may process rows multiple times or none at all.</blockquote> \n<p>遍历每页中行要小心，你的编辑可能会改变分页的顺序，还有你可能会对行结果处理多次，或一次也没有。</p>\n<h4>has_items()</h4> \n<blockquote>Checks to see if the paginator returns at least 1 item. Returns a boolean. This is more efficient than counting the items and checking for a number greater than 0 because the query generated by this function doesn’t do any counting.</blockquote> \n<p>检查处理，判断分页器至少返回一条数据。返回的是boolean值，这个比判断返回结果&gt;0更高效，因为用这函数生成不会产生任何的计数查询。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> pager:has_items() <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"comment\">-- ...</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\">SELECT <span class=\"number\">1</span> FROM <span class=\"string\">&quot;users&quot;</span> where group_id = <span class=\"number\">123</span> limit <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>","text":"作者：leafo 翻译：糖果 Pagination分页 Using the paginated method on models we can easily paginate through a query that might otherwise return many res...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Pagination分页</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">get_all()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">num_pages()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">total_items()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">has_items()</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"在Heroku云上部署Lua应用","uid":"2707eecc13e3136ac3d2044a4e3fff26","slug":"old_topic/2016-09-17-223","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.208Z","comments":true,"path":"api/articles/old_topic/2016-09-17-223.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"在Heroku云上部署Lua应用 Running Lua on Heroku Posted February 05, 2012 by leafo (@moonscript) Since the release of Heroku’s Cedar platform they've ...","link":"","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Writing a DSL in Lua","uid":"27a76f8b85be215ce4dc3b40107bebc6","slug":"old_topic/2016-09-17-225","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.148Z","comments":true,"path":"api/articles/old_topic/2016-09-17-225.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"text":"作者：leafo DSLs, or domain specific languages, are programming languages that are designed to implement a set of features specific to a partic...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}