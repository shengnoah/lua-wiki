{"title":"CSRF攻击预防的Token生成原理","uid":"2caace3339612aabd4a60ee7889dcc5d","slug":"old_topic/2016-09-17-155","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.221Z","comments":true,"path":"api/articles/old_topic/2016-09-17-155.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>作者：糖果</p>\n<p>以往我们讲到CSRF，谈及都是CSRF的攻击原理，这次讲一下预防CSRF，生成Token背后的加密原理和具体实现例示。</p>\n<p>1.Token构成。</p>\n<p>从需求功能上来讲，为了防止CSRF工具，token需要具有不重复，另外，还含有特定的功能信息，比如过期时间戳。</p>\n<p>下面的图描述了一个token的数据构成：</p>\n<p>Token的数据结构。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------------------------------------------------------------------------</span><br><span class=\"line\">|             msg                  |        separator       |           signature                    |</span><br><span class=\"line\">-----------------------------------------------------------------------------</span><br><span class=\"line\">|     key     |   timestamp  |              .               |    Base64(sha256(msg))        |</span><br><span class=\"line\">-----------------------------------------------------------------------------</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>token由三部分组成：a).msg b). separator c).signature。</p>\n<p>a). msg部分：而msg本身也有两部分组成：一部分，随机字符的主体，另一部分是过期时间戳。</p>\n<p>b). 分隔符号：用符号分隔msg部分，和加密后生成的signature签名部分，这里用的是”.“</p>\n<p>c). 签名signature。<br>\nsignature签名，是对上面提到的msg，按照msg中提到的msg的信息部分，按照特定的秘锁进行加密。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">token = base64(msg)格式化..base64(sha256(&quot;秘锁&quot;, msg))</span><br></pre></td></tr></table></figure>\n<p>2.Token的加密。首先，是按照合适得加密方法对数据进行加密。这里我们通用的就使用了sha256散列算法，然后进行BASE64的格式转换。然后，我们需要在token串中隐含过期时间的设定，从需求上讲，每条与服务器交互的token有是有过期时间的，超过这个时间范围，就无效了，需要重新从服务器中取得。</p>\n<p>3.Token的验证。</p>\n<p>当用户从客户端，得到了token,再次提交给服务器的时候，服务器需要判断token的有效性，否则不加判断直接处理数据，token的生成就无意义了。</p>\n<p>验证的过程是:</p>\n<p>a). token解包。</p>\n<p>先把接受到的token，进行分解。“.”为分隔符，分为msg部分+signature签名部分。</p>\n<p>b). 比对签名。</p>\n<p>对msg部分进行base64解码, decode_base64(msg)然后在对解码后的msg明文，进行同样的encode_base64(sha256(msg))加密。秘锁相同，然后，判断加密后的数据和客户端传过来的token.signature的部分是否一致。如果一致，说明这个token是有效的。</p>\n<p>c). 判断时间过期。如果是有效的,取出msg.timestamp，和当前系统时间进行比较，如果过期时间小于当前时间，那这个token是过期的，需要重新的取得token。</p>\n<p>原理都通用，此处使用lua对上处理过程进行描述。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">local</span> gen_token = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(key, expires)</span></span></span><br><span class=\"line\">    <span class=\"comment\">--做成一个过期时间戳。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> expires == <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">     expires = <span class=\"built_in\">os</span>.<span class=\"built_in\">time</span>() + <span class=\"number\">60</span> + <span class=\"number\">60</span> * <span class=\"number\">8</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">--对msg部分进行base64编码。</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> msg = encode_base64(</span><br><span class=\"line\">     json.encode(&#123;</span><br><span class=\"line\">         key = key,</span><br><span class=\"line\">         expires = expires</span><br><span class=\"line\">     &#125;))</span><br><span class=\"line\">     </span><br><span class=\"line\">   <span class=\"comment\">--进行sha256哈希。</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> signature = encode_base64(hmac_sha256(<span class=\"string\">&#x27;testkey&#x27;</span>, msg))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">--拼接成一条token。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> msg .. <span class=\"string\">&quot;.&quot;</span> ..signature</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">local</span>  val_token = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(key,token)</span></span></span><br><span class=\"line\">    <span class=\"comment\">--对输入数据的判空操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (token) <span class=\"keyword\">then</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"string\">&#x27;mssing csrf token&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">--对token的msg部分，signature签名部分进行拆分。</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> msg, sig = token:<span class=\"built_in\">match</span>(<span class=\"string\">&quot;^(.*)%.(.*)$&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (msg) <span class=\"keyword\">then</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"string\">&quot;malformed csrf token&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    sig = encoding.decode_base64(sig)</span><br><span class=\"line\">    <span class=\"comment\">--对解包后msg，按照相同的加密key:&quot;testkey&quot;，重新进行sha256哈希，比对signature，</span></span><br><span class=\"line\">    <span class=\"comment\">--如果不一致，说明这个token中的数据有问题，无效的token。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (sig == hmac_sha256(<span class=\"string\">&#x27;testkey&#x27;</span>, msg)) <span class=\"keyword\">then</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"string\">&quot;invalid csrf token(bad sig)&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">--对msg进行base64解码，判断其中的key和传入的key是否一致。</span></span><br><span class=\"line\">    <span class=\"comment\">--如果不一致说明token也是无效的。</span></span><br><span class=\"line\">    msg =json.decode(decode_base64(msg))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (msg.key == key) <span class=\"keyword\">then</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"string\">&quot;invalid csrf token (bad key)&quot;</span>    </span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">--取出msg部分的时间戳，判断是否大于当前时间，如果大于，说明token过期无效了。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"keyword\">not</span> msg.expires <span class=\"keyword\">or</span> msg.expires &gt; <span class=\"built_in\">os</span>.<span class=\"built_in\">time</span>()) <span class=\"keyword\">then</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"string\">&quot;csrf token expired&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>下面是关于Lua语言加密库，lua语言有别于其他语言，没有同意的官方指定加密库，为了便于读者，看后实践，下面对lua的加密库进行了补充描述。lua语言是一种弱类型的语言，简单明了，对于描述某些课题，便于表述，类似于伪语言，操作起来也很轻便，便于实践推敲算法。即使之后不适用lua，也可以很方面的迁移到其他语言。</p>\n<p>我们在开发的工作中，难免要对一些数据进行加密处理，而加密模块的使用有是就必不可少。在lua官方的WIKI列表中就列出了，很多lua程序写的加密库，这写加密库有的是用纯lua写的，也有用lua调用C的程序实现加密。不过有些时候甄选这些库还是需要花一些时间精力，只是需要测试一下这是加密算是否是好用的。这是lua组织列出的一览列表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://lua-users.org/wiki/CryptographyStuff</span><br></pre></td></tr></table></figure>\n<p>说一下为什么要加密，我们面临的任务是什么！我们现在面临的任务是，要对一段字符串进行sha256算法加密。我们从列表中选出了几个支持sha256加密的包，并说明一下这几个工具包。</p>\n<h3>1.SecureHashAlgorithm和SecureHashAlgorithmBW</h3> \n这个工具包是支持sha256加密的，而且是纯lua方法的实现，问题是，这两个包分别依赖lua5.2和lua5.3。\n而我们系统的运行环境是lua5.1，因为大部分的生产环境都是lua5.1，因为历史原因暂时没法改变。如果要把5.2的程序移植到5.1下运行，还需要移植一个lua5.2才独有的包，这是lua5.2升级之后才有的部件：bit32,而在lua5.3中又将这个部件去掉了,移植的动力不大，暂时不使用这个包。\n<h3>2.Lcrypt</h3> \n这个包不是纯lua的实现，底层加密用的是C语言，而且额外还有依赖另外另个工具包 libTomCrypt和libTomMath，这两个包的官网已经被和谐了，github上有源码，所以要想让这个包正常运行需要手动make安装3个源码工程，还是算了，有时间的时候再装好测试一下，先暂时不用。\n<p>网站：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.eder.us/projects/lcrypt/</span><br></pre></td></tr></table></figure>\n<h3>3.LuaCrypto</h3> \n这个包的安装用的是luarocks，就比较简单了 \n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">luarocks install luacrypto </span><br></pre></td></tr></table></figure>\n<p>我们选用这个包进行加密处理。<br>\nLuaCrypto其实是openssl库的前端lua调用，依赖openssl，openssl库显然会支持sha256加密，相对也比一般的第三方实现更可靠。写一个简单的加密程序：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> crypto = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;crypto&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">local</span> hmac = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;crypto.hmac&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">local</span> ret = hmac.digest(<span class=\"string\">&quot;sha256&quot;</span>, <span class=\"string\">&quot;abcdefg&quot;</span>, <span class=\"string\">&quot;hmackey&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(ret)</span><br></pre></td></tr></table></figure>\n<p>ret的返回结果是，如下这个字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">704d25d116a700656bfa5a6a7b0f462efdc7df828cdbafa6fbf8b39a12e83f24</span><br></pre></td></tr></table></figure>\n<p>我们需要改造一下代码，在调用digest的时候指定输出的形式是raw二进制数据形式，然后在编码成base64的数据形式。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> ret = hmac.digest(<span class=\"string\">&quot;sha256&quot;</span>, <span class=\"string\">&quot;abcdefg&quot;</span>, <span class=\"string\">&quot;hmackey&quot;</span>,<span class=\"built_in\">rawequal</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(ret)</span><br></pre></td></tr></table></figure>\n<p>这时候的输出结果是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cE0l0RanAGVr+lpqew9GLv3H34KM26+m+/izmhLoPyQ=</span><br><span class=\"line\">lua-base64</span><br></pre></td></tr></table></figure>\n<p>使用的是下面的库，lua库就是这样，有很多功能程序有很多的实现，并且很多非官方的第三方实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://github.com/toastdriven/lua-base64</span><br></pre></td></tr></table></figure>\n<p>作者：糖果<br>\nPS:转载到其它平台请注明作者姓名及原文链接，请勿用于商业用途。</p>\n<p><a href=\"http://www.lua.ren/topic/133/lua-faq\" target=\"_blank\">点击查看Lua FAQ</a></p>\n","text":"作者：糖果 以往我们讲到CSRF，谈及都是CSRF的攻击原理，这次讲一下预防CSRF，生成Token背后的加密原理和具体实现例示。 1.Token构成。 从需求功能上来讲，为了防止CSRF工具，token需要具有不重复，另外，还含有特定的功能信息，比如过期时间戳。 下面的图描述了...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">1.SecureHashAlgorithm和SecureHashAlgorithmBW</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">2.Lcrypt</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">3.LuaCrypto</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua相关资源的下载","uid":"5b530fb1728124affce356d72e211113","slug":"old_topic/2016-09-17-168","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.190Z","comments":true,"path":"api/articles/old_topic/2016-09-17-168.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"一个WEB框架 https://github.com/appwilldev/moochine 压力测试工具 loadrunner 淘宝使用的压测工具 tsung 压测工具 tcpcopy cosbench分布式压力测度工具 http://reins.se.sjtu.edu.cn/...","link":"","photos":[],"count_time":{"symbolsCount":470,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"LUA FAQ提问区","uid":"a746a11133e39b0cf464a04ba5004aa9","slug":"old_topic/2016-09-17-169","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.183Z","comments":true,"path":"api/articles/old_topic/2016-09-17-169.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"如果您希望Lua FAQ出现一些您感兴趣的课题，请在评论下留言!😃 ","link":"","photos":[],"count_time":{"symbolsCount":35,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}