{"title":"与其他 location 配合","uid":"66c1d79a932fd4e754d2057db394f613","slug":"old_topic/2016-09-17-311","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.179Z","comments":true,"path":"api/articles/old_topic/2016-09-17-311.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"content":"<h1>与其他 location 配合</h1>\n<p>nginx 世界的 location 是异常强大的，毕竟 nginx 的主要应用场景是在负载均衡、API server，在不同 server、location 之间跳转更是家常便饭。利用不同 location 的功能组合，我们可以完成内部调用、流水线方式跳转、外部重定向等几大不同方式，下面将给大家介绍几个主要应用，就当抛砖引玉。</p>\n<h2 id=\"内部调用\">内部调用</h2>\n<p>例如对数据库、内部公共函数的统一接口，可以把它们放到统一的 location 中。通常情况下，为了保护这些内部接口，都会把这些接口设置为 internal 。这么做的最主要好处就是可以让这个内部接口相对独立，不受外界干扰。</p>\n<p>示例代码：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">location</span> = /sum &#123;</span><br><span class=\"line\">    <span class=\"comment\"># 只允许内部调用</span></span><br><span class=\"line\">    internal;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 这里做了一个求和运算只是一个例子，可以在这里完成一些数据库、</span></span><br><span class=\"line\">    <span class=\"comment\"># 缓存服务器的操作，达到基础模块和业务逻辑分离目的</span></span><br><span class=\"line\">    <span class=\"section\">content_by_lua_block</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">local</span> args = ngx.req.get_uri_args()</span><br><span class=\"line\">        ngx.say(tonumber(args.a) + tonumber(args.b))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">location = /app/test &#123;</span><br><span class=\"line\">    <span class=\"section\">content_by_lua_block</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">local</span> res = ngx.location.capture(</span><br><span class=\"line\">                        <span class=\"string\">&quot;/sum&quot;</span>, &#123;args=&#123;a=3, b=8&#125;&#125;</span><br><span class=\"line\">                        )</span><br><span class=\"line\">        ngx.say(&quot;status:&quot;, res.status, &quot; response:&quot;, res.body)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>紧接着，稍微扩充一下，并行请求的效果，示例如下：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">location</span> = /sum &#123;</span><br><span class=\"line\">    internal;</span><br><span class=\"line\">    <span class=\"section\">content_by_lua_block</span> &#123;</span><br><span class=\"line\">        ngx.sleep(0.1)</span><br><span class=\"line\">        <span class=\"attribute\">local</span> args = ngx.req.get_uri_args()</span><br><span class=\"line\">        ngx.print(tonumber(args.a) + tonumber(args.b))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">location = /subduction &#123;</span><br><span class=\"line\">    internal;</span><br><span class=\"line\">    <span class=\"section\">content_by_lua_block</span> &#123;</span><br><span class=\"line\">        ngx.sleep(0.1)</span><br><span class=\"line\">        <span class=\"attribute\">local</span> args = ngx.req.get_uri_args()</span><br><span class=\"line\">        ngx.print(tonumber(args.a) - tonumber(args.b))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">location = /app/test_parallels &#123;</span><br><span class=\"line\">    <span class=\"section\">content_by_lua_block</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">local</span> start_time = ngx.now()</span><br><span class=\"line\">        local res1, res2 = ngx.location.capture_multi( &#123;</span><br><span class=\"line\">                        &#123;&quot;/sum&quot;, &#123;args=&#123;a=3, b=8&#125;&#125;&#125;,</span><br><span class=\"line\">                        &#123;&quot;/subduction&quot;, &#123;args=&#123;a=3, b=8&#125;&#125;&#125;</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">        ngx.say(&quot;status:&quot;, res1.status, &quot; response:&quot;, res1.body)</span><br><span class=\"line\">        ngx.say(&quot;status:&quot;, res2.status, &quot; response:&quot;, res2.body)</span><br><span class=\"line\">        ngx.say(&quot;<span class=\"attribute\">time</span> used:<span class=\"string\">&quot;, ngx.now() - start_time)</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">location = /app/test_queue &#123;</span></span><br><span class=\"line\"><span class=\"string\">    content_by_lua_block &#123;</span></span><br><span class=\"line\"><span class=\"string\">        local start_time = ngx.now()</span></span><br><span class=\"line\"><span class=\"string\">        local res1 = ngx.location.capture_multi( &#123;</span></span><br><span class=\"line\"><span class=\"string\">                        &#123;&quot;</span>/sum<span class=\"string\">&quot;, &#123;args=&#123;a=3, b=8&#125;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">                    &#125;)</span></span><br><span class=\"line\"><span class=\"string\">        local res2 = ngx.location.capture_multi( &#123;</span></span><br><span class=\"line\"><span class=\"string\">                        &#123;&quot;</span>/subduction<span class=\"string\">&quot;, &#123;args=&#123;a=3, b=8&#125;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">                    &#125;)</span></span><br><span class=\"line\"><span class=\"string\">        ngx.say(&quot;</span>status:<span class=\"string\">&quot;, res1.status, &quot;</span> response:<span class=\"string\">&quot;, res1.body)</span></span><br><span class=\"line\"><span class=\"string\">        ngx.say(&quot;</span>status:<span class=\"string\">&quot;, res2.status, &quot;</span> response:<span class=\"string\">&quot;, res2.body)</span></span><br><span class=\"line\"><span class=\"string\">        ngx.say(&quot;</span>time used:<span class=\"string\">&quot;, ngx.now() - start_time)</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ curl 127.0.0.1/app/test_parallels</span><br><span class=\"line\">status:200 response:11</span><br><span class=\"line\">status:200 response:-5</span><br><span class=\"line\">time used:0.10099983215332</span><br><span class=\"line\">➜  ~ curl 127.0.0.1/app/test_queue</span><br><span class=\"line\">status:200 response:11</span><br><span class=\"line\">status:200 response:-5</span><br><span class=\"line\">time used:0.20199990272522</span><br></pre></td></tr></table></figure>\n<p>利用 <code>ngx.location.capture_multi</code> 函数，直接完成了两个子请求并行执行。当两个请求没有相互依赖，这种方法可以极大提高查询效率。两个无依赖请求，各自是 100ms，顺序执行需要 200ms，但通过并行执行可以在 100ms 完成两个请求。实际生产中查询时间可能没这么规整，但思想大同小异，这个特性是很有用的。</p>\n<p><img src=\"../images/work_location_flow_1.png\" alt=\"图例\"></p>\n<p>该方法，可以被广泛应用于广告系统（1：N模型，一个请求，后端从N家供应商中获取条件最优广告）、高并发前端页面展示（并行无依赖界面、降级开关等）。</p>\n<h2 id=\"流水线方式跳转\">流水线方式跳转</h2>\n<p>现在的网络请求，已经变得越来越拥挤。各种不同 API 、下载请求混杂在一起，就要求不同厂商对下载的动态调整有各种不同的定制策略，而这些策略在一天的不同时间段，规则可能还不一样。这时候我们还可以效仿工厂的流水线模式，逐层过滤、处理。</p>\n<p>示例代码：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">location</span> <span class=\"regexp\">~ ^/static/([-_a-zA-Z0-9/]+).jpg</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">set</span> <span class=\"variable\">$image_name</span> <span class=\"variable\">$1</span>;</span><br><span class=\"line\">    <span class=\"section\">content_by_lua_block</span> &#123;</span><br><span class=\"line\">        ngx.exec(&quot;/download_internal/images/&quot;</span><br><span class=\"line\">                .. ngx.var.<span class=\"attribute\">image_name</span> .. <span class=\"string\">&quot;.jpg&quot;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">location</span> /download_internal &#123;</span><br><span class=\"line\">    internal;</span><br><span class=\"line\">    <span class=\"comment\"># 这里还可以有其他统一的 download 下载设置，例如限速等</span></span><br><span class=\"line\">    <span class=\"attribute\">alias</span> ../download;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，ngx.exec 方法与 ngx.redirect 是完全不同的，前者是个纯粹的内部跳转并且没有引入任何额外 HTTP 信号。 这里的两个 location 更像是流水线上工人之间的协作关系。第一环节的工人对完成自己处理部分后，直接交给第二环节处理人（实际上可以有更多环节），它们之间的数据流是定向的。</p>\n<p><img src=\"../images/work_location_flow_2.png\" alt=\"图例\"></p>\n<h2 id=\"外部重定向\">外部重定向</h2>\n<p>不知道大家什么时候开始注意的，百度的首页已经不再是 HTTP 协议，它已经全面修改到了 HTTPS 协议上。但是对于大家的输入习惯，估计还是在地址栏里面输入 <code>baidu.com</code> ，回车后发现它会自动跳转到 <code>https://www.baidu.com</code> ，这时候就需要的外部重定向了。</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">location</span> = /foo &#123;</span><br><span class=\"line\">    <span class=\"section\">content_by_lua_block</span> &#123;</span><br><span class=\"line\">        ngx.say([[<span class=\"attribute\">I</span> am foo]])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">location = / &#123;</span><br><span class=\"line\">    <span class=\"section\">rewrite_by_lua_block</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">return</span> ngx.<span class=\"literal\">redirect</span>(<span class=\"string\">&#x27;/foo&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行测试，结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~  curl 127.0.0.1 -i</span><br><span class=\"line\">HTTP/1.1 302 Moved Temporarily</span><br><span class=\"line\">Server: openresty/1.9.3.2rc3</span><br><span class=\"line\">Date: Sun, 22 Nov 2015 11:04:03 GMT</span><br><span class=\"line\">Content-Type: text/html</span><br><span class=\"line\">Content-Length: 169</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Location: /foo</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;</span><br><span class=\"line\">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class=\"line\">&lt;center&gt;&lt;h1&gt;302 Found&lt;/h1&gt;&lt;/center&gt;</span><br><span class=\"line\">&lt;hr&gt;&lt;center&gt;openresty/1.9.3.2rc3&lt;/center&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">➜  ~  curl 127.0.0.1/foo -i</span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Server: openresty/1.9.3.2rc3</span><br><span class=\"line\">Date: Sun, 22 Nov 2015 10:43:51 GMT</span><br><span class=\"line\">Content-Type: text/html</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\"></span><br><span class=\"line\">I am foo</span><br></pre></td></tr></table></figure>\n<p>当我们使用浏览器访问页面 <code>http://127.0.0.1</code> 就可以发现浏览器会自动跳转到 <code>http://127.0.0.1/foo</code> 。</p>\n<p>与之前两个应用实例不同的，外部重定向是可以跨域名的。例如从 A 网站跳转到 B 网站是绝对允许的。在 CDN 场景的大量下载应用中，一般分为调度、存储两个重要环节。调度就是通过根据请求方 IP 、下载文件等信息寻找最近、最快节点，应答跳转给请求方完成下载。</p>\n","text":"与其他 location 配合 nginx 世界的 location 是异常强大的，毕竟 nginx 的主要应用场景是在负载均衡、API server，在不同 server、location 之间跳转更是家常便饭。利用不同 location 的功能组合，我们可以完成内部调用、流水...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\">与其他 location 配合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">内部调用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%96%B9%E5%BC%8F%E8%B7%B3%E8%BD%AC\"><span class=\"toc-text\">流水线方式跳转</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%96%E9%83%A8%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">外部重定向</span></a></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"不同阶段共享变量","uid":"4b4caaa9aaa4e586708012dea3b735d1","slug":"old_topic/2016-09-17-310","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.155Z","comments":true,"path":"api/articles/old_topic/2016-09-17-310.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"不同阶段共享变量 在 OpenResty 的体系中，可以通过共享内存的方式完成不同工作进程的数据共享，可以通过 Lua 模块方式完成单个进程内不同请求的数据共享。如何完成单个请求内不同阶段的数据共享呢？最典型的例子，估计就是在 log 阶段记录一些请求的特殊变量。 ngx.ctx...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"cosocket.md","uid":"3c01632b3d6ff48483bb42fd53fbe2b7","slug":"old_topic/2016-09-17-313","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.225Z","comments":true,"path":"api/articles/old_topic/2016-09-17-313.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"怎样理解 cosocket todo: waiting to todo ","link":"","photos":[],"count_time":{"symbolsCount":36,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}