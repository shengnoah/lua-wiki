{"title":"如何在Openresty中实现一个REST服务","uid":"6f22cd23969a4d12ca816a42b73ce9e8","slug":"old_topic/2016-09-17-380","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.754Z","comments":true,"path":"api/articles/old_topic/2016-09-17-380.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>作者：糖果</p>\n<p>使用Blues框架在Openresty中实现一个REST服务解析和返回JSON数据，并通过curl向openresty服务器端请求rest，采用GET请求方式，提交一个json,然后路由到对应的匿名函数，通过request.params.body直接取得json数据主体，解析成table变量，放回渲染。<br>下面：</p>\n<h3 id=\"1-1-接口测试\"><a href=\"#1-1-接口测试\" class=\"headerlink\" title=\"1-1.接口测试\"></a>1-1.接口测试</h3><p>通过CURL调用我们将要实现的REST接口:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET  http://0.0.0.0/blues -d  &#x27;&#123;&quot;key&quot;:&quot;value&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>在app.lua加入如下函数:</p>\n<h3 id=\"1-2-接口实现（案A）\"><a href=\"#1-2-接口实现（案A）\" class=\"headerlink\" title=\"1-2.接口实现（案A）\"></a>1-2.接口实现（案A）</h3><p>app.lua </p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app:get(<span class=\"string\">&quot;/blues&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(request,id)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">--读取用户请求中的body数据</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> ret = request.params.body</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">--调用cjso库</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> json = <span class=\"built_in\">require</span> <span class=\"string\">&quot;cjson&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> util = <span class=\"built_in\">require</span> <span class=\"string\">&quot;cjson.util&quot;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">--对用户请求的数据进入JSON编码， 转成Table变量。</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> t = json.decode(ret)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">--递归显示JSON结构中的所有数据。</span></span><br><span class=\"line\">    ngx.say(util.serialise_value(t))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">--返回一个JSON数据结构</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br><span class=\"line\"><span class=\"keyword\">end</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-返回结果\"><a href=\"#1-3-返回结果\" class=\"headerlink\" title=\"1-3.返回结果\"></a>1-3.返回结果</h3><p>调用结果，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  [&quot;key&quot;] = &quot;value&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;&quot;key&quot;:&quot;value&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-1-接口实现（案B）\"><a href=\"#2-1-接口实现（案B）\" class=\"headerlink\" title=\"2-1.接口实现（案B）\"></a>2-1.接口实现（案B）</h3><p>下面我们去掉多余的JSON遍历部分，直接将用户请求中的JSON数据转成LUA的Table变量，然后<br>再把个Table变量，返回为一个JSON进行渲染。</p>\n<p>app.lua</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app:get(<span class=\"string\">&quot;/blues&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(request,id)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> ret = request.params.body</span><br><span class=\"line\">    <span class=\"keyword\">local</span> json = <span class=\"built_in\">require</span> <span class=\"string\">&quot;cjson&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> t = json.decode(ret)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t</span><br><span class=\"line\"><span class=\"keyword\">end</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-返回结果\"><a href=\"#2-2-返回结果\" class=\"headerlink\" title=\"2-2.返回结果\"></a>2-2.返回结果</h3><p>调用结果，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;key&quot;:&quot;value&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-1-接口实现（案c）\"><a href=\"#3-1-接口实现（案c）\" class=\"headerlink\" title=\"3-1.接口实现（案c）\"></a>3-1.接口实现（案c）</h3><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app:get(<span class=\"string\">&quot;/blues&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(request,id)</span></span></span><br><span class=\"line\">    ngx.say(<span class=\"string\">&quot;==============&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">local</span> t = utils:to_json(request)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t </span><br><span class=\"line\"><span class=\"keyword\">end</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-返回结果\"><a href=\"#3-2-返回结果\" class=\"headerlink\" title=\"3-2.返回结果\"></a>3-2.返回结果</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==============</span><br><span class=\"line\">&#123;&quot;key&quot;:&quot;value&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>C方案就是我们将之前的cjson做的json编码工作进行了封装，封装成了一个叫to_json函数来完成这个工作。</p>\n<p>PS:转载到其它平台请注明作者姓名及原文链接，请勿用于商业用途。</p>\n<p><a href=\"http://www.candylab.net/\">糖果实验室</a></p>\n<p><a href=\"http://www.candylab.net/\">http://www.candylab.net</a></p>\n","text":"作者：糖果 使用Blues框架在Openresty中实现一个REST服务解析和返回JSON数据，并通过curl向openresty服务器端请求rest，采用GET请求方式，提交一个json,然后路由到对应的匿名函数，通过request.params.body直接取得json数据主...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">1-1.接口测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%A1%88A%EF%BC%89\"><span class=\"toc-text\">1-2.接口实现（案A）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">1-3.返回结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%A1%88B%EF%BC%89\"><span class=\"toc-text\">2-1.接口实现（案B）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">2-2.返回结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%A1%88c%EF%BC%89\"><span class=\"toc-text\">3-1.接口实现（案c）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">3-2.返回结果</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"xml-sitemaps.com自动生成网站sitemap","uid":"babc875b7e0a7de20c19f4de9786a53d","slug":"old_topic/2016-09-17-374","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.753Z","comments":true,"path":"api/articles/old_topic/2016-09-17-374.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"xml-sitemaps.com自动生成网站sitemap,之前这网站是，根据数库后台数生成sitemap.xml和sitemap.html. 这种方式很自动化，但有没有一种工具，可以不通过自己写的代码，直接在前台输入网站地址就会生成相应的文件呢，有就是www.xml-sitem...","link":"","photos":[],"count_time":{"symbolsCount":181,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Moonscript的Map声明差异","uid":"6565f98206b7c6f49f5b3e935831f11b","slug":"old_topic/2016-09-17-375","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.753Z","comments":true,"path":"api/articles/old_topic/2016-09-17-375.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"Moonscript的Map声明差异 在Moonscript中，第一种table map的声明，对变量的赋值使用的是：“=”，，而第二种使用的方式是：“：”，可以通过下面moonc生成的代码，看出差异在那里： 使用：“=” 12345678910stats= &#123; buf...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}