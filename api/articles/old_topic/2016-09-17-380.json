{"title":"如何在Openresty中实现一个REST服务","uid":"6f22cd23969a4d12ca816a42b73ce9e8","slug":"old_topic/2016-09-17-380","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.210Z","comments":true,"path":"api/articles/old_topic/2016-09-17-380.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>作者：糖果</p>\n<p>使用Blues框架在Openresty中实现一个REST服务解析和返回JSON数据，并通过curl向openresty服务器端请求rest，采用GET请求方式，提交一个json,然后路由到对应的匿名函数，通过request.params.body直接取得json数据主体，解析成table变量，放回渲染。下面：</p>\n<h3 id=\"1-1-接口测试\">1-1.接口测试</h3>\n<p>通过CURL调用我们将要实现的REST接口:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X GET  http://0.0.0.0/blues -d  &#x27;&#123;&quot;key&quot;:&quot;value&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>\n<p>在app.lua加入如下函数:</p>\n<h3 id=\"1-2-接口实现（案A）\">1-2.接口实现（案A）</h3>\n<p>app.lua</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app:get(<span class=\"string\">&quot;/blues&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(request,id)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">--读取用户请求中的body数据</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> ret = request.params.body</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">--调用cjso库</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> json = <span class=\"built_in\">require</span> <span class=\"string\">&quot;cjson&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> util = <span class=\"built_in\">require</span> <span class=\"string\">&quot;cjson.util&quot;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">--对用户请求的数据进入JSON编码， 转成Table变量。</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> t = json.decode(ret)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">--递归显示JSON结构中的所有数据。</span></span><br><span class=\"line\">    ngx.say(util.serialise_value(t))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">--返回一个JSON数据结构</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br><span class=\"line\"><span class=\"keyword\">end</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-返回结果\">1-3.返回结果</h3>\n<p>调用结果，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  [&quot;key&quot;] = &quot;value&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;&quot;key&quot;:&quot;value&quot;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-接口实现（案B）\">2-1.接口实现（案B）</h3>\n<p>下面我们去掉多余的JSON遍历部分，直接将用户请求中的JSON数据转成LUA的Table变量，然后再把个Table变量，返回为一个JSON进行渲染。</p>\n<p>app.lua</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app:get(<span class=\"string\">&quot;/blues&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(request,id)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> ret = request.params.body</span><br><span class=\"line\">    <span class=\"keyword\">local</span> json = <span class=\"built_in\">require</span> <span class=\"string\">&quot;cjson&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> t = json.decode(ret)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t</span><br><span class=\"line\"><span class=\"keyword\">end</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-返回结果\">2-2.返回结果</h3>\n<p>调用结果，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;key&quot;:&quot;value&quot;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-接口实现（案c）\">3-1.接口实现（案c）</h3>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app:get(<span class=\"string\">&quot;/blues&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(request,id)</span></span></span><br><span class=\"line\">    ngx.say(<span class=\"string\">&quot;==============&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">local</span> t = utils:to_json(request)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t </span><br><span class=\"line\"><span class=\"keyword\">end</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-返回结果\">3-2.返回结果</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==============</span><br><span class=\"line\">&#123;&quot;key&quot;:&quot;value&quot;&#125;</span><br></pre></td></tr></table></figure>\n<p>C方案就是我们将之前的cjson做的json编码工作进行了封装，封装成了一个叫to_json函数来完成这个工作。</p>\n<p>PS:转载到其它平台请注明作者姓名及原文链接，请勿用于商业用途。</p>\n<p><a href=\"http://www.candylab.net\">糖果实验室</a></p>\n<p><a href=\"http://www.candylab.net\">http://www.candylab.net</a></p>\n","text":"作者：糖果 使用Blues框架在Openresty中实现一个REST服务解析和返回JSON数据，并通过curl向openresty服务器端请求rest，采用GET请求方式，提交一个json,然后路由到对应的匿名函数，通过request.params.body直接取得json数据主...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">1-1.接口测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%A1%88A%EF%BC%89\"><span class=\"toc-text\">1-2.接口实现（案A）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">1-3.返回结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%A1%88B%EF%BC%89\"><span class=\"toc-text\">2-1.接口实现（案B）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">2-2.返回结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%A1%88c%EF%BC%89\"><span class=\"toc-text\">3-1.接口实现（案c）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">3-2.返回结果</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua的Table的成员函数声明中的形参self","uid":"68ecc63ec79c9905410118253d04884f","slug":"old_topic/2016-09-17-382","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.163Z","comments":true,"path":"api/articles/old_topic/2016-09-17-382.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者：糖果 Lua函数声明中的形参self Lua中有两种对Table结构的成员函数声明方式：“:“和”.”。而对table的函数成员表量的调用也是这两种方试。 允许的：第一种:用&quot;.“声明函数，用”:&quot;调用用函数。函数调用时lua会把table变量本身做为第...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"lua的table复制copy","uid":"d63383a09ac480bfeab8c376afa1f147","slug":"old_topic/2016-09-17-385","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.228Z","comments":true,"path":"api/articles/old_topic/2016-09-17-385.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"源代码实现，来至于RESTY-HTTP 代码如下： 1234567891011121314151617-- Returns a new table, recursively copied from the one given.---- @param table table to ...","link":"","photos":[],"count_time":{"symbolsCount":522,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}