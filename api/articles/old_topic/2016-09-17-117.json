{"title":"LUA与STOMP协议","uid":"9aeff2cf84352e0facabfc6256b648d7","slug":"old_topic/2016-09-17-117","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.734Z","comments":true,"path":"api/articles/old_topic/2016-09-17-117.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>作者：糖果</p>\n<p>STOMP协议是一种简单的消息文本协议。协义本身简单明了，用消息头定义和消息体数据传输。</p>\n<p>RabbitMQ做为一种队列中间件，提供了STOMP协议的支持，我们可以通过STOMP协议向队列发送消息。下面的例子中，我们将使用LUA程序向RabbitMQ发送消息， 通过Python程序读取消息。</p>\n<p>send.lua文件</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> client = <span class=\"built_in\">require</span> <span class=\"string\">&quot;stomp&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> mq, err = client:new()</span><br><span class=\"line\"><span class=\"keyword\">local</span> ok, err = mq:connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">61613</span>)</span><br><span class=\"line\"><span class=\"keyword\">local</span> msg = <span class=\"string\">&quot;say hi!&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> headers = &#123;&#125;</span><br><span class=\"line\">headers[<span class=\"string\">&quot;destination&quot;</span>] = <span class=\"string\">&quot;/queue/test&quot;</span></span><br><span class=\"line\">headers[<span class=\"string\">&quot;app-id&quot;</span>] = <span class=\"string\">&quot;APP&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> ok, err = mq:send(info_json, headers)</span><br></pre></td></tr></table></figure>\n\n<p>对上面的代码说明一下：</p>\n<p>连接时候RabbitMQ的IP是本机的127.0.0.1， STOMP协议的服务的端口是默认的61613。</p>\n<p>在headers的头定义部分，指明了我们发送信息的目的地“/queue/test“名字为Test的队列。</p>\n<p>其实可以深入到STOMP的LUA的实现内部，仔细研究一下是如何实现，如何直接通过sock，发送数据帧到服务器，可以作为独立的章节。</p>\n<p>与LUA不同，Python对STOMP协议支持的比较好，不需要甄别第三库，然后再选择使用。用pythonstomp就好。</p>\n<p>receive.py文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> stomp</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyListener</span>(stomp.ConnectionListener):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">on_error</span>(<span class=\"params\">self, headers, message</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;received an error %s&#x27;</span> % message)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">on_message</span>(<span class=\"params\">self, headers, message</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k,v <span class=\"keyword\">in</span> headers.iteritems():</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;header: key %s , value %s&#x27;</span> %(k,v))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;received message\\n %s&#x27;</span>% message)</span><br><span class=\"line\"></span><br><span class=\"line\">conn=stomp.Connection([(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>,<span class=\"number\">61613</span>)])</span><br><span class=\"line\">conn.set_listener(<span class=\"string\">&#x27;somename&#x27;</span>,MyListener())</span><br><span class=\"line\">conn.start()</span><br><span class=\"line\">conn.connect(wait=<span class=\"literal\">True</span>)</span><br><span class=\"line\">message=<span class=\"string\">&#x27;say hi!&#x27;</span></span><br><span class=\"line\">dest = <span class=\"string\">&#x27;/queue/test&#x27;</span></span><br><span class=\"line\">headers=&#123;<span class=\"string\">&#x27;seltype&#x27;</span>:<span class=\"string\">&#x27;mandi-age-to-man&#x27;</span>,<span class=\"string\">&#x27;type&#x27;</span>:<span class=\"string\">&#x27;textMessage&#x27;</span>,<span class=\"string\">&#x27;MessageNumber&#x27;</span>:random.randint(<span class=\"number\">0</span>,<span class=\"number\">65535</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">metadata = [</span><br><span class=\"line\">]</span><br><span class=\"line\">info_json = json.dumps(metadata)</span><br><span class=\"line\">conn.send(body=info_json, destination=<span class=\"string\">&#x27;/queue/test&#x27;</span>)</span><br><span class=\"line\">conn.disconnect()</span><br></pre></td></tr></table></figure>\n\n\n<p>接受程序和发送程序的主要流程区别是：要在接受端注册监听回调程序。</p>\n<p>上面的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn.set_listener(<span class=\"string\">&#x27;somename&#x27;</span>,MyListener())</span><br><span class=\"line\">conn.start()</span><br></pre></td></tr></table></figure>\n\n<p>这两行代码就是注册监听类，在队列上有消息的时候，就会调用监听回调。</p>\n<p>on_message。发生错误的时候调用。on_error函数。</p>\n<p>具体的实现不完全列出来，针对一般的STOMP连接过程，列出”连接“和</p>\n<p>发送的”消息包”的数据结构，结构采用的是LUA语法，table类型定义的。</p>\n<p>共计二帧的数据：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connect_frame = &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;CONNECT\\n&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;accept-version:1.2\\n&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;login:guest\\n&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;passcode:guest\\n&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;host:/\\n&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;\\n\\n&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;\\0&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">send_frame = &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;SEND\\n&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;destination:/queue/test\\n&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;app-id:APP\\n&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;\\n&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;say hi!\\n&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;\\0&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>包体的第一个字段“CONNECT,SEND”都是协议的命令，剩下的是说明字段。<br>文字不能把所有的问题和协议都描述清楚，可参考以下网站：<br><a href=\"http://stomp.github.io/stomp-specification-1.1.html\">http://stomp.github.io/stomp-specification-1.1.html</a></p>\n<p>PS:转载到其它平台请注明作者姓名及原文链接，请勿用于商业用途。</p>\n","text":"作者：糖果 STOMP协议是一种简单的消息文本协议。协义本身简单明了，用消息头定义和消息体数据传输。 RabbitMQ做为一种队列中间件，提供了STOMP协议的支持，我们可以通过STOMP协议向队列发送消息。下面的例子中，我们将使用LUA程序向RabbitMQ发送消息， 通过Py...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Openresty的Lua定时器（计划任务）","uid":"1e5b544e537ce9e8013f8d5d976629a9","slug":"old_topic/2016-09-17-114","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.733Z","comments":true,"path":"api/articles/old_topic/2016-09-17-114.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"在系统中有一类需求是：周期性的执行某些任务，利用定时的timer去实现这种操作。 Openresty为Lua提供了这种机制实现的API，通过设定timer来完成这种类似计划任务功能。 下面，就是一个典型的Openresty的timer API的使用例子： 实现思路是，通过一个ti...","link":"","photos":[],"count_time":{"symbolsCount":824,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"WEB IDE环境运行Lua网页应用","uid":"94c79648b27c71adf58b46e7d0e952fe","slug":"old_topic/2016-09-17-113","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.733Z","comments":true,"path":"api/articles/old_topic/2016-09-17-113.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者：糖果 如Python和Ruby一样，Lua也可以创建WEB应用，之前提过的一个Lua WEB框架 这次就在WEB IDE环境下，部署一下LuaWEB的运行环境，并创建一个Lua WEB应用。 第一步：安装WEB服务器， Openresty。 1).下载安装包 1wget h...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}