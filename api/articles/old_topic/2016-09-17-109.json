{"title":"Lua中脚本中加载C语言的.SO共享库","uid":"f95942805ad9929705bec3ec56164a8b","slug":"old_topic/2016-09-17-109","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.733Z","comments":true,"path":"api/articles/old_topic/2016-09-17-109.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>作者：糖果</p>\n<p>在Lua中，可以使用loadlib的方式直接的加载C语言写的库，如同加载.lua文件一样。C写的模块可以做一些对效率要求相对比较高的模块，或是一些底层操作。下面举例</p>\n<p>说明：</p>\n<p>第一步：创建C模块文件。</p>\n<p>foo.h头文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> foo_h__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> foot_h__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title function_\">foo</span><span class=\"params\">(lua_State* L)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>foo.c实现文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lauxlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">foo</span><span class=\"params\">(lua_State* L)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Hello, I&#x27;m a shared library&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二步：创建.o文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -c -Wall -Werror -fpic foo.c -I/usr/include/lua5.1</span><br></pre></td></tr></table></figure>\n\n<p>注意一下的是.h文件中包含了”lauxlib.h”文件，所以要在编译的时候加上-I选项，后面追加.h文件的路径。</p>\n<p>第三步：创建.so文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -shared -o libfoo.so foo.o</span><br></pre></td></tr></table></figure>\n\n<p>如此操作后，”.so“文件就完成了生成，在使用libfoo.so动态库的时候，有以下几种方式让Lua找到库文件。</p>\n<p>a). 设置LD_LIBRARY_PATH环境变量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export LD_LIBRARY_PATH=/home/username/foo:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>\n\n<p>b). 复制库文件到系统目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp /home/coding/workspace/libfoo.so /usr/lib</span><br><span class=\"line\">ldconfig </span><br></pre></td></tr></table></figure>\n\n<p>用ldconfig更新一下缓冲，然后看是否生效。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldconfig -p | grep foo</span><br></pre></td></tr></table></figure>\n\n<p>(也可以看一下.so文件是否关联到其他的库。ldd XXX{XXX为非lua文件，可以含有main函数的C程序。}</p>\n<p>c). 把.so文件放到当前目录。</p>\n<p>第四步：在lua中加载.so库。</p>\n<p>test.lua文件。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = <span class=\"built_in\">package</span>.<span class=\"built_in\">loadlib</span>(<span class=\"string\">&quot;libfoo.so&quot;</span>, <span class=\"string\">&quot;foo&quot;</span>)</span><br><span class=\"line\">f()</span><br></pre></td></tr></table></figure>\n\n<p>以上，就是如何创建.so共享库，然后在Lua加载调用的过程，使用Lua版本是Lua5.15, 开发环境是在coding.net的WEB IDE的terminal终端环境。</p>\n<p>之前so库，是没有传递参数的，下面我们用一个简单传参的例子来说明问题，然后以Makefile的形式编译共享程序。</p>\n<p>首先要定义就是.h文件，定义最常见的接口add, sub。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __tangguo_h__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __tangguo_h__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lua.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lualib.h&quot;</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lauxlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(lua_State* L)</span>;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> <span class=\"title function_\">sub</span><span class=\"params\">(lua_State* L)</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> luaL_Reg libtangguo[] = &#123;</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;add&quot;</span>, add&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;sub&quot;</span>, sub&#125;,</span><br><span class=\"line\">    &#123;<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>&#125;</span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> </span></span><br></pre></td></tr></table></figure>\n\n<p>luaL_Reg 这个结构体相对很重要，下面是引用这个结构全的原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">luaL_Reg</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *name;</span><br><span class=\"line\">  lua_CFunction func;</span><br><span class=\"line\">&#125; luaL_Reg;</span><br></pre></td></tr></table></figure>\n\n<p>主要的元素:一个函数名字符串，另外一个是lua_CFunction的函数指针。<br>在定义时地函数最后要用两个NULL,作业结构体数据的结尾。</p>\n<blockquote>Type for arrays of functions to be registered byluaL_register.name is the function name and func is a pointer to the function.Any array of luaL_Reg must end with an sentinel entry in which both name and func are NULL.</blockquote> \n\n\n<p>lua_CFunction函数指针原型定义，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"title function_\">int</span> <span class=\"params\">(*lua_CFunction)</span> <span class=\"params\">(lua_State *L)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>下面是函数体的实体部分，所有函数的接口定义都是遵循lua_CFunction指针函数的原型定义，形参都是lua_State* L。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;tangguo.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sub</span><span class=\"params\">(lua_State* L)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> op1 = luaL_checknumber(L, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">double</span> op2 = luaL_checknumber(L, <span class=\"number\">2</span>);</span><br><span class=\"line\">    lua_pushnumber(L, op1 - op2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(lua_State* L)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> op1 = luaL_checknumber(L, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">double</span> op2 = luaL_checknumber(L, <span class=\"number\">2</span>);</span><br><span class=\"line\">    lua_pushnumber(L, op1 + op2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">luaopen_libtangguo</span><span class=\"params\">(lua_State* L)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    luaL_openlibs(L);</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *libName = <span class=\"string\">&quot;libtangguo&quot;</span>;</span><br><span class=\"line\">    luaL_register(L, libName, libtangguo);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>涉及到lua调用c语言，面对的一个课题是，如何在c函数中取得lua传递的对数，如果将计算结果，返回给lua程序。在这种最常见的add、sub函数例子都数字运算，我们用luaL_checknumber这个函数，原型如下：</p>\n<p>lua_Number luaL_checknumber (lua_State *L, int narg);</p>\n<blockquote>Checks whether the function argument narg is a numberand returns this number.</blockquote> \n\n<p>检查函数的参数是不是数字，返回这个数字。第一个参数是入参的状态机，第二个参数是lua调用c函数时，形参列表里第几个形参。</p>\n<p>还有一个比较重要的函数，luaopen_libtangguo，这函数是用来注册这此函数。</p>\n<p>luaL_register</p>\n<p>lua_pushnumber</p>\n<p>为了更好的适应编译环境，生成一个简单的Makefile， 需要注意的是LUALIB的定义要与你自己的环境相符。主要的参数是就是-I来指定.h的位置，-L用来定义用了那些库。</p>\n<p>默认的编辑选项是要提定平台。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make linux</span><br></pre></td></tr></table></figure>\n\n<p>Makefile文件如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LUALIB=-I/usr/include/lua5.1 -L/usr/local/lib -ldl -lm</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY: all win linux</span><br><span class=\"line\"></span><br><span class=\"line\">all:</span><br><span class=\"line\">        @echo Please do \\&#x27;make PLATFROM\\&#x27; where PLATFORM is one of these;</span><br><span class=\"line\">        @echo win linux</span><br><span class=\"line\"></span><br><span class=\"line\">win:</span><br><span class=\"line\"></span><br><span class=\"line\">linux: libtangguo.so</span><br><span class=\"line\"></span><br><span class=\"line\">libtangguo.so : tangguo.c</span><br><span class=\"line\">        #gcc --shared -Wall -fPIC -O2 $^ -o $@ $(LUALIB)</span><br><span class=\"line\">        gcc --shared -fPIC -O2 $^ -o $@ $(LUALIB)</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">        rm -f libtangguo.so</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>编译后会在当前目录生成.so文件，我们要以把.so文件复制到/usr/lib下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ldconfig</span><br></pre></td></tr></table></figure>\n\n\n<p>我们来测试一下库是否工作，用package.loadlib直接了复对应的函数指钍。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> aadd = <span class=\"built_in\">package</span>.<span class=\"built_in\">loadlib</span>(<span class=\"string\">&quot;libtangguo.so&quot;</span>, <span class=\"string\">&quot;add&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">local</span> asub = <span class=\"built_in\">package</span>.<span class=\"built_in\">loadlib</span>(<span class=\"string\">&quot;libtangguo.so&quot;</span>, <span class=\"string\">&quot;sub&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">local</span> ret = aadd(<span class=\"number\">1</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(ret)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">local</span> ret = asub(<span class=\"number\">6</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(ret)</span><br></pre></td></tr></table></figure>\n\n<p>输出的结是：</p>\n<p>3</p>\n<p>6</p>\n<p><strong>后记：</strong><br>涉及到lua调用c语言，面对的一个课题是，如何在c函数中取得lua传递的对数，如果将计算结果，返回给lua程序。</p>\n<p><a href=\"https://github.com/shengnoah/c_lua_so\" target=\"_blank\">源码地址：</a></p>\n","text":"作者：糖果 在Lua中，可以使用loadlib的方式直接的加载C语言写的库，如同加载.lua文件一样。C写的模块可以做一些对效率要求相对比较高的模块，或是一些底层操作。下面举例 说明： 第一步：创建C模块文件。 foo.h头文件 12345678#ifndef foo_h__#d...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua功能模块之“CURL”","uid":"c275b3b66a0c53930718bc2fb02605c5","slug":"old_topic/2016-09-17-107","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.733Z","comments":true,"path":"api/articles/old_topic/2016-09-17-107.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者：糖果 Curl是一个WEB开发常用的工具，直接用官网的翻译 curl是一个开源的命令行工具，也是一个库，用于传输URL语法的工具，支持DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, ...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"如何创建部署WSGI类型的（Django, Tornado, Flask）Python应用","uid":"834dc1c98ae0dfc3f6c8b6dfa350a594","slug":"old_topic/2016-09-17-110","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.733Z","comments":true,"path":"api/articles/old_topic/2016-09-17-110.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者：糖果 第一部分：安装必要工具。 1.因为这是部署Python开发环境，所以安装pip可以简化一些软件的安装过程。（PIP对应Lua的luarocks） 1sudo apt-get install python-pip 安装三个Python框架 123sudo pip ins...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}