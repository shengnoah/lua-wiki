{"title":"Tail Call 到底有啥用？","uid":"d50433282a5b8a29764977173d70c1a2","slug":"old_topic/2016-09-17-279","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.203Z","comments":true,"path":"api/articles/old_topic/2016-09-17-279.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"content":"<p>作者：ms2008</p>\n<p>整理编辑：糖果</p>\n<p>在聊今天这个话题之前，我们需要知道什么叫 tail call。先来看下，lua 程序设计是怎么定义的：</p>\n<p>尾调用是一种类似在函数结尾的 goto 调用，当函数最后一个动作是调用另外一个函数时，我们称这种调用尾调用。例如：</p>\n<p>function f(x)<br>\nreturn g(x)<br>\nend</p>\n<p>g 的调用是尾调用。</p>\n<p>例子中 f 调用 g 后不会再做任何事情，这种情况下当被调用函数 g 结束时程序不需要返回到调用者 f；所以尾调用之后程序不需要在栈中保留关于调用者的任何信息。一些编译器比如 Lua 解释器利用这种特性在处理尾调用时不使用额外的栈，我们称这种语言支持正确的尾调用。</p>\n<p>由于尾调用不需要使用栈空间，那么尾调用递归的层次可以无限制的。</p>\n<p>是不是有些迷糊？那我继续来解释下「详情可以参考廖雪峰的blog」：</p>\n<p>我们知道在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。递归函数的优点是定义简单，逻辑清晰。但是使用递归函数有个要命的缺点就是需要注意防止栈溢出！</p>\n<p>在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试这个求阶乘的用例：</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/sOId2kGKNxhdFrfmk2Uo0sz8FdpYZj3d4S3HkiblePAqzcsrRpuH29O6Zn4Z8vsEIY4ickhHwOzrQIDVAMsCuDHA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"图片\"></p>\n<p>解决递归调用栈溢出的方法是通过尾递归优化。尾递归是指，在函数返回的时候，调用自身本身，并且，return 语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>\n<p>上面的 fact(n) 函数由于 return n * fact(n - 1) 引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/sOId2kGKNxhdFrfmk2Uo0sz8FdpYZj3dDZ3u1yYLnBaRtjGnQnwFFbA7M59aWyFibGKYR8hroS0FhkI9nQJjdyQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"图片\"></p>\n<p>可以看到，return fact_iter(n-1, now<em>n) 仅返回递归函数本身，n-1 和 now</em>n 在函数调用前就会被计算，不影响函数调用。</p>\n<p>任何递归函数都存在栈溢出的问题。尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。这也正是 tail call 的威力所在。</p>\n<p>遗憾的是，大多数编程语言没有针对尾递归做优化，当然 lua 除外 😃</p>\n","text":"作者：ms2008 整理编辑：糖果 在聊今天这个话题之前，我们需要知道什么叫 tail call。先来看下，lua 程序设计是怎么定义的： 尾调用是一种类似在函数结尾的 goto 调用，当函数最后一个动作是调用另外一个函数时，我们称这种调用尾调用。例如： function f(x...","link":"","photos":[],"count_time":{"symbolsCount":979,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Threading的Timer是否可以被wait和communicate阻塞","uid":"1f0e7f34ab02983eb011a2f068cfda64","slug":"old_topic/2016-09-17-268","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.193Z","comments":true,"path":"api/articles/old_topic/2016-09-17-268.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者：糖果 测试的内容是将Timer的使用和Popen的使用混合在一起，测试当wait()和communicate()被调用时，是否会阻塞主进程的Timer。 找到Timer在Python2.7里的源码位置： 12345678910111213141516171819202122...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"OpenResty 中的连接池","uid":"34fb78ae79ed28901f3aef22da440208","slug":"old_topic/2016-09-17-280","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.230Z","comments":true,"path":"api/articles/old_topic/2016-09-17-280.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"OpenResty 中的连接池 作者：ms2008 编辑整理：糖果 注：set_keepalive 和 close 互斥(一个 socket 对象不能执行多次 setkeepalive 操作，会报：连接已关闭) 连接池的大小是对每一个 nginx worker 而言的。如果有 N...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}