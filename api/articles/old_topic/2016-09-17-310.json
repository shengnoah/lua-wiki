{"title":"不同阶段共享变量","uid":"4b4caaa9aaa4e586708012dea3b735d1","slug":"old_topic/2016-09-17-310","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.155Z","comments":true,"path":"api/articles/old_topic/2016-09-17-310.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h1 id=\"不同阶段共享变量\"><a class=\"markdownIt-Anchor\" href=\"#不同阶段共享变量\"></a> 不同阶段共享变量</h1>\n<p>在 OpenResty 的体系中，可以通过共享内存的方式完成不同工作进程的数据共享，可以通过 Lua 模块方式完成单个进程内不同请求的数据共享。如何完成单个请求内不同阶段的数据共享呢？最典型的例子，估计就是在 log 阶段记录一些请求的特殊变量。</p>\n<p>ngx.ctx 表就是为了解决这类问题而设计的。参考下面例子：</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">location</span> /test</span> <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token directive\"><span class=\"token keyword\">rewrite_by_lua</span> <span class=\"token string\">'\n         ngx.ctx.foo = 76\n     '</span></span><span class=\"token punctuation\">;</span>\n     <span class=\"token directive\"><span class=\"token keyword\">access_by_lua</span> <span class=\"token string\">'\n         ngx.ctx.foo = ngx.ctx.foo + 3\n     '</span></span><span class=\"token punctuation\">;</span>\n     <span class=\"token directive\"><span class=\"token keyword\">content_by_lua</span> <span class=\"token string\">'\n         ngx.say(ngx.ctx.foo)\n     '</span></span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>首先 ngx.ctx 是一个表，所以我们可以对他添加、修改。它用来存储基于请求的 Lua 环境数据，其生存周期与当前请求相同 (类似 Nginx 变量)。它有一个最重要的特性：单个请求内的 rewrite (重写)，access (访问)，和 content (内容) 等各处理阶段是保持一致的。</p>\n<p>额外注意，每个请求，包括子请求，都有一份自己的 ngx.ctx 表。例如：</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">location</span> /sub</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">content_by_lua</span> <span class=\"token string\">'\n        ngx.say(\"sub pre: \", ngx.ctx.blah)\n        ngx.ctx.blah = 32\n        ngx.say(\"sub post: \", ngx.ctx.blah)\n    '</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token directive\"><span class=\"token keyword\">location</span> /main</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">content_by_lua</span> <span class=\"token string\">'\n        ngx.ctx.blah = 73\n        ngx.say(\"main pre: \", ngx.ctx.blah)\n        local res = ngx.location.capture(\"/sub\")\n        ngx.print(res.body)\n        ngx.say(\"main post: \", ngx.ctx.blah)\n    '</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>访问 GET /main 输出</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">main pre: <span class=\"token number\">73</span>\nsub pre: nil\nsub post: <span class=\"token number\">32</span>\nmain post: <span class=\"token number\">73</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>任意数据值，包括 Lua 闭包与嵌套表，都可以被插入这个“魔法”表，也允许注册自定义元方法。</p>\n<p>也可以将 ngx.ctx 覆盖为一个新 Lua 表，例如，</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\">ngx<span class=\"token punctuation\">.</span>ctx <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> foo <span class=\"token operator\">=</span> <span class=\"token number\">32</span><span class=\"token punctuation\">,</span> bar <span class=\"token operator\">=</span> <span class=\"token number\">54</span> <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><code>ngx.ctx</code> 表查询需要相对昂贵的元方法调用，这比通过用户自己的函数参数直接传递基于请求的数据要慢得多。所以不要为了节约用户函数参数而滥用此 API，因为它可能对性能有明显影响。</p>\n<p>由于 ngx.ctx 保存的是指定请求资源，所以这个变量是不能直接共享给其他请求使用的。</p>\n","text":" 不同阶段共享变量 在 OpenResty 的体系中，可以通过共享内存的方式完成不同工作进程的数据共享，可以通过 Lua 模块方式完成单个进程内不同请求的数据共享。如何完成单个请求内不同阶段的数据共享呢？最典型的例子，估计就是在 log 阶段记录一些请求的特殊变量。 ngx.ct...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F\"><span class=\"toc-text\"> 不同阶段共享变量</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"子查询","uid":"880333deb35be82c4d3989968275351e","slug":"old_topic/2016-09-17-309","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.200Z","comments":true,"path":"api/articles/old_topic/2016-09-17-309.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 子查询 Nginx 子请求是一种非常强有力的方式，它可以发起非阻塞的内部请求访问目标 location。目标 location 可以是配置文件中其他文件目录，或 任何 其他 nginx C 模块，包括 ngx_proxy、ngx_fastcgi、ngx_memc、ngx_pos...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"与其他 location 配合","uid":"66c1d79a932fd4e754d2057db394f613","slug":"old_topic/2016-09-17-311","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.179Z","comments":true,"path":"api/articles/old_topic/2016-09-17-311.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 与其他 location 配合 nginx 世界的 location 是异常强大的，毕竟 nginx 的主要应用场景是在负载均衡、API server，在不同 server、location 之间跳转更是家常便饭。利用不同 location 的功能组合，我们可以完成内部调用、流...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}