{"title":"不同阶段共享变量","uid":"4b4caaa9aaa4e586708012dea3b735d1","slug":"old_topic/2016-09-17-310","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.748Z","comments":true,"path":"api/articles/old_topic/2016-09-17-310.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<h1 id=\"不同阶段共享变量\"><a href=\"#不同阶段共享变量\" class=\"headerlink\" title=\"不同阶段共享变量\"></a>不同阶段共享变量</h1><p>在 OpenResty 的体系中，可以通过共享内存的方式完成不同工作进程的数据共享，可以通过 Lua 模块方式完成单个进程内不同请求的数据共享。如何完成单个请求内不同阶段的数据共享呢？最典型的例子，估计就是在 log 阶段记录一些请求的特殊变量。</p>\n<p>ngx.ctx 表就是为了解决这类问题而设计的。参考下面例子：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">location</span> /test &#123;</span><br><span class=\"line\">     <span class=\"attribute\">rewrite_by_lua</span> <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">         ngx.ctx.foo = 76</span></span><br><span class=\"line\"><span class=\"string\">     &#x27;</span>;</span><br><span class=\"line\">     <span class=\"attribute\">access_by_lua</span> <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">         ngx.ctx.foo = ngx.ctx.foo + 3</span></span><br><span class=\"line\"><span class=\"string\">     &#x27;</span>;</span><br><span class=\"line\">     <span class=\"attribute\">content_by_lua</span> <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">         ngx.say(ngx.ctx.foo)</span></span><br><span class=\"line\"><span class=\"string\">     &#x27;</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先 ngx.ctx 是一个表，所以我们可以对他添加、修改。它用来存储基于请求的 Lua 环境数据，其生存周期与当前请求相同 (类似 Nginx 变量)。它有一个最重要的特性：单个请求内的 rewrite (重写)，access (访问)，和 content (内容) 等各处理阶段是保持一致的。</p>\n<p>额外注意，每个请求，包括子请求，都有一份自己的 ngx.ctx 表。例如：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">location</span> /sub &#123;</span><br><span class=\"line\">    <span class=\"attribute\">content_by_lua</span> <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        ngx.say(&quot;sub pre: &quot;, ngx.ctx.blah)</span></span><br><span class=\"line\"><span class=\"string\">        ngx.ctx.blah = 32</span></span><br><span class=\"line\"><span class=\"string\">        ngx.say(&quot;sub post: &quot;, ngx.ctx.blah)</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">location</span> /main &#123;</span><br><span class=\"line\">    <span class=\"attribute\">content_by_lua</span> <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        ngx.ctx.blah = 73</span></span><br><span class=\"line\"><span class=\"string\">        ngx.say(&quot;main pre: &quot;, ngx.ctx.blah)</span></span><br><span class=\"line\"><span class=\"string\">        local res = ngx.location.capture(&quot;/sub&quot;)</span></span><br><span class=\"line\"><span class=\"string\">        ngx.print(res.body)</span></span><br><span class=\"line\"><span class=\"string\">        ngx.say(&quot;main post: &quot;, ngx.ctx.blah)</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>访问 GET /main 输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main pre: 73</span><br><span class=\"line\">sub pre: nil</span><br><span class=\"line\">sub post: 32</span><br><span class=\"line\">main post: 73</span><br></pre></td></tr></table></figure>\n\n<p>任意数据值，包括 Lua 闭包与嵌套表，都可以被插入这个“魔法”表，也允许注册自定义元方法。</p>\n<p>也可以将 ngx.ctx 覆盖为一个新 Lua 表，例如，</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ngx.ctx = &#123; foo = <span class=\"number\">32</span>, bar = <span class=\"number\">54</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ngx.ctx</code> 表查询需要相对昂贵的元方法调用，这比通过用户自己的函数参数直接传递基于请求的数据要慢得多。所以不要为了节约用户函数参数而滥用此 API，因为它可能对性能有明显影响。</p>\n<p>由于 ngx.ctx 保存的是指定请求资源，所以这个变量是不能直接共享给其他请求使用的。</p>\n","text":"不同阶段共享变量在 OpenResty 的体系中，可以通过共享内存的方式完成不同工作进程的数据共享，可以通过 Lua 模块方式完成单个进程内不同请求的数据共享。如何完成单个请求内不同阶段的数据共享呢？最典型的例子，估计就是在 log 阶段记录一些请求的特殊变量。 ngx.ctx ...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">不同阶段共享变量</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"日志输出","uid":"7971c98c6c54521c1f721d0c7bf2b182","slug":"old_topic/2016-09-17-312","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.748Z","comments":true,"path":"api/articles/old_topic/2016-09-17-312.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"日志输出你如何测试和调试你的代码呢？Lua 的两个主力作者是这样回复的： Luiz Henrique de Figueiredo：我主要是一块一块的构建，分块测试。我很少使用调试器。即使用调试器，也只是调试 C 代码。我从不用调试器调试 Lua 代码。对于 Lua 来说，在适当的...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Socket 编程发展","uid":"bb3459175ba9079fc75c2b75c372ea8d","slug":"old_topic/2016-09-17-307","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.748Z","comments":true,"path":"api/articles/old_topic/2016-09-17-307.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"text":"Socket 编程发展Linux Socket 编程领域，为了处理大量连接请求场景，需要使用非阻塞 I/O 和复用。select、poll 和 epoll 是 Linux API 提供的 I/O 复用方式，自从 Linux 2.6 中加入了 epoll 之后，高性能服务器领域得到...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}