{"title":"获取请求 body","uid":"61064bea0a023b51846839ff3c2e6c07","slug":"old_topic/2016-09-17-317","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.234Z","comments":true,"path":"api/articles/old_topic/2016-09-17-317.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h1 id=\"获取请求-body\"><a class=\"markdownIt-Anchor\" href=\"#获取请求-body\"></a> 获取请求 body</h1>\n<p>在 Nginx 的典型应用场景中，几乎都是只读取 HTTP 头即可，例如负载均衡、正反向代理等场景。但是对于 API Server 或者 Web Application ，对 body 可以说就比较敏感了。由于 OpenResty 基于 Nginx ，所以天然的对请求 body 的读取细节与其他成熟 Web 框架有些不同。</p>\n<h3 id=\"最简单的-hello\"><a class=\"markdownIt-Anchor\" href=\"#最简单的-hello\"></a> 最简单的 “Hello ****”</h3>\n<p>我们先来构造最简单的一个请求，POST 一个名字给服务端，服务端应答一个 “Hello ****”。</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">http</span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">listen</span>    <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token directive\"><span class=\"token keyword\">location</span> /test</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token directive\"><span class=\"token keyword\">content_by_lua_block</span></span> <span class=\"token punctuation\">&#123;</span>\n                local data = ngx.req.get_body_data()\n                ngx.say(\"hello \", data)\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>测试结果：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜  ~  <span class=\"token function\">curl</span> <span class=\"token number\">127.0</span>.0.1/test <span class=\"token parameter variable\">-d</span> jack\nhello nil<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>大家可以看到 data 部分获取为空，如果你熟悉其他 web 开发框架，估计立刻就觉得 OpenResty 弱爆了。查阅一下官方 wiki 我们很快知道，原来我们还需要添加指令 lua_need_request_body 。究其原因，主要是 Nginx 诞生之初主要是为了解决负载均衡情况，而这种情况，是不需要读取 body 就可以决定负载策略的，所以这个点对于 API Server 和 Web Application 开发的同学有点怪。</p>\n<p>参看下面例子：</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">http</span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">listen</span>    <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\"># 默认读取 body</span>\n        <span class=\"token directive\"><span class=\"token keyword\">lua_need_request_body</span> <span class=\"token boolean\">on</span></span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token directive\"><span class=\"token keyword\">location</span> /test</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token directive\"><span class=\"token keyword\">content_by_lua_block</span></span> <span class=\"token punctuation\">&#123;</span>\n                local data = ngx.req.get_body_data()\n                ngx.say(\"hello \", data)\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>再次测试，符合我们预期：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜  ~  <span class=\"token function\">curl</span> <span class=\"token number\">127.0</span>.0.1/test <span class=\"token parameter variable\">-d</span> jack\nhello jack<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>如果你只是某个接口需要读取 body（并非全局行为），那么这时候也可以显示调用 ngx.req.read_body() 接口，参看下面示例：</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">http</span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">listen</span>    <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token directive\"><span class=\"token keyword\">location</span> /test</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token directive\"><span class=\"token keyword\">content_by_lua_block</span></span> <span class=\"token punctuation\">&#123;</span>\n                ngx.req.read_body()\n                local data = ngx.req.get_body_data()\n                ngx.say(\"hello \", data)\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"body-偶尔读取不到\"><a class=\"markdownIt-Anchor\" href=\"#body-偶尔读取不到\"></a> body 偶尔读取不到？</h3>\n<p>ngx.req.get_body_data() 读请求体，会偶尔出现读取不到直接返回 nil 的情况。</p>\n<p>如果请求体尚未被读取，请先调用 <a href=\"#ngxreqread_body\">ngx.req.read_body</a> (或打开 <a href=\"#lua_need_request_body\">lua_need_request_body</a> 选项强制本模块读取请求体，此方法不推荐）。</p>\n<p>如果请求体已经被存入临时文件，请使用 <a href=\"#ngxreqget_body_file\">ngx.req.get_body_file</a> 函数代替。</p>\n<p>如需要强制在内存中保存请求体，请设置 <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size\">client_body_buffer_size</a> 和 <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size\">client_max_body_size</a> 为同样大小。</p>\n<p>参考下面代码：</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">http</span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">listen</span>    <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\"># 强制请求 body 到临时文件中（仅仅为了演示）</span>\n        <span class=\"token directive\"><span class=\"token keyword\">client_body_in_file_only</span> <span class=\"token boolean\">on</span></span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token directive\"><span class=\"token keyword\">location</span> /test</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token directive\"><span class=\"token keyword\">content_by_lua_block</span></span> <span class=\"token punctuation\">&#123;</span>\n                function getFile(file_name)\n                    local f = assert(io.open(file_name, 'r'))\n                    local string = f:read(\"*all\")\n                    f:close()\n                    return string\n                end\n\n                ngx.req.read_body()\n                local data = ngx.req.get_body_data()\n                if nil == data then\n                    local file_name = ngx.req.get_body_file()\n                    ngx.say(\">> temp file: \", file_name)\n                    if file_name then\n                        data = getFile(file_name)\n                    end\n                end\n\n                ngx.say(\"hello \", data)\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>测试结果：</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\">➜  ~  curl 127.0.0.1/test -d jack\n>> temp file: /Users/rain/Downloads/nginx/client_body_temp/0000000018\nhello jack<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>由于 Nginx 是为了解决负载均衡场景诞生的，所以它默认是不读取 body 的行为，会对 API Server 和 Web Application 场景造成一些影响。根据需要正确读取、丢弃 body 对 OpenResty 开发是至关重要的。</p>\n","text":" 获取请求 body 在 Nginx 的典型应用场景中，几乎都是只读取 HTTP 头即可，例如负载均衡、正反向代理等场景。但是对于 API Server 或者 Web Application ，对 body 可以说就比较敏感了。由于 OpenResty 基于 Nginx ，所以天...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82-body\"><span class=\"toc-text\"> 获取请求 body</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-hello\"><span class=\"toc-text\"> 最简单的 “Hello ****”</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#body-%E5%81%B6%E5%B0%94%E8%AF%BB%E5%8F%96%E4%B8%8D%E5%88%B0\"><span class=\"toc-text\"> body 偶尔读取不到？</span></a></li></ol></li></ol></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"简单API Server框架","uid":"00e0afc1c0a95123fda2364773b4d3e8","slug":"old_topic/2016-09-17-316","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.212Z","comments":true,"path":"api/articles/old_topic/2016-09-17-316.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 简单API Server框架 实现一个最最简单的数学计算：加、减、乘、除，给大家演示如何搭建简单的 API Server。 按照前面几章的写法，先来看看加法、减法示例代码： worker_processes 1; #nginx worker 数量 error_log logs/...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"helloworld","uid":"7feb1bc48352a2bd04c7a6d1cf8eb726","slug":"old_topic/2016-09-17-314","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.165Z","comments":true,"path":"api/articles/old_topic/2016-09-17-314.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" HelloWorld HelloWorld 是我们亘古不变的第一个入门程序。但是 OpenResty 不是一门编程语言，跟其他编程语言的 HelloWorld 不一样，让我们看看都有哪些不一样吧。 创建工作目录 OpenResty 安装之后就有配置文件及相关的目录的，为了工作目...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}