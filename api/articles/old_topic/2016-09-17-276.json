{"title":"微博API发送微博","uid":"a7777311d1e67a84d45b8c65389d0ce5","slug":"old_topic/2016-09-17-276","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.215Z","comments":true,"path":"api/articles/old_topic/2016-09-17-276.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>使用微博的API和SDK的其中的关键一步是取得token. 而取得token是需要通过oauth2认证才可以得到。</p>\n<p>下面是一段取得token的代码逻辑：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">APP_KEY =<span class=\"string\">&#x27;012345678&#x27;</span></span><br><span class=\"line\">APP_SECRET = <span class=\"string\">&#x27;01234567891011121314151617181920&#x27;</span></span><br><span class=\"line\">CALL_BACK= <span class=\"string\">&#x27;http://www.lua.ren/callback&#x27;</span></span><br><span class=\"line\">client = weibo.APIClient(APP_KEY, APP_SECRET, CALL_BACK)</span><br><span class=\"line\">auth_url = client.get_authorize_url()</span><br><span class=\"line\">login_url = <span class=\"string\">&#x27;https://api.weibo.com/oauth2/authorize&#x27;</span></span><br><span class=\"line\">params = urllib.urlencode(&#123;<span class=\"string\">&#x27;action&#x27;</span> : <span class=\"string\">&#x27;submit&#x27;</span>,<span class=\"string\">&#x27;response_type&#x27;</span> : <span class=\"string\">&#x27;code&#x27;</span>,<span class=\"string\">&#x27;redirect_uri&#x27;</span> : CALL_BACK,<span class=\"string\">&#x27;client_id&#x27;</span> : APP_KEY,<span class=\"string\">&#x27;userId&#x27;</span> : <span class=\"string\">&#x27;userid&#x27;</span>,<span class=\"string\">&#x27;passwd&#x27;</span> : <span class=\"string\">&#x27;password&#x27;</span>,&#125;)</span><br><span class=\"line\">url = client.get_authorize_url()</span><br></pre></td></tr></table></figure>\n<p>APP_KEY各APP_SECRET是申请OPEN API时被分配的，CALL_BACK是在微博开放API后台自定义的，当你用浏览器访问client.get_authorize_url()函数返回的url时，微博开发接口会调用这个callback的url，调用中包含了code这个字段，通过code可以取得token。</p>\n<p>只有取得了token之后，才可以正常的访问微博的API。</p>\n<p>代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = client.request_access_token(code)</span><br><span class=\"line\">client.set_access_token(r.access_token, r.expires_in)</span><br></pre></td></tr></table></figure>\n<p>发送微博代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">content = <span class=\"string\">&#x27;test&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> content:</span><br><span class=\"line\">    client.statuses.update.post(status=content)</span><br></pre></td></tr></table></figure>","text":"使用微博的API和SDK的其中的关键一步是取得token. 而取得token是需要通过oauth2认证才可以得到。 下面是一段取得token的代码逻辑： 123456789APP_KEY =&#x27;012345678&#x27;APP_SECRET = &#x27;01234...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"又见QT","uid":"92cca58992d4502022c1dbbf5585cfdb","slug":"old_topic/2016-09-17-274","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.149Z","comments":true,"path":"api/articles/old_topic/2016-09-17-274.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"MinGW https://sourceforge.net/projects/mingw/?source=top3_dlp_t5 PyQT5 https://riverbankcomputing.com/software/pyqt/download5 PyQT4 https://...","link":"","photos":[],"count_time":{"symbolsCount":512,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Threading的Timer是否可以被wait和communicate阻塞","uid":"1f0e7f34ab02983eb011a2f068cfda64","slug":"old_topic/2016-09-17-268","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.193Z","comments":true,"path":"api/articles/old_topic/2016-09-17-268.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者：糖果 测试的内容是将Timer的使用和Popen的使用混合在一起，测试当wait()和communicate()被调用时，是否会阻塞主进程的Timer。 找到Timer在Python2.7里的源码位置： 12345678910111213141516171819202122...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}