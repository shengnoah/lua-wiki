{"title":"如何在SAE上架设RPC服务与Openresty的Lua服务通信","uid":"1c16f4ddd5c0935af18ce72063de0291","slug":"old_topic/2016-09-17-123","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.178Z","comments":true,"path":"api/articles/old_topic/2016-09-17-123.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>作者：糖果</p>\n<p>有时候我们写的服务可能会部署到很同种不同类型的服务器上，有一些数据，可能不便于存在本地，需要一个数据中心，保存这些数据。</p>\n<p>我们要求是这样的：</p>\n<p>1．客户端服务要周期性的去服务器上拉取数据。（存在SAE MySQL中）。</p>\n<p>2．不使用长连接的方式通信，使用基于HTTP的协议。</p>\n<p>3．客户端与数据库交互不依赖服务器端采用什么数据库，抽象出一层数据访问层。</p>\n<p>基于以上三点：</p>\n<p>服务器端：我们将服务器服务架设到SAE的云端，使用SAE支持的Python语言，WEB框架使用的Django,通过RPC协议，为客户端提供服务。服务端的数据存储在SAE的MySQL数据库中，为使服务器端可以对外开发RPC服务接口，使用开源的RPC服务端解决方案RPC4Django。</p>\n<p>客户端：这里的客户端其是架设在另一台服务器的Openresty服务，使用Lua语言进行扩展，加入了定时拉取访问数据的流程演示模块，至于如何接定RPC接口，传输什么数据，看具体的实际业务，这里只是通过程序演示这个机制如何在SAE上完成变互的过程。</p>\n<p>客户访问端使用持术是用Openresty做服务器，用Lua Lapis框架写成应用。在客户访问端需要做以下几件事情：</p>\n<p>1.安装Openresty服务器，按装Lua Lapis框架。</p>\n<p>2.使用Lua  Lapis创建一个Openresty的项目。</p>\n<p>3.配置Openresty，创建一个定时作任务。</p>\n<p>这时我们先跳出Lua阶段，进行SAE端Python的RPC服务的,部署和编码，然后回来完成，客户端的剩下的两个动作。</p>\n<p>4.用Lua RPC Client访问SAE上的RPC服务。</p>\n<p>5.将取得的数据，存储到客户端的Openresty服务器的ShareDiction中，供本地其它业务使用些数据。</p>\n<p>下面开始：</p>\n<p>第1步：Openresty服务器安装和Lapis框架部署（此处只介绍Lapis的安装），更详细的信息请参考如下文章。</p>\n<p>a). 安装luarocks。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sudo apt-get install luarocks<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>b). 通过luarocks安装lapis框架。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sudo luarocks install lapis<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>第2步：用Lapis 创建Openresty工程.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lapis new<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>命令执行后，会生成下面所示的目录结构。</p>\n<p>3.在Openresty中创建一个定时任务。</p>\n<p>定时器的实现思想如下：</p>\n<p>让Openresty去加载一个lua脚本，脚本通过启动一个timer设定，调用一个函数，在被调用的函数内部，循环递归的进行time设定，调用这个被周函数本身，利用这种周期性的调用事件，我们定时递归的函数体中，执行一个函数过程CallRPC（）去通过RPC协议访问SAE云上的数据。</p>\n<p>RPC接口定义与实现，在下面接下来的Django部分会详细说明，下面就是提到的函数。此函数的主要的目的是6秒钟的时间间隔，通过RPC协议，拉取SAE上Mysql数据库里的数据，至于传输什么数据是和你的业务直接相关的，我们此处就使用一个简单的数据结构来说明问题。</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\"><span class=\"token keyword\">local</span> handler\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span>premature<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">)</span>\n\n     <span class=\"token comment\">--CallRPC就是Lua通过JSON.RPC访问SAE的RPC服务器。</span>\n\n     <span class=\"token function\">CallRPC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n     <span class=\"token comment\">--递归的timer，重复调用handler函数。</span>\n\n     <span class=\"token keyword\">local</span> ok<span class=\"token punctuation\">,</span> err <span class=\"token operator\">=</span> ngx<span class=\"token punctuation\">.</span>timer<span class=\"token punctuation\">.</span><span class=\"token function\">at</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">,</span> <span class=\"token string\">\"params-data\"</span><span class=\"token punctuation\">)</span>\n\n     ngx<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>ngx<span class=\"token punctuation\">.</span>DEBUG<span class=\"token punctuation\">,</span> <span class=\"token string\">\"ok:\"</span><span class=\"token punctuation\">,</span> ok<span class=\"token punctuation\">,</span> <span class=\"token string\">\" err:\"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">end</span>\n\n\n<span class=\"token comment\">--第一次设定timer，调用hander函数。</span>\n\n<span class=\"token keyword\">local</span> ok<span class=\"token punctuation\">,</span> err <span class=\"token operator\">=</span> ngx<span class=\"token punctuation\">.</span>timer<span class=\"token punctuation\">.</span><span class=\"token function\">at</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">,</span><span class=\"token string\">\"params-data\"</span><span class=\"token punctuation\">)</span>\n\nngx<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>ngx<span class=\"token punctuation\">.</span>DEBUG<span class=\"token punctuation\">,</span> <span class=\"token string\">\"ok:\"</span><span class=\"token punctuation\">,</span> ok<span class=\"token punctuation\">,</span><span class=\"token string\">\" err:\"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">--判断第一次调用是否成功，如查不成功，把问题原因打印出来。</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> ok <span class=\"token keyword\">then</span>\n\n       ngx<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>ngx<span class=\"token punctuation\">.</span>ERR<span class=\"token punctuation\">,</span> <span class=\"token string\">\"err:\"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">end</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>创建SAE上的RPC服务：</p>\n<p>完成创建工作需要五步：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>创建一个Django工程 。</p>\n</li>\n<li class=\"lvl-3\">\n<p>安装RPC4Django。</p>\n</li>\n<li class=\"lvl-3\">\n<p>.创建立数据库表。</p>\n</li>\n<li class=\"lvl-3\">\n<p>实现RPC服务接口。</p>\n</li>\n<li class=\"lvl-3\">\n<p>启动RPC服务。</p>\n</li>\n</ol>\n<p>我们先暂停Openresty的部分，先介绍如何在SAE构建RPC服务器。</p>\n<p>之前已经提过，构SAE上的RPC服务使用的是SAE的PYTHON服务，使用的也是SAE天然支持的Django框架。下面介绍的是创建一个Django工程，SAE天然支持 Django, Tornado, Flask框加。如果需要更多信息，请参考如下文章。</p>\n<p><a href=\"http://www.epubit.com.cn/article/143\">http://www.epubit.com.cn/article/143</a></p>\n<p>服务器端</p>\n<p>第一步：创建一个Django工程 。</p>\n<p>a).  创建工程。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">django-admin.pystartproject testrpc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>b).  在工程内创建APP。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">pythonmanage.py startapp myrpc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>两格指令执行后，系统上建立如下的目录结构。</p>\n<p>这表明Djago已经成功能完成创建工程和APP。</p>\n<p>第二步：安装RPC4Django。</p>\n<p>RPC服务主要靠的就是用RPC4Django来实现，rpc4django是一个开源项目，项目的地址如下：<a href=\"https://github.com/davidfischer/rpc4django\">https://github.com/davidfischer/rpc4django</a></p>\n<p>rpc4django也是一个Django的App，使用的话，只要在setting.py配置文件中引用即可。</p>\n<p>修改testrpc文件夹中的setting.py文件,如下图：</p>\n<p>把rpc4django加入到工程安装的APP的列表里，这样就可以像引用普APP一样使用rpc4django了。</p>\n<p>第三步.创建立数据库表。</p>\n<p>Django是MVC模式的Python框加，并且支持ORM，只要定一义一个Python的Model类，就可以同步生成数据库表。</p>\n<p>我们在myrpc文件夹下的models.py里面加入表定义类，如下图：</p>\n<p>创建完Model模块类后，需要同步一下DB，将Django根据类的定义生成对应的DB表格。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">pythonmanage.py syncdb<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>如果之前安装了SAE的本地运行环境的话，<a href=\"http://xn--cloudsql-hu2mn08ab85gqx3a.py\">可能使用cloudsql.py</a> 直接访问远端的SAE数据库命令行。</p>\n<p>执行后同步后，我们查看一下MyRPC数据库表的定义。</p>\n<p>上图所示，表生成成功。</p>\n<p>第四步.实现RPC服务接口。</p>\n<p>因为使用rpc4django，生成一个RPC接口，就变的简单很多。</p>\n<p>之前在新建的每一个Django App的时候，对应每个APP文件夹都有一个__init__.py文 ，我们在此文件中声明函数，并且使用rpcmethod装饰器，就会对应产生一个RPC服务接口，可以提供给客户端访问使用。这里我们就创建了一个叫做testrpc.MyRPC的RPC服务接口，返回的数据类型是一个数驵元素。这个数组的取得，就是通过Django的ORM模型，访问了我们之前所定义的MySQL数据表MyRPC。</p>\n<p>第五步：启动RPC服务。</p>\n<p>经过以上四步，一个最简单的SAE上的RPC服务就架设完了，让我们启到一个这个应用，然后RPC服务才可用。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Python manager.py runserver 127.0.0.1:8080<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>回到之前的Lua介绍，还剩下的步骤:</p>\n<p>1.Lua调用 SAE上的RPC服务接口。</p>\n<p>2.将返回的数据写入Openresty的ShareDiction中。</p>\n<p>3.使用Lapis模板系统，将返回结果显示到网页上。</p>\n<p>（此部分略，可参考此连接内容：<a href=\"http://www.epubit.com.cn/article/158%EF%BC%89\">http://www.epubit.com.cn/article/158）</a></p>\n<p>第一步：如何使用Lua RPC客户端访问RPC。</p>\n<p>Lua访问RPC使用的库是JSON库的RPC机能，原来还是通过HTTP向服务器发送一定格式的</p>\n<p>JSON数据，并将服务器返回的数据，从JSON数据专成函数可以直接使用数据。</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\">json<span class=\"token operator\">=</span>require<span class=\"token string\">\"json\"</span>\n\nrequire<span class=\"token string\">\"json.rpc\"</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">CallRPC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\nlist<span class=\"token punctuation\">,</span> error <span class=\"token operator\">=</span>json<span class=\"token punctuation\">.</span>rpc<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"http://XXX.sinaapp.com/RPC\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"testrpc.MyRPC\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> _key<span class=\"token punctuation\">,</span> _val <span class=\"token keyword\">in</span> <span class=\"token function\">pairs</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n    print  _val\n\n    print <span class=\"token string\">\"\\n\"</span>\n<span class=\"token keyword\">end</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>运行后会把SAE上数据库表里的数据返回，并打印出来，如下图：</p>\n<p>第二步：将返回的数据写入Openresty的ShareDiction中。</p>\n<p>我们已经通过Lua RPC客户端，访问RPC服务，将数据返回了，我们还需要将读取的数据存储到Openresty的ShareDiction里，提供给Openresty的Lua系统内部其它模块使用。</p>\n<p>使用ShareDiction首先要修改.conf配置文件，需要在文件加入如下内容：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">http &#123;\n\n  include mime.types;\n\n  lua_shared_dict g_dict 10m;\n\n  ...<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>创建了一个名字为g_dict的10m的共享字典，我们需要的就是将取后的数据，存入到共享字典中，封闭一个简单的函数来存储返回值。</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\"><span class=\"token keyword\">function</span> <span class=\"token function\">set_key</span><span class=\"token punctuation\">(</span>_key<span class=\"token punctuation\">,</span>_value<span class=\"token punctuation\">)</span>  \n\n  <span class=\"token keyword\">if</span> _key <span class=\"token keyword\">then</span>\n\n    <span class=\"token keyword\">local</span> g_dict <span class=\"token operator\">=</span> ngx<span class=\"token punctuation\">.</span>shared<span class=\"token punctuation\">.</span>g_dict    \n\n    g_dict<span class=\"token punctuation\">:</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>_key<span class=\"token punctuation\">,</span> _value<span class=\"token punctuation\">)</span>    \n\n  <span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">end</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>第三步：使用Lapis模板系统，将返回结果显示到网页上。</p>\n<p>（此部分略，可参考此连接内容：<a href=\"http://www.epubit.com.cn/article/158%EF%BC%89\">http://www.epubit.com.cn/article/158）</a></p>\n<p>接下来，还会介绍，如何利用Django的用户验证系统，进行RPC的限制性访问。</p>\n<p>（通过JS调用SAE上的RPC服务。）</p>\n<p>如何在SAE上，使用BeautifulSoup在线分析指定网站内容的文章。</p>\n<p>作者：糖果</p>\n<p>PS:转载到其它平台请注明作者姓名及原文链接，请勿用于商业用途。</p>\n","text":"作者：糖果 有时候我们写的服务可能会部署到很同种不同类型的服务器上，有一些数据，可能不便于存在本地，需要一个数据中心，保存这些数据。 我们要求是这样的： 1．客户端服务要周期性的去服务器上拉取数据。（存在SAE MySQL中）。 2．不使用长连接的方式通信，使用基于HTTP的协议...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"GoTTY简介：共享字符终端，变网页应用","uid":"00c93259923cc318f00ee1ff616c73ad","slug":"old_topic/2016-09-17-122","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.153Z","comments":true,"path":"api/articles/old_topic/2016-09-17-122.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"作者：糖果 一.简介。 GoTTY是一个用Go语言开发的工具，这个工具可以把你的Uinx系列操作系统的命令字符终端，共享成普通的网页应用展示出来。 使用tmux工具进行终端分屏。 二.安装。 安装用两种方式： a).安装目标机器上有GO开始环境。 $ go get github....","link":"","photos":[],"count_time":{"symbolsCount":709,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"使用VNC访问VPS的XWindows桌面","uid":"6f09c7b7e8900bc4f645404ba465a39b","slug":"old_topic/2016-09-17-124","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-19T07:36:23.880Z","comments":true,"path":"api/articles/old_topic/2016-09-17-124.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"作者：糖果 一般的VPS都提供不SSH得登录方式，通过terminal操作服务器， 除了这种方式，还有让VPS拥有XWindows的Desktop操作模式。 在这里概要的总结一下，如何用VNC访问VPS上的Linux桌面系统。 1：首先要给linux安装桌面系统，VPS使用的是C...","link":"","photos":[],"count_time":{"symbolsCount":799,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}