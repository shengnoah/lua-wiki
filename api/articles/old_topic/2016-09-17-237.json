{"title":"Openresty使用Log_by_lua推送数据到Syslog服务器","uid":"a808962806fc68aa9d5c82e6e01d4f97","slug":"old_topic/2016-09-17-237","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.219Z","comments":true,"path":"api/articles/old_topic/2016-09-17-237.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"content":"<p>LOG_BY_LUA推送数据到Syslog服务器</p>\n<h3>正文：</h3> \n<p>Openresy的resty_logger组件，提供了一种可能，就是在Openresty的Log阶段，推送数据到syslog-ng服务器上，Openresty的执行阶段，其实是一种虚拟化的逻辑业务划分，如果从TCP数据包的角度来看，是分不出什么init, content，log等阶段，而log阶段应该是所有的Openresty执行阶段的最后一个阶段，关于执行阶段的顺序，可以参照下面的这个图：</p>\n<img src=\"http://ww4.sinaimg.cn/mw690/6d579ff4gw1f3wljbt257j20rx0pa77c.jpg\" alt=\"Openresty执行阶段\" /> \n<p>对于resty-logger的执行处理，如果要划分几大处理的话，可以分成， syslog服务器信息定义，初始化连接，写入log数据。可以在代码中，比较清晰的看出来，官方的例子如下，一些参数进行了调整：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log_by_lua &#x27;</span><br><span class=\"line\">           local logger = require &quot;resty.logger.socket&quot;</span><br><span class=\"line\">           ngx.log(ngx.ERR, &quot;Test Syslog: &quot;, &quot;call&quot;)</span><br><span class=\"line\">           if not logger.initted() then</span><br><span class=\"line\">               local ok, err = logger.init &#123;</span><br><span class=\"line\">                   host=&quot;127.0.0.1&quot;,</span><br><span class=\"line\">                   port=810,</span><br><span class=\"line\">                   sock_type=&quot;udp&quot;,</span><br><span class=\"line\">                   flush_limit = 1,</span><br><span class=\"line\">                   --drop_limit = 5678</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               if not ok then</span><br><span class=\"line\">                   ngx.log(ngx.ERR, &quot;failed to initialize the logger: &quot;, err)</span><br><span class=\"line\">                   return</span><br><span class=\"line\">               end</span><br><span class=\"line\">           end</span><br><span class=\"line\"></span><br><span class=\"line\">           -- construct the custom access log message in</span><br><span class=\"line\">           -- the Lua variable &quot;msg&quot;</span><br><span class=\"line\">           local bytes, err = logger.log(&quot;test&quot;)</span><br><span class=\"line\">           if err then</span><br><span class=\"line\">               ngx.log(ngx.ERR, &quot;failed to log message: &quot;, err)</span><br><span class=\"line\">               return</span><br><span class=\"line\">           end</span><br><span class=\"line\">       &#x27;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上面的代码，需要注意的是 <strong>flush_limit</strong>  这个参数，在实际的联动Openresty和Syslog-ng服务的过程中，可能更希望看到实时写入效果，比如说， 用tail -f 监控syslog-ng端的日志服务，然后在浏览器中，请求Openresty的WEB服务，访问一次,syslog文件就写入一条，如果是这样话，需要把<strong>flush_limit</strong>，设置等于1，不然会，等待log数据积攒到一定的数据（我们自己指定，&gt;1）才向syslog服务器的服务端口推送一次。</p>\n<h3>此阶段有那些数据可输出？</h3> \n<p>做一个小实验，以下的API，都可以在这个阶段调用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- construct the custom access log message in</span><br><span class=\"line\">-- the Lua variable &quot;msg&quot;</span><br><span class=\"line\">local url = ngx.var.uri</span><br><span class=\"line\">local method = ngx.req.get_method()</span><br><span class=\"line\">local headers = ngx.req.raw_header(true)</span><br><span class=\"line\">-- tbl</span><br><span class=\"line\">local params_var = ngx.req.get_uri_args()</span><br><span class=\"line\">local client_ip = ngx.var.remote_addr</span><br><span class=\"line\">-- tbl</span><br><span class=\"line\">local body_var = ngx.req.get_post_args()</span><br><span class=\"line\">local user_agent = ngx.req.get_headers()[&quot;User-Agent&quot;]</span><br><span class=\"line\">local referer = ngx.req.get_headers()[&quot;Referer&quot;]</span><br><span class=\"line\">local cookies = ngx.req.get_headers()[&quot;Cookie&quot;]</span><br></pre></td></tr></table></figure>\n<p>这样就可以把这些数据，通过“分隔符”推送到syslog-ng服务器上，然后用logstash安照正则，分词解开，将对应的字段，以JSON形式存到ES里。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local bytes, err = logger.log(client_ip..&quot; &quot;..table.concat(params_var)..&quot; &quot;..table.concat(body_var)..&quot; &quot;..user_agent..&quot; &quot;..referer..&quot; &quot;..cookies..&quot; &quot;..url..&quot; &quot;..method)</span><br></pre></td></tr></table></figure>\n<p><strong>后记：</strong></p>\n<p>上面的table.concat的数据其实连在一起时，会对解析产生困扰，最好不用，此处只是为了简单的实验用。</p>\n<p>最后，没有给出完整的代码，直接把logger.log手动的替换一下，就可以完成这个实验，剩下就是自定义和整合问题。</p>\n<p>如果是用Logstash向ES导入数据，也可不使用这种方式，直接使用远程代理的方式向远端口的ES导入数据。而使用这种，会涉及到修改Openresty的Conf中的代理代码，好处是可以更细致的定制log输出的格式。</p>\n","text":"LOG_BY_LUA推送数据到Syslog服务器 正文： Openresy的resty_logger组件，提供了一种可能，就是在Openresty的Log阶段，推送数据到syslog-ng服务器上，Openresty的执行阶段，其实是一种虚拟化的逻辑业务划分，如果从TCP数据包的...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">正文：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">此阶段有那些数据可输出？</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua的HTTP库","uid":"7c6c0bd644fe170c87ec457e7a5178a5","slug":"old_topic/2016-09-17-235","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.158Z","comments":true,"path":"api/articles/old_topic/2016-09-17-235.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"其实除lua curl，还有另外一个库，也用以用HTTP请求。就是lua socket的http请求。 可以用这种方式进行http请求和简单的数据爬取，然后用正则，对返回的数据进行分析。 123http = require(&quot;socket.http&quot;)body...","link":"","photos":[],"count_time":{"symbolsCount":206,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Openresty的Lua各阶段模块执行的顺序","uid":"c71d78db21b611560e342ecd25e79bf6","slug":"old_topic/2016-09-17-228","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.203Z","comments":true,"path":"api/articles/old_topic/2016-09-17-228.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"text":"by 糖果收集 ","link":"","photos":[],"count_time":{"symbolsCount":9,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}