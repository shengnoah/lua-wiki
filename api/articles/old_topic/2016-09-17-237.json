{"title":"Openresty使用Log_by_lua推送数据到Syslog服务器","uid":"a808962806fc68aa9d5c82e6e01d4f97","slug":"old_topic/2016-09-17-237","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.219Z","comments":true,"path":"api/articles/old_topic/2016-09-17-237.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>LOG_BY_LUA推送数据到Syslog服务器</p>\n<h3>正文：</h3> \n<p>Openresy的resty_logger组件，提供了一种可能，就是在Openresty的Log阶段，推送数据到syslog-ng服务器上，Openresty的执行阶段，其实是一种虚拟化的逻辑业务划分，如果从TCP数据包的角度来看，是分不出什么init, content，log等阶段，而log阶段应该是所有的Openresty执行阶段的最后一个阶段，关于执行阶段的顺序，可以参照下面的这个图：</p>\n<img src=\"http://ww4.sinaimg.cn/mw690/6d579ff4gw1f3wljbt257j20rx0pa77c.jpg\" alt=\"Openresty执行阶段\" /> \n<p>对于resty-logger的执行处理，如果要划分几大处理的话，可以分成， syslog服务器信息定义，初始化连接，写入log数据。可以在代码中，比较清晰的看出来，官方的例子如下，一些参数进行了调整：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">log_by_lua &#39;\n           local logger &#x3D; require &quot;resty.logger.socket&quot;\n           ngx.log(ngx.ERR, &quot;Test Syslog: &quot;, &quot;call&quot;)\n           if not logger.initted() then\n               local ok, err &#x3D; logger.init &#123;\n                   host&#x3D;&quot;127.0.0.1&quot;,\n                   port&#x3D;810,\n                   sock_type&#x3D;&quot;udp&quot;,\n                   flush_limit &#x3D; 1,\n                   --drop_limit &#x3D; 5678\n               &#125;\n               if not ok then\n                   ngx.log(ngx.ERR, &quot;failed to initialize the logger: &quot;, err)\n                   return\n               end\n           end\n\n           -- construct the custom access log message in\n           -- the Lua variable &quot;msg&quot;\n           local bytes, err &#x3D; logger.log(&quot;test&quot;)\n           if err then\n               ngx.log(ngx.ERR, &quot;failed to log message: &quot;, err)\n               return\n           end\n       &#39;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面的代码，需要注意的是 <strong>flush_limit</strong>  这个参数，在实际的联动Openresty和Syslog-ng服务的过程中，可能更希望看到实时写入效果，比如说， 用tail -f 监控syslog-ng端的日志服务，然后在浏览器中，请求Openresty的WEB服务，访问一次,syslog文件就写入一条，如果是这样话，需要把<strong>flush_limit</strong>，设置等于1，不然会，等待log数据积攒到一定的数据（我们自己指定，&gt;1）才向syslog服务器的服务端口推送一次。</p>\n<h3>此阶段有那些数据可输出？</h3> \n<p>做一个小实验，以下的API，都可以在这个阶段调用。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-- construct the custom access log message in\n-- the Lua variable &quot;msg&quot;\nlocal url &#x3D; ngx.var.uri\nlocal method &#x3D; ngx.req.get_method()\nlocal headers &#x3D; ngx.req.raw_header(true)\n-- tbl\nlocal params_var &#x3D; ngx.req.get_uri_args()\nlocal client_ip &#x3D; ngx.var.remote_addr\n-- tbl\nlocal body_var &#x3D; ngx.req.get_post_args()\nlocal user_agent &#x3D; ngx.req.get_headers()[&quot;User-Agent&quot;]\nlocal referer &#x3D; ngx.req.get_headers()[&quot;Referer&quot;]\nlocal cookies &#x3D; ngx.req.get_headers()[&quot;Cookie&quot;]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这样就可以把这些数据，通过“分隔符”推送到syslog-ng服务器上，然后用logstash安照正则，分词解开，将对应的字段，以JSON形式存到ES里。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">local bytes, err &#x3D; logger.log(client_ip..&quot; &quot;..table.concat(params_var)..&quot; &quot;..table.concat(body_var)..&quot; &quot;..user_agent..&quot; &quot;..referer..&quot; &quot;..cookies..&quot; &quot;..url..&quot; &quot;..method)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>后记：</strong></p>\n<p>上面的table.concat的数据其实连在一起时，会对解析产生困扰，最好不用，此处只是为了简单的实验用。</p>\n<p>最后，没有给出完整的代码，直接把logger.log手动的替换一下，就可以完成这个实验，剩下就是自定义和整合问题。</p>\n<p>如果是用Logstash向ES导入数据，也可不使用这种方式，直接使用远程代理的方式向远端口的ES导入数据。而使用这种，会涉及到修改Openresty的Conf中的代理代码，好处是可以更细致的定制log输出的格式。</p>\n","text":"LOG_BY_LUA推送数据到Syslog服务器 正文： Openresy的resty_logger组件，提供了一种可能，就是在Openresty的Log阶段，推送数据到syslog-ng服务器上，Openresty的执行阶段，其实是一种虚拟化的逻辑业务划分，如果从TCP数据包的...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">正文：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">此阶段有那些数据可输出？</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Lua的HTTP库","uid":"7c6c0bd644fe170c87ec457e7a5178a5","slug":"old_topic/2016-09-17-235","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.158Z","comments":true,"path":"api/articles/old_topic/2016-09-17-235.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"其实除lua curl，还有另外一个库，也用以用HTTP请求。就是lua socket的http请求。 可以用这种方式进行http请求和简单的数据爬取，然后用正则，对返回的数据进行分析。 http &#x3D; require(&quot;socket.http&quot;) b...","link":"","photos":[],"count_time":{"symbolsCount":225,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"LVS负载均衡下的Openresty间的主从Redis同步","uid":"1e50e730134daba789397d1d6a4f834b","slug":"old_topic/2016-09-17-238","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.204Z","comments":true,"path":"api/articles/old_topic/2016-09-17-238.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"LVS负载均衡下的Openresty间的主从redis同步 正文： 像一般在多台提供相同服务的Openresty服务前端会挂F5或是Ha,做为负载均衡，因为逻辑关系有时会用共享使用一份Redis，如果这时，使用Redis的主从模式，就可以很好共享一份Redis服务的数据，但从时间...","link":"","photos":[],"count_time":{"symbolsCount":595,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}