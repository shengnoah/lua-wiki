{"title":"C模拟多态","uid":"f9f6eed6d27827bc96782faa045f082a","slug":"old_topic/2016-09-17-25","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.185Z","comments":true,"path":"api/articles/old_topic/2016-09-17-25.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>【问题】多态的虚函数调用，含虚函数对象大小计算，字节对齐，函数覆盖，构造与析函数的执行顺序,This指针。</p>\n<p>【简介】首先，需要介绍一下用C语言实现C<ins>的单根继承，然后分析一下构造函数和析构函数的执行顺序。看看C</ins>都在背后做了什么，这也是C<ins>的基本内容，不涉及哲学和C</ins>软件的复用性讨论，立足于，C++是对C的扩展，Class是对结构体的扩展，用struct和变量的讨论，代替class和属性。</p>\n<p>【概念】</p>\n<p>1.继承：子类继承父类，就是被叫做子类的结构体内，含有称为父类类型的结构体变量。例：drived结构体内含有base结构类型的变量。</p>\n<p>2.多态：在具有包含关系的结构体间的强类型转换，通过修改结构体内，指向虚表的，指针变量的内容，使其指向不同的虚表（虚表：指针函数结构体），来实现虚函数调用的功能。</p>\n<p>【代码】<br>\n[code]<br>\n#include&lt;stdlib.h&gt;<br>\n#include&lt;stdio.h&gt;</p>\n<p>typedef void(*F_BASE_A)(void *obj);<br>\ntypedef void(*F_BASE_B)(void *obj);<br>\ntypedef void(*F_DRIVED_B)(void *obj);</p>\n<p>void f_base_a(void *obj) {<br>\nprintf(“base class function a is called!\\n”);<br>\n}</p>\n<p>void f_base_b(void *obj) {<br>\nprintf(“base class function b is called!\\n”);<br>\n}</p>\n<p>void f_drived_b(void *obj) {<br>\nprintf(“drived class function b is called!\\n”);<br>\n}</p>\n<p>typedef struct base_vt {<br>\nunsigned int    rtti;<br>\nF_BASE_A        base_a;<br>\nF_BASE_B        base_b;<br>\n}base_vt;</p>\n<p>typedef struct drived_vt {<br>\nunsigned int    rtti;<br>\nF_DRIVED_B      drived_b;<br>\n}drived_vt;</p>\n<p>typedef struct Base {<br>\nvoid *vtr;<br>\nint b_data;<br>\n}Base;</p>\n<p>typedef struct Drived {<br>\nBase b;<br>\nint s_data;<br>\n}Drived;</p>\n<p>base_vt g_base_vt;<br>\ndrived_vt g_drived_vt;</p>\n<p>void complier_init() {<br>\ng_base_vt.rtti = 6;<br>\ng_base_vt.base_a = f_base_a;<br>\ng_base_vt.base_b = f_base_b;</p>\n<pre><code>    g_drived_vt.rtti = 8;\n    g_drived_vt.drived_b = f_drived_b;\n</code></pre>\n<p>}<br>\nvoid t_base_call() {<br>\nprintf(“### test base begin ###.\\n”);<br>\nBase b;<br>\nb.vtr = &amp;g_base_vt;</p>\n<pre><code>    //call stlye 1\n    F_BASE_A function =  (F_BASE_A)(g_base_vt.base_a);\n    function(&amp;b);\n\n    function = (F_BASE_B)(g_base_vt.base_b);\n    function(&amp;b);\n\n    //call style 2\n    F_BASE_A fun_a = (F_BASE_A)(( (base_vt*)b.vtr )-&gt;base_a);\n    fun_a(&amp;b);\n\n    F_BASE_B fun_b = (F_BASE_B)(( (base_vt*)b.vtr )-&gt;base_b);\n    fun_b(&amp;b);\n\n    //call style 3\n    unsigned int *ptr = (unsigned int*)(&amp;b);\n    printf(&quot;%d\\n&quot;, *ptr);\n\n    ptr = (unsigned int*)(*ptr);\n    printf(&quot;%d\\n&quot;, *ptr);\n\n    F_BASE_A fun = (F_BASE_A)(*(ptr+1));\n    fun(&amp;b);\n\n    fun = (F_BASE_B)(*(ptr+2));\n    fun(&amp;b);\n    printf(&quot;### test base end ###.\\n&quot;);\n</code></pre>\n<p>}</p>\n<p>void t_drived_call() {<br>\nprintf(“### test drived begin. ###\\n”);<br>\nDrived d;<br>\nd.b.vtr = &amp;g_drived_vt;</p>\n<pre><code>    unsigned int *ptr = (unsigned int*)(&amp;d);\n    ptr = (unsigned int*)(*ptr);\n    F_BASE_A function = (F_BASE_A)(*(ptr+1));\n    function(&amp;d);\n\n    function=(F_DRIVED_B)(*(ptr+2));\n    function(&amp;d);\n    printf(&quot;### test drived end. ###\\n&quot;);\n</code></pre>\n<p>}</p>\n<p>void t_poly()<br>\n{<br>\nprintf(“### test poly begin. ###\\n”);</p>\n<pre><code>    Drived d;\n    d.b.vtr = &amp;g_drived_vt;\n\n    Base* base = (Base*)&amp;d;\n    unsigned int *ptr = (unsigned int*)(base);\n    ptr = (unsigned int*)(*ptr);\n    F_BASE_A function = (F_BASE_A)(*(ptr+1));\n\n    function(base);\n\n    function = (F_DRIVED_B)(*(ptr+2));\n    function(base);\n    printf(&quot;### test poly end. ###\\n&quot;);\n</code></pre>\n<p>}</p>\n<p>int main(int argc, char** argv)<br>\n{</p>\n<pre><code>    complier_init();\n    t_base_call();\n    return 0;\n</code></pre>\n<p>}</p>\n<p>[/code]</p>\n<p>【多态】如果说class是struct的加强版本的话，class相比struct有了虚表的管理和对成员变量权限管理(public, protected, private).对于stuct来说，struct没有成员变量的权限管理，默认所有的struct成员变量都默认为是public属性，可以被其他函数访问。这篇主要是描述，C如何模拟C++对class虚表的模拟。</p>\n<p>模拟虚表管理采用的方式是，用两个struct模拟class,一个struct用于存储class的数据,一个struct用于存储class中接口函数的函数指针（函数指针集合。）【模拟类的定义】<br>\n[code]<br>\n//附属结构体（虚表）:用于存储，指向函数（接口）的函数指针。<br>\ntypedef struct base_vt {<br>\nunsigned int    rtti;// 是一个存储继承信息的变量。<br>\nF_BASE_A        base_a;//函数指针<br>\nF_BASE_B        base_b;//函数指针<br>\n}base_vt;</p>\n<p>//主结构体（数据）：用于存储数据。<br>\ntypedef struct Base {<br>\nvoid *vtr; //1.vtr指针用于指向base_vt结构体。2.vtr一定要是struct的第一个成员变量，这是之后实现多态的关键。<br>\nint b_data;<br>\n}Base;<br>\n[/code]</p>\n<p>并且这两个struct之间通过一个”void* vtr“的空类型指针进行联系。vtr是主stuct的一个指针类型的成员变量，用于指向附属类所在的内存空间。</p>\n<p>在定义函数指针的时候，使用了自定义的宏。<br>\n[code]<br>\ntypedef void(*F_BASE_A)(void *obj);<br>\ntypedef void(*F_BASE_B)(void *obj);<br>\ntypedef void(*F_DRIVED_B)(void *obj);<br>\n[/code]</p>\n<p>【this指针】在C++中，非静态的成员函数的形参列表中，有一个被隐藏的参数,就是”this“<br>\n[code]<br>\nclass Sample {<br>\npublic:<br>\nvoid foo(int i);<br>\n}<br>\n[/code]</p>\n<p>实际上foo的参数列表会被编译器翻译成，foo(Sample* this, int i);<br>\n这也是为什么，在成员函数中，可以访问Sample类的数据。</p>\n<p>[code]<br>\nclass Sample {<br>\npublic:<br>\nvoid foo(Sample* this, int i);<br>\n}<br>\n[/code]<br>\n而我们在使用函数指针宏的时候，typedef void(*F_BASE_A)(void *obj)，指定了void *obj，相当于this指针，让用宏定义的这些成员函数，都可以访问主结构体的成员数据。</p>\n<p>[code]<br>\ntypedef void(*F_BASE_A)(void *this) //obj和this作用类似<br>\n[/code]<br>\n【static方法】<br>\nC++类，有一种叫做static的成员函数，类的static函数，可以在类不被实例化前，允许调用，但是类的static方法不能访问类的成员变量，类没有对象实例化，在内存中就类成员的空间，也无从访问其数据。但是，如果类成员变量也是static类型的话，static函数就可以，因为static变量被分别在常量存储区。</p>\n<p>[code]<br>\ntypedef void(*F_BASE_A)(void *obj);<br>\n[/code]<br>\n如果把上面的函数定义的参数”void *obj“删除，那么用F_BASE_A定义的函数，就类似于static方法，因为没有obj指针，对于函数来说，是不能访问主struct的数据的。</p>\n<p>[code]<br>\ntypedef void(*F_BASE_A)();<br>\n[/code]</p>\n<p>【字节对齐】</p>\n<p>【对象的size】</p>\n<p>【选读】市面上往往出现过很多的大部头书，大部头书更多的时候被当做工具书进行查阅，但是如果书的组织形式不好，就很难高效的找到自己主要想看的内容，更多的视野被重复的内容的占据，做重复的阅读工作。</p>\n<p>参考文档：<br>\n<a href=\"http://blog.chinaunix.net/uid-20940095-id-66146.html\">http://blog.chinaunix.net/uid-20940095-id-66146.html</a><br>\n<a href=\"http://club.topsage.com/thread-2263309-1-1.html\">http://club.topsage.com/thread-2263309-1-1.html</a></p>\n","text":"【问题】多态的虚函数调用，含虚函数对象大小计算，字节对齐，函数覆盖，构造与析函数的执行顺序,This指针。 【简介】首先，需要介绍一下用C语言实现C的单根继承，然后分析一下构造函数和析构函数的执行顺序。看看C都在背后做了什么，这也是C的基本内容，不涉及哲学和C软件的复用性讨论，立...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":124,"path":"api/tags/lua.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"用Django构建REST网页服务","uid":"b3a6fb6eb4424ca7a4f65fdb6f39a8d3","slug":"old_topic/2016-09-17-247","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.228Z","comments":true,"path":"api/articles/old_topic/2016-09-17-247.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者:糖果 Django的高版本自身提供了很好REST服务组件和方便的库,Djano REST Framework提供了一个现成的方案，可以将对外的REST服务，与类似Mysql的数据存储建立有机关联，直接与ORM一起使用就更便利。 JSONRenderer和JSONParser...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Markdown语法说明","uid":"3654658d46c7379d31d55d1693594cbc","slug":"old_topic/2016-09-17-249","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.200Z","comments":true,"path":"api/articles/old_topic/2016-09-17-249.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"编辑：糖果 11# Guide 这是一篇讲解如何正确使用OpenResty China 的 Markdown 的排版示例，学会这个很有必要，能让你的文章有更佳清晰的排版。 引用文本：Markdown is a text formatting syntax inspired 语法指...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}