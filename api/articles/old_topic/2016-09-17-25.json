{"title":"C模拟多态","uid":"f9f6eed6d27827bc96782faa045f082a","slug":"old_topic/2016-09-17-25","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.743Z","comments":true,"path":"api/articles/old_topic/2016-09-17-25.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>【问题】<br>多态的虚函数调用，含虚函数对象大小计算，字节对齐，函数覆盖，构造与析函数的执行顺序,This指针。</p>\n<p>【简介】<br>首先，需要介绍一下用C语言实现C++的单根继承，然后分析一下构造函数和析构函数的执行顺序。看看C++都在背后做了什么，这也是C++的基本内容，不涉及哲学和C++软件的复用性讨论，立足于，C++是对C的扩展，Class是对结构体的扩展，用struct和变量的讨论，代替class和属性。</p>\n<p>【概念】</p>\n<p>1.继承：子类继承父类，就是被叫做子类的结构体内，含有称为父类类型的结构体变量。例：drived结构体内含有base结构类型的变量。</p>\n<p>2.多态：在具有包含关系的结构体间的强类型转换，通过修改结构体内，指向虚表的，指针变量的内容，使其指向不同的虚表（虚表：指针函数结构体），来实现虚函数调用的功能。</p>\n<p>【代码】<br>[code]<br>#include&lt;stdlib.h&gt;<br>#include&lt;stdio.h&gt;</p>\n<p>typedef void(*F_BASE_A)(void *obj);<br>typedef void(*F_BASE_B)(void *obj);<br>typedef void(*F_DRIVED_B)(void *obj);</p>\n<p>void f_base_a(void *obj) {<br>        printf(“base class function a is called!\\n”);<br>}</p>\n<p>void f_base_b(void *obj) {<br>        printf(“base class function b is called!\\n”);<br>}</p>\n<p>void f_drived_b(void *obj) {<br>        printf(“drived class function b is called!\\n”);<br>}</p>\n<p>typedef struct base_vt {<br>        unsigned int    rtti;<br>        F_BASE_A        base_a;<br>        F_BASE_B        base_b;<br>}base_vt;</p>\n<p>typedef struct drived_vt {<br>        unsigned int    rtti;<br>        F_DRIVED_B      drived_b;<br>}drived_vt;</p>\n<p>typedef struct Base {<br>        void *vtr;<br>        int b_data;<br>}Base;</p>\n<p>typedef struct Drived {<br>        Base b;<br>        int s_data;<br>}Drived;</p>\n<p>base_vt g_base_vt;<br>drived_vt g_drived_vt;</p>\n<p>void complier_init() {<br>        g_base_vt.rtti = 6;<br>        g_base_vt.base_a = f_base_a;<br>        g_base_vt.base_b = f_base_b;</p>\n<pre><code>    g_drived_vt.rtti = 8;\n    g_drived_vt.drived_b = f_drived_b;\n</code></pre>\n<p>}<br>void t_base_call() {<br>        printf(“### test base begin ###.\\n”);<br>        Base b;<br>        b.vtr = &amp;g_base_vt;</p>\n<pre><code>    //call stlye 1\n    F_BASE_A function =  (F_BASE_A)(g_base_vt.base_a);\n    function(&amp;b);\n\n    function = (F_BASE_B)(g_base_vt.base_b);\n    function(&amp;b);\n\n    //call style 2\n    F_BASE_A fun_a = (F_BASE_A)(( (base_vt*)b.vtr )-&gt;base_a);\n    fun_a(&amp;b);\n\n    F_BASE_B fun_b = (F_BASE_B)(( (base_vt*)b.vtr )-&gt;base_b);\n    fun_b(&amp;b);\n\n    //call style 3\n    unsigned int *ptr = (unsigned int*)(&amp;b);\n    printf(&quot;%d\\n&quot;, *ptr);\n\n    ptr = (unsigned int*)(*ptr);\n    printf(&quot;%d\\n&quot;, *ptr);\n\n    F_BASE_A fun = (F_BASE_A)(*(ptr+1));\n    fun(&amp;b);\n\n    fun = (F_BASE_B)(*(ptr+2));\n    fun(&amp;b);\n    printf(&quot;### test base end ###.\\n&quot;);\n</code></pre>\n<p>}</p>\n<p>void t_drived_call() {<br>        printf(“### test drived begin. ###\\n”);<br>        Drived d;<br>        d.b.vtr = &amp;g_drived_vt;</p>\n<pre><code>    unsigned int *ptr = (unsigned int*)(&amp;d);\n    ptr = (unsigned int*)(*ptr);\n    F_BASE_A function = (F_BASE_A)(*(ptr+1));\n    function(&amp;d);\n\n    function=(F_DRIVED_B)(*(ptr+2));\n    function(&amp;d);\n    printf(&quot;### test drived end. ###\\n&quot;);\n</code></pre>\n<p>}</p>\n<p>void t_poly()<br>{<br>        printf(“### test poly begin. ###\\n”);</p>\n<pre><code>    Drived d;\n    d.b.vtr = &amp;g_drived_vt;\n\n    Base* base = (Base*)&amp;d;\n    unsigned int *ptr = (unsigned int*)(base);\n    ptr = (unsigned int*)(*ptr);\n    F_BASE_A function = (F_BASE_A)(*(ptr+1));\n\n    function(base);\n\n    function = (F_DRIVED_B)(*(ptr+2));\n    function(base);\n    printf(&quot;### test poly end. ###\\n&quot;);\n</code></pre>\n<p>}</p>\n<p>int main(int argc, char** argv)<br>{</p>\n<pre><code>    complier_init();\n    t_base_call();\n    return 0;\n</code></pre>\n<p>}</p>\n<p>[/code]</p>\n<p>【多态】<br>如果说class是struct的加强版本的话，class相比struct有了虚表的管理和对成员变量权限管理(public, protected, private).对于stuct来说，struct没有成员变量的权限管理，默认所有的struct成员变量都默认为是public属性，可以被其他函数访问。这篇主要是描述，C如何模拟C++对class虚表的模拟。</p>\n<p>模拟虚表管理采用的方式是，用两个struct模拟class,一个struct用于存储class的数据,一个struct用于存储class中接口函数的函数指针（函数指针集合。）<br>【模拟类的定义】<br>[code]<br>//附属结构体（虚表）:用于存储，指向函数（接口）的函数指针。<br>typedef struct base_vt {<br>        unsigned int    rtti;// 是一个存储继承信息的变量。<br>        F_BASE_A        base_a;//函数指针<br>        F_BASE_B        base_b;//函数指针<br>}base_vt;</p>\n<p>//主结构体（数据）：用于存储数据。<br>typedef struct Base {<br>        void *vtr; //1.vtr指针用于指向base_vt结构体。2.vtr一定要是struct的第一个成员变量，这是之后实现多态的关键。<br>        int b_data;<br>}Base;<br>[/code]</p>\n<p>并且这两个struct之间通过一个”void* vtr“的空类型指针进行联系。vtr是主stuct的一个指针类型的成员变量，用于指向附属类所在的内存空间。</p>\n<p>在定义函数指针的时候，使用了自定义的宏。<br>[code]<br>typedef void(*F_BASE_A)(void *obj);<br>typedef void(*F_BASE_B)(void *obj);<br>typedef void(*F_DRIVED_B)(void *obj);<br>[/code]</p>\n<p>【this指针】<br>在C++中，非静态的成员函数的形参列表中，有一个被隐藏的参数,就是”this“<br>[code]<br>class Sample {<br>public:<br>     void foo(int i);<br>}<br>[/code]</p>\n<p>实际上foo的参数列表会被编译器翻译成，foo(Sample* this, int i);<br>这也是为什么，在成员函数中，可以访问Sample类的数据。 </p>\n<p>[code]<br>class Sample {<br>public:<br>     void foo(Sample* this, int i);<br>}<br>[/code]<br>而我们在使用函数指针宏的时候，typedef void(*F_BASE_A)(void *obj)，指定了void *obj，相当于this指针，让用宏定义的这些成员函数，都可以访问主结构体的成员数据。</p>\n<p>[code]<br>typedef void(*F_BASE_A)(void *this) //obj和this作用类似<br>[/code]<br>【static方法】<br>C++类，有一种叫做static的成员函数，类的static函数，可以在类不被实例化前，允许调用，但是类的static方法不能访问类的成员变量，类没有对象实例化，在内存中就类成员的空间，也无从访问其数据。但是，如果类成员变量也是static类型的话，static函数就可以，因为static变量被分别在常量存储区。</p>\n<p>[code]<br>typedef void(*F_BASE_A)(void *obj);<br>[/code]<br>如果把上面的函数定义的参数”void *obj“删除，那么用F_BASE_A定义的函数，就类似于static方法，因为没有obj指针，对于函数来说，是不能访问主struct的数据的。</p>\n<p>[code]<br>typedef void(*F_BASE_A)();<br>[/code]</p>\n<p>【字节对齐】</p>\n<p>【对象的size】</p>\n<p>【选读】<br>市面上往往出现过很多的大部头书，大部头书更多的时候被当做工具书进行查阅，但是如果书的组织形式不好，就很难高效的找到自己主要想看的内容，更多的视野被重复的内容的占据，做重复的阅读工作。</p>\n<p>参考文档：<br><a href=\"http://blog.chinaunix.net/uid-20940095-id-66146.html\">http://blog.chinaunix.net/uid-20940095-id-66146.html</a><br><a href=\"http://club.topsage.com/thread-2263309-1-1.html\">http://club.topsage.com/thread-2263309-1-1.html</a></p>\n","text":"【问题】多态的虚函数调用，含虚函数对象大小计算，字节对齐，函数覆盖，构造与析函数的执行顺序,This指针。 【简介】首先，需要介绍一下用C语言实现C++的单根继承，然后分析一下构造函数和析构函数的执行顺序。看看C++都在背后做了什么，这也是C++的基本内容，不涉及哲学和C++软件...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Octopress评论方本框的样式问题","uid":"f47eb985f6ae8a0bdc7e70fa6ba8170e","slug":"old_topic/2016-09-17-252","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.744Z","comments":true,"path":"api/articles/old_topic/2016-09-17-252.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者：糖果 前几天改octopress的样式，发现评论框的样式没了，变成了普通的表单。然后，想用vimdiff在vps上比较一下，发现新版的css就行一行，没有经过格式化，再小伙伴们的支持下，用chrome把css格式化了，然后在老版的css找到了评论文本框的样式，添加到新的cs...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Octopress的Figcaption的CSS样式差异","uid":"d97242e82975d5be79f8c9c982dae804","slug":"old_topic/2016-09-17-254","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.744Z","comments":true,"path":"api/articles/old_topic/2016-09-17-254.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者、编辑：糖果 新版的Octopress与旧版的的Figcaption的CSS样式差异，以下的CSS是被格式化之后的： 旧版的 12345678910111213141516171819202122232425262728293031.code-title,html .gist...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}