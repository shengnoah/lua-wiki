{"title":"子查询","uid":"880333deb35be82c4d3989968275351e","slug":"old_topic/2016-09-17-309","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.748Z","comments":true,"path":"api/articles/old_topic/2016-09-17-309.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<h1 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h1><p>Nginx 子请求是一种非常强有力的方式，它可以发起非阻塞的内部请求访问目标 location。目标 location 可以是配置文件中其他文件目录，或 <em>任何</em> 其他 nginx C 模块，包括 <code>ngx_proxy</code>、<code>ngx_fastcgi</code>、<code>ngx_memc</code>、<code>ngx_postgres</code>、<code>ngx_drizzle</code>，甚至 ngx_lua 自身等等 。</p>\n<p>需要注意的是，子请求只是模拟 HTTP 接口的形式， <em>没有</em> 额外的 HTTP/TCP 流量，也 <em>没有</em> IPC (进程间通信) 调用。所有工作在内部高效地在 C 语言级别完成。</p>\n<p>子请求与 HTTP 301/302 重定向指令 (通过 <a href=\"https://github.com/openresty/lua-nginx-module#ngxredirect\">ngx.redirect</a>) 完全不同，也与内部重定向 ((通过 <a href=\"https://github.com/openresty/lua-nginx-module#ngxexec\">ngx.exec</a>) 完全不同。</p>\n<p>在发起子请求前，用户程序应总是读取完整的 HTTP 请求体 (通过调用 <a href=\"https://github.com/openresty/lua-nginx-module#ngxreqread_body\">ngx.req.read_body</a> 或设置 <a href=\"https://github.com/openresty/lua-nginx-module#lua_need_request_body\">lua_need_request_body</a> 指令为 on).</p>\n<p>该 API 方法（<a href=\"https://github.com/openresty/lua-nginx-module#ngxlocationcapture_multi\">ngx.location.capture_multi</a> 也一样）总是缓冲整个请求体到内存中。因此，当需要处理一个大的子请求响应，用户程序应使用 <a href=\"https://github.com/openresty/lua-nginx-module#ngxsockettcp\">cosockets</a> 进行流式处理，</p>\n<p>下面是一个简单例子：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">res = ngx.location.capture(uri)</span><br></pre></td></tr></table></figure>\n\n<p>返回一个包含四个元素的 Lua 表 (<code>res.status</code>, <code>res.header</code>, <code>res.body</code>, 和 <code>res.truncated</code>)。</p>\n<p><code>res.status</code> (状态) 保存子请求的响应状态码。</p>\n<p><code>res.header</code> (头) 用一个标准 Lua 表储子请求响应的所有头信息。如果是“多值”响应头，这些值将使用 Lua (数组) 表顺序存储。例如，如果子请求响应头包含下面的行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Set-Cookie: a=3</span><br><span class=\"line\">Set-Cookie: foo=bar</span><br><span class=\"line\">Set-Cookie: baz=blah</span><br></pre></td></tr></table></figure>\n\n<p>则 <code>res.header[&quot;Set-Cookie&quot;]</code> 将存储 Lua 表 <code>&#123;&quot;a=3&quot;, &quot;foo=bar&quot;, &quot;baz=blah&quot;&#125;</code>。</p>\n<p><code>res.body</code> (体) 保存子请求的响应体数据，它可能被截断。用户需要检测 <code>res.truncated</code> (截断) 布尔值标记来判断 <code>res.body</code> 是否包含截断的数据。这种数据截断的原因只可能是因为子请求发生了不可恢复的错误，例如远端在发送响应体时过早中断了连接，或子请求在接收远端响应体时超时。</p>\n<p>URI 请求串可以与 URI 本身连在一起，例如，</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">res = ngx.location.capture(<span class=\"string\">&#x27;/foo/bar?a=3&amp;b=4&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>因为 Nginx 内核限制，子请求不允许类似 <code>@foo</code> 命名 location。请使用标准 location，并设置 <code>internal</code> 指令，仅服务内部请求。</p>\n<p>例如，发送一个 POST 子请求，可以这样做：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">res = ngx.location.capture(</span><br><span class=\"line\">    <span class=\"string\">&#x27;/foo/bar&#x27;</span>,</span><br><span class=\"line\">    &#123; method = ngx.HTTP_POST, body = <span class=\"string\">&#x27;hello, world&#x27;</span> &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>除了 POST 的其他 HTTP 请求方法请参考 <a href=\"https://github.com/openresty/lua-nginx-module#http-method-constants\">HTTP method constants</a>。<br><code>method</code> 选项默认值是 <code>ngx.HTTP_GET</code>。</p>\n<p><code>args</code> 选项可以设置附加的 URI 参数，例如：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ngx.location.capture(<span class=\"string\">&#x27;/foo?a=1&#x27;</span>,</span><br><span class=\"line\">    &#123; args = &#123; b = <span class=\"number\">3</span>, c = <span class=\"string\">&#x27;:&#x27;</span> &#125; &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>等同于</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ngx.location.capture(<span class=\"string\">&#x27;/foo?a=1&amp;b=3&amp;c=%3a&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，这个方法将根据 URI 规则转义参数键和值，并将它们拼接在一起组成一个完整的请求串。<code>args</code> 选项要求的 Lua 表的格式与 <a href=\"https://github.com/openresty/lua-nginx-module#ngxencode_args\">ngx.encode_args</a> 方法中使用的完全相同。</p>\n<p><code>args</code> 选项也可以直接包含 (转义过的) 请求串：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ngx.location.capture(<span class=\"string\">&#x27;/foo?a=1&#x27;</span>,</span><br><span class=\"line\">    &#123; args = <span class=\"string\">&#x27;b=3&amp;c=%3a&#x27;</span> &#125; &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>这个例子与上个例子的功能相同。</p>\n<p>请注意，通过 <a href=\"https://github.com/openresty/lua-nginx-module#ngxlocationcapture\">ngx.location.capture</a> 创建的子请求默认继承当前请求的所有请求头信息，这有可能导致子请求响应中不可预测的副作用。例如，当使用标准的 <code>ngx_proxy</code> 模块服务子请求时，如果主请求头中包含 “Accept-Encoding: gzip”，可能导致子请求返回 Lua 代码无法正确处理的 gzip 压缩过的结果。通过设置 <a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass_request_headers\">proxy_pass_request_headers</a> 为 <code>off</code> ，在子请求 location 中忽略原始请求头。</p>\n<p>注：<a href=\"https://github.com/openresty/lua-nginx-module#ngxlocationcapture\">ngx.location.capture</a> 和 <a href=\"https://github.com/openresty/lua-nginx-module#ngxlocationcapture_multi\">ngx.location.capture_multi</a> 指令无法抓取包含以下指令的 location： <a href=\"http://nginx.org/en/docs/http/ngx_http_addition_module.html#add_before_body\">add_before_body</a>, <a href=\"http://nginx.org/en/docs/http/ngx_http_addition_module.html#add_after_body\">add_after_body</a>, <a href=\"http://nginx.org/en/docs/http/ngx_http_auth_request_module.html#auth_request\">auth_request</a>, <a href=\"http://github.com/openresty/echo-nginx-module#echo_location\">echo_location</a>, <a href=\"http://github.com/openresty/echo-nginx-module#echo_location_async\">echo_location_async</a>, <a href=\"http://github.com/openresty/echo-nginx-module#echo_subrequest\">echo_subrequest</a>, 或 <a href=\"http://github.com/openresty/echo-nginx-module#echo_subrequest_async\">echo_subrequest_async</a> 。</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">location</span> /foo &#123;</span><br><span class=\"line\">    <span class=\"attribute\">content_by_lua</span> <span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        res = ngx.location.capture(&quot;/bar&quot;)</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"section\">location</span> /bar &#123;</span><br><span class=\"line\">    <span class=\"attribute\">echo_location</span> /blah;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"section\">location</span> /blah &#123;</span><br><span class=\"line\">    <span class=\"attribute\">echo</span> <span class=\"string\">&quot;Success!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"attribute\">curl</span> -i http://example.com/foo</span><br></pre></td></tr></table></figure>\n\n<p>他们将不会按照预期工作。</p>\n","text":"子查询Nginx 子请求是一种非常强有力的方式，它可以发起非阻塞的内部请求访问目标 location。目标 location 可以是配置文件中其他文件目录，或 任何 其他 nginx C 模块，包括 ngx_proxy、ngx_fastcgi、ngx_memc、ngx_postg...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%90%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">子查询</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"cosocket.md","uid":"3c01632b3d6ff48483bb42fd53fbe2b7","slug":"old_topic/2016-09-17-313","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.748Z","comments":true,"path":"api/articles/old_topic/2016-09-17-313.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"怎样理解 cosockettodo: waiting to todo ","link":"","photos":[],"count_time":{"symbolsCount":35,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"简单API Server框架","uid":"00e0afc1c0a95123fda2364773b4d3e8","slug":"old_topic/2016-09-17-316","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.748Z","comments":true,"path":"api/articles/old_topic/2016-09-17-316.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"简单API Server框架实现一个最最简单的数学计算：加、减、乘、除，给大家演示如何搭建简单的 API Server。 按照前面几章的写法，先来看看加法、减法示例代码： 123456789101112131415161718192021222324252627282930313...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}