{"title":"子查询","uid":"880333deb35be82c4d3989968275351e","slug":"old_topic/2016-09-17-309","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.200Z","comments":true,"path":"api/articles/old_topic/2016-09-17-309.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<h1 id=\"子查询\"><a class=\"markdownIt-Anchor\" href=\"#子查询\"></a> 子查询</h1>\n<p>Nginx 子请求是一种非常强有力的方式，它可以发起非阻塞的内部请求访问目标 location。目标 location 可以是配置文件中其他文件目录，或 <em>任何</em> 其他 nginx C 模块，包括 <code>ngx_proxy</code>、<code>ngx_fastcgi</code>、<code>ngx_memc</code>、<code>ngx_postgres</code>、<code>ngx_drizzle</code>，甚至 ngx_lua 自身等等 。</p>\n<p>需要注意的是，子请求只是模拟 HTTP 接口的形式， <em>没有</em> 额外的 HTTP/TCP 流量，也 <em>没有</em> IPC (进程间通信) 调用。所有工作在内部高效地在 C 语言级别完成。</p>\n<p>子请求与 HTTP 301/302 重定向指令 (通过 <a href=\"https://github.com/openresty/lua-nginx-module#ngxredirect\">ngx.redirect</a>) 完全不同，也与内部重定向 ((通过 <a href=\"https://github.com/openresty/lua-nginx-module#ngxexec\">ngx.exec</a>) 完全不同。</p>\n<p>在发起子请求前，用户程序应总是读取完整的 HTTP 请求体 (通过调用 <a href=\"https://github.com/openresty/lua-nginx-module#ngxreqread_body\">ngx.req.read_body</a> 或设置 <a href=\"https://github.com/openresty/lua-nginx-module#lua_need_request_body\">lua_need_request_body</a> 指令为 on).</p>\n<p>该 API 方法（<a href=\"https://github.com/openresty/lua-nginx-module#ngxlocationcapture_multi\">ngx.location.capture_multi</a> 也一样）总是缓冲整个请求体到内存中。因此，当需要处理一个大的子请求响应，用户程序应使用 <a href=\"https://github.com/openresty/lua-nginx-module#ngxsockettcp\">cosockets</a> 进行流式处理，</p>\n<p>下面是一个简单例子：</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\">\nres <span class=\"token operator\">=</span> ngx<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span><span class=\"token function\">capture</span><span class=\"token punctuation\">(</span>uri<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>返回一个包含四个元素的 Lua 表 (<code>res.status</code>, <code>res.header</code>, <code>res.body</code>, 和 <code>res.truncated</code>)。</p>\n<p><code>res.status</code> (状态) 保存子请求的响应状态码。</p>\n<p><code>res.header</code> (头) 用一个标准 Lua 表储子请求响应的所有头信息。如果是“多值”响应头，这些值将使用 Lua (数组) 表顺序存储。例如，如果子请求响应头包含下面的行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\nSet-Cookie: <span class=\"token assign-left variable\">a</span><span class=\"token operator\">=</span><span class=\"token number\">3</span>\nSet-Cookie: <span class=\"token assign-left variable\">foo</span><span class=\"token operator\">=</span>bar\nSet-Cookie: <span class=\"token assign-left variable\">baz</span><span class=\"token operator\">=</span>blah<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>则 <code>res.header[&quot;Set-Cookie&quot;]</code> 将存储 Lua 表 <code>&#123;&quot;a=3&quot;, &quot;foo=bar&quot;, &quot;baz=blah&quot;&#125;</code>。</p>\n<p><code>res.body</code> (体) 保存子请求的响应体数据，它可能被截断。用户需要检测 <code>res.truncated</code> (截断) 布尔值标记来判断 <code>res.body</code> 是否包含截断的数据。这种数据截断的原因只可能是因为子请求发生了不可恢复的错误，例如远端在发送响应体时过早中断了连接，或子请求在接收远端响应体时超时。</p>\n<p>URI 请求串可以与 URI 本身连在一起，例如，</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\">\nres <span class=\"token operator\">=</span> ngx<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span><span class=\"token function\">capture</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/foo/bar?a=3&amp;b=4'</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>因为 Nginx 内核限制，子请求不允许类似 <code>@foo</code> 命名 location。请使用标准 location，并设置 <code>internal</code> 指令，仅服务内部请求。</p>\n<p>例如，发送一个 POST 子请求，可以这样做：</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\">\nres <span class=\"token operator\">=</span> ngx<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span><span class=\"token function\">capture</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">'/foo/bar'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span> method <span class=\"token operator\">=</span> ngx<span class=\"token punctuation\">.</span>HTTP_POST<span class=\"token punctuation\">,</span> body <span class=\"token operator\">=</span> <span class=\"token string\">'hello, world'</span> <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>除了 POST 的其他 HTTP 请求方法请参考 <a href=\"https://github.com/openresty/lua-nginx-module#http-method-constants\">HTTP method constants</a>。<br />\n<code>method</code> 选项默认值是 <code>ngx.HTTP_GET</code>。</p>\n<p><code>args</code> 选项可以设置附加的 URI 参数，例如：</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\">\nngx<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span><span class=\"token function\">capture</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/foo?a=1'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span> args <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> b <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> c <span class=\"token operator\">=</span> <span class=\"token string\">':'</span> <span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>等同于</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\">\nngx<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span><span class=\"token function\">capture</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/foo?a=1&amp;b=3&amp;c=%3a'</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>也就是说，这个方法将根据 URI 规则转义参数键和值，并将它们拼接在一起组成一个完整的请求串。<code>args</code> 选项要求的 Lua 表的格式与 <a href=\"https://github.com/openresty/lua-nginx-module#ngxencode_args\">ngx.encode_args</a> 方法中使用的完全相同。</p>\n<p><code>args</code> 选项也可以直接包含 (转义过的) 请求串：</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\">\nngx<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span><span class=\"token function\">capture</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/foo?a=1'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span> args <span class=\"token operator\">=</span> <span class=\"token string\">'b=3&amp;c=%3a'</span> <span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这个例子与上个例子的功能相同。</p>\n<p>请注意，通过 <a href=\"https://github.com/openresty/lua-nginx-module#ngxlocationcapture\">ngx.location.capture</a> 创建的子请求默认继承当前请求的所有请求头信息，这有可能导致子请求响应中不可预测的副作用。例如，当使用标准的 <code>ngx_proxy</code> 模块服务子请求时，如果主请求头中包含 “Accept-Encoding: gzip”，可能导致子请求返回 Lua 代码无法正确处理的 gzip 压缩过的结果。通过设置 <a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass_request_headers\">proxy_pass_request_headers</a> 为 <code>off</code> ，在子请求 location 中忽略原始请求头。</p>\n<p>注：<a href=\"https://github.com/openresty/lua-nginx-module#ngxlocationcapture\">ngx.location.capture</a> 和 <a href=\"https://github.com/openresty/lua-nginx-module#ngxlocationcapture_multi\">ngx.location.capture_multi</a> 指令无法抓取包含以下指令的 location： <a href=\"http://nginx.org/en/docs/http/ngx_http_addition_module.html#add_before_body\">add_before_body</a>, <a href=\"http://nginx.org/en/docs/http/ngx_http_addition_module.html#add_after_body\">add_after_body</a>, <a href=\"http://nginx.org/en/docs/http/ngx_http_auth_request_module.html#auth_request\">auth_request</a>, <a href=\"http://github.com/openresty/echo-nginx-module#echo_location\">echo_location</a>, <a href=\"http://github.com/openresty/echo-nginx-module#echo_location_async\">echo_location_async</a>, <a href=\"http://github.com/openresty/echo-nginx-module#echo_subrequest\">echo_subrequest</a>, 或 <a href=\"http://github.com/openresty/echo-nginx-module#echo_subrequest_async\">echo_subrequest_async</a> 。</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\">\n<span class=\"token directive\"><span class=\"token keyword\">location</span> /foo</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">content_by_lua</span> <span class=\"token string\">'\n        res = ngx.location.capture(\"/bar\")\n    '</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token directive\"><span class=\"token keyword\">location</span> /bar</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">echo_location</span> /blah</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token directive\"><span class=\"token keyword\">location</span> /blah</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">echo</span> <span class=\"token string\">\"Success!\"</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\">\n$ curl -i http://example.com/foo<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>他们将不会按照预期工作。</p>\n","text":" 子查询 Nginx 子请求是一种非常强有力的方式，它可以发起非阻塞的内部请求访问目标 location。目标 location 可以是配置文件中其他文件目录，或 任何 其他 nginx C 模块，包括 ngx_proxy、ngx_fastcgi、ngx_memc、ngx_pos...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%90%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\"> 子查询</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"简介","uid":"e3b28e08d06ce54864d09189bebacd02","slug":"old_topic/2016-09-17-308","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.196Z","comments":true,"path":"api/articles/old_topic/2016-09-17-308.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 简介 OpenResty（也称为 ngx_openresty）是一个全功能的 Web 应用服务器。它打包了标准的 Nginx 核心，很多的常用的第三方模块，以及它们的大多数依赖项。 通过糅合众多设计良好的 Nginx 模块，OpenResty 有效地把 Nginx 服务器转变为...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"不同阶段共享变量","uid":"4b4caaa9aaa4e586708012dea3b735d1","slug":"old_topic/2016-09-17-310","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.155Z","comments":true,"path":"api/articles/old_topic/2016-09-17-310.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":" 不同阶段共享变量 在 OpenResty 的体系中，可以通过共享内存的方式完成不同工作进程的数据共享，可以通过 Lua 模块方式完成单个进程内不同请求的数据共享。如何完成单个请求内不同阶段的数据共享呢？最典型的例子，估计就是在 log 阶段记录一些请求的特殊变量。 ngx.ct...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}