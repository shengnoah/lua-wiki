{"title":"跨平台的库选择","uid":"9292b5d7db49cf3a15a4dacf7bf55d0e","slug":"old_topic/2016-09-17-327","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.749Z","comments":true,"path":"api/articles/old_topic/2016-09-17-327.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<h1 id=\"跨平台的库选择\"><a href=\"#跨平台的库选择\" class=\"headerlink\" title=\"跨平台的库选择\"></a>跨平台的库选择</h1><p>大家看过上面三个json的例子就发现，都是围绕cjson库的。原因也比较简单，就是cjson是默认绑定到openresty上的。很多开发喜欢 windows 系统，可以选择 dkjson（编解码效率没有cjson快，优势是纯Lua，完美跨任何平台）。</p>\n<p>并且我们的代码肯定不会因为 win、linux 的并存而写两套程序。那么我们就必须要把json处理部分封装一下，隐藏系统差异造成的差异化处理。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> _M = &#123; <span class=\"built_in\">_VERSION</span> = <span class=\"string\">&#x27;1.0&#x27;</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">-- require(&quot;ffi&quot;).os 获取系统类型</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> json = <span class=\"built_in\">require</span>(<span class=\"built_in\">require</span>(<span class=\"string\">&quot;ffi&quot;</span>).<span class=\"built_in\">os</span> == <span class=\"string\">&quot;Windows&quot;</span> <span class=\"keyword\">and</span> <span class=\"string\">&quot;dkjson&quot;</span> <span class=\"keyword\">or</span> <span class=\"string\">&quot;cjson&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_M.json_decode</span><span class=\"params\">( str )</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> json.decode(str)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_M.json_encode</span><span class=\"params\">( data )</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> json.encode(data)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> _M</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在我们的应用中，对于操作系统版本差异、操作系统位数差异、同时支持不同数据库使用等，几乎都是使用这个方法完成的，十分值得推荐。</p>\n<p>额外说个点，github上有个项目<a href=\"https://github.com/cloudflare/lua-resty-json\">cloudflare/lua-resty-json</a>，从官方资料上介绍decode的速度更快，我们也做了小范围应用。所以上面的json_decode对象来源，就可以改成这个库。</p>\n<p>外面总是有新鲜玩意，多抬头多发现，充实自己，站在巨人肩膀上，总是能够更容易够到高峰。</p>\n","text":"跨平台的库选择大家看过上面三个json的例子就发现，都是围绕cjson库的。原因也比较简单，就是cjson是默认绑定到openresty上的。很多开发喜欢 windows 系统，可以选择 dkjson（编解码效率没有cjson快，优势是纯Lua，完美跨任何平台）。 并且我们的代码...","link":"","photos":[],"count_time":{"symbolsCount":770,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%BA%93%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">跨平台的库选择</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"输出响应体","uid":"9aa16bf014a426133910ab8bd80b8292","slug":"old_topic/2016-09-17-325","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.749Z","comments":true,"path":"api/articles/old_topic/2016-09-17-325.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"text":"输出响应体HTTP响应报文分为三个部分： 响应行 响应头 响应体 对于 HTTP 响应体的输出，在 OpenResty 中调用 ngx.say 或 ngx.print 即可。经过查看官方 wiki ，这两者都是输出响应体，区别是 ngx.say 会对输出响应体多输出一个 \\n 。...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"编码为array还是object","uid":"dcced3e4781903088f00b4d841a17520","slug":"old_topic/2016-09-17-326","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.749Z","comments":true,"path":"api/articles/old_topic/2016-09-17-326.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"编码为array还是object 首先大家请看这段源码： 12345-- http://www.kyne.com.au/~mark/software/lua-cjson.php-- version: 2.1 devellocal json = require(&quot;cjso...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}