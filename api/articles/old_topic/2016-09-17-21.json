{"title":"Select 网络API","uid":"4565b99fae7d71a23c039a81b59544a8","slug":"old_topic/2016-09-17-21","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.182Z","comments":true,"path":"api/articles/old_topic/2016-09-17-21.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<h3>【问题】</h3>select,poll,epoll的区别是什么？\nselect的并发处理是源于BSD系统的支持，poll是商业公司的unix版本SystemV 提供支持。epoll是在Linux 2.5+开始支持的。就像message queue都有BSD和SystemV版本的API。select是处理网络并发处理，与poll的区别是有文件句柄上线限制。poll不会因为打开文件的增多而降低效率。\n<p>【select功能概述】</p>\n<p><strong>一切复杂的问题都是简单问题叠加组合，引用一下英文文档原文。</strong><br>\n“This module provides access to the select() and poll() functions available in most operating systems, epoll() available on Linux 2.5+ and kqueue() available on most BSD. Note that on Windows, it only works for sockets; on other operating systems, it also works for other file types (in particular, on Unix, it works on pipes). It cannot be used on regular files to determine whether a file has grown since it was last read.”</p>\n<h5>server.py</h5>\n[code]\nimport socket, select;\nimport time;\nimport os;\n<p>host = “127.0.0.1”<br>\nport = 1688</p>\n<p>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)#通过指定第三个参数“IPPROTO_TCP/IPPROTO_UDP”， 指定使用&quot;TCP/UDP&quot;协议进行传输！<br>\ns.bind((host, port))<br>\ns.listen(5)</p>\n<p>while True:<br>\ninputfds, outputfds, errorfds = select.select([s,],[],[],5)<br>\nif len(inputfds) !=0:<br>\nclientsock, clientaddr = s.accept()<br>\nbuf = clientsock.recv(8024)<br>\nif len(buf) != 0:<br>\nprint (buf)<br>\nclientsock.close()</p>\n<p>[/code]</p>\n<h5>client.py</h5>\n[code]\nimport socket, select\nhost = \"127.0.0.1\"\nport = 1688\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((host, port))\ns.send(\"the Candy Web server on SAE of sina!\")\ns.close()\n[/code]\n<h3>【API说明】</h3> \nselect的作用是“Waiting for I/O completion.”一般会和socket的API结合处理网络异步并发，但是也可以不和socket联系在一起应用。核心的API函数是select，结合几个关键的宏使用。FD_ZERO, FD_SET, FD_CLR，FD_ISSET。通过一套的函数和宏管理用户的文件描述符集合。（SETS）\n<p>英文文档总是能直戳这些宏的本质。<br>\n&quot; Four  macros  are provided to manipulate the sets.  FD_ZERO() clears a set.  FD_SET() and FD_CLR() respectively add and remove a given file descriptor from a set.  FD_ISSET() tests to see if a file descriptor is part of the set; this is useful after select() returns.<br>\n&quot;</p>\n<h3>【宏定义】</h3>\nFD_ZERO():清空文件集。\nFD_SET():添加句柄到集合。\nFD_CLR():从集合中清除句柄。\nFD_ISSET():判断句柄是否在集合中。\n<h3>【Select接口说明】</h3>\n1.int n\n2.fd_set * readfds\n3.fd_set * writefds\n4.fd_set * exceptfds\n5.struct timeval * timeout\ntimeout == NULL: 一直等待直到事件发生。\ntimeout > 0: 按设定的大于0的时间值进行等待。\ntimeout = 0: 没有时间等待，直接返回。\n<h3>【选读】</h3>\n<em>\n\"select（I/O多工机制）\n定义函数 int select(int n,fd_set * readfds,fd_set * writefds,fd_set * exceptfds,struct timeval * timeout);\n函数说明 select()用来等待文件描述词状态的改变。参数n代表最大的文件描述词加1，参数readfds、writefds 和exceptfds 称为描述词组，是用来回传该描述词的读，写或例外的状况。底下的宏提供了处理这三种描述词组的方式:\nFD_CLR(inr fd,fd_set* set)；用来清除描述词组set中相关fd 的位\nFD_ISSET(int fd,fd_set *set)；用来测试描述词组set中相关fd 的位是否为真\nFD_SET（int fd,fd_set*set）；用来设置描述词组set中相关fd的位\nFD_ZERO（fd_set *set）；用来清除描述词组set的全部位\"\n</em> \n看到，“多工机制”和类似\"是用来回传该描述词的读，写或例外的状况。\"这种文字，直接就被干倒了，难道原文英语就这么晦涩不堪吗？残酷的阅读体验。\n<h3>【例子A：读取键盘输入的数据】</h3>\n<p>在Linux系统中，键盘设备也被标识为文件，找来一个例子，很简短的/dev/tty键盘设备和select的联合使用。这么做的目的，就是很单纯的演示select本身相关函数和使用。</p>\n<p>keyboard.c<br>\n[code]<br>\n#include&lt;stdio.h&gt;<br>\n#include&lt;stdlib.h&gt;<br>\n#include&lt;assert.h&gt;<br>\n#include&lt;fcntl.h&gt;<br>\n#include&lt;sys/select.h&gt;</p>\n<p>int main(int argc, char **argv)<br>\n{<br>\nint keyboard; //键盘的文件句柄<br>\nint ret,i;<br>\nchar c;<br>\nfd_set readfd; //读操作的集合的定义<br>\nstruct timeval timeout; // 提供给select函数使用的，延时时间结构体，告知需要等待的时间长度<br>\nkeyboard = open(“/dev/tty”, O_RDONLY | O_NONBLOCK);//读取键盘缓冲区里的数据<br>\nassert(keyboard&gt;0);<br>\nwhile(1) //主循环<br>\n{<br>\ntimeout.tv_sec = 1;  // 等待的时间设定<br>\ntimeout.tv_usec = 0;<br>\nFD_ZERO(&amp;readfd); // 初始化读操作集合。<br>\nFD_SET(keyboard, &amp;readfd); //把键盘文件句柄填入读文件集<br>\nret = select(keyboard+1, &amp;readfd, NULL, NULL, &amp;timeout); // 取得外部IO的状态数据<br>\nif (FD_ISSET(keyboard, &amp;readfd)) //判断读集合中的keyboard句柄是否准备好了，可以工作。<br>\n{<br>\ni = read(keyboard, &amp;c, 1); //读取键盘文件<br>\nif (‘\\n’ == c)<br>\ncontinue;<br>\nprintf(“input is %c\\n”, c);<br>\nif (‘q’ == c)<br>\nbreak;</p>\n<pre><code>            &#125;\n    &#125;\n</code></pre>\n<p>}<br>\n[/code]</p>\n<p>server.cpp<br>\nclient.cpp</p>\n<h3>【结尾】</h3>\n也许我应该长期的维护这个文档，回头看看对细节表述曾经放下的错误，对说的不是人话的地方，进行修改，并且围绕主题加入更高级的应用内容。\n<p>作者：小盛注释：个人劳动成果，转载使用请注明本文作者及出处链接，谢谢合作！<br>\n<a href=\"http://upblog.sinaapp.com/topic/21/python%E4%B8%8Ec-select-api%E7%9A%84%E5%AF%B9%E6%AF%94\" target=\"_blank\">Python与C++ select API的对比</a></p>\n<p>参考文献：<br>\n<a href=\"http://docs.python.org/2/library/select.html\" target=\"_blank\">Python官方文档</a></p>\n","text":"【问题】select,poll,epoll的区别是什么？ select的并发处理是源于BSD系统的支持，poll是商业公司的unix版本SystemV 提供支持。epoll是在Linux 2.5+开始支持的。就像message queue都有BSD和SystemV版本的API。s...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">【问题】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\"><span class=\"toc-text\">server.py</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\"><span class=\"toc-text\">client.py</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">【API说明】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">【宏定义】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">【Select接口说明】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">【选读】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">【例子A：读取键盘输入的数据】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">【结尾】</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Openresty的非典型安装","uid":"bb30e03d07b81113ffb361e7f94598db","slug":"old_topic/2016-09-17-212","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.223Z","comments":true,"path":"api/articles/old_topic/2016-09-17-212.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者：糖果 Openresty也安装了很多遍整理一下安装过程。 上来先更新一下系统 1sudo yum update 安装Openresty安装需要的依赖： 1sudo yum install -y gcc gcc-c++ readline-devel pcre-devel op...","link":"","photos":[],"count_time":{"symbolsCount":487,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"2015年国产LUA WEB框架一览","uid":"0091fba8ffac5443fa18d009f43bac53","slug":"old_topic/2016-09-17-208","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.201Z","comments":true,"path":"api/articles/old_topic/2016-09-17-208.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"2015年国产LUA WEB框架一览 国内框架 Vanilla LOR SingeLUA 国外框架： Lapis Gin 概况 现在是2016年的开始， 这次想说说LUA国内外的WEB框架，国内开发者的开发框架。据平时的观察，国内做LUA的WEB框架的目前知道的有3到4个，有3个...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}