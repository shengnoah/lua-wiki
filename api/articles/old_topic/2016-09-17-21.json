{"title":"Select 网络API","uid":"4565b99fae7d71a23c039a81b59544a8","slug":"old_topic/2016-09-17-21","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.740Z","comments":true,"path":"api/articles/old_topic/2016-09-17-21.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<h3>【问题】</h3>select,poll,epoll的区别是什么？\nselect的并发处理是源于BSD系统的支持，poll是商业公司的unix版本SystemV 提供支持。epoll是在Linux 2.5+开始支持的。就像message queue都有BSD和SystemV版本的API。select是处理网络并发处理，与poll的区别是有文件句柄上线限制。poll不会因为打开文件的增多而降低效率。\n\n<p>【select功能概述】</p>\n<p><strong>一切复杂的问题都是简单问题叠加组合，引用一下英文文档原文。</strong><br>“This module provides access to the select() and poll() functions available in most operating systems, epoll() available on Linux 2.5+ and kqueue() available on most BSD. Note that on Windows, it only works for sockets; on other operating systems, it also works for other file types (in particular, on Unix, it works on pipes). It cannot be used on regular files to determine whether a file has grown since it was last read.”</p>\n<h5>server.py</h5>\n[code]\nimport socket, select;\nimport time;\nimport os;\n\n<p>host = “127.0.0.1”<br>port = 1688</p>\n<p>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)#通过指定第三个参数“IPPROTO_TCP/IPPROTO_UDP”， 指定使用”TCP/UDP”协议进行传输！<br>s.bind((host, port))<br>s.listen(5)</p>\n<p>while True:<br>        inputfds, outputfds, errorfds = select.select([s,],[],[],5)<br>        if len(inputfds) !=0:<br>                clientsock, clientaddr = s.accept()<br>                buf = clientsock.recv(8024)<br>                if len(buf) != 0:<br>                        print (buf)<br>                        clientsock.close() </p>\n<p>[/code]</p>\n<h5>client.py</h5>\n[code]\nimport socket, select\nhost = \"127.0.0.1\"\nport = 1688\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((host, port))\ns.send(\"the Candy Web server on SAE of sina!\")\ns.close()\n[/code]\n\n<h3>【API说明】</h3> \nselect的作用是“Waiting for I/O completion.”一般会和socket的API结合处理网络异步并发，但是也可以不和socket联系在一起应用。核心的API函数是select，结合几个关键的宏使用。FD_ZERO, FD_SET, FD_CLR，FD_ISSET。通过一套的函数和宏管理用户的文件描述符集合。（SETS）\n\n<p>英文文档总是能直戳这些宏的本质。<br>“ Four  macros  are provided to manipulate the sets.  FD_ZERO() clears a set.  FD_SET() and FD_CLR() respectively add and remove a given file descriptor from a set.  FD_ISSET() tests to see if a file descriptor is part of the set; this is useful after select() returns.<br>“</p>\n<h3>【宏定义】</h3>\nFD_ZERO():清空文件集。\nFD_SET():添加句柄到集合。\nFD_CLR():从集合中清除句柄。\nFD_ISSET():判断句柄是否在集合中。\n\n\n<h3>【Select接口说明】</h3>\n1.int n\n2.fd_set * readfds\n3.fd_set * writefds\n4.fd_set * exceptfds\n5.struct timeval * timeout\ntimeout == NULL: 一直等待直到事件发生。\ntimeout > 0: 按设定的大于0的时间值进行等待。\ntimeout = 0: 没有时间等待，直接返回。\n\n\n<h3>【选读】</h3>\n<em>\n\"select（I/O多工机制）\n定义函数 int select(int n,fd_set * readfds,fd_set * writefds,fd_set * exceptfds,struct timeval * timeout);\n函数说明 select()用来等待文件描述词状态的改变。参数n代表最大的文件描述词加1，参数readfds、writefds 和exceptfds 称为描述词组，是用来回传该描述词的读，写或例外的状况。底下的宏提供了处理这三种描述词组的方式:\nFD_CLR(inr fd,fd_set* set)；用来清除描述词组set中相关fd 的位\nFD_ISSET(int fd,fd_set *set)；用来测试描述词组set中相关fd 的位是否为真\nFD_SET（int fd,fd_set*set）；用来设置描述词组set中相关fd的位\nFD_ZERO（fd_set *set）；用来清除描述词组set的全部位\"\n</em> \n看到，“多工机制”和类似\"是用来回传该描述词的读，写或例外的状况。\"这种文字，直接就被干倒了，难道原文英语就这么晦涩不堪吗？残酷的阅读体验。\n\n\n\n<h3>【例子A：读取键盘输入的数据】</h3>\n\n<p>在Linux系统中，键盘设备也被标识为文件，找来一个例子，很简短的/dev/tty键盘设备和select的联合使用。这么做的目的，就是很单纯的演示select本身相关函数和使用。</p>\n<p>keyboard.c<br>[code]<br>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#include&lt;assert.h&gt;<br>#include&lt;fcntl.h&gt;<br>#include&lt;sys/select.h&gt;</p>\n<p>int main(int argc, char **argv)<br>{<br>        int keyboard; //键盘的文件句柄<br>        int ret,i;<br>        char c;<br>        fd_set readfd; //读操作的集合的定义<br>        struct timeval timeout; // 提供给select函数使用的，延时时间结构体，告知需要等待的时间长度<br>        keyboard = open(“/dev/tty”, O_RDONLY | O_NONBLOCK);//读取键盘缓冲区里的数据<br>        assert(keyboard&gt;0);<br>        while(1) //主循环<br>        {<br>                timeout.tv_sec = 1;  // 等待的时间设定<br>                timeout.tv_usec = 0;<br>                FD_ZERO(&amp;readfd); // 初始化读操作集合。<br>                FD_SET(keyboard, &amp;readfd); //把键盘文件句柄填入读文件集<br>                ret = select(keyboard+1, &amp;readfd, NULL, NULL, &amp;timeout); // 取得外部IO的状态数据<br>                if (FD_ISSET(keyboard, &amp;readfd)) //判断读集合中的keyboard句柄是否准备好了，可以工作。<br>                {<br>                        i = read(keyboard, &amp;c, 1); //读取键盘文件<br>                        if (‘\\n’ == c)<br>                                continue;<br>                        printf(“input is %c\\n”, c);<br>                        if (‘q’ == c)<br>                                break;</p>\n<pre><code>            &#125;\n    &#125;\n</code></pre>\n<p>}<br>[/code]</p>\n<p>server.cpp<br>client.cpp</p>\n<h3>【结尾】</h3>\n也许我应该长期的维护这个文档，回头看看对细节表述曾经放下的错误，对说的不是人话的地方，进行修改，并且围绕主题加入更高级的应用内容。\n\n\n<p>作者：小盛<br>注释：个人劳动成果，转载使用请注明本文作者及出处链接，谢谢合作！<br><a href=\"http://upblog.sinaapp.com/topic/21/python%E4%B8%8Ec-select-api%E7%9A%84%E5%AF%B9%E6%AF%94\" target=\"_blank\">Python与C++ select API的对比</a> </p>\n<p>参考文献：<br><a href=\"http://docs.python.org/2/library/select.html\" target=\"_blank\">Python官方文档</a></p>\n","text":"【问题】select,poll,epoll的区别是什么？ select的并发处理是源于BSD系统的支持，poll是商业公司的unix版本SystemV 提供支持。epoll是在Linux 2.5+开始支持的。就像message queue都有BSD和SystemV版本的API。s...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[{"name":"lua","slug":"lua","count":153,"path":"api/tags/lua.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">【问题】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\"><span class=\"toc-text\">server.py</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\"><span class=\"toc-text\">client.py</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">【API说明】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">【宏定义】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">【Select接口说明】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">【选读】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">【例子A：读取键盘输入的数据】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">【结尾】</span></a></li></ol>","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"setmetatable和__call","uid":"cec276ee8af804b9a2147b603fad4daa","slug":"old_topic/2016-09-17-210","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.740Z","comments":true,"path":"api/articles/old_topic/2016-09-17-210.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者：糖果 网上找来一个很能说明__call用法的例子： 12345678910111213141516171819function f(tb, x, y) for k,v in pairs(tb) do print(k,v) end return x+y+tb.nendb = ...","link":"","photos":[],"count_time":{"symbolsCount":403,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"LUA WEB架框LOR基础简介","uid":"e465db6ba9cb253a17d5f94de4f683b9","slug":"old_topic/2016-09-17-211","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T06:15:59.740Z","comments":true,"path":"api/articles/old_topic/2016-09-17-211.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":[],"text":"作者：糖果 LOR是最近国内的LUA WEB开发框架，目前已经发布到了0.3版，昨天晚上作者分享了他的初始设计图， 在QQ群里发的。 最开始的时候，lor是借鉴vanilla的，之后作者转向设计，开始向expressjs靠拢。 目前来看的，lor非常引人关注的是lor的路由设计。...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}