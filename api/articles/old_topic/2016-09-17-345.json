{"title":"Openresty定时器ngx.timer通过Redis的pubsub进行通信","uid":"9e3061a0f19c04425ccac351efe5e0da","slug":"old_topic/2016-09-17-345","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.166Z","comments":true,"path":"api/articles/old_topic/2016-09-17-345.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","content":"<p>做一个小实验：</p>\n<p>先打开一个redis-cli, 监听所有事件：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">127.0.0.1:6379&gt;  config set notify-keyspace-events KEA \n127.0.0.1:6379&gt; psubscribe __key*@0__:* <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>再开一个redis-cli,进行publish与subscribe操作：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">127.0.0.1:6379&gt; publish chatroom &quot;123&quot;\n127.0.0.1:6379&gt; publish chatroom &quot;abc&quot;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>然于，打开一个python redis client进行subscribe:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">r &#x3D; redis.StrictRedis(host&#x3D;&#39;localhost&#39;, port&#x3D;6379, db&#x3D;0, password&#x3D;&#39;candylab.net&#39;)\n\nps &#x3D; rc.pubsub()\n\nps.subscribe(&#39;chatroom&#39;)\n\nfor item in ps.listen():  \n    if item[&#39;type&#39;] &#x3D;&#x3D; &#39;message&#39;:  \n        print item[&#39;data&#39;]  <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><a href=\"https://github.com/andymccurdy/redis-py\">Python Redis客户端</a></p>\n<p><a href=\"https://github.com/nrk/redis-lua\">LUA Redis客户端</a></p>\n<p><a href=\"https://github.com/hoisie/redis\">LUA Redis客户端</a></p>\n<p>实际上我们是可以，在OpenResty的定时器处理过程中对Redis进行操作的， 这种对redis的数据操作的API是不会在OpenResty的各个阶段被disabled，所以我们可以通过redis进行表数据共享，通过订阅与支持Redis客户端口的相应语言进行耦合通信与协作工作,比如我们可以通过publish IP数据让订阅者对当地的Iptable进行封禁。</p>\n<p>实际上下面的思路是，用Openrsty的Timer生成心跳，让OpenResty通过publish吐出一个二维结构的计划任务表，让对应订阅者去执行，这样在Openresty阶段做的就是这张表的维护与发布，基于OpenResty本身Timer设定的心跳的基础上。</p>\n","text":"做一个小实验： 先打开一个redis-cli, 监听所有事件： 127.0.0.1:6379&gt; config set notify-keyspace-events KEA 127.0.0.1:6379&gt; psubscribe __key*@0__:* 再开一个redi...","link":"","photos":[],"count_time":{"symbolsCount":976,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"MoonScript与Redis客户端","uid":"55c8ceefd620d530c7de11d61153ba84","slug":"old_topic/2016-09-17-346","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.233Z","comments":true,"path":"api/articles/old_topic/2016-09-17-346.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"所谓的Redis LUA客户端有两种版本，一种就是本地可运行版本，还有一个版本是OpenResty的版本，下面介绍的这段Moonscript段代码是本地版的。 作者：糖果 candylab.moon redis = require \"redis\" client = redis.c...","link":"","photos":[],"count_time":{"symbolsCount":553,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"从实现角度看Openresty + LUA = WAF","uid":"4b277b3bf21c49d9a15db633f740d15e","slug":"old_topic/2016-09-17-347","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.211Z","comments":true,"path":"api/articles/old_topic/2016-09-17-347.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","text":"作者：糖果 1.WAF存在形态 WAF就是WEB防火墙，Nginx Lua和Openresty的出现，让基于LUA开发的WAF更有可能。对所有 会造成安全威胁的HTTP请求数据，都应该成为安全检查策略应该关注的内容，笼统上来讲OR WAF的式样要求的输入数据，就是可以在WEB服务...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"topic","slug":"topic","count":1441,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}