{"title":"Lua的Require理解","uid":"f9e8867ab3929a213362390d7a6ff2ff","slug":"old_topic/2016-09-17-278","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.192Z","comments":true,"path":"api/articles/old_topic/2016-09-17-278.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"content":"<p>作者：ms2008</p>\n<p>整理编辑：糖果</p>\n<p>在 lua 中加载的其他文件的代码，通常可以使用 dofile、loadfile、require 函数等来完成。其中 dofile 每次加载都要编译执行，效率比较低，所以不推荐使用；同样 loadfile 虽然只需编译一次，但是并没有把结果缓存到 lua vm 中；因而，我们这里总是推荐使用第三种方式 require。</p>\n<p>require 能够避免多次重复加载模块，一个模块被加载后会被缓存到 pacakge.loaded。 如果需要重新加载模块，可以清理 package.loaded.test = nil。</p>\n<p>需要注意的是，require() 函数并没有使用全局变量，它是在 package.loaded 表里缓存已经加载的 Lua module 的。而 package.loaded 是挂载在 Lua VM 的 registry 表里的，不同于全局变量的环境表。</p>\n<p>另外：</p>\n<p>Lua module 不一定是 table，也可以是 function，只是 table 比较常见罢了。function 的一个例子是 LuaJIT 2.1 的 require(“table.new”).<br>\n在 Lua module 文件里的顶层作用域里声明的 local 变量一般会通过 upvalue 的形式挂载到 Lua module 里使用到这些变量的 function 里，而这些 function 一般会注册到 Lua module 的 table 里面，或者进一步以 upvalue 的形式挂载到这样的其他 function 中</p>\n<p>所以，lua module 的顶层作用域是不可以用来声明需要变动的值的。并且，在 Lua 里加载模块的正确方式是：</p>\n<p>local foo = require “foo”</p>\n<p>直接写：</p>\n<p>require “foo”</p>\n<p>其实是错误的，因为它依赖于 module() 函数创建和模块同名的 Lua 全局变量的副作用。而使用 module() 函数在 Lua 社区里也是不推荐的（以至于 Lua 5.2 语言里干脆移除了 module 这个内建函数）。</p>\n<p>最后，lua 的 vm 和 luajit 的 vm 有些行为是不同的，这一点在 or 的 github 就有提到：</p>\n<p>As the standard Lua 5.1 interpreter’s VM is not fully resumable, the methods ngx.location.capture, ngx.location.capture_multi, ngx.redirect, ngx.exec, and ngx.exit cannot be used within the context of a Lua pcall() or xpcall() or even the first line of the for … in … statement when the standard Lua 5.1 interpreter is used and the attempt to yield across metamethod/C-call boundary error will be produced. Please use LuaJIT 2.x, which supports a fully resumable VM, to avoid this.</p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzIwNjQ2MzkwNw==&amp;mid=2247483698&amp;idx=1&amp;sn=cb5b9e49be97e07bd852a17635242445&amp;scene=4#wechat_redirect\">原文链接</a></p>\n","text":"作者：ms2008 整理编辑：糖果 在 lua 中加载的其他文件的代码，通常可以使用 dofile、loadfile、require 函数等来完成。其中 dofile 每次加载都要编译执行，效率比较低，所以不推荐使用；同样 loadfile 虽然只需编译一次，但是并没有把结果缓存...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"toc":"","author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"OpenResty 中的连接池","uid":"34fb78ae79ed28901f3aef22da440208","slug":"old_topic/2016-09-17-280","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.230Z","comments":true,"path":"api/articles/old_topic/2016-09-17-280.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"OpenResty 中的连接池 作者：ms2008 编辑整理：糖果 注：set_keepalive 和 close 互斥(一个 socket 对象不能执行多次 setkeepalive 操作，会报：连接已关闭) 连接池的大小是对每一个 nginx worker 而言的。如果有 N...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"TMUX最常用操作命令","uid":"65ce57f5fdb9c6ca938fd44776fc3ed9","slug":"old_topic/2016-09-17-277","date":"2016-09-17T14:50:18.000Z","updated":"2024-03-14T07:45:09.222Z","comments":true,"path":"api/articles/old_topic/2016-09-17-277.json","keywords":"AIGC,LLM,糖果AIGC实验室","cover":null,"text":"作者：糖果 一般情况下，当你用SSH链接VPS，然后关掉terminal的操作窗口时，所有的当前操作都结束了。而如果用TMUX,当前正在运行的非后台操作会话还会存在，下面是TMUX最常用的操作了。 1.创建新会话 tmux new -s candylab 2.选择新会话 tmux...","link":"","photos":[],"count_time":{"symbolsCount":804,"symbolsTime":"1 mins."},"categories":[{"name":"topic","slug":"topic","count":308,"path":"api/categories/topic.json"}],"tags":[],"author":{"name":"安全书","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"《墨守之道-Web服务安全架构与实践》","socials":{"github":"https://github.com/shengnoah","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/3732639263","zhihu":"https://www.zhihu.com/people/openresty","csdn":"","juejin":"","customs":{}}}}}